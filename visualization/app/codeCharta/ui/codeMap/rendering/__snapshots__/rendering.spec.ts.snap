// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`common rendering tests shader strings init 1`] = `"varying vec3 vColor;varying vec3 vDeltaColor;varying vec3 worldNormal;varying vec3 vLightFront;varying highp float vDelta;varying vec2 vUV;uniform vec3 ambientLightColor;#define RECIPROCAL_PI 0.31830988618#define PI 3.14159265359struct ReflectedLight {    vec3 directDiffuse;    vec3 directSpecular;    vec3 indirectDiffuse;    vec3 indirectSpecular;};vec3 getAmbientLightIrradiance(const in vec3 ambientLightColor) {    vec3 irradiance = ambientLightColor;    irradiance *= PI;    return irradiance;}vec3 BRDF_Diffuse_Lambert (const in vec3 diffuseColor) {    return RECIPROCAL_PI * diffuseColor;}bool normalPointingUp(const in vec3 normal){    return normal.y > 0.9;}struct Rect {    vec2 min;    vec2 max;};bool uvCoordInRectangle(const in vec2 uv, const in Rect r){    return uv.x >= r.min.x && uv.x < r.max.x && uv.y >= r.min.y && uv.y < r.max.y;}void main() {    vec4 diffuseColor = vec4(vColor, 1.0);    const float epsilon = 0.5;    const float minDelta = 0.001;    bool isTop = normalPointingUp(worldNormal);    if (abs(vDelta) > minDelta && (vUV.y > 1.0 - abs(vDelta) || isTop))    {        diffuseColor.xyz = vDeltaColor;    }    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));    reflectedLight.indirectDiffuse = getAmbientLightIrradiance(ambientLightColor);    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert(diffuseColor.rgb);    reflectedLight.directDiffuse = vLightFront;    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert(diffuseColor.rgb);    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;    gl_FragColor = vec4(outgoingLight, diffuseColor.a);}"`;

exports[`common rendering tests shader strings init 2`] = `"#define PI 3.14159265359#define saturate(a) clamp( a, 0.0, 1.0)attribute vec3 color;attribute vec3 defaultColor;attribute vec3 deltaColor;attribute highp float subGeomIdx;attribute highp float delta;varying vec3 vColor;varying vec3 vDeltaColor;varying vec3 worldNormal;varying vec3 vLightFront;varying highp float vDelta;varying vec2 vUV;struct GeometricContext {    vec3 position;    vec3 normal;    vec3 viewDir;};struct DirectionalLight {    vec3 direction;    vec3 color;    int shadow;    float shadowBias;    float shadowRadius;    vec2 shadowMapSize;};struct IncidentLight {    vec3 color;    vec3 direction;    bool visible;};uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];void getDirectionalDirectLightIrradiance(const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight) {    directLight.color = directionalLight.color;    directLight.direction = directionalLight.direction;    directLight.visible = true;}void main() {    vec4 worldPosition = modelMatrix * vec4(position, 1.0);    vec4 viewPosition = viewMatrix * worldPosition;    vec4 projectedPosition = projectionMatrix * viewPosition;	vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);	gl_Position = projectionMatrix * modelViewPosition;    worldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);    vec3 diffuse = vec3(1.0);        GeometricContext geometry;    geometry.position = viewPosition.xyz;    geometry.normal = normalize(normalMatrix * normal);    geometry.viewDir = normalize(-viewPosition.xyz);    vLightFront = vec3(0.0);    vUV = uv;    vColor = color;    vDeltaColor = deltaColor;    vDelta = delta;    for (int i=0; i < 2; ++i)    {        IncidentLight directLight;        getDirectionalDirectLightIrradiance(directionalLights[i], geometry, directLight);        float dotNL = dot(geometry.normal, directLight.direction);        vec3 directLightColor_Diffuse = PI * directLight.color;        vLightFront += saturate(dotNL) * directLightColor_Diffuse;    }}"`;
