package de.maibornwolff.codecharta.analysers.analyserinterface

import de.maibornwolff.codecharta.analysers.analyserinterface.util.CommaSeparatedParameterPreprocessor
import de.maibornwolff.codecharta.analysers.analyserinterface.util.CommaSeparatedStringToListConverter
import de.maibornwolff.codecharta.analysers.analyserinterface.util.FileExtensionConverter
import de.maibornwolff.codecharta.model.Node
import de.maibornwolff.codecharta.model.NodeType
import de.maibornwolff.codecharta.serialization.ProjectDeserializer
import de.maibornwolff.codecharta.util.Logger
import picocli.CommandLine
import java.io.File
import java.io.FileInputStream

abstract class CommonAnalyserParameters {
    @CommandLine.Option(names = ["-h", "--help"], usageHelp = true, description = ["displays this help and exits"])
    protected var help = false

    @CommandLine.Parameters(
        arity = "1..2",
        paramLabel = "FILE or FOLDER",
        description = [
            "file/project to parse. To merge the result with an existing project piped into STDIN, " +
                "pass a '-' as an additional argument"
        ]
    )
    protected var inputFiles: List<File> = mutableListOf()

    @CommandLine.Option(names = ["-o", "--output-file"], description = ["output File (or empty for stdout)"])
    protected var outputFile: String? = null

    @CommandLine.Option(names = ["--verbose"], description = ["verbose mode"])
    protected var verbose = false

    @CommandLine.Option(names = ["-nc", "--not-compressed"], description = ["save uncompressed output File"])
    protected var compress = true

    @CommandLine.Option(
        names = ["-e", "--exclude"],
        description = [
            "comma-separated list of regex patterns to exclude files/folders " +
                "(when using powershell, the list either can't contain spaces or has to be in quotes)"
        ],
        converter = [(CommaSeparatedStringToListConverter::class)],
        preprocessor = CommaSeparatedParameterPreprocessor::class
    )
    protected var patternsToExclude: List<String> = listOf()

    @CommandLine.Option(
        names = ["-ibf", "--include-build-folders"],
        description = [
            "include build folders (out, build, dist and target) and " +
                "common resource folders (e.g. resources, node_modules or files/folders starting with '.')"
        ]
    )
    protected var includeBuildFolders = false

    @CommandLine.Option(
        names = ["-fe", "--file-extensions"],
        description = ["comma-separated list of file-extensions to parse only those files (default: any)"],
        converter = [(FileExtensionConverter::class)],
        preprocessor = CommaSeparatedParameterPreprocessor::class
    )
    protected var fileExtensionsToAnalyse: List<String> = listOf()

    @CommandLine.Option(
        names = ["-bf", "--base-file"],
        description = ["base cc.json file with checksums to skip unchanged files during analysis"]
    )
    protected var baseFile: File? = null

    protected fun loadBaseFileNodes(): Map<String, Node> {
        if (baseFile == null) {
            return emptyMap()
        }

        if (!baseFile!!.exists()) {
            Logger.warn { "Base file '${baseFile!!.absolutePath}' does not exist, continuing with normal analysis... " }
            return emptyMap()
        }

        return try {
            val baseProject = ProjectDeserializer.deserializeProject(FileInputStream(baseFile!!))
            val nodeMap = mutableMapOf<String, Node>()
            extractFileNodesWithPaths(baseProject.rootNode, "", nodeMap)
            Logger.info { "Loaded ${nodeMap.size} file nodes from base file for checksum comparison" }
            nodeMap
        } catch (e: Exception) {
            Logger.warn { "Failed to load base file: ${e.message}" }
            emptyMap()
        }
    }

    private fun extractFileNodesWithPaths(node: Node, currentPath: String, nodeMap: MutableMap<String, Node>) {
        // Skip the root node name to match the relative paths generated by parsers
        val nodePath = if (currentPath.isEmpty() && node.name == "root") {
            ""
        } else if (currentPath.isEmpty()) {
            node.name
        } else {
            "$currentPath/${node.name}"
        }

        if (node.type == NodeType.File && node.checksum != null) {
            nodeMap[nodePath] = node
        }

        node.children.forEach { child ->
            extractFileNodesWithPaths(child, nodePath, nodeMap)
        }
    }
}
