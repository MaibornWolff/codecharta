---

permalink: /docs/tree-map-algorithm/
title: "Tree Map Algorithm"

The CodeCharta map is generated by calculating a map size first as well as placing all 2d buildings and folders as areas. Afterwards we use [three-js](https://threejs.org) to generate the 3d-models at the calculated positions.

In this document we will focus on the first part, the placement algorithm. We use [d3-hierarchy](https://github.com/d3/d3-hierarchy), a module for visualizing hierarchical data, like our code maps. The algorithm operates by placing buildings inside folders and sub-folders inside their parents. All those steps ar performed in a depth-first manner all the way up to the root node.
To calculate an "optimal" packing the algorithm requires a hierarchical structure with node sizes and width and height of the root node. When receiving the data d3-hierarchy calculates a placement and allows applying margins to components.

For our visualization we apply outer-margins to have padding between folders and inner-margins for padding between the files in each folder. Furthermore, we use paddingRight to generate folder labels **below** each folder.

However, the problem with the approach is that margins are not part of the calculated map size, which leads to buildings being "compressed", e.g. a building of area 100 appearing smaller in area then a building of size 50. In some cases it even leads to buildings disappearing entirely.

The algorithm presented below aims to address the issue by calculating building areas extended by padding and providing them to the algorithm instead. This allows us to reserve more space even before paddings are applied by d3-hierarchy.

## Preprocessing

Before performing the main area calculations some preprocessing is required.

1. All buildings with area 0 are removed from the calculation
2. A hierarchy is constructed from the data, to allow tracking parent-child relationships
3. A delta, the smallest difference between two files or the smallest file size, is calculated
4. The delta is used to ensure all buildings have an initial size of at least 100, to avoid buildings that are too small to be visible
5. The delta is also applied to the padding to ensure the padding fits the map and is not too big or small, the starting input for this is a scaling percentage given by the user and an initial value of 50 for historic reasons

## Algorithm idea

To avoid estimate and ensure that buildings will not be lost we need to provide d3-hierarchy with enough space for all buildings including inner and outer paddings as well as floor labels.

The algorithm proceeds as follows:

1. At the start a padding area is calculated for each building and added to the total area, this accounts for inner paddings.
2. To calculate outer paddings, a folders padding to its children, we need to first calculate its area. A folder's area is the sum of its children areas, so all direct children(files) as well as sub-folders.
   Therefore, we need to calculate the areas depth-first.
3. Some buildings might now appear to compressed as d3 assumes the parent area is too big, therefore in the next step they are scaled up accordingly, if needed.
4. In place summing up of folder values (folder value is not the same as folder area, a folder value is its area without paddings) for use in the next step
5. The implementation proceeds by using the results from 4 as well as the folder label algorithm to apply folder paddings and floor labels to each folder size.
6. Floor labels are only applied for folders with depth 1 or 2 that are "big enough".
   In this case "big enough" refers to a folder area that is not less than 20% of its parents value or 2% of the total value of the map. The values are chosen heuristically. For most maps a value is approximated based on % of the folders area.
7. If it's too small a fixed value is chosen instead. For small maps a scaling factor is set to avoid potentially loosing buildings/ area due to fixed values.
8. As the map is always a square, root side sizes can be calculated by drawing the root for folder sizes.
9. In case of big maps the root and all components are scaled down proportionally

## Methods and Function

|                   Method                    | Function                                                               |
| :-----------------------------------------: | ---------------------------------------------------------------------- |
|          `getChildrenAreaValues()`          | returns all non zero area values for a given metric and hierarchy node |
|  `getSmallestValueOrSmallestDifference()`   | returns minimum between smallest difference and smallest value         |
|   `calculatePaddingBasedOnBuildingArea()`   | calculate the median building area and scale padding down              |
| `getBuildingAreasWithProportionalPadding()` | scale building area by minimum-area by delta, add scaled padding       |
|         `calculateTotalNodeArea()`          | calculate map width, height and hierarchy via d3                       |

## calculateTotalNodeArea: intermediate steps

| Steps | intermediate results                                                                                                                                                                                              |
| :---: | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `1:`  | **totalNodeArea**: sum building areas or throw an error if none exist                                                                                                                                             |
| `2:`  | generate two maps from hierarchyNode<br>**nodeKeyMap(path, node)**: maps paths to node data, helps find parent/child of node<br> **nodeAreaMap(path, 0)**: maps paths to a node area value, all set to 0 at start |
| `3:`  | **nodeAreaMap**: set file values and folder values as sum of direct children only                                                                                                                                 |
| `4:`  | **paths** : reverse nodeKeyMap(), d3-hierarchy operates depth first                                                                                                                                               |
| `5:`  | **nodeAreaMap**: add children folder areas to parent folders, root now contains total area including innerPaddings                                                                                                |
| `6:`  | calculate and apply scaling factor for each file-area per folder <br> count the amount of fodlers with floor label per hierarchy level                                                                            |
| `7:`  | hierarchyNode sum up each file in place for further calculations                                                                                                                                                  |
| `8:`  | **totalNodeArea**: add paddings areas to sum of folder areas (outerPadding), add folder label sizes                                                                                                               |
| `9:`  | **rootSide**: set root side length<br> root-folder is always a square                                                                                                                                             |
| `10:` | **factor**: check if map root is to big and set a factor to scale down if required                                                                                                                                |
| `11:` | **metricSum**: sum up all files again (overwrite), applying scaling factor to each file/folder if required                                                                                                        |
