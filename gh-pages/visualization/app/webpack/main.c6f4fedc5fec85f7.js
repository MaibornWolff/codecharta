;(self.webpackChunkvisualization = self.webpackChunkvisualization || []).push([
	[179],
	{
		490: (ct, ft, A) => {
			"use strict"
			var X = {}
			function q(t) {
				return "function" == typeof t
			}
			function m(t) {
				const e = t(i => {
					Error.call(i), (i.stack = new Error().stack)
				})
				return (e.prototype = Object.create(Error.prototype)), (e.prototype.constructor = e), e
			}
			A.r(X),
				A.d(X, {
					ACESFilmicToneMapping: () => kW,
					AddEquation: () => Zm,
					AddOperation: () => CW,
					AdditiveAnimationBlendMode: () => AR,
					AdditiveBlending: () => ZL,
					AlphaFormat: () => PW,
					AlwaysDepth: () => gW,
					AlwaysStencilFunc: () => Fj,
					AmbientLight: () => nw,
					AmbientLightProbe: () => aK,
					AnimationClip: () => Xy,
					AnimationLoader: () => uCe,
					AnimationMixer: () => gK,
					AnimationObjectGroup: () => AK,
					AnimationUtils: () => Kr,
					ArcCurve: () => hP,
					ArrayCamera: () => $M,
					ArrowHelper: () => BK,
					Audio: () => IP,
					AudioAnalyser: () => fK,
					AudioContext: () => FP,
					AudioListener: () => MCe,
					AudioLoader: () => oK,
					AxesHelper: () => VP,
					AxisHelper: () => MEe,
					BackSide: () => Lo,
					BasicDepthPacking: () => Sj,
					BasicShadowMap: () => q0e,
					BinaryTextureLoader: () => BEe,
					Bone: () => Oy,
					BooleanKeyframeTrack: () => pp,
					BoundingBoxHelper: () => SEe,
					Box2: () => mb,
					Box3: () => is,
					Box3Helper: () => jCe,
					BoxBufferGeometry: () => _l,
					BoxGeometry: () => _l,
					BoxHelper: () => UP,
					BufferAttribute: () => xn,
					BufferGeometry: () => vn,
					BufferGeometryLoader: () => tK,
					ByteType: () => FW,
					Cache: () => gp,
					Camera: () => rf,
					CameraHelper: () => WCe,
					CanvasRenderer: () => DEe,
					CanvasTexture: () => JR,
					CatmullRomCurve3: () => gP,
					CineonToneMapping: () => SW,
					CircleBufferGeometry: () => tS,
					CircleGeometry: () => tS,
					ClampToEdgeWrapping: () => ua,
					Clock: () => BP,
					Color: () => Lt,
					ColorKeyframeTrack: () => lP,
					CompressedTexture: () => ZR,
					CompressedTextureLoader: () => uP,
					ConeBufferGeometry: () => nS,
					ConeGeometry: () => nS,
					CubeCamera: () => HM,
					CubeReflectionMapping: () => ny,
					CubeRefractionMapping: () => iy,
					CubeTexture: () => Zg,
					CubeTextureLoader: () => z7,
					CubeUVReflectionMapping: () => Lg,
					CubeUVRefractionMapping: () => ry,
					CubicBezierCurve: () => SS,
					CubicBezierCurve3: () => kS,
					CubicInterpolant: () => vS,
					CullFaceBack: () => XL,
					CullFaceFront: () => nW,
					CullFaceFrontBack: () => Y0e,
					CullFaceNone: () => tW,
					Curve: () => ga,
					CurvePath: () => W7,
					CustomBlending: () => rW,
					CustomToneMapping: () => TW,
					CylinderBufferGeometry: () => lb,
					CylinderGeometry: () => lb,
					Cylindrical: () => UCe,
					DataTexture: () => Jg,
					DataTexture2DArray: () => zR,
					DataTexture3D: () => GR,
					DataTextureLoader: () => CS,
					DataUtils: () => YCe,
					DecrementStencilOp: () => cve,
					DecrementWrapStencilOp: () => dve,
					DefaultLoadingManager: () => Q7,
					DepthFormat: () => tp,
					DepthStencilFormat: () => Ng,
					DepthTexture: () => R7,
					DirectionalLight: () => _p,
					DirectionalLightHelper: () => $Ce,
					DiscreteInterpolant: () => yS,
					DodecahedronBufferGeometry: () => iS,
					DodecahedronGeometry: () => iS,
					DoubleSide: () => ey,
					DstAlphaFactor: () => uW,
					DstColorFactor: () => fW,
					DynamicBufferAttribute: () => AEe,
					DynamicCopyUsage: () => Cve,
					DynamicDrawUsage: () => op,
					DynamicReadUsage: () => yve,
					EdgesGeometry: () => tP,
					EdgesHelper: () => kEe,
					EllipseCurve: () => Yy,
					EqualDepth: () => _W,
					EqualStencilFunc: () => mve,
					EquirectangularReflectionMapping: () => fM,
					EquirectangularRefractionMapping: () => mM,
					Euler: () => lp,
					EventDispatcher: () => Iu,
					ExtrudeBufferGeometry: () => Hu,
					ExtrudeGeometry: () => Hu,
					FaceColors: () => oEe,
					FileLoader: () => Hc,
					FlatShading: () => qL,
					Float16BufferAttribute: () => wy,
					Float32Attribute: () => CEe,
					Float32BufferAttribute: () => cn,
					Float64Attribute: () => EEe,
					Float64BufferAttribute: () => xy,
					FloatType: () => Bu,
					Fog: () => By,
					FogExp2: () => Fy,
					Font: () => TP,
					FontLoader: () => xCe,
					FrontSide: () => Ig,
					Frustum: () => My,
					GLBufferAttribute: () => PP,
					GLSL1: () => Mve,
					GLSL3: () => vR,
					GammaEncoding: () => _M,
					GreaterDepth: () => yW,
					GreaterEqualDepth: () => vW,
					GreaterEqualStencilFunc: () => bve,
					GreaterStencilFunc: () => Ave,
					GridHelper: () => SK,
					Group: () => ps,
					HalfFloatType: () => cy,
					HemisphereLight: () => vP,
					HemisphereLightHelper: () => zCe,
					HemisphereLightProbe: () => sK,
					IcosahedronBufferGeometry: () => dS,
					IcosahedronGeometry: () => dS,
					ImageBitmapLoader: () => kP,
					ImageLoader: () => xS,
					ImageUtils: () => sp,
					ImmediateRenderObject: () => sw,
					IncrementStencilOp: () => ave,
					IncrementWrapStencilOp: () => lve,
					InstancedBufferAttribute: () => BS,
					InstancedBufferGeometry: () => rw,
					InstancedInterleavedBuffer: () => RP,
					InstancedMesh: () => qM,
					Int16Attribute: () => vEe,
					Int16BufferAttribute: () => vy,
					Int32Attribute: () => wEe,
					Int32BufferAttribute: () => yy,
					Int8Attribute: () => gEe,
					Int8BufferAttribute: () => gy,
					IntType: () => IW,
					InterleavedBuffer: () => Ra,
					InterleavedBufferAttribute: () => cf,
					Interpolant: () => ac,
					InterpolateDiscrete: () => ly,
					InterpolateLinear: () => dy,
					InterpolateSmooth: () => gM,
					InvertStencilOp: () => uve,
					JSONLoader: () => LEe,
					KeepStencilOp: () => yM,
					KeyframeTrack: () => yl,
					LOD: () => KR,
					LatheBufferGeometry: () => uS,
					LatheGeometry: () => uS,
					Layers: () => kR,
					LensFlare: () => PEe,
					LessDepth: () => bW,
					LessEqualDepth: () => uM,
					LessEqualStencilFunc: () => pve,
					LessStencilFunc: () => fve,
					Light: () => xl,
					LightProbe: () => iw,
					Line: () => ma,
					Line3: () => yK,
					LineBasicMaterial: () => Go,
					LineCurve: () => Jy,
					LineCurve3: () => $7,
					LineDashedMaterial: () => cP,
					LineLoop: () => YR,
					LinePieces: () => iEe,
					LineSegments: () => pa,
					LineStrip: () => nEe,
					LinearEncoding: () => fa,
					LinearFilter: () => xo,
					LinearInterpolant: () => Wy,
					LinearMipMapLinearFilter: () => nve,
					LinearMipMapNearestFilter: () => tve,
					LinearMipmapLinearFilter: () => Rg,
					LinearMipmapNearestFilter: () => oR,
					LinearToneMapping: () => EW,
					Loader: () => Eo,
					LoaderUtils: () => SP,
					LoadingManager: () => dP,
					LogLuvEncoding: () => Mj,
					LoopOnce: () => wj,
					LoopPingPong: () => Cj,
					LoopRepeat: () => xj,
					LuminanceAlphaFormat: () => NW,
					LuminanceFormat: () => OW,
					MOUSE: () => K0e,
					Material: () => jr,
					MaterialLoader: () => eK,
					Math: () => jn,
					MathUtils: () => jn,
					Matrix3: () => ns,
					Matrix4: () => Cn,
					MaxEquation: () => nR,
					Mesh: () => Mi,
					MeshBasicMaterial: () => Cd,
					MeshDepthMaterial: () => zM,
					MeshDistanceMaterial: () => GM,
					MeshFaceMaterial: () => aEe,
					MeshLambertMaterial: () => hb,
					MeshMatcapMaterial: () => aP,
					MeshNormalMaterial: () => _S,
					MeshPhongMaterial: () => bS,
					MeshPhysicalMaterial: () => uf,
					MeshStandardMaterial: () => Md,
					MeshToonMaterial: () => sP,
					MinEquation: () => tR,
					MirroredRepeatWrapping: () => oy,
					MixOperation: () => xW,
					MultiMaterial: () => cEe,
					MultiplyBlending: () => eR,
					MultiplyOperation: () => ty,
					NearestFilter: () => ts,
					NearestMipMapLinearFilter: () => eve,
					NearestMipMapNearestFilter: () => J0e,
					NearestMipmapLinearFilter: () => AM,
					NearestMipmapNearestFilter: () => pM,
					NeverDepth: () => AW,
					NeverStencilFunc: () => hve,
					NoBlending: () => Fu,
					NoColors: () => rEe,
					NoToneMapping: () => Jm,
					NormalAnimationBlendMode: () => bM,
					NormalBlending: () => Dg,
					NotEqualDepth: () => wW,
					NotEqualStencilFunc: () => gve,
					NumberKeyframeTrack: () => jy,
					Object3D: () => On,
					ObjectLoader: () => _Ce,
					ObjectSpaceNormalMap: () => Tj,
					OctahedronBufferGeometry: () => zy,
					OctahedronGeometry: () => zy,
					OneFactor: () => cW,
					OneMinusDstAlphaFactor: () => hW,
					OneMinusDstColorFactor: () => mW,
					OneMinusSrcAlphaFactor: () => rR,
					OneMinusSrcColorFactor: () => dW,
					OrthographicCamera: () => bp,
					PCFShadowMap: () => YL,
					PCFSoftShadowMap: () => iW,
					PMREMGenerator: () => ZCe,
					ParametricBufferGeometry: () => mp,
					ParametricGeometry: () => mp,
					Particle: () => dEe,
					ParticleBasicMaterial: () => fEe,
					ParticleSystem: () => uEe,
					ParticleSystemMaterial: () => mEe,
					Path: () => ew,
					PerspectiveCamera: () => Co,
					Plane: () => Al,
					PlaneBufferGeometry: () => sf,
					PlaneGeometry: () => sf,
					PlaneHelper: () => KCe,
					PointCloud: () => lEe,
					PointCloudMaterial: () => hEe,
					PointLight: () => CP,
					PointLightHelper: () => VCe,
					Points: () => cb,
					PointsMaterial: () => fp,
					PolarGridHelper: () => GCe,
					PolyhedronBufferGeometry: () => lf,
					PolyhedronGeometry: () => lf,
					PositionalAudio: () => kCe,
					PropertyBinding: () => Gs,
					PropertyMixer: () => mK,
					QuadraticBezierCurve: () => TS,
					QuadraticBezierCurve3: () => bP,
					Quaternion: () => fs,
					QuaternionKeyframeTrack: () => fb,
					QuaternionLinearInterpolant: () => wS,
					REVISION: () => KL,
					RGBADepthPacking: () => kj,
					RGBAFormat: () => ha,
					RGBAIntegerFormat: () => $W,
					RGBA_ASTC_10x10_Format: () => rj,
					RGBA_ASTC_10x5_Format: () => tj,
					RGBA_ASTC_10x6_Format: () => nj,
					RGBA_ASTC_10x8_Format: () => ij,
					RGBA_ASTC_12x10_Format: () => oj,
					RGBA_ASTC_12x12_Format: () => sj,
					RGBA_ASTC_4x4_Format: () => jW,
					RGBA_ASTC_5x4_Format: () => KW,
					RGBA_ASTC_5x5_Format: () => XW,
					RGBA_ASTC_6x5_Format: () => YW,
					RGBA_ASTC_6x6_Format: () => qW,
					RGBA_ASTC_8x5_Format: () => ZW,
					RGBA_ASTC_8x6_Format: () => JW,
					RGBA_ASTC_8x8_Format: () => ej,
					RGBA_BPTC_Format: () => aj,
					RGBA_ETC2_EAC_Format: () => pR,
					RGBA_PVRTC_2BPPV1_Format: () => fR,
					RGBA_PVRTC_4BPPV1_Format: () => hR,
					RGBA_S3TC_DXT1_Format: () => aR,
					RGBA_S3TC_DXT3_Format: () => cR,
					RGBA_S3TC_DXT5_Format: () => lR,
					RGBDEncoding: () => _R,
					RGBEEncoding: () => vM,
					RGBEFormat: () => UW,
					RGBFormat: () => Xh,
					RGBIntegerFormat: () => GW,
					RGBM16Encoding: () => bR,
					RGBM7Encoding: () => gR,
					RGB_ETC1_Format: () => WW,
					RGB_ETC2_Format: () => mR,
					RGB_PVRTC_2BPPV1_Format: () => uR,
					RGB_PVRTC_4BPPV1_Format: () => dR,
					RGB_S3TC_DXT1_Format: () => sR,
					RGFormat: () => QW,
					RGIntegerFormat: () => zW,
					RawShaderMaterial: () => ub,
					Ray: () => Ru,
					Raycaster: () => ow,
					RectAreaLight: () => EP,
					RedFormat: () => HW,
					RedIntegerFormat: () => VW,
					ReinhardToneMapping: () => MW,
					RepeatWrapping: () => ep,
					ReplaceStencilOp: () => sve,
					ReverseSubtractEquation: () => sW,
					RingBufferGeometry: () => hS,
					RingGeometry: () => hS,
					SRGB8_ALPHA8_ASTC_10x10_Format: () => _j,
					SRGB8_ALPHA8_ASTC_10x5_Format: () => Aj,
					SRGB8_ALPHA8_ASTC_10x6_Format: () => gj,
					SRGB8_ALPHA8_ASTC_10x8_Format: () => bj,
					SRGB8_ALPHA8_ASTC_12x10_Format: () => vj,
					SRGB8_ALPHA8_ASTC_12x12_Format: () => yj,
					SRGB8_ALPHA8_ASTC_4x4_Format: () => cj,
					SRGB8_ALPHA8_ASTC_5x4_Format: () => lj,
					SRGB8_ALPHA8_ASTC_5x5_Format: () => dj,
					SRGB8_ALPHA8_ASTC_6x5_Format: () => uj,
					SRGB8_ALPHA8_ASTC_6x6_Format: () => hj,
					SRGB8_ALPHA8_ASTC_8x5_Format: () => fj,
					SRGB8_ALPHA8_ASTC_8x6_Format: () => mj,
					SRGB8_ALPHA8_ASTC_8x8_Format: () => pj,
					Scene: () => nb,
					SceneUtils: () => REe,
					ShaderChunk: () => Bi,
					ShaderLib: () => vl,
					ShaderMaterial: () => Ds,
					ShadowMaterial: () => oP,
					Shape: () => hf,
					ShapeBufferGeometry: () => Gy,
					ShapeGeometry: () => Gy,
					ShapePath: () => rK,
					ShapeUtils: () => Uu,
					ShortType: () => BW,
					Skeleton: () => Ny,
					SkeletonHelper: () => xK,
					SkinnedMesh: () => Py,
					SmoothShading: () => Z0e,
					Sphere: () => xd,
					SphereBufferGeometry: () => $y,
					SphereGeometry: () => $y,
					Spherical: () => NCe,
					SphericalHarmonics3: () => MP,
					SplineCurve: () => FS,
					SpotLight: () => wP,
					SpotLightHelper: () => HCe,
					Sprite: () => ab,
					SpriteMaterial: () => Iy,
					SrcAlphaFactor: () => iR,
					SrcAlphaSaturateFactor: () => pW,
					SrcColorFactor: () => lW,
					StaticCopyUsage: () => xve,
					StaticDrawUsage: () => fy,
					StaticReadUsage: () => vve,
					StereoCamera: () => CCe,
					StreamCopyUsage: () => Eve,
					StreamDrawUsage: () => _ve,
					StreamReadUsage: () => wve,
					StringKeyframeTrack: () => Ap,
					SubtractEquation: () => oW,
					SubtractiveBlending: () => JL,
					TOUCH: () => X0e,
					TangentSpaceNormalMap: () => rp,
					TetrahedronBufferGeometry: () => fS,
					TetrahedronGeometry: () => fS,
					TextBufferGeometry: () => mS,
					TextGeometry: () => mS,
					Texture: () => zo,
					TextureLoader: () => ES,
					TorusBufferGeometry: () => pS,
					TorusGeometry: () => pS,
					TorusKnotBufferGeometry: () => AS,
					TorusKnotGeometry: () => AS,
					Triangle: () => Ro,
					TriangleFanDrawMode: () => rve,
					TriangleStripDrawMode: () => ive,
					TrianglesDrawMode: () => Ej,
					TubeBufferGeometry: () => gS,
					TubeGeometry: () => gS,
					UVMapping: () => hM,
					Uint16Attribute: () => yEe,
					Uint16BufferAttribute: () => dp,
					Uint32Attribute: () => xEe,
					Uint32BufferAttribute: () => up,
					Uint8Attribute: () => bEe,
					Uint8BufferAttribute: () => by,
					Uint8ClampedAttribute: () => _Ee,
					Uint8ClampedBufferAttribute: () => _y,
					Uniform: () => DS,
					UniformsLib: () => Ht,
					UniformsUtils: () => UM,
					UnsignedByteType: () => Pg,
					UnsignedInt248Type: () => Og,
					UnsignedIntType: () => ay,
					UnsignedShort4444Type: () => DW,
					UnsignedShort5551Type: () => LW,
					UnsignedShort565Type: () => RW,
					UnsignedShortType: () => sy,
					VSMShadowMap: () => Bg,
					Vector2: () => lt,
					Vector3: () => K,
					Vector4: () => lr,
					VectorKeyframeTrack: () => Ky,
					Vertex: () => pEe,
					VertexColors: () => sEe,
					VideoTexture: () => L7,
					WebGL1Renderer: () => p7,
					WebGLCubeRenderTarget: () => VM,
					WebGLMultisampleRenderTarget: () => Bj,
					WebGLRenderTarget: () => ml,
					WebGLRenderTargetCube: () => IEe,
					WebGLRenderer: () => dr,
					WebGLUtils: () => f7,
					WireframeGeometry: () => rP,
					WireframeHelper: () => TEe,
					WrapAroundEnding: () => uy,
					XHRLoader: () => FEe,
					ZeroCurvatureEnding: () => np,
					ZeroFactor: () => aW,
					ZeroSlopeEnding: () => ip,
					ZeroStencilOp: () => ove,
					sRGBEncoding: () => hy
				})
			const de = m(
				t =>
					function (e) {
						t(this),
							(this.message = e
								? `${e.length} errors occurred during unsubscription:\n${e
										.map((i, r) => `${r + 1}) ${i.toString()}`)
										.join("\n  ")}`
								: ""),
							(this.name = "UnsubscriptionError"),
							(this.errors = e)
					}
			)
			function Q(t, n) {
				if (t) {
					const e = t.indexOf(n)
					0 <= e && t.splice(e, 1)
				}
			}
			class D {
				constructor(n) {
					;(this.initialTeardown = n), (this.closed = !1), (this._parentage = null), (this._finalizers = null)
				}
				unsubscribe() {
					let n
					if (!this.closed) {
						this.closed = !0
						const { _parentage: e } = this
						if (e)
							if (((this._parentage = null), Array.isArray(e))) for (const o of e) o.remove(this)
							else e.remove(this)
						const { initialTeardown: i } = this
						if (q(i))
							try {
								i()
							} catch (o) {
								n = o instanceof de ? o.errors : [o]
							}
						const { _finalizers: r } = this
						if (r) {
							this._finalizers = null
							for (const o of r)
								try {
									V(o)
								} catch (s) {
									;(n = n ?? []), s instanceof de ? (n = [...n, ...s.errors]) : n.push(s)
								}
						}
						if (n) throw new de(n)
					}
				}
				add(n) {
					var e
					if (n && n !== this)
						if (this.closed) V(n)
						else {
							if (n instanceof D) {
								if (n.closed || n._hasParent(this)) return
								n._addParent(this)
							}
							;(this._finalizers = null !== (e = this._finalizers) && void 0 !== e ? e : []).push(n)
						}
				}
				_hasParent(n) {
					const { _parentage: e } = this
					return e === n || (Array.isArray(e) && e.includes(n))
				}
				_addParent(n) {
					const { _parentage: e } = this
					this._parentage = Array.isArray(e) ? (e.push(n), e) : e ? [e, n] : n
				}
				_removeParent(n) {
					const { _parentage: e } = this
					e === n ? (this._parentage = null) : Array.isArray(e) && Q(e, n)
				}
				remove(n) {
					const { _finalizers: e } = this
					e && Q(e, n), n instanceof D && n._removeParent(this)
				}
			}
			D.EMPTY = (() => {
				const t = new D()
				return (t.closed = !0), t
			})()
			const $ = D.EMPTY
			function R(t) {
				return t instanceof D || (t && "closed" in t && q(t.remove) && q(t.add) && q(t.unsubscribe))
			}
			function V(t) {
				q(t) ? t() : t.unsubscribe()
			}
			const B = {
					onUnhandledError: null,
					onStoppedNotification: null,
					Promise: void 0,
					useDeprecatedSynchronousErrorHandling: !1,
					useDeprecatedNextContext: !1
				},
				H = {
					setTimeout(t, n, ...e) {
						const { delegate: i } = H
						return i?.setTimeout ? i.setTimeout(t, n, ...e) : setTimeout(t, n, ...e)
					},
					clearTimeout(t) {
						const { delegate: n } = H
						return (n?.clearTimeout || clearTimeout)(t)
					},
					delegate: void 0
				}
			function I(t) {
				H.setTimeout(() => {
					const { onUnhandledError: n } = B
					if (!n) throw t
					n(t)
				})
			}
			function G() {}
			const J = Ne("C", void 0, void 0)
			function Ne(t, n, e) {
				return { kind: t, value: n, error: e }
			}
			let ye = null
			function Qe(t) {
				if (B.useDeprecatedSynchronousErrorHandling) {
					const n = !ye
					if ((n && (ye = { errorThrown: !1, error: null }), t(), n)) {
						const { errorThrown: e, error: i } = ye
						if (((ye = null), e)) throw i
					}
				} else t()
			}
			class Ce extends D {
				constructor(n) {
					super(), (this.isStopped = !1), n ? ((this.destination = n), R(n) && n.add(this)) : (this.destination = Ve)
				}
				static create(n, e, i) {
					return new st(n, e, i)
				}
				next(n) {
					this.isStopped
						? he(
								(function pe(t) {
									return Ne("N", t, void 0)
								})(n),
								this
						  )
						: this._next(n)
				}
				error(n) {
					this.isStopped
						? he(
								(function Y(t) {
									return Ne("E", void 0, t)
								})(n),
								this
						  )
						: ((this.isStopped = !0), this._error(n))
				}
				complete() {
					this.isStopped ? he(J, this) : ((this.isStopped = !0), this._complete())
				}
				unsubscribe() {
					this.closed || ((this.isStopped = !0), super.unsubscribe(), (this.destination = null))
				}
				_next(n) {
					this.destination.next(n)
				}
				_error(n) {
					try {
						this.destination.error(n)
					} finally {
						this.unsubscribe()
					}
				}
				_complete() {
					try {
						this.destination.complete()
					} finally {
						this.unsubscribe()
					}
				}
			}
			const We = Function.prototype.bind
			function it(t, n) {
				return We.call(t, n)
			}
			class Ue {
				constructor(n) {
					this.partialObserver = n
				}
				next(n) {
					const { partialObserver: e } = this
					if (e.next)
						try {
							e.next(n)
						} catch (i) {
							et(i)
						}
				}
				error(n) {
					const { partialObserver: e } = this
					if (e.error)
						try {
							e.error(n)
						} catch (i) {
							et(i)
						}
					else et(n)
				}
				complete() {
					const { partialObserver: n } = this
					if (n.complete)
						try {
							n.complete()
						} catch (e) {
							et(e)
						}
				}
			}
			class st extends Ce {
				constructor(n, e, i) {
					let r
					if ((super(), q(n) || !n)) r = { next: n ?? void 0, error: e ?? void 0, complete: i ?? void 0 }
					else {
						let o
						this && B.useDeprecatedNextContext
							? ((o = Object.create(n)),
							  (o.unsubscribe = () => this.unsubscribe()),
							  (r = {
									next: n.next && it(n.next, o),
									error: n.error && it(n.error, o),
									complete: n.complete && it(n.complete, o)
							  }))
							: (r = n)
					}
					this.destination = new Ue(r)
				}
			}
			function et(t) {
				B.useDeprecatedSynchronousErrorHandling
					? (function Je(t) {
							B.useDeprecatedSynchronousErrorHandling && ye && ((ye.errorThrown = !0), (ye.error = t))
					  })(t)
					: I(t)
			}
			function he(t, n) {
				const { onStoppedNotification: e } = B
				e && H.setTimeout(() => e(t, n))
			}
			const Ve = {
					closed: !0,
					next: G,
					error: function ke(t) {
						throw t
					},
					complete: G
				},
				je = ("function" == typeof Symbol && Symbol.observable) || "@@observable"
			function Re(t) {
				return t
			}
			let Ge = (() => {
				class t {
					constructor(e) {
						e && (this._subscribe = e)
					}
					lift(e) {
						const i = new t()
						return (i.source = this), (i.operator = e), i
					}
					subscribe(e, i, r) {
						const o = (function yn(t) {
							return (
								(t && t instanceof Ce) ||
								((function Jt(t) {
									return t && q(t.next) && q(t.error) && q(t.complete)
								})(t) &&
									R(t))
							)
						})(e)
							? e
							: new st(e, i, r)
						return (
							Qe(() => {
								const { operator: s, source: a } = this
								o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o))
							}),
							o
						)
					}
					_trySubscribe(e) {
						try {
							return this._subscribe(e)
						} catch (i) {
							e.error(i)
						}
					}
					forEach(e, i) {
						return new (i = wt(i))((r, o) => {
							const s = new st({
								next: a => {
									try {
										e(a)
									} catch (c) {
										o(c), s.unsubscribe()
									}
								},
								error: o,
								complete: r
							})
							this.subscribe(s)
						})
					}
					_subscribe(e) {
						var i
						return null === (i = this.source) || void 0 === i ? void 0 : i.subscribe(e)
					}
					[je]() {
						return this
					}
					pipe(...e) {
						return (function qe(t) {
							return 0 === t.length
								? Re
								: 1 === t.length
								? t[0]
								: function (e) {
										return t.reduce((i, r) => r(i), e)
								  }
						})(e)(this)
					}
					toPromise(e) {
						return new (e = wt(e))((i, r) => {
							let o
							this.subscribe(
								s => (o = s),
								s => r(s),
								() => i(o)
							)
						})
					}
				}
				return (t.create = n => new t(n)), t
			})()
			function wt(t) {
				var n
				return null !== (n = t ?? B.Promise) && void 0 !== n ? n : Promise
			}
			const ai = m(
				t =>
					function () {
						t(this), (this.name = "ObjectUnsubscribedError"), (this.message = "object unsubscribed")
					}
			)
			let vt = (() => {
				class t extends Ge {
					constructor() {
						super(),
							(this.closed = !1),
							(this.currentObservers = null),
							(this.observers = []),
							(this.isStopped = !1),
							(this.hasError = !1),
							(this.thrownError = null)
					}
					lift(e) {
						const i = new hi(this, this)
						return (i.operator = e), i
					}
					_throwIfClosed() {
						if (this.closed) throw new ai()
					}
					next(e) {
						Qe(() => {
							if ((this._throwIfClosed(), !this.isStopped)) {
								this.currentObservers || (this.currentObservers = Array.from(this.observers))
								for (const i of this.currentObservers) i.next(e)
							}
						})
					}
					error(e) {
						Qe(() => {
							if ((this._throwIfClosed(), !this.isStopped)) {
								;(this.hasError = this.isStopped = !0), (this.thrownError = e)
								const { observers: i } = this
								for (; i.length; ) i.shift().error(e)
							}
						})
					}
					complete() {
						Qe(() => {
							if ((this._throwIfClosed(), !this.isStopped)) {
								this.isStopped = !0
								const { observers: e } = this
								for (; e.length; ) e.shift().complete()
							}
						})
					}
					unsubscribe() {
						;(this.isStopped = this.closed = !0), (this.observers = this.currentObservers = null)
					}
					get observed() {
						var e
						return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0
					}
					_trySubscribe(e) {
						return this._throwIfClosed(), super._trySubscribe(e)
					}
					_subscribe(e) {
						return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e)
					}
					_innerSubscribe(e) {
						const { hasError: i, isStopped: r, observers: o } = this
						return i || r
							? $
							: ((this.currentObservers = null),
							  o.push(e),
							  new D(() => {
									;(this.currentObservers = null), Q(o, e)
							  }))
					}
					_checkFinalizedStatuses(e) {
						const { hasError: i, thrownError: r, isStopped: o } = this
						i ? e.error(r) : o && e.complete()
					}
					asObservable() {
						const e = new Ge()
						return (e.source = this), e
					}
				}
				return (t.create = (n, e) => new hi(n, e)), t
			})()
			class hi extends vt {
				constructor(n, e) {
					super(), (this.destination = n), (this.source = e)
				}
				next(n) {
					var e, i
					null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.next) || void 0 === i || i.call(e, n)
				}
				error(n) {
					var e, i
					null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.error) || void 0 === i || i.call(e, n)
				}
				complete() {
					var n, e
					null === (e = null === (n = this.destination) || void 0 === n ? void 0 : n.complete) || void 0 === e || e.call(n)
				}
				_subscribe(n) {
					var e, i
					return null !== (i = null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(n)) && void 0 !== i ? i : $
				}
			}
			function Wt(t) {
				return n => {
					if (
						(function yi(t) {
							return q(t?.lift)
						})(n)
					)
						return n.lift(function (e) {
							try {
								return t(e, this)
							} catch (i) {
								this.error(i)
							}
						})
					throw new TypeError("Unable to lift unknown Observable type")
				}
			}
			function we(t, n, e, i, r) {
				return new gt(t, n, e, i, r)
			}
			class gt extends Ce {
				constructor(n, e, i, r, o, s) {
					super(n),
						(this.onFinalize = o),
						(this.shouldUnsubscribe = s),
						(this._next = e
							? function (a) {
									try {
										e(a)
									} catch (c) {
										n.error(c)
									}
							  }
							: super._next),
						(this._error = r
							? function (a) {
									try {
										r(a)
									} catch (c) {
										n.error(c)
									} finally {
										this.unsubscribe()
									}
							  }
							: super._error),
						(this._complete = i
							? function () {
									try {
										i()
									} catch (a) {
										n.error(a)
									} finally {
										this.unsubscribe()
									}
							  }
							: super._complete)
				}
				unsubscribe() {
					var n
					if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
						const { closed: e } = this
						super.unsubscribe(), !e && (null === (n = this.onFinalize) || void 0 === n || n.call(this))
					}
				}
			}
			function Ke(t, n) {
				return Wt((e, i) => {
					let r = 0
					e.subscribe(
						we(i, o => {
							i.next(t.call(n, o, r++))
						})
					)
				})
			}
			function Qr(t) {
				return this instanceof Qr ? ((this.v = t), this) : new Qr(t)
			}
			function $c(t) {
				if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.")
				var e,
					n = t[Symbol.asyncIterator]
				return n
					? n.call(t)
					: ((t = (function Yr(t) {
							var n = "function" == typeof Symbol && Symbol.iterator,
								e = n && t[n],
								i = 0
							if (e) return e.call(t)
							if (t && "number" == typeof t.length)
								return {
									next: function () {
										return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t }
									}
								}
							throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.")
					  })(t)),
					  (e = {}),
					  i("next"),
					  i("throw"),
					  i("return"),
					  (e[Symbol.asyncIterator] = function () {
							return this
					  }),
					  e)
				function i(o) {
					e[o] =
						t[o] &&
						function (s) {
							return new Promise(function (a, c) {
								!(function r(o, s, a, c) {
									Promise.resolve(c).then(function (l) {
										o({ value: l, done: a })
									}, s)
								})(a, c, (s = t[o](s)).done, s.value)
							})
						}
				}
			}
			"function" == typeof SuppressedError && SuppressedError
			const Wc = t => t && "number" == typeof t.length && "function" != typeof t
			function nh(t) {
				return q(t?.then)
			}
			function Nd(t) {
				return q(t[je])
			}
			function Df(t) {
				return Symbol.asyncIterator && q(t?.[Symbol.asyncIterator])
			}
			function Qp(t) {
				return new TypeError(
					`You provided ${
						null !== t && "object" == typeof t ? "an invalid object" : `'${t}'`
					} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`
				)
			}
			const pi = (function Lf() {
				return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"
			})()
			function Ll(t) {
				return q(t?.[pi])
			}
			function be(t) {
				return (function ba(t, n, e) {
					if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.")
					var r,
						i = e.apply(t, n || []),
						o = []
					return (
						(r = {}),
						s("next"),
						s("throw"),
						s("return"),
						(r[Symbol.asyncIterator] = function () {
							return this
						}),
						r
					)
					function s(h) {
						i[h] &&
							(r[h] = function (f) {
								return new Promise(function (_, y) {
									o.push([h, f, _, y]) > 1 || a(h, f)
								})
							})
					}
					function a(h, f) {
						try {
							!(function c(h) {
								h.value instanceof Qr ? Promise.resolve(h.value.v).then(l, d) : u(o[0][2], h)
							})(i[h](f))
						} catch (_) {
							u(o[0][3], _)
						}
					}
					function l(h) {
						a("next", h)
					}
					function d(h) {
						a("throw", h)
					}
					function u(h, f) {
						h(f), o.shift(), o.length && a(o[0][0], o[0][1])
					}
				})(this, arguments, function* () {
					const e = t.getReader()
					try {
						for (;;) {
							const { value: i, done: r } = yield Qr(e.read())
							if (r) return yield Qr(void 0)
							yield yield Qr(i)
						}
					} finally {
						e.releaseLock()
					}
				})
			}
			function ie(t) {
				return q(t?.getReader)
			}
			function _e(t) {
				if (t instanceof Ge) return t
				if (null != t) {
					if (Nd(t))
						return (function $e(t) {
							return new Ge(n => {
								const e = t[je]()
								if (q(e.subscribe)) return e.subscribe(n)
								throw new TypeError("Provided object does not correctly implement Symbol.observable")
							})
						})(t)
					if (Wc(t))
						return (function Xe(t) {
							return new Ge(n => {
								for (let e = 0; e < t.length && !n.closed; e++) n.next(t[e])
								n.complete()
							})
						})(t)
					if (nh(t))
						return (function Xt(t) {
							return new Ge(n => {
								t.then(
									e => {
										n.closed || (n.next(e), n.complete())
									},
									e => n.error(e)
								).then(null, I)
							})
						})(t)
					if (Df(t)) return Ti(t)
					if (Ll(t))
						return (function ii(t) {
							return new Ge(n => {
								for (const e of t) if ((n.next(e), n.closed)) return
								n.complete()
							})
						})(t)
					if (ie(t))
						return (function ji(t) {
							return Ti(be(t))
						})(t)
				}
				throw Qp(t)
			}
			function Ti(t) {
				return new Ge(n => {
					;(function Ir(t, n) {
						var e, i, r, o
						return (function Pi(t, n, e, i) {
							return new (e || (e = Promise))(function (o, s) {
								function a(d) {
									try {
										l(i.next(d))
									} catch (u) {
										s(u)
									}
								}
								function c(d) {
									try {
										l(i.throw(d))
									} catch (u) {
										s(u)
									}
								}
								function l(d) {
									d.done
										? o(d.value)
										: (function r(o) {
												return o instanceof e
													? o
													: new e(function (s) {
															s(o)
													  })
										  })(d.value).then(a, c)
								}
								l((i = i.apply(t, n || [])).next())
							})
						})(this, void 0, void 0, function* () {
							try {
								for (e = $c(t); !(i = yield e.next()).done; ) if ((n.next(i.value), n.closed)) return
							} catch (s) {
								r = { error: s }
							} finally {
								try {
									i && !i.done && (o = e.return) && (yield o.call(e))
								} finally {
									if (r) throw r.error
								}
							}
							n.complete()
						})
					})(t, n).catch(e => n.error(e))
				})
			}
			function Jn(t, n, e, i = 0, r = !1) {
				const o = n.schedule(function () {
					e(), r ? t.add(this.schedule(null, i)) : this.unsubscribe()
				}, i)
				if ((t.add(o), !r)) return o
			}
			function ir(t, n, e = 1 / 0) {
				return q(n)
					? ir((i, r) => Ke((o, s) => n(i, o, r, s))(_e(t(i, r))), e)
					: ("number" == typeof n && (e = n),
					  Wt((i, r) =>
							(function wr(t, n, e, i, r, o, s, a) {
								const c = []
								let l = 0,
									d = 0,
									u = !1
								const h = () => {
										u && !c.length && !l && n.complete()
									},
									f = y => (l < i ? _(y) : c.push(y)),
									_ = y => {
										o && n.next(y), l++
										let C = !1
										_e(e(y, d++)).subscribe(
											we(
												n,
												x => {
													r?.(x), o ? f(x) : n.next(x)
												},
												() => {
													C = !0
												},
												void 0,
												() => {
													if (C)
														try {
															for (l--; c.length && l < i; ) {
																const x = c.shift()
																s ? Jn(n, s, () => _(x)) : _(x)
															}
															h()
														} catch (x) {
															n.error(x)
														}
												}
											)
										)
									}
								return (
									t.subscribe(
										we(n, f, () => {
											;(u = !0), h()
										})
									),
									() => {
										a?.()
									}
								)
							})(i, r, t, e)
					  ))
			}
			function fr(t = 1 / 0) {
				return ir(Re, t)
			}
			const Ai = new Ge(t => t.complete())
			function Ps(t) {
				return t && q(t.schedule)
			}
			function Uo(t) {
				return t[t.length - 1]
			}
			function ko(t) {
				return q(Uo(t)) ? t.pop() : void 0
			}
			function Oi(t) {
				return Ps(Uo(t)) ? t.pop() : void 0
			}
			function ss(t, n = 0) {
				return Wt((e, i) => {
					e.subscribe(
						we(
							i,
							r => Jn(i, t, () => i.next(r), n),
							() => Jn(i, t, () => i.complete(), n),
							r => Jn(i, t, () => i.error(r), n)
						)
					)
				})
			}
			function Xs(t, n = 0) {
				return Wt((e, i) => {
					i.add(t.schedule(() => e.subscribe(i), n))
				})
			}
			function Hd(t, n) {
				if (!t) throw new Error("Iterable cannot be null")
				return new Ge(e => {
					Jn(e, n, () => {
						const i = t[Symbol.asyncIterator]()
						Jn(
							e,
							n,
							() => {
								i.next().then(r => {
									r.done ? e.complete() : e.next(r.value)
								})
							},
							0,
							!0
						)
					})
				})
			}
			function ro(t, n) {
				return n
					? (function Ha(t, n) {
							if (null != t) {
								if (Nd(t))
									return (function va(t, n) {
										return _e(t).pipe(Xs(n), ss(n))
									})(t, n)
								if (Wc(t))
									return (function Ud(t, n) {
										return new Ge(e => {
											let i = 0
											return n.schedule(function () {
												i === t.length ? e.complete() : (e.next(t[i++]), e.closed || this.schedule())
											})
										})
									})(t, n)
								if (nh(t))
									return (function gs(t, n) {
										return _e(t).pipe(Xs(n), ss(n))
									})(t, n)
								if (Df(t)) return Hd(t, n)
								if (Ll(t))
									return (function ih(t, n) {
										return new Ge(e => {
											let i
											return (
												Jn(e, n, () => {
													;(i = t[pi]()),
														Jn(
															e,
															n,
															() => {
																let r, o
																try {
																	;({ value: r, done: o } = i.next())
																} catch (s) {
																	return void e.error(s)
																}
																o ? e.complete() : e.next(r)
															},
															0,
															!0
														)
												}),
												() => q(i?.return) && i.return()
											)
										})
									})(t, n)
								if (ie(t))
									return (function Ua(t, n) {
										return Hd(be(t), n)
									})(t, n)
							}
							throw Qp(t)
					  })(t, n)
					: _e(t)
			}
			function oo(...t) {
				const n = Oi(t),
					e = (function To(t, n) {
						return "number" == typeof Uo(t) ? t.pop() : n
					})(t, 1 / 0),
					i = t
				return i.length ? (1 === i.length ? _e(i[0]) : fr(e)(ro(i, n))) : Ai
			}
			class zr extends vt {
				constructor(n) {
					super(), (this._value = n)
				}
				get value() {
					return this.getValue()
				}
				_subscribe(n) {
					const e = super._subscribe(n)
					return !e.closed && n.next(this._value), e
				}
				getValue() {
					const { hasError: n, thrownError: e, _value: i } = this
					if (n) throw e
					return this._throwIfClosed(), i
				}
				next(n) {
					super.next((this._value = n))
				}
			}
			function Wo(...t) {
				return ro(t, Oi(t))
			}
			function Rl(t = {}) {
				const { connector: n = () => new vt(), resetOnError: e = !0, resetOnComplete: i = !0, resetOnRefCountZero: r = !0 } = t
				return o => {
					let s,
						a,
						c,
						l = 0,
						d = !1,
						u = !1
					const h = () => {
							a?.unsubscribe(), (a = void 0)
						},
						f = () => {
							h(), (s = c = void 0), (d = u = !1)
						},
						_ = () => {
							const y = s
							f(), y?.unsubscribe()
						}
					return Wt((y, C) => {
						l++, !u && !d && h()
						const x = (c = c ?? n())
						C.add(() => {
							l--, 0 === l && !u && !d && (a = Rf(_, r))
						}),
							x.subscribe(C),
							!s &&
								l > 0 &&
								((s = new st({
									next: w => x.next(w),
									error: w => {
										;(u = !0), h(), (a = Rf(f, e, w)), x.error(w)
									},
									complete: () => {
										;(d = !0), h(), (a = Rf(f, i)), x.complete()
									}
								})),
								_e(y).subscribe(s))
					})(o)
				}
			}
			function Rf(t, n, ...e) {
				if (!0 === n) return void t()
				if (!1 === n) return
				const i = new st({
					next: () => {
						i.unsubscribe(), t()
					}
				})
				return _e(n(...e)).subscribe(i)
			}
			function ya(t, n) {
				return Wt((e, i) => {
					let r = null,
						o = 0,
						s = !1
					const a = () => s && !r && i.complete()
					e.subscribe(
						we(
							i,
							c => {
								r?.unsubscribe()
								let l = 0
								const d = o++
								_e(t(c, d)).subscribe(
									(r = we(
										i,
										u => i.next(n ? n(c, u, d, l++) : u),
										() => {
											;(r = null), a()
										}
									))
								)
							},
							() => {
								;(s = !0), a()
							}
						)
					)
				})
			}
			function Ys(t, n = Re) {
				return (
					(t = t ?? Vd),
					Wt((e, i) => {
						let r,
							o = !0
						e.subscribe(
							we(i, s => {
								const a = n(s)
								;(o || !t(r, a)) && ((o = !1), (r = a), i.next(s))
							})
						)
					})
				)
			}
			function Vd(t, n) {
				return t === n
			}
			function Ki(t) {
				for (let n in t) if (t[n] === Ki) return n
				throw Error("Could not find renamed property on target object.")
			}
			function pc(t, n) {
				for (const e in n) n.hasOwnProperty(e) && !t.hasOwnProperty(e) && (t[e] = n[e])
			}
			function Lr(t) {
				if ("string" == typeof t) return t
				if (Array.isArray(t)) return "[" + t.map(Lr).join(", ") + "]"
				if (null == t) return "" + t
				if (t.overriddenName) return `${t.overriddenName}`
				if (t.name) return `${t.name}`
				const n = t.toString()
				if (null == n) return "" + n
				const e = n.indexOf("\n")
				return -1 === e ? n : n.substring(0, e)
			}
			function rh(t, n) {
				return null == t || "" === t ? (null === n ? "" : n) : null == n || "" === n ? t : t + " " + n
			}
			const zp = Ki({ __forward_ref__: Ki })
			function Kn(t) {
				return (
					(t.__forward_ref__ = Kn),
					(t.toString = function () {
						return Lr(this())
					}),
					t
				)
			}
			function Tn(t) {
				return Pl(t) ? t() : t
			}
			function Pl(t) {
				return "function" == typeof t && t.hasOwnProperty(zp) && t.__forward_ref__ === Kn
			}
			function Ac(t) {
				return t && !!t.ɵproviders
			}
			const jb = "https://g.co/ng/security#xss"
			class ht extends Error {
				constructor(n, e) {
					super(
						(function gc(t, n) {
							return `NG0${Math.abs(t)}${n ? ": " + n : ""}`
						})(n, e)
					),
						(this.code = n)
				}
			}
			function Dn(t) {
				return "string" == typeof t ? t : null == t ? "" : String(t)
			}
			function Gp(t, n) {
				throw new ht(-201, !1)
			}
			function mr(t, n) {
				null == t &&
					(function $n(t, n, e, i) {
						throw new Error(`ASSERTION ERROR: ${t}` + (null == i ? "" : ` [Expected=> ${e} ${i} ${n} <=Actual]`))
					})(n, t, null, "!=")
			}
			function mt(t) {
				return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 }
			}
			function rt(t) {
				return { providers: t.providers || [], imports: t.imports || [] }
			}
			function Qd(t) {
				return ex(t, oh) || ex(t, tx)
			}
			function ex(t, n) {
				return t.hasOwnProperty(n) ? t[n] : null
			}
			function zd(t) {
				return t && (t.hasOwnProperty(Yb) || t.hasOwnProperty(vT)) ? t[Yb] : null
			}
			const oh = Ki({ ɵprov: Ki }),
				Yb = Ki({ ɵinj: Ki }),
				tx = Ki({ ngInjectableDef: Ki }),
				vT = Ki({ ngInjectorDef: Ki })
			var Di = (function (t) {
				return (
					(t[(t.Default = 0)] = "Default"),
					(t[(t.Host = 1)] = "Host"),
					(t[(t.Self = 2)] = "Self"),
					(t[(t.SkipSelf = 4)] = "SkipSelf"),
					(t[(t.Optional = 8)] = "Optional"),
					t
				)
			})(Di || {})
			let qb
			function nx() {
				return qb
			}
			function Ns(t) {
				const n = qb
				return (qb = t), n
			}
			function ix(t, n, e) {
				const i = Qd(t)
				return i && "root" == i.providedIn
					? void 0 === i.value
						? (i.value = i.factory())
						: i.value
					: e & Di.Optional
					? null
					: void 0 !== n
					? n
					: void Gp(Lr(t))
			}
			const vr = globalThis
			class He {
				constructor(n, e) {
					;(this._desc = n),
						(this.ngMetadataName = "InjectionToken"),
						(this.ɵprov = void 0),
						"number" == typeof e
							? (this.__NG_ELEMENT_ID__ = e)
							: void 0 !== e && (this.ɵprov = mt({ token: this, providedIn: e.providedIn || "root", factory: e.factory }))
				}
				get multi() {
					return this
				}
				toString() {
					return `InjectionToken ${this._desc}`
				}
			}
			const Kc = {},
				Nl = "__NG_DI_FLAG__",
				qi = "ngTempTokenPath",
				n_ = /\n/gm,
				Gd = "__source"
			let bs
			function _s(t) {
				const n = bs
				return (bs = t), n
			}
			function mo(t, n = Di.Default) {
				if (void 0 === bs) throw new ht(-203, !1)
				return null === bs ? ix(t, void 0, n) : bs.get(t, n & Di.Optional ? null : void 0, n)
			}
			function re(t, n = Di.Default) {
				return (nx() || mo)(Tn(t), n)
			}
			function Rt(t, n = Di.Default) {
				return re(t, Va(n))
			}
			function Va(t) {
				return typeof t > "u" || "number" == typeof t
					? t
					: 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4)
			}
			function $d(t) {
				const n = []
				for (let e = 0; e < t.length; e++) {
					const i = Tn(t[e])
					if (Array.isArray(i)) {
						if (0 === i.length) throw new ht(900, !1)
						let r,
							o = Di.Default
						for (let s = 0; s < i.length; s++) {
							const a = i[s],
								c = ax(a)
							"number" == typeof c ? (-1 === c ? (r = a.token) : (o |= c)) : (r = a)
						}
						n.push(re(r, o))
					} else n.push(re(i))
				}
				return n
			}
			function tr(t, n) {
				return (t[Nl] = n), (t.prototype[Nl] = n), t
			}
			function ax(t) {
				return t[Nl]
			}
			function _c(t) {
				return { toString: t }.toString()
			}
			var Wd = (function (t) {
					return (t[(t.OnPush = 0)] = "OnPush"), (t[(t.Default = 1)] = "Default"), t
				})(Wd || {}),
				Zs = (function (t) {
					return (t[(t.Emulated = 0)] = "Emulated"), (t[(t.None = 2)] = "None"), (t[(t.ShadowDom = 3)] = "ShadowDom"), t
				})(Zs || {})
			const Qa = {},
				oi = [],
				za = Ki({ ɵcmp: Ki }),
				vc = Ki({ ɵdir: Ki }),
				po = Ki({ ɵpipe: Ki }),
				Xc = Ki({ ɵmod: Ki }),
				yc = Ki({ ɵfac: Ki }),
				sh = Ki({ __NG_ELEMENT_ID__: Ki }),
				$p = Ki({ __NG_ENV_ID__: Ki })
			function i_(t, n, e) {
				let i = t.length
				for (;;) {
					const r = t.indexOf(n, e)
					if (-1 === r) return r
					if (0 === r || t.charCodeAt(r - 1) <= 32) {
						const o = n.length
						if (r + o === i || t.charCodeAt(r + o) <= 32) return r
					}
					e = r + 1
				}
			}
			function r_(t, n, e) {
				let i = 0
				for (; i < e.length; ) {
					const r = e[i]
					if ("number" == typeof r) {
						if (0 !== r) break
						i++
						const o = e[i++],
							s = e[i++],
							a = e[i++]
						t.setAttribute(n, s, a, o)
					} else {
						const o = r,
							s = e[++i]
						wc(o) ? t.setProperty(n, o, s) : t.setAttribute(n, o, s), i++
					}
				}
				return i
			}
			function ah(t) {
				return 3 === t || 4 === t || 6 === t
			}
			function wc(t) {
				return 64 === t.charCodeAt(0)
			}
			function Of(t, n) {
				if (null !== n && 0 !== n.length)
					if (null === t || 0 === t.length) t = n.slice()
					else {
						let e = -1
						for (let i = 0; i < n.length; i++) {
							const r = n[i]
							"number" == typeof r ? (e = r) : 0 === e || dx(t, e, r, null, -1 === e || 2 === e ? n[++i] : null)
						}
					}
				return t
			}
			function dx(t, n, e, i, r) {
				let o = 0,
					s = t.length
				if (-1 === n) s = -1
				else
					for (; o < t.length; ) {
						const a = t[o++]
						if ("number" == typeof a) {
							if (a === n) {
								s = -1
								break
							}
							if (a > n) {
								s = o - 1
								break
							}
						}
					}
				for (; o < t.length; ) {
					const a = t[o]
					if ("number" == typeof a) break
					if (a === e) {
						if (null === i) return void (null !== r && (t[o + 1] = r))
						if (i === t[o + 1]) return void (t[o + 2] = r)
					}
					o++, null !== i && o++, null !== r && o++
				}
				;-1 !== s && (t.splice(s, 0, n), (o = s + 1)),
					t.splice(o++, 0, e),
					null !== i && t.splice(o++, 0, i),
					null !== r && t.splice(o++, 0, r)
			}
			const Nf = "ng-template"
			function ux(t, n, e) {
				let i = 0,
					r = !0
				for (; i < t.length; ) {
					let o = t[i++]
					if ("string" == typeof o && r) {
						const s = t[i++]
						if (e && "class" === o && -1 !== i_(s.toLowerCase(), n, 0)) return !0
					} else {
						if (1 === o) {
							for (; i < t.length && "string" == typeof (o = t[i++]); ) if (o.toLowerCase() === n) return !0
							return !1
						}
						"number" == typeof o && (r = !1)
					}
				}
				return !1
			}
			function hx(t) {
				return 4 === t.type && t.value !== Nf
			}
			function MT(t, n, e) {
				return n === (4 !== t.type || e ? t.value : Nf)
			}
			function Ga(t, n, e) {
				let i = 4
				const r = t.attrs || [],
					o = (function kT(t) {
						for (let n = 0; n < t.length; n++) if (ah(t[n])) return n
						return t.length
					})(r)
				let s = !1
				for (let a = 0; a < n.length; a++) {
					const c = n[a]
					if ("number" != typeof c) {
						if (!s)
							if (4 & i) {
								if (((i = 2 | (1 & i)), ("" !== c && !MT(t, c, e)) || ("" === c && 1 === n.length))) {
									if (wa(i)) return !1
									s = !0
								}
							} else {
								const l = 8 & i ? c : n[++a]
								if (8 & i && null !== t.attrs) {
									if (!ux(t.attrs, l, e)) {
										if (wa(i)) return !1
										s = !0
									}
									continue
								}
								const u = ST(8 & i ? "class" : c, r, hx(t), e)
								if (-1 === u) {
									if (wa(i)) return !1
									s = !0
									continue
								}
								if ("" !== l) {
									let h
									h = u > o ? "" : r[u + 1].toLowerCase()
									const f = 8 & i ? h : null
									if ((f && -1 !== i_(f, l, 0)) || (2 & i && l !== h)) {
										if (wa(i)) return !1
										s = !0
									}
								}
							}
					} else {
						if (!s && !wa(i) && !wa(c)) return !1
						if (s && wa(c)) continue
						;(s = !1), (i = c | (1 & i))
					}
				}
				return wa(i) || s
			}
			function wa(t) {
				return 0 == (1 & t)
			}
			function ST(t, n, e, i) {
				if (null === n) return -1
				let r = 0
				if (i || !e) {
					let o = !1
					for (; r < n.length; ) {
						const s = n[r]
						if (s === t) return r
						if (3 === s || 6 === s) o = !0
						else {
							if (1 === s || 2 === s) {
								let a = n[++r]
								for (; "string" == typeof a; ) a = n[++r]
								continue
							}
							if (4 === s) break
							if (0 === s) {
								r += 4
								continue
							}
						}
						r += o ? 1 : 2
					}
					return -1
				}
				return (function mx(t, n) {
					let e = t.indexOf(4)
					if (e > -1)
						for (e++; e < t.length; ) {
							const i = t[e]
							if ("number" == typeof i) return -1
							if (i === n) return e
							e++
						}
					return -1
				})(n, t)
			}
			function fx(t, n, e = !1) {
				for (let i = 0; i < n.length; i++) if (Ga(t, n[i], e)) return !0
				return !1
			}
			function px(t, n) {
				e: for (let e = 0; e < n.length; e++) {
					const i = n[e]
					if (t.length === i.length) {
						for (let r = 0; r < t.length; r++) if (t[r] !== i[r]) continue e
						return !0
					}
				}
				return !1
			}
			function o_(t, n) {
				return t ? ":not(" + n.trim() + ")" : n
			}
			function Ax(t) {
				let n = t[0],
					e = 1,
					i = 2,
					r = "",
					o = !1
				for (; e < t.length; ) {
					let s = t[e]
					if ("string" == typeof s)
						if (2 & i) {
							const a = t[++e]
							r += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]"
						} else 8 & i ? (r += "." + s) : 4 & i && (r += " " + s)
					else "" !== r && !wa(s) && ((n += o_(o, r)), (r = "")), (i = s), (o = o || !wa(i))
					e++
				}
				return "" !== r && (n += o_(o, r)), n
			}
			function Ye(t) {
				return _c(() => {
					const n = ch(t),
						e = {
							...n,
							decls: t.decls,
							vars: t.vars,
							template: t.template,
							consts: t.consts || null,
							ngContentSelectors: t.ngContentSelectors,
							onPush: t.changeDetection === Wd.OnPush,
							directiveDefs: null,
							pipeDefs: null,
							dependencies: (n.standalone && t.dependencies) || null,
							getStandaloneInjector: null,
							signals: t.signals ?? !1,
							data: t.data || {},
							encapsulation: t.encapsulation || Zs.Emulated,
							styles: t.styles || oi,
							_: null,
							schemas: t.schemas || null,
							tView: null,
							id: ""
						}
					_x(e)
					const i = t.dependencies
					return (
						(e.directiveDefs = Xp(i, !1)),
						(e.pipeDefs = Xp(i, !0)),
						(e.id = (function BT(t) {
							let n = 0
							const e = [
								t.selectors,
								t.ngContentSelectors,
								t.hostVars,
								t.hostAttrs,
								t.consts,
								t.vars,
								t.decls,
								t.encapsulation,
								t.standalone,
								t.signals,
								t.exportAs,
								JSON.stringify(t.inputs),
								JSON.stringify(t.outputs),
								Object.getOwnPropertyNames(t.type.prototype),
								!!t.contentQueries,
								!!t.viewQuery
							].join("|")
							for (const r of e) n = (Math.imul(31, n) + r.charCodeAt(0)) << 0
							return (n += 2147483648), "c" + n
						})(e)),
						e
					)
				})
			}
			function Uf(t, n, e) {
				const i = t.ɵcmp
				;(i.directiveDefs = Xp(n, !1)), (i.pipeDefs = Xp(e, !0))
			}
			function TT(t) {
				return Ni(t) || jo(t)
			}
			function jp(t) {
				return null !== t
			}
			function at(t) {
				return _c(() => ({
					type: t.type,
					bootstrap: t.bootstrap || oi,
					declarations: t.declarations || oi,
					imports: t.imports || oi,
					exports: t.exports || oi,
					transitiveCompileScopes: null,
					schemas: t.schemas || null,
					id: t.id || null
				}))
			}
			function Kp(t, n) {
				if (null == t) return Qa
				const e = {}
				for (const i in t)
					if (t.hasOwnProperty(i)) {
						let r = t[i],
							o = r
						Array.isArray(r) && ((o = r[1]), (r = r[0])), (e[r] = i), n && (n[r] = o)
					}
				return e
			}
			function yt(t) {
				return _c(() => {
					const n = ch(t)
					return _x(n), n
				})
			}
			function Zi(t) {
				return {
					type: t.type,
					name: t.name,
					factory: null,
					pure: !1 !== t.pure,
					standalone: !0 === t.standalone,
					onDestroy: t.type.prototype.ngOnDestroy || null
				}
			}
			function Ni(t) {
				return t[za] || null
			}
			function jo(t) {
				return t[vc] || null
			}
			function vs(t) {
				return t[po] || null
			}
			function ch(t) {
				const n = {}
				return {
					type: t.type,
					providersResolver: null,
					factory: null,
					hostBindings: t.hostBindings || null,
					hostVars: t.hostVars || 0,
					hostAttrs: t.hostAttrs || null,
					contentQueries: t.contentQueries || null,
					declaredInputs: n,
					inputTransforms: null,
					inputConfig: t.inputs || Qa,
					exportAs: t.exportAs || null,
					standalone: !0 === t.standalone,
					signals: !0 === t.signals,
					selectors: t.selectors || oi,
					viewQuery: t.viewQuery || null,
					features: t.features || null,
					setInput: null,
					findHostDirectiveDefs: null,
					hostDirectives: null,
					inputs: Kp(t.inputs, n),
					outputs: Kp(t.outputs)
				}
			}
			function _x(t) {
				t.features?.forEach(n => n(t))
			}
			function Xp(t, n) {
				if (!t) return null
				const e = n ? vs : TT
				return () => ("function" == typeof t ? t() : t).map(i => e(i)).filter(jp)
			}
			const qr = 0,
				Qt = 1,
				si = 2,
				pr = 3,
				$a = 4,
				Vf = 5,
				as = 6,
				lh = 7,
				Rr = 8,
				Ul = 9,
				dh = 10,
				ei = 11,
				Qf = 12,
				zf = 13,
				uh = 14,
				so = 15,
				Gf = 16,
				hh = 17,
				xc = 18,
				$f = 19,
				vx = 20,
				Hl = 21,
				Yc = 22,
				Wf = 23,
				jd = 24,
				Ei = 25,
				qp = 1,
				yx = 2,
				Cc = 7,
				qc = 9,
				Ko = 11
			function Us(t) {
				return Array.isArray(t) && "object" == typeof t[qp]
			}
			function ys(t) {
				return Array.isArray(t) && !0 === t[qp]
			}
			function s_(t) {
				return 0 != (4 & t.flags)
			}
			function Ec(t) {
				return t.componentOffset > -1
			}
			function Zp(t) {
				return 1 == (1 & t.flags)
			}
			function Wa(t) {
				return !!t.template
			}
			function a_(t) {
				return 0 != (512 & t[si])
			}
			function Kd(t, n) {
				return t.hasOwnProperty(yc) ? t[yc] : null
			}
			const Vl = Symbol("SIGNAL")
			function Ao(t, n) {
				return (null === t || "object" != typeof t) && Object.is(t, n)
			}
			let Xo = null,
				Jp = !1
			function xa(t) {
				const n = Xo
				return (Xo = t), n
			}
			const eA = {
				version: 0,
				dirty: !1,
				producerNode: void 0,
				producerLastReadVersion: void 0,
				producerIndexOfThis: void 0,
				nextProducerIndex: 0,
				liveConsumerNode: void 0,
				liveConsumerIndexOfThis: void 0,
				consumerAllowSignalWrites: !1,
				consumerIsAlwaysLive: !1,
				producerMustRecompute: () => !1,
				producerRecomputeValue: () => {},
				consumerMarkedDirty: () => {}
			}
			function Cx(t) {
				if (Jp) throw new Error("")
				if (null === Xo) return
				const n = Xo.nextProducerIndex++
				Ql(Xo),
					n < Xo.producerNode.length && Xo.producerNode[n] !== t && Kf(Xo) && iA(Xo.producerNode[n], Xo.producerIndexOfThis[n]),
					Xo.producerNode[n] !== t && ((Xo.producerNode[n] = t), (Xo.producerIndexOfThis[n] = Kf(Xo) ? qt(t, Xo, n) : 0)),
					(Xo.producerLastReadVersion[n] = t.version)
			}
			function l_(t) {
				if (!Kf(t) || t.dirty) {
					if (!t.producerMustRecompute(t) && !Sx(t)) return void (t.dirty = !1)
					t.producerRecomputeValue(t), (t.dirty = !1)
				}
			}
			function Ex(t) {
				if (void 0 === t.liveConsumerNode) return
				const n = Jp
				Jp = !0
				try {
					for (const e of t.liveConsumerNode) e.dirty || Mx(e)
				} finally {
					Jp = n
				}
			}
			function d_() {
				return !1 !== Xo?.consumerAllowSignalWrites
			}
			function Mx(t) {
				;(t.dirty = !0), Ex(t), t.consumerMarkedDirty?.(t)
			}
			function tA(t) {
				return t && (t.nextProducerIndex = 0), xa(t)
			}
			function nA(t, n) {
				if ((xa(n), t && void 0 !== t.producerNode && void 0 !== t.producerIndexOfThis && void 0 !== t.producerLastReadVersion)) {
					if (Kf(t))
						for (let e = t.nextProducerIndex; e < t.producerNode.length; e++) iA(t.producerNode[e], t.producerIndexOfThis[e])
					for (; t.producerNode.length > t.nextProducerIndex; )
						t.producerNode.pop(), t.producerLastReadVersion.pop(), t.producerIndexOfThis.pop()
				}
			}
			function Sx(t) {
				Ql(t)
				for (let n = 0; n < t.producerNode.length; n++) {
					const e = t.producerNode[n],
						i = t.producerLastReadVersion[n]
					if (i !== e.version || (l_(e), i !== e.version)) return !0
				}
				return !1
			}
			function u_(t) {
				if ((Ql(t), Kf(t))) for (let n = 0; n < t.producerNode.length; n++) iA(t.producerNode[n], t.producerIndexOfThis[n])
				;(t.producerNode.length = t.producerLastReadVersion.length = t.producerIndexOfThis.length = 0),
					t.liveConsumerNode && (t.liveConsumerNode.length = t.liveConsumerIndexOfThis.length = 0)
			}
			function qt(t, n, e) {
				if ((ja(t), Ql(t), 0 === t.liveConsumerNode.length))
					for (let i = 0; i < t.producerNode.length; i++) t.producerIndexOfThis[i] = qt(t.producerNode[i], t, i)
				return t.liveConsumerIndexOfThis.push(e), t.liveConsumerNode.push(n) - 1
			}
			function iA(t, n) {
				if ((ja(t), Ql(t), 1 === t.liveConsumerNode.length))
					for (let i = 0; i < t.producerNode.length; i++) iA(t.producerNode[i], t.producerIndexOfThis[i])
				const e = t.liveConsumerNode.length - 1
				if (
					((t.liveConsumerNode[n] = t.liveConsumerNode[e]),
					(t.liveConsumerIndexOfThis[n] = t.liveConsumerIndexOfThis[e]),
					t.liveConsumerNode.length--,
					t.liveConsumerIndexOfThis.length--,
					n < t.liveConsumerNode.length)
				) {
					const i = t.liveConsumerIndexOfThis[n],
						r = t.liveConsumerNode[n]
					Ql(r), (r.producerIndexOfThis[i] = n)
				}
			}
			function Kf(t) {
				return t.consumerIsAlwaysLive || (t?.liveConsumerNode?.length ?? 0) > 0
			}
			function Ql(t) {
				;(t.producerNode ??= []), (t.producerIndexOfThis ??= []), (t.producerLastReadVersion ??= [])
			}
			function ja(t) {
				;(t.liveConsumerNode ??= []), (t.liveConsumerIndexOfThis ??= [])
			}
			function kx(t, n) {
				const e = Object.create(NT)
				;(e.computation = t), n?.equal && (e.equal = n.equal)
				const i = () => {
					if ((l_(e), Cx(e), e.value === Yd)) throw e.error
					return e.value
				}
				return (i[Vl] = e), i
			}
			const rA = Symbol("UNSET"),
				Xd = Symbol("COMPUTING"),
				Yd = Symbol("ERRORED"),
				NT = (() => ({
					...eA,
					value: rA,
					dirty: !0,
					error: null,
					equal: Ao,
					producerMustRecompute: t => t.value === rA || t.value === Xd,
					producerRecomputeValue(t) {
						if (t.value === Xd) throw new Error("Detected cycle in computations.")
						const n = t.value
						t.value = Xd
						const e = tA(t)
						let i
						try {
							i = t.computation()
						} catch (r) {
							;(i = Yd), (t.error = r)
						} finally {
							nA(t, e)
						}
						n !== rA && n !== Yd && i !== Yd && t.equal(n, i) ? (t.value = n) : ((t.value = i), t.version++)
					}
				}))()
			let Tx = function UT() {
				throw new Error()
			}
			function Zc() {
				Tx()
			}
			let Xf = null
			const VT = (() => ({ ...eA, equal: Ao, readonlyFn: void 0 }))()
			function oA(t) {
				t.version++, Ex(t), Xf?.()
			}
			function Bx(t) {
				const n = this[Vl]
				d_() || Zc(), n.equal(n.value, t) || ((n.value = t), oA(n))
			}
			function QT(t) {
				d_() || Zc(), Bx.call(this, t(this[Vl].value))
			}
			function zT(t) {
				const n = this[Vl]
				d_() || Zc(), t(n.value), oA(n)
			}
			function GT() {
				const t = this[Vl]
				if (void 0 === t.readonlyFn) {
					const n = () => this()
					;(n[Vl] = t), (t.readonlyFn = n)
				}
				return t.readonlyFn
			}
			function Ix(t) {
				const n = xa(null)
				try {
					return t()
				} finally {
					xa(n)
				}
			}
			const Dx = () => {},
				WT = (() => ({
					...eA,
					consumerIsAlwaysLive: !0,
					consumerAllowSignalWrites: !1,
					consumerMarkedDirty: t => {
						t.schedule(t.ref)
					},
					hasRun: !1,
					cleanupFn: Dx
				}))()
			class KT {
				constructor(n, e, i) {
					;(this.previousValue = n), (this.currentValue = e), (this.firstChange = i)
				}
				isFirstChange() {
					return this.firstChange
				}
			}
			function Ar() {
				return Lx
			}
			function Lx(t) {
				return t.type.prototype.ngOnChanges && (t.setInput = XT), Rx
			}
			function Rx() {
				const t = Px(this),
					n = t?.current
				if (n) {
					const e = t.previous
					if (e === Qa) t.previous = n
					else for (let i in n) e[i] = n[i]
					;(t.current = null), this.ngOnChanges(n)
				}
			}
			function XT(t, n, e, i) {
				const r = this.declaredInputs[e],
					o =
						Px(t) ||
						(function f_(t, n) {
							return (t[Yf] = n)
						})(t, { previous: Qa, current: null }),
					s = o.current || (o.current = {}),
					a = o.previous,
					c = a[r]
				;(s[r] = new KT(c && c.currentValue, n, a === Qa)), (t[i] = n)
			}
			Ar.ngInherit = !0
			const Yf = "__ngSimpleChanges__"
			function Px(t) {
				return t[Yf] || null
			}
			const Ka = function (t, n, e) {},
				Nx = "svg"
			function ar(t) {
				for (; Array.isArray(t); ) t = t[qr]
				return t
			}
			function Jf(t, n) {
				return ar(n[t])
			}
			function ws(t, n) {
				return ar(n[t.index])
			}
			function p_(t, n) {
				return t.data[n]
			}
			function zl(t, n) {
				return t[n]
			}
			function ea(t, n) {
				const e = n[t]
				return Us(e) ? e : e[qr]
			}
			function Mc(t, n) {
				return null == n ? null : t[n]
			}
			function Hx(t) {
				t[hh] = 0
			}
			function ZT(t) {
				1024 & t[si] || ((t[si] |= 1024), Qx(t, 1))
			}
			function Vx(t) {
				1024 & t[si] && ((t[si] &= -1025), Qx(t, -1))
			}
			function Qx(t, n) {
				let e = t[pr]
				if (null === e) return
				e[Vf] += n
				let i = e
				for (e = e[pr]; null !== e && ((1 === n && 1 === i[Vf]) || (-1 === n && 0 === i[Vf])); ) (e[Vf] += n), (i = e), (e = e[pr])
			}
			function zx(t, n) {
				if (256 == (256 & t[si])) throw new ht(911, !1)
				null === t[Hl] && (t[Hl] = []), t[Hl].push(n)
			}
			const Wn = { lFrame: Jx(null), bindingsEnabled: !0, skipHydrationRootTNode: null }
			function g_() {
				return Wn.bindingsEnabled
			}
			function Zr() {
				return null !== Wn.skipHydrationRootTNode
			}
			function bt() {
				return Wn.lFrame.lView
			}
			function Ui() {
				return Wn.lFrame.tView
			}
			function rn(t) {
				return (Wn.lFrame.contextLView = t), t[Rr]
			}
			function on(t) {
				return (Wn.lFrame.contextLView = null), t
			}
			function Yo() {
				let t = jx()
				for (; null !== t && 64 === t.type; ) t = t.parent
				return t
			}
			function jx() {
				return Wn.lFrame.currentTNode
			}
			function Sc(t, n) {
				const e = Wn.lFrame
				;(e.currentTNode = t), (e.isParent = n)
			}
			function sA() {
				return Wn.lFrame.isParent
			}
			function aA() {
				Wn.lFrame.isParent = !1
			}
			function xs() {
				const t = Wn.lFrame
				let n = t.bindingRootIndex
				return -1 === n && (n = t.bindingRootIndex = t.tView.bindingStartIndex), n
			}
			function mh() {
				return Wn.lFrame.bindingIndex++
			}
			function Ea(t) {
				const n = Wn.lFrame,
					e = n.bindingIndex
				return (n.bindingIndex = n.bindingIndex + t), e
			}
			function qx(t, n) {
				const e = Wn.lFrame
				;(e.bindingIndex = e.bindingRootIndex = t), dA(n)
			}
			function dA(t) {
				Wn.lFrame.currentDirectiveIndex = t
			}
			function v_() {
				return Wn.lFrame.currentQueryIndex
			}
			function y_(t) {
				Wn.lFrame.currentQueryIndex = t
			}
			function hA(t) {
				const n = t[Qt]
				return 2 === n.type ? n.declTNode : 1 === n.type ? t[as] : null
			}
			function w_(t, n, e) {
				if (e & Di.SkipSelf) {
					let r = n,
						o = t
					for (; !((r = r.parent), null !== r || e & Di.Host || ((r = hA(o)), null === r || ((o = o[uh]), 10 & r.type))); );
					if (null === r) return !1
					;(n = r), (t = o)
				}
				const i = (Wn.lFrame = Zx())
				return (i.currentTNode = n), (i.lView = t), !0
			}
			function fA(t) {
				const n = Zx(),
					e = t[Qt]
				;(Wn.lFrame = n),
					(n.currentTNode = e.firstChild),
					(n.lView = t),
					(n.tView = e),
					(n.contextLView = t),
					(n.bindingIndex = e.bindingStartIndex),
					(n.inI18n = !1)
			}
			function Zx() {
				const t = Wn.lFrame,
					n = null === t ? null : t.child
				return null === n ? Jx(t) : n
			}
			function Jx(t) {
				const n = {
					currentTNode: null,
					isParent: !0,
					lView: null,
					tView: null,
					selectedIndex: -1,
					contextLView: null,
					elementDepthCount: 0,
					currentNamespace: null,
					currentDirectiveIndex: -1,
					bindingRootIndex: -1,
					bindingIndex: -1,
					currentQueryIndex: 0,
					parent: t,
					child: null,
					inI18n: !1
				}
				return null !== t && (t.child = n), n
			}
			function x_() {
				const t = Wn.lFrame
				return (Wn.lFrame = t.parent), (t.currentTNode = null), (t.lView = null), t
			}
			const qd = x_
			function nm() {
				const t = x_()
				;(t.isParent = !0),
					(t.tView = null),
					(t.selectedIndex = -1),
					(t.contextLView = null),
					(t.elementDepthCount = 0),
					(t.currentDirectiveIndex = -1),
					(t.currentNamespace = null),
					(t.bindingRootIndex = -1),
					(t.bindingIndex = -1),
					(t.currentQueryIndex = 0)
			}
			function Cs() {
				return Wn.lFrame.selectedIndex
			}
			function Zd(t) {
				Wn.lFrame.selectedIndex = t
			}
			function Gr() {
				const t = Wn.lFrame
				return p_(t.tView, t.selectedIndex)
			}
			function Xa() {
				Wn.lFrame.currentNamespace = Nx
			}
			function ph() {
				!(function e1() {
					Wn.lFrame.currentNamespace = null
				})()
			}
			let E_ = !0
			function im() {
				return E_
			}
			function Gl(t) {
				E_ = t
			}
			function Jd(t, n) {
				for (let e = n.directiveStart, i = n.directiveEnd; e < i; e++) {
					const o = t.data[e].type.prototype,
						{ ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: c, ngAfterViewChecked: l, ngOnDestroy: d } = o
					s && (t.contentHooks ??= []).push(-e, s),
						a && ((t.contentHooks ??= []).push(e, a), (t.contentCheckHooks ??= []).push(e, a)),
						c && (t.viewHooks ??= []).push(-e, c),
						l && ((t.viewHooks ??= []).push(e, l), (t.viewCheckHooks ??= []).push(e, l)),
						null != d && (t.destroyHooks ??= []).push(e, d)
				}
			}
			function rm(t, n, e) {
				S_(t, n, 3, e)
			}
			function om(t, n, e, i) {
				;(3 & t[si]) === e && S_(t, n, e, i)
			}
			function M_(t, n) {
				let e = t[si]
				;(3 & e) === n && ((e &= 8191), (e += 1), (t[si] = e))
			}
			function S_(t, n, e, i) {
				const o = i ?? -1,
					s = n.length - 1
				let a = 0
				for (let c = void 0 !== i ? 65535 & t[hh] : 0; c < s; c++)
					if ("number" == typeof n[c + 1]) {
						if (((a = n[c]), null != i && a >= i)) break
					} else n[c] < 0 && (t[hh] += 65536), (a < o || -1 == o) && (oF(t, e, n, c), (t[hh] = (4294901760 & t[hh]) + c + 2)), c++
			}
			function k_(t, n) {
				Ka(4, t, n)
				const e = xa(null)
				try {
					n.call(t)
				} finally {
					xa(e), Ka(5, t, n)
				}
			}
			function oF(t, n, e, i) {
				const r = e[i] < 0,
					o = e[i + 1],
					a = t[r ? -e[i] : e[i]]
				r ? t[si] >> 13 < t[hh] >> 16 && (3 & t[si]) === n && ((t[si] += 8192), k_(a, o)) : k_(a, o)
			}
			const Ah = -1
			class kc {
				constructor(n, e, i) {
					;(this.factory = n), (this.resolving = !1), (this.canSeeViewProviders = e), (this.injectImpl = i)
				}
			}
			function bA(t) {
				return t !== Ah
			}
			function gh(t) {
				return 32767 & t
			}
			function eu(t, n) {
				let e = (function n1(t) {
						return t >> 16
					})(t),
					i = n
				for (; e > 0; ) (i = i[uh]), e--
				return i
			}
			let tu = !0
			function am(t) {
				const n = tu
				return (tu = t), n
			}
			const cm = 255,
				r1 = 5
			let aF = 0
			const Tc = {}
			function _A(t, n) {
				const e = o1(t, n)
				if (-1 !== e) return e
				const i = n[Qt]
				i.firstCreatePass && ((t.injectorIndex = n.length), lm(i.data, t), lm(n, null), lm(i.blueprint, null))
				const r = vA(t, n),
					o = t.injectorIndex
				if (bA(r)) {
					const s = gh(r),
						a = eu(r, n),
						c = a[Qt].data
					for (let l = 0; l < 8; l++) n[o + l] = a[s + l] | c[s + l]
				}
				return (n[o + 8] = r), o
			}
			function lm(t, n) {
				t.push(0, 0, 0, 0, 0, 0, 0, 0, n)
			}
			function o1(t, n) {
				return -1 === t.injectorIndex || (t.parent && t.parent.injectorIndex === t.injectorIndex) || null === n[t.injectorIndex + 8]
					? -1
					: t.injectorIndex
			}
			function vA(t, n) {
				if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex
				let e = 0,
					i = null,
					r = n
				for (; null !== r; ) {
					if (((i = nu(r)), null === i)) return Ah
					if ((e++, (r = r[uh]), -1 !== i.injectorIndex)) return i.injectorIndex | (e << 16)
				}
				return Ah
			}
			function T_(t, n, e) {
				!(function cF(t, n, e) {
					let i
					"string" == typeof e ? (i = e.charCodeAt(0) || 0) : e.hasOwnProperty(sh) && (i = e[sh]), null == i && (i = e[sh] = aF++)
					const r = i & cm
					n.data[t + (r >> r1)] |= 1 << r
				})(t, n, e)
			}
			function s1(t, n, e) {
				if (e & Di.Optional || void 0 !== t) return t
				Gp()
			}
			function yA(t, n, e, i) {
				if ((e & Di.Optional && void 0 === i && (i = null), !(e & (Di.Self | Di.Host)))) {
					const r = t[Ul],
						o = Ns(void 0)
					try {
						return r ? r.get(n, i, e & Di.Optional) : ix(n, i, e & Di.Optional)
					} finally {
						Ns(o)
					}
				}
				return s1(i, 0, e)
			}
			function wA(t, n, e, i = Di.Default, r) {
				if (null !== t) {
					if (2048 & n[si] && !(i & Di.Self)) {
						const s = (function jt(t, n, e, i, r) {
							let o = t,
								s = n
							for (; null !== o && null !== s && 2048 & s[si] && !(512 & s[si]); ) {
								const a = F_(o, s, e, i | Di.Self, Tc)
								if (a !== Tc) return a
								let c = o.parent
								if (!c) {
									const l = s[vx]
									if (l) {
										const d = l.get(e, Tc, i)
										if (d !== Tc) return d
									}
									;(c = nu(s)), (s = s[uh])
								}
								o = c
							}
							return r
						})(t, n, e, i, Tc)
						if (s !== Tc) return s
					}
					const o = F_(t, n, e, i, Tc)
					if (o !== Tc) return o
				}
				return yA(n, e, i, r)
			}
			function F_(t, n, e, i, r) {
				const o = (function uF(t) {
					if ("string" == typeof t) return t.charCodeAt(0) || 0
					const n = t.hasOwnProperty(sh) ? t[sh] : void 0
					return "number" == typeof n ? (n >= 0 ? n & cm : fF) : n
				})(e)
				if ("function" == typeof o) {
					if (!w_(n, t, i)) return i & Di.Host ? s1(r, 0, i) : yA(n, e, i, r)
					try {
						let s
						if (((s = o(i)), null != s || i & Di.Optional)) return s
						Gp()
					} finally {
						qd()
					}
				} else if ("number" == typeof o) {
					let s = null,
						a = o1(t, n),
						c = Ah,
						l = i & Di.Host ? n[so][as] : null
					for (
						(-1 === a || i & Di.SkipSelf) &&
						((c = -1 === a ? vA(t, n) : n[a + 8]),
						c !== Ah && c1(i, !1) ? ((s = n[Qt]), (a = gh(c)), (n = eu(c, n))) : (a = -1));
						-1 !== a;

					) {
						const d = n[Qt]
						if (a1(o, a, d.data)) {
							const u = dF(a, n, e, s, i, l)
							if (u !== Tc) return u
						}
						;(c = n[a + 8]),
							c !== Ah && c1(i, n[Qt].data[a + 8] === l) && a1(o, a, n) ? ((s = d), (a = gh(c)), (n = eu(c, n))) : (a = -1)
					}
				}
				return r
			}
			function dF(t, n, e, i, r, o) {
				const s = n[Qt],
					a = s.data[t + 8],
					d = xA(a, s, e, null == i ? Ec(a) && tu : i != s && 0 != (3 & a.type), r & Di.Host && o === a)
				return null !== d ? Kl(n, s, d, a) : Tc
			}
			function xA(t, n, e, i, r) {
				const o = t.providerIndexes,
					s = n.data,
					a = 1048575 & o,
					c = t.directiveStart,
					d = o >> 20,
					h = r ? a + d : t.directiveEnd
				for (let f = i ? a : a + d; f < h; f++) {
					const _ = s[f]
					if ((f < c && e === _) || (f >= c && _.type === e)) return f
				}
				if (r) {
					const f = s[c]
					if (f && Wa(f) && f.type === e) return c
				}
				return null
			}
			function Kl(t, n, e, i) {
				let r = t[e]
				const o = n.data
				if (
					(function t1(t) {
						return t instanceof kc
					})(r)
				) {
					const s = r
					s.resolving &&
						(function Kb(t, n) {
							const e = n ? `. Dependency path: ${n.join(" > ")} > ${t}` : ""
							throw new ht(-200, `Circular dependency in DI detected for ${t}${e}`)
						})(
							(function Xi(t) {
								return "function" == typeof t
									? t.name || t.toString()
									: "object" == typeof t && null != t && "function" == typeof t.type
									? t.type.name || t.type.toString()
									: Dn(t)
							})(o[e])
						)
					const a = am(s.canSeeViewProviders)
					s.resolving = !0
					const l = s.injectImpl ? Ns(s.injectImpl) : null
					w_(t, i, Di.Default)
					try {
						;(r = t[e] = s.factory(void 0, o, t, i)),
							n.firstCreatePass &&
								e >= i.directiveStart &&
								(function AA(t, n, e) {
									const { ngOnChanges: i, ngOnInit: r, ngDoCheck: o } = n.type.prototype
									if (i) {
										const s = Lx(n)
										;(e.preOrderHooks ??= []).push(t, s), (e.preOrderCheckHooks ??= []).push(t, s)
									}
									r && (e.preOrderHooks ??= []).push(0 - t, r),
										o && ((e.preOrderHooks ??= []).push(t, o), (e.preOrderCheckHooks ??= []).push(t, o))
								})(e, o[e], n)
					} finally {
						null !== l && Ns(l), am(a), (s.resolving = !1), qd()
					}
				}
				return r
			}
			function a1(t, n, e) {
				return !!(e[n + (t >> r1)] & (1 << t))
			}
			function c1(t, n) {
				return !(t & Di.Self || (t & Di.Host && n))
			}
			class qo {
				constructor(n, e) {
					;(this._tNode = n), (this._lView = e)
				}
				get(n, e, i) {
					return wA(this._tNode, this._lView, n, Va(i), e)
				}
			}
			function fF() {
				return new qo(Yo(), bt())
			}
			function gr(t) {
				return _c(() => {
					const n = t.prototype.constructor,
						e = n[yc] || B_(n),
						i = Object.prototype
					let r = Object.getPrototypeOf(t.prototype).constructor
					for (; r && r !== i; ) {
						const o = r[yc] || B_(r)
						if (o && o !== e) return o
						r = Object.getPrototypeOf(r)
					}
					return o => new o()
				})
			}
			function B_(t) {
				return Pl(t)
					? () => {
							const n = B_(Tn(t))
							return n && n()
					  }
					: Kd(t)
			}
			function nu(t) {
				const n = t[Qt],
					e = n.type
				return 2 === e ? n.declTNode : 1 === e ? t[as] : null
			}
			function Ma(t) {
				return (function lF(t, n) {
					if ("class" === n) return t.classes
					if ("style" === n) return t.styles
					const e = t.attrs
					if (e) {
						const i = e.length
						let r = 0
						for (; r < i; ) {
							const o = e[r]
							if (ah(o)) break
							if (0 === o) r += 2
							else if ("number" == typeof o) for (r++; r < i && "string" == typeof e[r]; ) r++
							else {
								if (o === n) return e[r + 1]
								r += 2
							}
						}
					}
					return null
				})(Yo(), t)
			}
			const bh = "__parameters__"
			function vh(t, n, e) {
				return _c(() => {
					const i = (function _h(t) {
						return function (...e) {
							if (t) {
								const i = t(...e)
								for (const r in i) this[r] = i[r]
							}
						}
					})(n)
					function r(...o) {
						if (this instanceof r) return i.apply(this, o), this
						const s = new r(...o)
						return (a.annotation = s), a
						function a(c, l, d) {
							const u = c.hasOwnProperty(bh) ? c[bh] : Object.defineProperty(c, bh, { value: [] })[bh]
							for (; u.length <= d; ) u.push(null)
							return (u[d] = u[d] || []).push(s), c
						}
					}
					return e && (r.prototype = Object.create(e.prototype)), (r.prototype.ngMetadataName = t), (r.annotationCls = r), r
				})
			}
			function wh(t, n) {
				t.forEach(e => (Array.isArray(e) ? wh(e, n) : n(e)))
			}
			function f1(t, n, e) {
				n >= t.length ? t.push(e) : t.splice(n, 0, e)
			}
			function iu(t, n) {
				return n >= t.length - 1 ? t.pop() : t.splice(n, 1)[0]
			}
			function cs(t, n) {
				const e = []
				for (let i = 0; i < t; i++) e.push(n)
				return e
			}
			function Es(t, n, e) {
				let i = tl(t, n)
				return (
					i >= 0
						? (t[1 | i] = e)
						: ((i = ~i),
						  (function gF(t, n, e, i) {
								let r = t.length
								if (r == n) t.push(e, i)
								else if (1 === r) t.push(i, t[0]), (t[0] = e)
								else {
									for (r--, t.push(t[r - 1], t[r]); r > n; ) (t[r] = t[r - 2]), r--
									;(t[n] = e), (t[n + 1] = i)
								}
						  })(t, i, n, e)),
					i
				)
			}
			function Xl(t, n) {
				const e = tl(t, n)
				if (e >= 0) return t[1 | e]
			}
			function tl(t, n) {
				return (function ru(t, n, e) {
					let i = 0,
						r = t.length >> e
					for (; r !== i; ) {
						const o = i + ((r - i) >> 1),
							s = t[o << e]
						if (n === s) return o << e
						s > n ? (r = o) : (i = o + 1)
					}
					return ~(r << e)
				})(t, n, 1)
			}
			const P_ = tr(
					vh("Inject", t => ({ token: t })),
					-1
				),
				O_ = tr(vh("Optional"), 8),
				N_ = tr(vh("SkipSelf"), 4)
			function Fc(t) {
				return 128 == (128 & t.flags)
			}
			var ls = (function (t) {
				return (t[(t.Important = 1)] = "Important"), (t[(t.DashCase = 2)] = "DashCase"), t
			})(ls || {})
			const ou = /^>|^->|<!--|-->|--!>|<!-$/g,
				rl = /(<|>)/g,
				xh = "\u200b$1\u200b"
			const MF = new Map()
			let Lee = 0
			const kF = "__ngContext__"
			function Hs(t, n) {
				Us(n)
					? ((t[kF] = n[$f]),
					  (function Pee(t) {
							MF.set(t[$f], t)
					  })(n))
					: (t[kF] = n)
			}
			let TF
			function FF(t, n) {
				return TF(t, n)
			}
			function V_(t) {
				const n = t[pr]
				return ys(n) ? n[pr] : n
			}
			function HU(t) {
				return QU(t[Qf])
			}
			function VU(t) {
				return QU(t[$a])
			}
			function QU(t) {
				for (; null !== t && !ys(t); ) t = t[$a]
				return t
			}
			function MA(t, n, e, i, r) {
				if (null != i) {
					let o,
						s = !1
					ys(i) ? (o = i) : Us(i) && ((s = !0), (i = i[qr]))
					const a = ar(i)
					0 === t && null !== e
						? null == r
							? WU(n, e, a)
							: hm(n, e, a, r || null, !0)
						: 1 === t && null !== e
						? hm(n, e, a, r || null, !0)
						: 2 === t
						? (function C1(t, n, e) {
								const i = w1(t, n)
								i &&
									(function tte(t, n, e, i) {
										t.removeChild(n, e, i)
									})(t, i, n, e)
						  })(n, a, s)
						: 3 === t && n.destroyNode(a),
						null != o &&
							(function rte(t, n, e, i, r) {
								const o = e[Cc]
								o !== ar(e) && MA(n, t, i, o, r)
								for (let a = Ko; a < e.length; a++) {
									const c = e[a]
									z_(c[Qt], c, t, n, i, o)
								}
							})(n, t, o, e, r)
				}
			}
			function BF(t, n) {
				return t.createComment(
					(function Ch(t) {
						return t.replace(ou, n => n.replace(rl, xh))
					})(n)
				)
			}
			function v1(t, n, e) {
				return t.createElement(n, e)
			}
			function GU(t, n) {
				const e = t[qc],
					i = e.indexOf(n)
				Vx(n), e.splice(i, 1)
			}
			function y1(t, n) {
				if (t.length <= Ko) return
				const e = Ko + n,
					i = t[e]
				if (i) {
					const r = i[Gf]
					null !== r && r !== t && GU(r, i), n > 0 && (t[e - 1][$a] = i[$a])
					const o = iu(t, Ko + n)
					!(function jee(t, n) {
						z_(t, n, n[ei], 2, null, null), (n[qr] = null), (n[as] = null)
					})(i[Qt], i)
					const s = o[xc]
					null !== s && s.detachView(o[Qt]), (i[pr] = null), (i[$a] = null), (i[si] &= -129)
				}
				return i
			}
			function IF(t, n) {
				if (!(256 & n[si])) {
					const e = n[ei]
					n[Wf] && u_(n[Wf]),
						n[jd] && u_(n[jd]),
						e.destroyNode && z_(t, n, e, 3, null, null),
						(function Yee(t) {
							let n = t[Qf]
							if (!n) return DF(t[Qt], t)
							for (; n; ) {
								let e = null
								if (Us(n)) e = n[Qf]
								else {
									const i = n[Ko]
									i && (e = i)
								}
								if (!e) {
									for (; n && !n[$a] && n !== t; ) Us(n) && DF(n[Qt], n), (n = n[pr])
									null === n && (n = t), Us(n) && DF(n[Qt], n), (e = n && n[$a])
								}
								n = e
							}
						})(n)
				}
			}
			function DF(t, n) {
				if (!(256 & n[si])) {
					;(n[si] &= -129),
						(n[si] |= 256),
						(function ete(t, n) {
							let e
							if (null != t && null != (e = t.destroyHooks))
								for (let i = 0; i < e.length; i += 2) {
									const r = n[e[i]]
									if (!(r instanceof kc)) {
										const o = e[i + 1]
										if (Array.isArray(o))
											for (let s = 0; s < o.length; s += 2) {
												const a = r[o[s]],
													c = o[s + 1]
												Ka(4, a, c)
												try {
													c.call(a)
												} finally {
													Ka(5, a, c)
												}
											}
										else {
											Ka(4, r, o)
											try {
												o.call(r)
											} finally {
												Ka(5, r, o)
											}
										}
									}
								}
						})(t, n),
						(function Jee(t, n) {
							const e = t.cleanup,
								i = n[lh]
							if (null !== e)
								for (let o = 0; o < e.length - 1; o += 2)
									if ("string" == typeof e[o]) {
										const s = e[o + 3]
										s >= 0 ? i[s]() : i[-s].unsubscribe(), (o += 2)
									} else e[o].call(i[e[o + 1]])
							null !== i && (n[lh] = null)
							const r = n[Hl]
							if (null !== r) {
								n[Hl] = null
								for (let o = 0; o < r.length; o++) (0, r[o])()
							}
						})(t, n),
						1 === n[Qt].type && n[ei].destroy()
					const e = n[Gf]
					if (null !== e && ys(n[pr])) {
						e !== n[pr] && GU(e, n)
						const i = n[xc]
						null !== i && i.detachView(t)
					}
					!(function Oee(t) {
						MF.delete(t[$f])
					})(n)
				}
			}
			function LF(t, n, e) {
				return (function $U(t, n, e) {
					let i = n
					for (; null !== i && 40 & i.type; ) i = (n = i).parent
					if (null === i) return e[qr]
					{
						const { componentOffset: r } = i
						if (r > -1) {
							const { encapsulation: o } = t.data[i.directiveStart + r]
							if (o === Zs.None || o === Zs.Emulated) return null
						}
						return ws(i, e)
					}
				})(t, n.parent, e)
			}
			function hm(t, n, e, i, r) {
				t.insertBefore(n, e, i, r)
			}
			function WU(t, n, e) {
				t.appendChild(n, e)
			}
			function jU(t, n, e, i, r) {
				null !== i ? hm(t, n, e, i, r) : WU(t, n, e)
			}
			function w1(t, n) {
				return t.parentNode(n)
			}
			function KU(t, n, e) {
				return YU(t, n, e)
			}
			let RF,
				E1,
				UF,
				M1,
				YU = function XU(t, n, e) {
					return 40 & t.type ? ws(t, e) : null
				}
			function x1(t, n, e, i) {
				const r = LF(t, i, n),
					o = n[ei],
					a = KU(i.parent || n[as], i, n)
				if (null != r)
					if (Array.isArray(e)) for (let c = 0; c < e.length; c++) jU(o, r, e[c], a, !1)
					else jU(o, r, e, a, !1)
				void 0 !== RF && RF(o, i, n, e, r)
			}
			function Q_(t, n) {
				if (null !== n) {
					const e = n.type
					if (3 & e) return ws(n, t)
					if (4 & e) return PF(-1, t[n.index])
					if (8 & e) {
						const i = n.child
						if (null !== i) return Q_(t, i)
						{
							const r = t[n.index]
							return ys(r) ? PF(-1, r) : ar(r)
						}
					}
					if (32 & e) return FF(n, t)() || ar(t[n.index])
					{
						const i = ZU(t, n)
						return null !== i ? (Array.isArray(i) ? i[0] : Q_(V_(t[so]), i)) : Q_(t, n.next)
					}
				}
				return null
			}
			function ZU(t, n) {
				return null !== n ? t[so][as].projection[n.projection] : null
			}
			function PF(t, n) {
				const e = Ko + t + 1
				if (e < n.length) {
					const i = n[e],
						r = i[Qt].firstChild
					if (null !== r) return Q_(i, r)
				}
				return n[Cc]
			}
			function OF(t, n, e, i, r, o, s) {
				for (; null != e; ) {
					const a = i[e.index],
						c = e.type
					if ((s && 0 === n && (a && Hs(ar(a), i), (e.flags |= 2)), 32 != (32 & e.flags)))
						if (8 & c) OF(t, n, e.child, i, r, o, !1), MA(n, t, r, a, o)
						else if (32 & c) {
							const l = FF(e, i)
							let d
							for (; (d = l()); ) MA(n, t, r, d, o)
							MA(n, t, r, a, o)
						} else 16 & c ? e4(t, n, i, e, r, o) : MA(n, t, r, a, o)
					e = s ? e.projectionNext : e.next
				}
			}
			function z_(t, n, e, i, r, o) {
				OF(e, i, t.firstChild, n, r, o, !1)
			}
			function e4(t, n, e, i, r, o) {
				const s = e[so],
					c = s[as].projection[i.projection]
				if (Array.isArray(c)) for (let l = 0; l < c.length; l++) MA(n, t, r, c[l], o)
				else {
					let l = c
					const d = s[pr]
					Fc(i) && (l.flags |= 128), OF(t, n, l, d, r, o, !0)
				}
			}
			function t4(t, n, e) {
				"" === e ? t.removeAttribute(n, "class") : t.setAttribute(n, "class", e)
			}
			function n4(t, n, e) {
				const { mergedAttrs: i, classes: r, styles: o } = e
				null !== i && r_(t, n, i),
					null !== r && t4(t, n, r),
					null !== o &&
						(function ste(t, n, e) {
							t.setAttribute(n, "style", e)
						})(t, n, o)
			}
			function SA(t) {
				return (
					(function NF() {
						if (void 0 === E1 && ((E1 = null), vr.trustedTypes))
							try {
								E1 = vr.trustedTypes.createPolicy("angular", {
									createHTML: t => t,
									createScript: t => t,
									createScriptURL: t => t
								})
							} catch {}
						return E1
					})()?.createHTML(t) || t
				)
			}
			function kA() {
				if (void 0 !== UF) return UF
				if (typeof document < "u") return document
				throw new ht(210, !1)
			}
			function i4(t) {
				return (
					(function HF() {
						if (void 0 === M1 && ((M1 = null), vr.trustedTypes))
							try {
								M1 = vr.trustedTypes.createPolicy("angular#unsafe-bypass", {
									createHTML: t => t,
									createScript: t => t,
									createScriptURL: t => t
								})
							} catch {}
						return M1
					})()?.createHTML(t) || t
				)
			}
			class s4 {
				constructor(n) {
					this.changingThisBreaksApplicationSecurity = n
				}
				toString() {
					return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${jb})`
				}
			}
			function Eh(t) {
				return t instanceof s4 ? t.changingThisBreaksApplicationSecurity : t
			}
			function G_(t, n) {
				const e = (function Ate(t) {
					return (t instanceof s4 && t.getTypeName()) || null
				})(t)
				if (null != e && e !== n) {
					if ("ResourceURL" === e && "URL" === n) return !0
					throw new Error(`Required a safe ${n}, got a ${e} (see ${jb})`)
				}
				return e === n
			}
			class gte {
				constructor(n) {
					this.inertDocumentHelper = n
				}
				getInertBodyElement(n) {
					n = "<body><remove></remove>" + n
					try {
						const e = new window.DOMParser().parseFromString(SA(n), "text/html").body
						return null === e ? this.inertDocumentHelper.getInertBodyElement(n) : (e.removeChild(e.firstChild), e)
					} catch {
						return null
					}
				}
			}
			class bte {
				constructor(n) {
					;(this.defaultDoc = n), (this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"))
				}
				getInertBodyElement(n) {
					const e = this.inertDocument.createElement("template")
					return (e.innerHTML = SA(n)), e
				}
			}
			const vte = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i
			function VF(t) {
				return (t = String(t)).match(vte) ? t : "unsafe:" + t
			}
			function su(t) {
				const n = {}
				for (const e of t.split(",")) n[e] = !0
				return n
			}
			function $_(...t) {
				const n = {}
				for (const e of t) for (const i in e) e.hasOwnProperty(i) && (n[i] = !0)
				return n
			}
			const c4 = su("area,br,col,hr,img,wbr"),
				l4 = su("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
				d4 = su("rp,rt"),
				QF = $_(
					c4,
					$_(
						l4,
						su(
							"address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"
						)
					),
					$_(
						d4,
						su(
							"a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"
						)
					),
					$_(d4, l4)
				),
				zF = su("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
				u4 = $_(
					zF,
					su(
						"abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"
					),
					su(
						"aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"
					)
				),
				yte = su("script,style,template")
			class wte {
				constructor() {
					;(this.sanitizedSomething = !1), (this.buf = [])
				}
				sanitizeChildren(n) {
					let e = n.firstChild,
						i = !0
					for (; e; )
						if (
							(e.nodeType === Node.ELEMENT_NODE
								? (i = this.startElement(e))
								: e.nodeType === Node.TEXT_NODE
								? this.chars(e.nodeValue)
								: (this.sanitizedSomething = !0),
							i && e.firstChild)
						)
							e = e.firstChild
						else
							for (; e; ) {
								e.nodeType === Node.ELEMENT_NODE && this.endElement(e)
								let r = this.checkClobberedElement(e, e.nextSibling)
								if (r) {
									e = r
									break
								}
								e = this.checkClobberedElement(e, e.parentNode)
							}
					return this.buf.join("")
				}
				startElement(n) {
					const e = n.nodeName.toLowerCase()
					if (!QF.hasOwnProperty(e)) return (this.sanitizedSomething = !0), !yte.hasOwnProperty(e)
					this.buf.push("<"), this.buf.push(e)
					const i = n.attributes
					for (let r = 0; r < i.length; r++) {
						const o = i.item(r),
							s = o.name,
							a = s.toLowerCase()
						if (!u4.hasOwnProperty(a)) {
							this.sanitizedSomething = !0
							continue
						}
						let c = o.value
						zF[a] && (c = VF(c)), this.buf.push(" ", s, '="', h4(c), '"')
					}
					return this.buf.push(">"), !0
				}
				endElement(n) {
					const e = n.nodeName.toLowerCase()
					QF.hasOwnProperty(e) && !c4.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">"))
				}
				chars(n) {
					this.buf.push(h4(n))
				}
				checkClobberedElement(n, e) {
					if (e && (n.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY)
						throw new Error(`Failed to sanitize html because the element is clobbered: ${n.outerHTML}`)
					return e
				}
			}
			const xte = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
				Cte = /([^\#-~ |!])/g
			function h4(t) {
				return t
					.replace(/&/g, "&amp;")
					.replace(xte, function (n) {
						return "&#" + (1024 * (n.charCodeAt(0) - 55296) + (n.charCodeAt(1) - 56320) + 65536) + ";"
					})
					.replace(Cte, function (n) {
						return "&#" + n.charCodeAt(0) + ";"
					})
					.replace(/</g, "&lt;")
					.replace(/>/g, "&gt;")
			}
			let S1
			function GF(t) {
				return "content" in t &&
					(function Mte(t) {
						return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName
					})(t)
					? t.content
					: null
			}
			var TA = (function (t) {
				return (
					(t[(t.NONE = 0)] = "NONE"),
					(t[(t.HTML = 1)] = "HTML"),
					(t[(t.STYLE = 2)] = "STYLE"),
					(t[(t.SCRIPT = 3)] = "SCRIPT"),
					(t[(t.URL = 4)] = "URL"),
					(t[(t.RESOURCE_URL = 5)] = "RESOURCE_URL"),
					t
				)
			})(TA || {})
			function $F(t) {
				const n = W_()
				return n
					? i4(n.sanitize(TA.HTML, t) || "")
					: G_(t, "HTML")
					? i4(Eh(t))
					: (function Ete(t, n) {
							let e = null
							try {
								S1 =
									S1 ||
									(function a4(t) {
										const n = new bte(t)
										return (function _te() {
											try {
												return !!new window.DOMParser().parseFromString(SA(""), "text/html")
											} catch {
												return !1
											}
										})()
											? new gte(n)
											: n
									})(t)
								let i = n ? String(n) : ""
								e = S1.getInertBodyElement(i)
								let r = 5,
									o = i
								do {
									if (0 === r) throw new Error("Failed to sanitize html because the input is unstable")
									r--, (i = o), (o = e.innerHTML), (e = S1.getInertBodyElement(i))
								} while (i !== o)
								return SA(new wte().sanitizeChildren(GF(e) || e))
							} finally {
								if (e) {
									const i = GF(e) || e
									for (; i.firstChild; ) i.removeChild(i.firstChild)
								}
							}
					  })(kA(), Dn(t))
			}
			function fm(t) {
				const n = W_()
				return n ? n.sanitize(TA.URL, t) || "" : G_(t, "URL") ? Eh(t) : VF(Dn(t))
			}
			function W_() {
				const t = bt()
				return t && t[dh].sanitizer
			}
			const FA = new He("ENVIRONMENT_INITIALIZER"),
				m4 = new He("INJECTOR", -1),
				p4 = new He("INJECTOR_DEF_TYPES")
			class WF {
				get(n, e = Kc) {
					if (e === Kc) {
						const i = new Error(`NullInjectorError: No provider for ${Lr(n)}!`)
						throw ((i.name = "NullInjectorError"), i)
					}
					return e
				}
			}
			function Dte(...t) {
				return { ɵproviders: A4(0, t), ɵfromNgModule: !0 }
			}
			function A4(t, ...n) {
				const e = [],
					i = new Set()
				let r
				const o = s => {
					e.push(s)
				}
				return (
					wh(n, s => {
						const a = s
						k1(a, o, [], i) && ((r ||= []), r.push(a))
					}),
					void 0 !== r && g4(r, o),
					e
				)
			}
			function g4(t, n) {
				for (let e = 0; e < t.length; e++) {
					const { ngModule: i, providers: r } = t[e]
					KF(r, o => {
						n(o, i)
					})
				}
			}
			function k1(t, n, e, i) {
				if (!(t = Tn(t))) return !1
				let r = null,
					o = zd(t)
				const s = !o && Ni(t)
				if (o || s) {
					if (s && !s.standalone) return !1
					r = t
				} else {
					const c = t.ngModule
					if (((o = zd(c)), !o)) return !1
					r = c
				}
				const a = i.has(r)
				if (s) {
					if (a) return !1
					if ((i.add(r), s.dependencies)) {
						const c = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies
						for (const l of c) k1(l, n, e, i)
					}
				} else {
					if (!o) return !1
					{
						if (null != o.imports && !a) {
							let l
							i.add(r)
							try {
								wh(o.imports, d => {
									k1(d, n, e, i) && ((l ||= []), l.push(d))
								})
							} finally {
							}
							void 0 !== l && g4(l, n)
						}
						if (!a) {
							const l = Kd(r) || (() => new r())
							n({ provide: r, useFactory: l, deps: oi }, r),
								n({ provide: p4, useValue: r, multi: !0 }, r),
								n({ provide: FA, useValue: () => re(r), multi: !0 }, r)
						}
						const c = o.providers
						if (null != c && !a) {
							const l = t
							KF(c, d => {
								n(d, l)
							})
						}
					}
				}
				return r !== t && void 0 !== t.providers
			}
			function KF(t, n) {
				for (let e of t) Ac(e) && (e = e.ɵproviders), Array.isArray(e) ? KF(e, n) : n(e)
			}
			const Lte = Ki({ provide: String, useValue: Ki })
			function XF(t) {
				return null !== t && "object" == typeof t && Lte in t
			}
			function mm(t) {
				return "function" == typeof t
			}
			const YF = new He("Set Injector scope."),
				T1 = {},
				Pte = {}
			let qF
			function F1() {
				return void 0 === qF && (qF = new WF()), qF
			}
			class Yl {}
			class BA extends Yl {
				get destroyed() {
					return this._destroyed
				}
				constructor(n, e, i, r) {
					super(),
						(this.parent = e),
						(this.source = i),
						(this.scopes = r),
						(this.records = new Map()),
						(this._ngOnDestroyHooks = new Set()),
						(this._onDestroyHooks = []),
						(this._destroyed = !1),
						JF(n, s => this.processProvider(s)),
						this.records.set(m4, IA(void 0, this)),
						r.has("environment") && this.records.set(Yl, IA(void 0, this))
					const o = this.records.get(YF)
					null != o && "string" == typeof o.value && this.scopes.add(o.value),
						(this.injectorDefTypes = new Set(this.get(p4.multi, oi, Di.Self)))
				}
				destroy() {
					this.assertNotDestroyed(), (this._destroyed = !0)
					try {
						for (const e of this._ngOnDestroyHooks) e.ngOnDestroy()
						const n = this._onDestroyHooks
						this._onDestroyHooks = []
						for (const e of n) e()
					} finally {
						this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear()
					}
				}
				onDestroy(n) {
					return this.assertNotDestroyed(), this._onDestroyHooks.push(n), () => this.removeOnDestroy(n)
				}
				runInContext(n) {
					this.assertNotDestroyed()
					const e = _s(this),
						i = Ns(void 0)
					try {
						return n()
					} finally {
						_s(e), Ns(i)
					}
				}
				get(n, e = Kc, i = Di.Default) {
					if ((this.assertNotDestroyed(), n.hasOwnProperty($p))) return n[$p](this)
					i = Va(i)
					const o = _s(this),
						s = Ns(void 0)
					try {
						if (!(i & Di.SkipSelf)) {
							let c = this.records.get(n)
							if (void 0 === c) {
								const l =
									(function Vte(t) {
										return "function" == typeof t || ("object" == typeof t && t instanceof He)
									})(n) && Qd(n)
								;(c = l && this.injectableDefInScope(l) ? IA(ZF(n), T1) : null), this.records.set(n, c)
							}
							if (null != c) return this.hydrate(n, c)
						}
						return (i & Di.Self ? F1() : this.parent).get(n, (e = i & Di.Optional && e === Kc ? null : e))
					} catch (a) {
						if ("NullInjectorError" === a.name) {
							if (((a[qi] = a[qi] || []).unshift(Lr(n)), o)) throw a
							return (function cx(t, n, e, i) {
								const r = t[qi]
								throw (
									(n[Gd] && r.unshift(n[Gd]),
									(t.message = (function lx(t, n, e, i = null) {
										t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.slice(2) : t
										let r = Lr(n)
										if (Array.isArray(n)) r = n.map(Lr).join(" -> ")
										else if ("object" == typeof n) {
											let o = []
											for (let s in n)
												if (n.hasOwnProperty(s)) {
													let a = n[s]
													o.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : Lr(a)))
												}
											r = `{${o.join(", ")}}`
										}
										return `${e}${i ? "(" + i + ")" : ""}[${r}]: ${t.replace(n_, "\n  ")}`
									})("\n" + t.message, r, e, i)),
									(t.ngTokenPath = r),
									(t[qi] = null),
									t)
								)
							})(a, n, "R3InjectorError", this.source)
						}
						throw a
					} finally {
						Ns(s), _s(o)
					}
				}
				resolveInjectorInitializers() {
					const n = _s(this),
						e = Ns(void 0)
					try {
						const r = this.get(FA.multi, oi, Di.Self)
						for (const o of r) o()
					} finally {
						_s(n), Ns(e)
					}
				}
				toString() {
					const n = [],
						e = this.records
					for (const i of e.keys()) n.push(Lr(i))
					return `R3Injector[${n.join(", ")}]`
				}
				assertNotDestroyed() {
					if (this._destroyed) throw new ht(205, !1)
				}
				processProvider(n) {
					let e = mm((n = Tn(n))) ? n : Tn(n && n.provide)
					const i = (function Nte(t) {
						return XF(t) ? IA(void 0, t.useValue) : IA(v4(t), T1)
					})(n)
					if (mm(n) || !0 !== n.multi) this.records.get(e)
					else {
						let r = this.records.get(e)
						r || ((r = IA(void 0, T1, !0)), (r.factory = () => $d(r.multi)), this.records.set(e, r)), (e = n), r.multi.push(n)
					}
					this.records.set(e, i)
				}
				hydrate(n, e) {
					return (
						e.value === T1 && ((e.value = Pte), (e.value = e.factory())),
						"object" == typeof e.value &&
							e.value &&
							(function Hte(t) {
								return null !== t && "object" == typeof t && "function" == typeof t.ngOnDestroy
							})(e.value) &&
							this._ngOnDestroyHooks.add(e.value),
						e.value
					)
				}
				injectableDefInScope(n) {
					if (!n.providedIn) return !1
					const e = Tn(n.providedIn)
					return "string" == typeof e ? "any" === e || this.scopes.has(e) : this.injectorDefTypes.has(e)
				}
				removeOnDestroy(n) {
					const e = this._onDestroyHooks.indexOf(n)
					;-1 !== e && this._onDestroyHooks.splice(e, 1)
				}
			}
			function ZF(t) {
				const n = Qd(t),
					e = null !== n ? n.factory : Kd(t)
				if (null !== e) return e
				if (t instanceof He) throw new ht(204, !1)
				if (t instanceof Function)
					return (function Ote(t) {
						const n = t.length
						if (n > 0) throw (cs(n, "?"), new ht(204, !1))
						const e = (function Ol(t) {
							return (t && (t[oh] || t[tx])) || null
						})(t)
						return null !== e ? () => e.factory(t) : () => new t()
					})(t)
				throw new ht(204, !1)
			}
			function v4(t, n, e) {
				let i
				if (mm(t)) {
					const r = Tn(t)
					return Kd(r) || ZF(r)
				}
				if (XF(t)) i = () => Tn(t.useValue)
				else if (
					(function _4(t) {
						return !(!t || !t.useFactory)
					})(t)
				)
					i = () => t.useFactory(...$d(t.deps || []))
				else if (
					(function b4(t) {
						return !(!t || !t.useExisting)
					})(t)
				)
					i = () => re(Tn(t.useExisting))
				else {
					const r = Tn(t && (t.useClass || t.provide))
					if (
						!(function Ute(t) {
							return !!t.deps
						})(t)
					)
						return Kd(r) || ZF(r)
					i = () => new r(...$d(t.deps))
				}
				return i
			}
			function IA(t, n, e = !1) {
				return { factory: t, value: n, multi: e ? [] : void 0 }
			}
			function JF(t, n) {
				for (const e of t) Array.isArray(e) ? JF(e, n) : e && Ac(e) ? JF(e.ɵproviders, n) : n(e)
			}
			const j_ = new He("AppId", { providedIn: "root", factory: () => Qte }),
				Qte = "ng",
				y4 = new He("Platform Initializer"),
				Mh = new He("Platform ID", { providedIn: "platform", factory: () => "unknown" }),
				Bo = new He("AnimationModuleType"),
				eB = new He("CSP nonce", {
					providedIn: "root",
					factory: () => kA().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null
				})
			let w4 = (t, n, e) => null
			function cB(t, n, e = !1) {
				return w4(t, n, e)
			}
			class Zte {}
			class E4 {}
			class ene {
				resolveComponentFactory(n) {
					throw (function Jte(t) {
						const n = Error(`No component factory found for ${Lr(t)}.`)
						return (n.ngComponent = t), n
					})(n)
				}
			}
			let RA = (() => {
				class t {
					static {
						this.NULL = new ene()
					}
				}
				return t
			})()
			function tne() {
				return PA(Yo(), bt())
			}
			function PA(t, n) {
				return new wn(ws(t, n))
			}
			let wn = (() => {
				class t {
					constructor(e) {
						this.nativeElement = e
					}
					static {
						this.__NG_ELEMENT_ID__ = tne
					}
				}
				return t
			})()
			function nne(t) {
				return t instanceof wn ? t.nativeElement : t
			}
			class Y_ {}
			let pm = (() => {
					class t {
						constructor() {
							this.destroyNode = null
						}
						static {
							this.__NG_ELEMENT_ID__ = () =>
								(function ine() {
									const t = bt(),
										e = ea(Yo().index, t)
									return (Us(e) ? e : t)[ei]
								})()
						}
					}
					return t
				})(),
				rne = (() => {
					class t {
						static {
							this.ɵprov = mt({ token: t, providedIn: "root", factory: () => null })
						}
					}
					return t
				})()
			class OA {
				constructor(n) {
					;(this.full = n),
						(this.major = n.split(".")[0]),
						(this.minor = n.split(".")[1]),
						(this.patch = n.split(".").slice(2).join("."))
				}
			}
			const one = new OA("16.2.12"),
				uB = {}
			function F4(t, n = null, e = null, i) {
				const r = B4(t, n, e, i)
				return r.resolveInjectorInitializers(), r
			}
			function B4(t, n = null, e = null, i, r = new Set()) {
				const o = [e || oi, Dte(t)]
				return (i = i || ("object" == typeof t ? void 0 : Lr(t))), new BA(o, n || F1(), i || null, r)
			}
			let ks = (() => {
				class t {
					static {
						this.THROW_IF_NOT_FOUND = Kc
					}
					static {
						this.NULL = new WF()
					}
					static create(e, i) {
						if (Array.isArray(e)) return F4({ name: "" }, i, e, "")
						{
							const r = e.name ?? ""
							return F4({ name: r }, e.parent, e.providers, r)
						}
					}
					static {
						this.ɵprov = mt({ token: t, providedIn: "any", factory: () => re(m4) })
					}
					static {
						this.__NG_ELEMENT_ID__ = -1
					}
				}
				return t
			})()
			function hB(t) {
				return t.ngOriginalError
			}
			class ql {
				constructor() {
					this._console = console
				}
				handleError(n) {
					const e = this._findOriginalError(n)
					this._console.error("ERROR", n), e && this._console.error("ORIGINAL ERROR", e)
				}
				_findOriginalError(n) {
					let e = n && hB(n)
					for (; e && hB(e); ) e = hB(e)
					return e || null
				}
			}
			let NA = (() => {
				class t {
					static {
						this.__NG_ELEMENT_ID__ = hne
					}
					static {
						this.__NG_ENV_ID__ = e => e
					}
				}
				return t
			})()
			class une extends NA {
				constructor(n) {
					super(), (this._lView = n)
				}
				onDestroy(n) {
					return (
						zx(this._lView, n),
						() =>
							(function JT(t, n) {
								if (null === t[Hl]) return
								const e = t[Hl].indexOf(n)
								;-1 !== e && t[Hl].splice(e, 1)
							})(this._lView, n)
					)
				}
			}
			function hne() {
				return new une(bt())
			}
			function fB(t) {
				return n => {
					setTimeout(t, void 0, n)
				}
			}
			const _n = class fne extends vt {
				constructor(n = !1) {
					super(), (this.__isAsync = n)
				}
				emit(n) {
					super.next(n)
				}
				subscribe(n, e, i) {
					let r = n,
						o = e || (() => null),
						s = i
					if (n && "object" == typeof n) {
						const c = n
						;(r = c.next?.bind(c)), (o = c.error?.bind(c)), (s = c.complete?.bind(c))
					}
					this.__isAsync && ((o = fB(o)), r && (r = fB(r)), s && (s = fB(s)))
					const a = super.subscribe({ next: r, error: o, complete: s })
					return n instanceof D && n.add(a), a
				}
			}
			function D4(...t) {}
			class mn {
				constructor({
					enableLongStackTrace: n = !1,
					shouldCoalesceEventChangeDetection: e = !1,
					shouldCoalesceRunChangeDetection: i = !1
				}) {
					if (
						((this.hasPendingMacrotasks = !1),
						(this.hasPendingMicrotasks = !1),
						(this.isStable = !0),
						(this.onUnstable = new _n(!1)),
						(this.onMicrotaskEmpty = new _n(!1)),
						(this.onStable = new _n(!1)),
						(this.onError = new _n(!1)),
						typeof Zone > "u")
					)
						throw new ht(908, !1)
					Zone.assertZonePatched()
					const r = this
					;(r._nesting = 0),
						(r._outer = r._inner = Zone.current),
						Zone.TaskTrackingZoneSpec && (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec())),
						n && Zone.longStackTraceZoneSpec && (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)),
						(r.shouldCoalesceEventChangeDetection = !i && e),
						(r.shouldCoalesceRunChangeDetection = i),
						(r.lastRequestAnimationFrameId = -1),
						(r.nativeRequestAnimationFrame = (function mne() {
							const t = "function" == typeof vr.requestAnimationFrame
							let n = vr[t ? "requestAnimationFrame" : "setTimeout"],
								e = vr[t ? "cancelAnimationFrame" : "clearTimeout"]
							if (typeof Zone < "u" && n && e) {
								const i = n[Zone.__symbol__("OriginalDelegate")]
								i && (n = i)
								const r = e[Zone.__symbol__("OriginalDelegate")]
								r && (e = r)
							}
							return { nativeRequestAnimationFrame: n, nativeCancelAnimationFrame: e }
						})().nativeRequestAnimationFrame),
						(function gne(t) {
							const n = () => {
								!(function Ane(t) {
									t.isCheckStableRunning ||
										-1 !== t.lastRequestAnimationFrameId ||
										((t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(vr, () => {
											t.fakeTopEventTask ||
												(t.fakeTopEventTask = Zone.root.scheduleEventTask(
													"fakeTopEventTask",
													() => {
														;(t.lastRequestAnimationFrameId = -1),
															pB(t),
															(t.isCheckStableRunning = !0),
															mB(t),
															(t.isCheckStableRunning = !1)
													},
													void 0,
													() => {},
													() => {}
												)),
												t.fakeTopEventTask.invoke()
										})),
										pB(t))
								})(t)
							}
							t._inner = t._inner.fork({
								name: "angular",
								properties: { isAngularZone: !0 },
								onInvokeTask: (e, i, r, o, s, a) => {
									if (
										(function _ne(t) {
											return !(!Array.isArray(t) || 1 !== t.length) && !0 === t[0].data?.__ignore_ng_zone__
										})(a)
									)
										return e.invokeTask(r, o, s, a)
									try {
										return L4(t), e.invokeTask(r, o, s, a)
									} finally {
										;((t.shouldCoalesceEventChangeDetection && "eventTask" === o.type) ||
											t.shouldCoalesceRunChangeDetection) &&
											n(),
											R4(t)
									}
								},
								onInvoke: (e, i, r, o, s, a, c) => {
									try {
										return L4(t), e.invoke(r, o, s, a, c)
									} finally {
										t.shouldCoalesceRunChangeDetection && n(), R4(t)
									}
								},
								onHasTask: (e, i, r, o) => {
									e.hasTask(r, o),
										i === r &&
											("microTask" == o.change
												? ((t._hasPendingMicrotasks = o.microTask), pB(t), mB(t))
												: "macroTask" == o.change && (t.hasPendingMacrotasks = o.macroTask))
								},
								onHandleError: (e, i, r, o) => (e.handleError(r, o), t.runOutsideAngular(() => t.onError.emit(o)), !1)
							})
						})(r)
				}
				static isInAngularZone() {
					return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone")
				}
				static assertInAngularZone() {
					if (!mn.isInAngularZone()) throw new ht(909, !1)
				}
				static assertNotInAngularZone() {
					if (mn.isInAngularZone()) throw new ht(909, !1)
				}
				run(n, e, i) {
					return this._inner.run(n, e, i)
				}
				runTask(n, e, i, r) {
					const o = this._inner,
						s = o.scheduleEventTask("NgZoneEvent: " + r, n, pne, D4, D4)
					try {
						return o.runTask(s, e, i)
					} finally {
						o.cancelTask(s)
					}
				}
				runGuarded(n, e, i) {
					return this._inner.runGuarded(n, e, i)
				}
				runOutsideAngular(n) {
					return this._outer.run(n)
				}
			}
			const pne = {}
			function mB(t) {
				if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable)
					try {
						t._nesting++, t.onMicrotaskEmpty.emit(null)
					} finally {
						if ((t._nesting--, !t.hasPendingMicrotasks))
							try {
								t.runOutsideAngular(() => t.onStable.emit(null))
							} finally {
								t.isStable = !0
							}
					}
			}
			function pB(t) {
				t.hasPendingMicrotasks = !!(
					t._hasPendingMicrotasks ||
					((t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId)
				)
			}
			function L4(t) {
				t._nesting++, t.isStable && ((t.isStable = !1), t.onUnstable.emit(null))
			}
			function R4(t) {
				t._nesting--, mB(t)
			}
			class bne {
				constructor() {
					;(this.hasPendingMicrotasks = !1),
						(this.hasPendingMacrotasks = !1),
						(this.isStable = !0),
						(this.onUnstable = new _n()),
						(this.onMicrotaskEmpty = new _n()),
						(this.onStable = new _n()),
						(this.onError = new _n())
				}
				run(n, e, i) {
					return n.apply(e, i)
				}
				runGuarded(n, e, i) {
					return n.apply(e, i)
				}
				runOutsideAngular(n) {
					return n()
				}
				runTask(n, e, i, r) {
					return n.apply(e, i)
				}
			}
			const P4 = new He("", { providedIn: "root", factory: O4 })
			function O4() {
				const t = Rt(mn)
				let n = !0
				return oo(
					new Ge(r => {
						;(n = t.isStable && !t.hasPendingMacrotasks && !t.hasPendingMicrotasks),
							t.runOutsideAngular(() => {
								r.next(n), r.complete()
							})
					}),
					new Ge(r => {
						let o
						t.runOutsideAngular(() => {
							o = t.onStable.subscribe(() => {
								mn.assertNotInAngularZone(),
									queueMicrotask(() => {
										!n && !t.hasPendingMacrotasks && !t.hasPendingMicrotasks && ((n = !0), r.next(!0))
									})
							})
						})
						const s = t.onUnstable.subscribe(() => {
							mn.assertInAngularZone(),
								n &&
									((n = !1),
									t.runOutsideAngular(() => {
										r.next(!1)
									}))
						})
						return () => {
							o.unsubscribe(), s.unsubscribe()
						}
					}).pipe(Rl())
				)
			}
			function q_(t) {
				return t.ownerDocument.defaultView
			}
			function N4(t) {
				return t.ownerDocument
			}
			let AB = (() => {
				class t {
					constructor() {
						;(this.renderDepth = 0), (this.handler = null)
					}
					begin() {
						this.handler?.validateBegin(), this.renderDepth++
					}
					end() {
						this.renderDepth--, 0 === this.renderDepth && this.handler?.execute()
					}
					ngOnDestroy() {
						this.handler?.destroy(), (this.handler = null)
					}
					static {
						this.ɵprov = mt({ token: t, providedIn: "root", factory: () => new t() })
					}
				}
				return t
			})()
			function Z_(t) {
				for (; t; ) {
					t[si] |= 64
					const n = V_(t)
					if (a_(t) && !n) return t
					t = n
				}
				return null
			}
			const z4 = new He("", { providedIn: "root", factory: () => !1 })
			let N1 = null
			function j4(t, n) {
				return t[n] ?? Y4()
			}
			function K4(t, n) {
				const e = Y4()
				e.producerNode?.length && ((t[n] = N1), (e.lView = t), (N1 = X4()))
			}
			const Sne = {
				...eA,
				consumerIsAlwaysLive: !0,
				consumerMarkedDirty: t => {
					Z_(t.lView)
				},
				lView: null
			}
			function X4() {
				return Object.create(Sne)
			}
			function Y4() {
				return (N1 ??= X4()), N1
			}
			const di = {}
			function T(t) {
				q4(Ui(), bt(), Cs() + t, !1)
			}
			function q4(t, n, e, i) {
				if (!i)
					if (3 == (3 & n[si])) {
						const o = t.preOrderCheckHooks
						null !== o && rm(n, o, e)
					} else {
						const o = t.preOrderHooks
						null !== o && om(n, o, 0, e)
					}
				Zd(e)
			}
			function P(t, n = Di.Default) {
				const e = bt()
				return null === e ? re(t, n) : wA(Yo(), e, Tn(t), n)
			}
			function Am() {
				throw new Error("invalid")
			}
			function U1(t, n, e, i, r, o, s, a, c, l, d) {
				const u = n.blueprint.slice()
				return (
					(u[qr] = r),
					(u[si] = 140 | i),
					(null !== l || (t && 2048 & t[si])) && (u[si] |= 2048),
					Hx(u),
					(u[pr] = u[uh] = t),
					(u[Rr] = e),
					(u[dh] = s || (t && t[dh])),
					(u[ei] = a || (t && t[ei])),
					(u[Ul] = c || (t && t[Ul]) || null),
					(u[as] = o),
					(u[$f] = (function Ree() {
						return Lee++
					})()),
					(u[Yc] = d),
					(u[vx] = l),
					(u[so] = 2 == n.type ? t[so] : u),
					u
				)
			}
			function VA(t, n, e, i, r) {
				let o = t.data[n]
				if (null === o)
					(o = (function gB(t, n, e, i, r) {
						const o = jx(),
							s = sA(),
							c = (t.data[n] = (function Rne(t, n, e, i, r, o) {
								let s = n ? n.injectorIndex : -1,
									a = 0
								return (
									Zr() && (a |= 128),
									{
										type: e,
										index: i,
										insertBeforeIndex: null,
										injectorIndex: s,
										directiveStart: -1,
										directiveEnd: -1,
										directiveStylingLast: -1,
										componentOffset: -1,
										propertyBindings: null,
										flags: a,
										providerIndexes: 0,
										value: r,
										attrs: o,
										mergedAttrs: null,
										localNames: null,
										initialInputs: void 0,
										inputs: null,
										outputs: null,
										tView: null,
										next: null,
										prev: null,
										projectionNext: null,
										child: null,
										parent: n,
										projection: null,
										styles: null,
										stylesWithoutHost: null,
										residualStyles: void 0,
										classes: null,
										classesWithoutHost: null,
										residualClasses: void 0,
										classBindings: 0,
										styleBindings: 0
									}
								)
							})(0, s ? o : o && o.parent, e, n, i, r))
						return (
							null === t.firstChild && (t.firstChild = c),
							null !== o &&
								(s
									? null == o.child && null !== c.parent && (o.child = c)
									: null === o.next && ((o.next = c), (c.prev = o))),
							c
						)
					})(t, n, e, i, r)),
						(function lA() {
							return Wn.lFrame.inI18n
						})() && (o.flags |= 32)
				else if (64 & o.type) {
					;(o.type = e), (o.value = i), (o.attrs = r)
					const s = (function tm() {
						const t = Wn.lFrame,
							n = t.currentTNode
						return t.isParent ? n : n.parent
					})()
					o.injectorIndex = null === s ? -1 : s.injectorIndex
				}
				return Sc(o, !0), o
			}
			function J_(t, n, e, i) {
				if (0 === e) return -1
				const r = n.length
				for (let o = 0; o < e; o++) n.push(i), t.blueprint.push(i), t.data.push(null)
				return r
			}
			function Z4(t, n, e, i, r) {
				const o = j4(n, Wf),
					s = Cs(),
					a = 2 & i
				try {
					Zd(-1), a && n.length > Ei && q4(t, n, Ei, !1), Ka(a ? 2 : 0, r)
					const l = a ? o : null,
						d = tA(l)
					try {
						null !== l && (l.dirty = !1), e(i, r)
					} finally {
						nA(l, d)
					}
				} finally {
					a && null === n[Wf] && K4(n, Wf), Zd(s), Ka(a ? 3 : 1, r)
				}
			}
			function bB(t, n, e) {
				if (s_(n)) {
					const i = xa(null)
					try {
						const o = n.directiveEnd
						for (let s = n.directiveStart; s < o; s++) {
							const a = t.data[s]
							a.contentQueries && a.contentQueries(1, e[s], s)
						}
					} finally {
						xa(i)
					}
				}
			}
			function _B(t, n, e) {
				g_() &&
					((function Qne(t, n, e, i) {
						const r = e.directiveStart,
							o = e.directiveEnd
						Ec(e) &&
							(function Xne(t, n, e) {
								const i = ws(n, t),
									r = J4(e)
								let s = 16
								e.signals ? (s = 4096) : e.onPush && (s = 64)
								const a = H1(t, U1(t, r, null, s, i, n, null, t[dh].rendererFactory.createRenderer(i, e), null, null, null))
								t[n.index] = a
							})(n, e, t.data[r + e.componentOffset]),
							t.firstCreatePass || _A(e, n),
							Hs(i, n)
						const s = e.initialInputs
						for (let a = r; a < o; a++) {
							const c = t.data[a],
								l = Kl(n, t, a, e)
							Hs(l, n), null !== s && Yne(0, a - r, l, c, 0, s), Wa(c) && (ea(e.index, n)[Rr] = Kl(n, t, a, e))
						}
					})(t, n, e, ws(e, n)),
					64 == (64 & e.flags) && rH(t, n, e))
			}
			function vB(t, n, e = ws) {
				const i = n.localNames
				if (null !== i) {
					let r = n.index + 1
					for (let o = 0; o < i.length; o += 2) {
						const s = i[o + 1],
							a = -1 === s ? e(n, t) : t[s]
						t[r++] = a
					}
				}
			}
			function J4(t) {
				const n = t.tView
				return null === n || n.incompleteFirstPass
					? (t.tView = yB(
							1,
							null,
							t.template,
							t.decls,
							t.vars,
							t.directiveDefs,
							t.pipeDefs,
							t.viewQuery,
							t.schemas,
							t.consts,
							t.id
					  ))
					: n
			}
			function yB(t, n, e, i, r, o, s, a, c, l, d) {
				const u = Ei + i,
					h = u + r,
					f = (function Tne(t, n) {
						const e = []
						for (let i = 0; i < n; i++) e.push(i < t ? null : di)
						return e
					})(u, h),
					_ = "function" == typeof l ? l() : l
				return (f[Qt] = {
					type: t,
					blueprint: f,
					template: e,
					queries: null,
					viewQuery: a,
					declTNode: n,
					data: f.slice().fill(null, u),
					bindingStartIndex: u,
					expandoStartIndex: h,
					hostBindingOpCodes: null,
					firstCreatePass: !0,
					firstUpdatePass: !0,
					staticViewQueries: !1,
					staticContentQueries: !1,
					preOrderHooks: null,
					preOrderCheckHooks: null,
					contentHooks: null,
					contentCheckHooks: null,
					viewHooks: null,
					viewCheckHooks: null,
					destroyHooks: null,
					cleanup: null,
					contentQueries: null,
					components: null,
					directiveRegistry: "function" == typeof o ? o() : o,
					pipeRegistry: "function" == typeof s ? s() : s,
					firstChild: null,
					schemas: c,
					consts: _,
					incompleteFirstPass: !1,
					ssrId: d
				})
			}
			let eH = t => null
			function tH(t, n, e, i) {
				for (let r in t)
					if (t.hasOwnProperty(r)) {
						e = null === e ? {} : e
						const o = t[r]
						null === i ? nH(e, n, r, o) : i.hasOwnProperty(r) && nH(e, n, i[r], o)
					}
				return e
			}
			function nH(t, n, e, i) {
				t.hasOwnProperty(e) ? t[e].push(n, i) : (t[e] = [n, i])
			}
			function qa(t, n, e, i, r, o, s, a) {
				const c = ws(n, e)
				let d,
					l = n.inputs
				!a && null != l && (d = l[i])
					? (MB(t, e, d, i, r),
					  Ec(n) &&
							(function Nne(t, n) {
								const e = ea(n, t)
								16 & e[si] || (e[si] |= 64)
							})(e, n.index))
					: 3 & n.type &&
					  ((i = (function One(t) {
							return "class" === t
								? "className"
								: "for" === t
								? "htmlFor"
								: "formaction" === t
								? "formAction"
								: "innerHtml" === t
								? "innerHTML"
								: "readonly" === t
								? "readOnly"
								: "tabindex" === t
								? "tabIndex"
								: t
					  })(i)),
					  (r = null != s ? s(r, n.value || "", i) : r),
					  o.setProperty(c, i, r))
			}
			function wB(t, n, e, i) {
				if (g_()) {
					const r = null === i ? null : { "": -1 },
						o = (function Gne(t, n) {
							const e = t.directiveRegistry
							let i = null,
								r = null
							if (e)
								for (let o = 0; o < e.length; o++) {
									const s = e[o]
									if (fx(n, s.selectors, !1))
										if ((i || (i = []), Wa(s)))
											if (null !== s.findHostDirectiveDefs) {
												const a = []
												;(r = r || new Map()),
													s.findHostDirectiveDefs(s, a, r),
													i.unshift(...a, s),
													xB(t, n, a.length)
											} else i.unshift(s), xB(t, n, 0)
										else (r = r || new Map()), s.findHostDirectiveDefs?.(s, i, r), i.push(s)
								}
							return null === i ? null : [i, r]
						})(t, e)
					let s, a
					null === o ? (s = a = null) : ([s, a] = o),
						null !== s && iH(t, n, e, s, r, a),
						r &&
							(function $ne(t, n, e) {
								if (n) {
									const i = (t.localNames = [])
									for (let r = 0; r < n.length; r += 2) {
										const o = e[n[r + 1]]
										if (null == o) throw new ht(-301, !1)
										i.push(n[r], o)
									}
								}
							})(e, i, r)
				}
				e.mergedAttrs = Of(e.mergedAttrs, e.attrs)
			}
			function iH(t, n, e, i, r, o) {
				for (let l = 0; l < i.length; l++) T_(_A(e, n), t, i[l].type)
				!(function jne(t, n, e) {
					;(t.flags |= 1), (t.directiveStart = n), (t.directiveEnd = n + e), (t.providerIndexes = n)
				})(e, t.data.length, i.length)
				for (let l = 0; l < i.length; l++) {
					const d = i[l]
					d.providersResolver && d.providersResolver(d)
				}
				let s = !1,
					a = !1,
					c = J_(t, n, i.length, null)
				for (let l = 0; l < i.length; l++) {
					const d = i[l]
					;(e.mergedAttrs = Of(e.mergedAttrs, d.hostAttrs)),
						Kne(t, e, n, c, d),
						Wne(c, d, r),
						null !== d.contentQueries && (e.flags |= 4),
						(null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (e.flags |= 64)
					const u = d.type.prototype
					!s && (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) && ((t.preOrderHooks ??= []).push(e.index), (s = !0)),
						!a && (u.ngOnChanges || u.ngDoCheck) && ((t.preOrderCheckHooks ??= []).push(e.index), (a = !0)),
						c++
				}
				!(function Pne(t, n, e) {
					const r = n.directiveEnd,
						o = t.data,
						s = n.attrs,
						a = []
					let c = null,
						l = null
					for (let d = n.directiveStart; d < r; d++) {
						const u = o[d],
							h = e ? e.get(u) : null,
							_ = h ? h.outputs : null
						;(c = tH(u.inputs, d, c, h ? h.inputs : null)), (l = tH(u.outputs, d, l, _))
						const y = null === c || null === s || hx(n) ? null : qne(c, d, s)
						a.push(y)
					}
					null !== c && (c.hasOwnProperty("class") && (n.flags |= 8), c.hasOwnProperty("style") && (n.flags |= 16)),
						(n.initialInputs = a),
						(n.inputs = c),
						(n.outputs = l)
				})(t, e, o)
			}
			function rH(t, n, e) {
				const i = e.directiveStart,
					r = e.directiveEnd,
					o = e.index,
					s = (function __() {
						return Wn.lFrame.currentDirectiveIndex
					})()
				try {
					Zd(o)
					for (let a = i; a < r; a++) {
						const c = t.data[a],
							l = n[a]
						dA(a), (null !== c.hostBindings || 0 !== c.hostVars || null !== c.hostAttrs) && zne(c, l)
					}
				} finally {
					Zd(-1), dA(s)
				}
			}
			function zne(t, n) {
				null !== t.hostBindings && t.hostBindings(1, n)
			}
			function xB(t, n, e) {
				;(n.componentOffset = e), (t.components ??= []).push(n.index)
			}
			function Wne(t, n, e) {
				if (e) {
					if (n.exportAs) for (let i = 0; i < n.exportAs.length; i++) e[n.exportAs[i]] = t
					Wa(n) && (e[""] = t)
				}
			}
			function Kne(t, n, e, i, r) {
				t.data[i] = r
				const o = r.factory || (r.factory = Kd(r.type)),
					s = new kc(o, Wa(r), P)
				;(t.blueprint[i] = s),
					(e[i] = s),
					(function Hne(t, n, e, i, r) {
						const o = r.hostBindings
						if (o) {
							let s = t.hostBindingOpCodes
							null === s && (s = t.hostBindingOpCodes = [])
							const a = ~n.index
							;(function Vne(t) {
								let n = t.length
								for (; n > 0; ) {
									const e = t[--n]
									if ("number" == typeof e && e < 0) return e
								}
								return 0
							})(s) != a && s.push(a),
								s.push(e, i, o)
						}
					})(t, n, i, J_(t, e, r.hostVars, di), r)
			}
			function Zl(t, n, e, i, r, o) {
				const s = ws(t, n)
				!(function CB(t, n, e, i, r, o, s) {
					if (null == o) t.removeAttribute(n, r, e)
					else {
						const a = null == s ? Dn(o) : s(o, i || "", r)
						t.setAttribute(n, r, a, e)
					}
				})(n[ei], s, o, t.value, e, i, r)
			}
			function Yne(t, n, e, i, r, o) {
				const s = o[n]
				if (null !== s) for (let a = 0; a < s.length; ) oH(i, e, s[a++], s[a++], s[a++])
			}
			function oH(t, n, e, i, r) {
				const o = xa(null)
				try {
					const s = t.inputTransforms
					null !== s && s.hasOwnProperty(i) && (r = s[i].call(n, r)), null !== t.setInput ? t.setInput(n, r, e, i) : (n[i] = r)
				} finally {
					xa(o)
				}
			}
			function qne(t, n, e) {
				let i = null,
					r = 0
				for (; r < e.length; ) {
					const o = e[r]
					if (0 !== o)
						if (5 !== o) {
							if ("number" == typeof o) break
							if (t.hasOwnProperty(o)) {
								null === i && (i = [])
								const s = t[o]
								for (let a = 0; a < s.length; a += 2)
									if (s[a] === n) {
										i.push(o, s[a + 1], e[r + 1])
										break
									}
							}
							r += 2
						} else r += 2
					else r += 4
				}
				return i
			}
			function sH(t, n, e, i) {
				return [t, !0, !1, n, null, 0, i, e, null, null, null]
			}
			function aH(t, n) {
				const e = t.contentQueries
				if (null !== e)
					for (let i = 0; i < e.length; i += 2) {
						const o = e[i + 1]
						if (-1 !== o) {
							const s = t.data[o]
							y_(e[i]), s.contentQueries(2, n[o], o)
						}
					}
			}
			function H1(t, n) {
				return t[Qf] ? (t[zf][$a] = n) : (t[Qf] = n), (t[zf] = n), n
			}
			function EB(t, n, e) {
				y_(0)
				const i = xa(null)
				try {
					n(t, e)
				} finally {
					xa(i)
				}
			}
			function cH(t) {
				return t[lh] || (t[lh] = [])
			}
			function lH(t) {
				return t.cleanup || (t.cleanup = [])
			}
			function uH(t, n) {
				const e = t[Ul],
					i = e ? e.get(ql, null) : null
				i && i.handleError(n)
			}
			function MB(t, n, e, i, r) {
				for (let o = 0; o < e.length; ) {
					const s = e[o++],
						a = e[o++]
					oH(t.data[s], n[s], i, a, r)
				}
			}
			function cu(t, n, e) {
				const i = Jf(n, t)
				!(function zU(t, n, e) {
					t.setValue(n, e)
				})(t[ei], i, e)
			}
			function Zne(t, n) {
				const e = ea(n, t),
					i = e[Qt]
				!(function Jne(t, n) {
					for (let e = n.length; e < t.blueprint.length; e++) n.push(t.blueprint[e])
				})(i, e)
				const r = e[qr]
				null !== r && null === e[Yc] && (e[Yc] = cB(r, e[Ul])), SB(i, e, e[Rr])
			}
			function SB(t, n, e) {
				fA(n)
				try {
					const i = t.viewQuery
					null !== i && EB(1, i, e)
					const r = t.template
					null !== r && Z4(t, n, r, 1, e),
						t.firstCreatePass && (t.firstCreatePass = !1),
						t.staticContentQueries && aH(t, n),
						t.staticViewQueries && EB(2, t.viewQuery, e)
					const o = t.components
					null !== o &&
						(function eie(t, n) {
							for (let e = 0; e < n.length; e++) Zne(t, n[e])
						})(n, o)
				} catch (i) {
					throw (t.firstCreatePass && ((t.incompleteFirstPass = !0), (t.firstCreatePass = !1)), i)
				} finally {
					;(n[si] &= -5), nm()
				}
			}
			let hH = (() => {
				class t {
					constructor() {
						;(this.all = new Set()), (this.queue = new Map())
					}
					create(e, i, r) {
						const o = typeof Zone > "u" ? null : Zone.current,
							s = (function $T(t, n, e) {
								const i = Object.create(WT)
								e && (i.consumerAllowSignalWrites = !0), (i.fn = t), (i.schedule = n)
								const r = s => {
									i.cleanupFn = s
								}
								return (
									(i.ref = {
										notify: () => Mx(i),
										run: () => {
											if (((i.dirty = !1), i.hasRun && !Sx(i))) return
											i.hasRun = !0
											const s = tA(i)
											try {
												i.cleanupFn(), (i.cleanupFn = Dx), i.fn(r)
											} finally {
												nA(i, s)
											}
										},
										cleanup: () => i.cleanupFn()
									}),
									i.ref
								)
							})(
								e,
								l => {
									this.all.has(l) && this.queue.set(l, o)
								},
								r
							)
						let a
						this.all.add(s), s.notify()
						const c = () => {
							s.cleanup(), a?.(), this.all.delete(s), this.queue.delete(s)
						}
						return (a = i?.onDestroy(c)), { destroy: c }
					}
					flush() {
						if (0 !== this.queue.size) for (const [e, i] of this.queue) this.queue.delete(e), i ? i.run(() => e.run()) : e.run()
					}
					get isQueueEmpty() {
						return 0 === this.queue.size
					}
					static {
						this.ɵprov = mt({ token: t, providedIn: "root", factory: () => new t() })
					}
				}
				return t
			})()
			function V1(t, n, e) {
				let i = e ? t.styles : null,
					r = e ? t.classes : null,
					o = 0
				if (null !== n)
					for (let s = 0; s < n.length; s++) {
						const a = n[s]
						"number" == typeof a ? (o = a) : 1 == o ? (r = rh(r, a)) : 2 == o && (i = rh(i, a + ": " + n[++s] + ";"))
					}
				e ? (t.styles = i) : (t.stylesWithoutHost = i), e ? (t.classes = r) : (t.classesWithoutHost = r)
			}
			function e0(t, n, e, i, r = !1) {
				for (; null !== e; ) {
					const o = n[e.index]
					null !== o && i.push(ar(o)), ys(o) && fH(o, i)
					const s = e.type
					if (8 & s) e0(t, n, e.child, i)
					else if (32 & s) {
						const a = FF(e, n)
						let c
						for (; (c = a()); ) i.push(c)
					} else if (16 & s) {
						const a = ZU(n, e)
						if (Array.isArray(a)) i.push(...a)
						else {
							const c = V_(n[so])
							e0(c[Qt], c, a, i, !0)
						}
					}
					e = r ? e.projectionNext : e.next
				}
				return i
			}
			function fH(t, n) {
				for (let e = Ko; e < t.length; e++) {
					const i = t[e],
						r = i[Qt].firstChild
					null !== r && e0(i[Qt], i, r, n)
				}
				t[Cc] !== t[qr] && n.push(t[Cc])
			}
			function Q1(t, n, e, i = !0) {
				const r = n[dh],
					o = r.rendererFactory,
					s = r.afterRenderEventManager
				o.begin?.(), s?.begin()
				try {
					mH(t, n, t.template, e)
				} catch (c) {
					throw (i && uH(n, c), c)
				} finally {
					o.end?.(), r.effectManager?.flush(), s?.end()
				}
			}
			function mH(t, n, e, i) {
				const r = n[si]
				if (256 != (256 & r)) {
					n[dh].effectManager?.flush(), fA(n)
					try {
						Hx(n),
							(function Xx(t) {
								return (Wn.lFrame.bindingIndex = t)
							})(t.bindingStartIndex),
							null !== e && Z4(t, n, e, 2, i)
						const s = 3 == (3 & r)
						if (s) {
							const l = t.preOrderCheckHooks
							null !== l && rm(n, l, null)
						} else {
							const l = t.preOrderHooks
							null !== l && om(n, l, 0, null), M_(n, 0)
						}
						if (
							((function iie(t) {
								for (let n = HU(t); null !== n; n = VU(n)) {
									if (!n[yx]) continue
									const e = n[qc]
									for (let i = 0; i < e.length; i++) {
										ZT(e[i])
									}
								}
							})(n),
							pH(n, 2),
							null !== t.contentQueries && aH(t, n),
							s)
						) {
							const l = t.contentCheckHooks
							null !== l && rm(n, l)
						} else {
							const l = t.contentHooks
							null !== l && om(n, l, 1), M_(n, 1)
						}
						!(function kne(t, n) {
							const e = t.hostBindingOpCodes
							if (null === e) return
							const i = j4(n, jd)
							try {
								for (let r = 0; r < e.length; r++) {
									const o = e[r]
									if (o < 0) Zd(~o)
									else {
										const s = o,
											a = e[++r],
											c = e[++r]
										qx(a, s), (i.dirty = !1)
										const l = tA(i)
										try {
											c(2, n[s])
										} finally {
											nA(i, l)
										}
									}
								}
							} finally {
								null === n[jd] && K4(n, jd), Zd(-1)
							}
						})(t, n)
						const a = t.components
						null !== a && gH(n, a, 0)
						const c = t.viewQuery
						if ((null !== c && EB(2, c, i), s)) {
							const l = t.viewCheckHooks
							null !== l && rm(n, l)
						} else {
							const l = t.viewHooks
							null !== l && om(n, l, 2), M_(n, 2)
						}
						!0 === t.firstUpdatePass && (t.firstUpdatePass = !1), (n[si] &= -73), Vx(n)
					} finally {
						nm()
					}
				}
			}
			function pH(t, n) {
				for (let e = HU(t); null !== e; e = VU(e)) for (let i = Ko; i < e.length; i++) AH(e[i], n)
			}
			function rie(t, n, e) {
				AH(ea(n, t), e)
			}
			function AH(t, n) {
				if (
					!(function qT(t) {
						return 128 == (128 & t[si])
					})(t)
				)
					return
				const e = t[Qt],
					i = t[si]
				if ((80 & i && 0 === n) || 1024 & i || 2 === n) mH(e, t, e.template, t[Rr])
				else if (t[Vf] > 0) {
					pH(t, 1)
					const r = e.components
					null !== r && gH(t, r, 1)
				}
			}
			function gH(t, n, e) {
				for (let i = 0; i < n.length; i++) rie(t, n[i], e)
			}
			class t0 {
				get rootNodes() {
					const n = this._lView,
						e = n[Qt]
					return e0(e, n, e.firstChild, [])
				}
				constructor(n, e) {
					;(this._lView = n), (this._cdRefInjectingView = e), (this._appRef = null), (this._attachedToViewContainer = !1)
				}
				get context() {
					return this._lView[Rr]
				}
				set context(n) {
					this._lView[Rr] = n
				}
				get destroyed() {
					return 256 == (256 & this._lView[si])
				}
				destroy() {
					if (this._appRef) this._appRef.detachView(this)
					else if (this._attachedToViewContainer) {
						const n = this._lView[pr]
						if (ys(n)) {
							const e = n[8],
								i = e ? e.indexOf(this) : -1
							i > -1 && (y1(n, i), iu(e, i))
						}
						this._attachedToViewContainer = !1
					}
					IF(this._lView[Qt], this._lView)
				}
				onDestroy(n) {
					zx(this._lView, n)
				}
				markForCheck() {
					Z_(this._cdRefInjectingView || this._lView)
				}
				detach() {
					this._lView[si] &= -129
				}
				reattach() {
					this._lView[si] |= 128
				}
				detectChanges() {
					Q1(this._lView[Qt], this._lView, this.context)
				}
				checkNoChanges() {}
				attachToViewContainerRef() {
					if (this._appRef) throw new ht(902, !1)
					this._attachedToViewContainer = !0
				}
				detachFromAppRef() {
					;(this._appRef = null),
						(function Xee(t, n) {
							z_(t, n, n[ei], 2, null, null)
						})(this._lView[Qt], this._lView)
				}
				attachToAppRef(n) {
					if (this._attachedToViewContainer) throw new ht(902, !1)
					this._appRef = n
				}
			}
			class oie extends t0 {
				constructor(n) {
					super(n), (this._view = n)
				}
				detectChanges() {
					const n = this._view
					Q1(n[Qt], n, n[Rr], !1)
				}
				checkNoChanges() {}
				get context() {
					return null
				}
			}
			class bH extends RA {
				constructor(n) {
					super(), (this.ngModule = n)
				}
				resolveComponentFactory(n) {
					const e = Ni(n)
					return new n0(e, this.ngModule)
				}
			}
			function _H(t) {
				const n = []
				for (let e in t) t.hasOwnProperty(e) && n.push({ propName: t[e], templateName: e })
				return n
			}
			class aie {
				constructor(n, e) {
					;(this.injector = n), (this.parentInjector = e)
				}
				get(n, e, i) {
					i = Va(i)
					const r = this.injector.get(n, uB, i)
					return r !== uB || e === uB ? r : this.parentInjector.get(n, e, i)
				}
			}
			class n0 extends E4 {
				get inputs() {
					const n = this.componentDef,
						e = n.inputTransforms,
						i = _H(n.inputs)
					if (null !== e) for (const r of i) e.hasOwnProperty(r.propName) && (r.transform = e[r.propName])
					return i
				}
				get outputs() {
					return _H(this.componentDef.outputs)
				}
				constructor(n, e) {
					super(),
						(this.componentDef = n),
						(this.ngModule = e),
						(this.componentType = n.type),
						(this.selector = (function gx(t) {
							return t.map(Ax).join(",")
						})(n.selectors)),
						(this.ngContentSelectors = n.ngContentSelectors ? n.ngContentSelectors : []),
						(this.isBoundToModule = !!e)
				}
				create(n, e, i, r) {
					let o = (r = r || this.ngModule) instanceof Yl ? r : r?.injector
					o && null !== this.componentDef.getStandaloneInjector && (o = this.componentDef.getStandaloneInjector(o) || o)
					const s = o ? new aie(n, o) : n,
						a = s.get(Y_, null)
					if (null === a) throw new ht(407, !1)
					const u = {
							rendererFactory: a,
							sanitizer: s.get(rne, null),
							effectManager: s.get(hH, null),
							afterRenderEventManager: s.get(AB, null)
						},
						h = a.createRenderer(null, this.componentDef),
						f = this.componentDef.selectors[0][0] || "div",
						_ = i
							? (function Fne(t, n, e, i) {
									const o = i.get(z4, !1) || e === Zs.ShadowDom,
										s = t.selectRootElement(n, o)
									return (
										(function Bne(t) {
											eH(t)
										})(s),
										s
									)
							  })(h, i, this.componentDef.encapsulation, s)
							: v1(
									h,
									f,
									(function sie(t) {
										const n = t.toLowerCase()
										return "svg" === n ? Nx : "math" === n ? "math" : null
									})(f)
							  ),
						x = this.componentDef.signals ? 4608 : this.componentDef.onPush ? 576 : 528
					let w = null
					null !== _ && (w = cB(_, s, !0))
					const S = yB(0, null, null, 1, 0, null, null, null, null, null, null),
						M = U1(null, S, null, x, null, null, u, h, s, null, w)
					let O, N
					fA(M)
					try {
						const j = this.componentDef
						let le,
							ae = null
						j.findHostDirectiveDefs ? ((le = []), (ae = new Map()), j.findHostDirectiveDefs(j, le, ae), le.push(j)) : (le = [j])
						const ce = (function lie(t, n) {
								const e = t[Qt],
									i = Ei
								return (t[i] = n), VA(e, i, 2, "#host", null)
							})(M, _),
							ue = (function die(t, n, e, i, r, o, s) {
								const a = r[Qt]
								!(function uie(t, n, e, i) {
									for (const r of t) n.mergedAttrs = Of(n.mergedAttrs, r.hostAttrs)
									null !== n.mergedAttrs && (V1(n, n.mergedAttrs, !0), null !== e && n4(i, e, n))
								})(i, t, n, s)
								let c = null
								null !== n && (c = cB(n, r[Ul]))
								const l = o.rendererFactory.createRenderer(n, e)
								let d = 16
								e.signals ? (d = 4096) : e.onPush && (d = 64)
								const u = U1(r, J4(e), null, d, r[t.index], t, o, l, null, null, c)
								return a.firstCreatePass && xB(a, t, i.length - 1), H1(r, u), (r[t.index] = u)
							})(ce, _, j, le, M, u, h)
						;(N = p_(S, Ei)),
							_ &&
								(function fie(t, n, e, i) {
									if (i) r_(t, e, ["ng-version", one.full])
									else {
										const { attrs: r, classes: o } = (function bx(t) {
											const n = [],
												e = []
											let i = 1,
												r = 2
											for (; i < t.length; ) {
												let o = t[i]
												if ("string" == typeof o) 2 === r ? "" !== o && n.push(o, t[++i]) : 8 === r && e.push(o)
												else {
													if (!wa(r)) break
													r = o
												}
												i++
											}
											return { attrs: n, classes: e }
										})(n.selectors[0])
										r && r_(t, e, r), o && o.length > 0 && t4(t, e, o.join(" "))
									}
								})(h, j, _, i),
							void 0 !== e &&
								(function mie(t, n, e) {
									const i = (t.projection = [])
									for (let r = 0; r < n.length; r++) {
										const o = e[r]
										i.push(null != o ? Array.from(o) : null)
									}
								})(N, this.ngContentSelectors, e),
							(O = (function hie(t, n, e, i, r, o) {
								const s = Yo(),
									a = r[Qt],
									c = ws(s, r)
								iH(a, r, s, e, null, i)
								for (let d = 0; d < e.length; d++) Hs(Kl(r, a, s.directiveStart + d, s), r)
								rH(a, r, s), c && Hs(c, r)
								const l = Kl(r, a, s.directiveStart + s.componentOffset, s)
								if (((t[Rr] = r[Rr] = l), null !== o)) for (const d of o) d(l, n)
								return bB(a, s, t), l
							})(ue, j, le, ae, M, [pie])),
							SB(S, M, null)
					} finally {
						nm()
					}
					return new cie(this.componentType, O, PA(N, M), M, N)
				}
			}
			class cie extends Zte {
				constructor(n, e, i, r, o) {
					super(),
						(this.location = i),
						(this._rootLView = r),
						(this._tNode = o),
						(this.previousInputValues = null),
						(this.instance = e),
						(this.hostView = this.changeDetectorRef = new oie(r)),
						(this.componentType = n)
				}
				setInput(n, e) {
					const i = this._tNode.inputs
					let r
					if (null !== i && (r = i[n])) {
						if (
							((this.previousInputValues ??= new Map()),
							this.previousInputValues.has(n) && Object.is(this.previousInputValues.get(n), e))
						)
							return
						const o = this._rootLView
						MB(o[Qt], o, r, n, e), this.previousInputValues.set(n, e), Z_(ea(this._tNode.index, o))
					}
				}
				get injector() {
					return new qo(this._tNode, this._rootLView)
				}
				destroy() {
					this.hostView.destroy()
				}
				onDestroy(n) {
					this.hostView.onDestroy(n)
				}
			}
			function pie() {
				const t = Yo()
				Jd(bt()[Qt], t)
			}
			function pn(t) {
				let n = (function vH(t) {
						return Object.getPrototypeOf(t.prototype).constructor
					})(t.type),
					e = !0
				const i = [t]
				for (; n; ) {
					let r
					if (Wa(t)) r = n.ɵcmp || n.ɵdir
					else {
						if (n.ɵcmp) throw new ht(903, !1)
						r = n.ɵdir
					}
					if (r) {
						if (e) {
							i.push(r)
							const s = t
							;(s.inputs = z1(t.inputs)),
								(s.inputTransforms = z1(t.inputTransforms)),
								(s.declaredInputs = z1(t.declaredInputs)),
								(s.outputs = z1(t.outputs))
							const a = r.hostBindings
							a && _ie(t, a)
							const c = r.viewQuery,
								l = r.contentQueries
							if (
								(c && gie(t, c),
								l && bie(t, l),
								pc(t.inputs, r.inputs),
								pc(t.declaredInputs, r.declaredInputs),
								pc(t.outputs, r.outputs),
								null !== r.inputTransforms &&
									(null === s.inputTransforms && (s.inputTransforms = {}), pc(s.inputTransforms, r.inputTransforms)),
								Wa(r) && r.data.animation)
							) {
								const d = t.data
								d.animation = (d.animation || []).concat(r.data.animation)
							}
						}
						const o = r.features
						if (o)
							for (let s = 0; s < o.length; s++) {
								const a = o[s]
								a && a.ngInherit && a(t), a === pn && (e = !1)
							}
					}
					n = Object.getPrototypeOf(n)
				}
				!(function Aie(t) {
					let n = 0,
						e = null
					for (let i = t.length - 1; i >= 0; i--) {
						const r = t[i]
						;(r.hostVars = n += r.hostVars), (r.hostAttrs = Of(r.hostAttrs, (e = Of(e, r.hostAttrs))))
					}
				})(i)
			}
			function z1(t) {
				return t === Qa ? {} : t === oi ? [] : t
			}
			function gie(t, n) {
				const e = t.viewQuery
				t.viewQuery = e
					? (i, r) => {
							n(i, r), e(i, r)
					  }
					: n
			}
			function bie(t, n) {
				const e = t.contentQueries
				t.contentQueries = e
					? (i, r, o) => {
							n(i, r, o), e(i, r, o)
					  }
					: n
			}
			function _ie(t, n) {
				const e = t.hostBindings
				t.hostBindings = e
					? (i, r) => {
							n(i, r), e(i, r)
					  }
					: n
			}
			function G1(t) {
				return !!kB(t) && (Array.isArray(t) || (!(t instanceof Map) && Symbol.iterator in t))
			}
			function kB(t) {
				return null !== t && ("function" == typeof t || "object" == typeof t)
			}
			function Jl(t, n, e) {
				return (t[n] = e)
			}
			function Vs(t, n, e) {
				return !Object.is(t[n], e) && ((t[n] = e), !0)
			}
			function gm(t, n, e, i) {
				const r = Vs(t, n, e)
				return Vs(t, n + 1, i) || r
			}
			function qn(t, n, e, i) {
				const r = bt()
				return Vs(r, mh(), n) && (Ui(), Zl(Gr(), r, t, n, e, i)), qn
			}
			function zA(t, n, e, i) {
				return Vs(t, mh(), e) ? n + Dn(e) + i : di
			}
			function GA(t, n, e, i, r, o) {
				const a = gm(
					t,
					(function Jc() {
						return Wn.lFrame.bindingIndex
					})(),
					e,
					r
				)
				return Ea(2), a ? n + Dn(e) + i + Dn(r) + o : di
			}
			function Ee(t, n, e, i, r, o, s, a) {
				const c = bt(),
					l = Ui(),
					d = t + Ei,
					u = l.firstCreatePass
						? (function $ie(t, n, e, i, r, o, s, a, c) {
								const l = n.consts,
									d = VA(n, t, 4, s || null, Mc(l, a))
								wB(n, e, d, Mc(l, c)), Jd(n, d)
								const u = (d.tView = yB(2, d, i, r, o, n.directiveRegistry, n.pipeRegistry, null, n.schemas, l, null))
								return null !== n.queries && (n.queries.template(n, d), (u.queries = n.queries.embeddedTView(d))), d
						  })(d, l, c, n, e, i, r, o, s)
						: l.data[d]
				Sc(u, !1)
				const h = PH(l, c, u, t)
				im() && x1(l, c, h, u), Hs(h, c), H1(c, (c[d] = sH(h, c, h, u))), Zp(u) && _B(l, c, u), null != s && vB(c, u, a)
			}
			let PH = function OH(t, n, e, i) {
				return Gl(!0), n[ei].createComment("")
			}
			function br(t) {
				return zl(
					(function Kx() {
						return Wn.lFrame.contextLView
					})(),
					Ei + t
				)
			}
			function U(t, n, e) {
				const i = bt()
				return Vs(i, mh(), n) && qa(Ui(), Gr(), i, t, n, i[ei], e, !1), U
			}
			function LB(t, n, e, i, r) {
				const s = r ? "class" : "style"
				MB(t, e, n.inputs[s], s, i)
			}
			function F(t, n, e, i) {
				const r = bt(),
					o = Ui(),
					s = Ei + t,
					a = r[ei],
					c = o.firstCreatePass
						? (function Xie(t, n, e, i, r, o) {
								const s = n.consts,
									c = VA(n, t, 2, i, Mc(s, r))
								return (
									wB(n, e, c, Mc(s, o)),
									null !== c.attrs && V1(c, c.attrs, !1),
									null !== c.mergedAttrs && V1(c, c.mergedAttrs, !0),
									null !== n.queries && n.queries.elementStart(n, c),
									c
								)
						  })(s, o, r, n, e, i)
						: o.data[s],
					l = NH(o, r, c, a, n, t)
				r[s] = l
				const d = Zp(c)
				return (
					Sc(c, !0),
					n4(a, l, c),
					32 != (32 & c.flags) && im() && x1(o, r, l, c),
					0 ===
						(function $x() {
							return Wn.lFrame.elementDepthCount
						})() && Hs(l, r),
					(function eF() {
						Wn.lFrame.elementDepthCount++
					})(),
					d && (_B(o, r, c), bB(o, c, r)),
					null !== i && vB(r, c),
					F
				)
			}
			function L() {
				let t = Yo()
				sA() ? aA() : ((t = t.parent), Sc(t, !1))
				const n = t
				;(function em(t) {
					return Wn.skipHydrationRootTNode === t
				})(n) &&
					(function b_() {
						Wn.skipHydrationRootTNode = null
					})(),
					(function A_() {
						Wn.lFrame.elementDepthCount--
					})()
				const e = Ui()
				return (
					e.firstCreatePass && (Jd(e, t), s_(t) && e.queries.elementEnd(t)),
					null != n.classesWithoutHost &&
						(function $l(t) {
							return 0 != (8 & t.flags)
						})(n) &&
						LB(e, n, bt(), n.classesWithoutHost, !0),
					null != n.stylesWithoutHost &&
						(function Wl(t) {
							return 0 != (16 & t.flags)
						})(n) &&
						LB(e, n, bt(), n.stylesWithoutHost, !1),
					L
				)
			}
			function fe(t, n, e, i) {
				return F(t, n, e, i), L(), fe
			}
			let NH = (t, n, e, i, r, o) => (
				Gl(!0),
				v1(
					i,
					r,
					(function pA() {
						return Wn.lFrame.currentNamespace
					})()
				)
			)
			function Cr(t, n, e) {
				const i = bt(),
					r = Ui(),
					o = t + Ei,
					s = r.firstCreatePass
						? (function Zie(t, n, e, i, r) {
								const o = n.consts,
									s = Mc(o, i),
									a = VA(n, t, 8, "ng-container", s)
								return (
									null !== s && V1(a, s, !0), wB(n, e, a, Mc(o, r)), null !== n.queries && n.queries.elementStart(n, a), a
								)
						  })(o, r, i, n, e)
						: r.data[o]
				Sc(s, !0)
				const a = UH(r, i, s, t)
				return (i[o] = a), im() && x1(r, i, a, s), Hs(a, i), Zp(s) && (_B(r, i, s), bB(r, s, i)), null != e && vB(i, s), Cr
			}
			function Er() {
				let t = Yo()
				const n = Ui()
				return sA() ? aA() : ((t = t.parent), Sc(t, !1)), n.firstCreatePass && (Jd(n, t), s_(t) && n.queries.elementEnd(t)), Er
			}
			function qA(t, n, e) {
				return Cr(t, n, e), Er(), qA
			}
			let UH = (t, n, e, i) => (Gl(!0), BF(n[ei], ""))
			function ri() {
				return bt()
			}
			function X1(t) {
				return !!t && "function" == typeof t.then
			}
			function HH(t) {
				return !!t && "function" == typeof t.subscribe
			}
			function Le(t, n, e, i) {
				const r = bt(),
					o = Ui(),
					s = Yo()
				return (
					(function QH(t, n, e, i, r, o, s) {
						const a = Zp(i),
							l = t.firstCreatePass && lH(t),
							d = n[Rr],
							u = cH(n)
						let h = !0
						if (3 & i.type || s) {
							const y = ws(i, n),
								C = s ? s(y) : y,
								x = u.length,
								w = s ? M => s(ar(M[i.index])) : i.index
							let S = null
							if (
								(!s &&
									a &&
									(S = (function tre(t, n, e, i) {
										const r = t.cleanup
										if (null != r)
											for (let o = 0; o < r.length - 1; o += 2) {
												const s = r[o]
												if (s === e && r[o + 1] === i) {
													const a = n[lh],
														c = r[o + 2]
													return a.length > c ? a[c] : null
												}
												"string" == typeof s && (o += 2)
											}
										return null
									})(t, n, r, i.index)),
								null !== S)
							)
								((S.__ngLastListenerFn__ || S).__ngNextListenerFn__ = o), (S.__ngLastListenerFn__ = o), (h = !1)
							else {
								o = GH(i, n, d, o, !1)
								const M = e.listen(C, r, o)
								u.push(o, M), l && l.push(r, w, x, x + 1)
							}
						} else o = GH(i, n, d, o, !1)
						const f = i.outputs
						let _
						if (h && null !== f && (_ = f[r])) {
							const y = _.length
							if (y)
								for (let C = 0; C < y; C += 2) {
									const O = n[_[C]][_[C + 1]].subscribe(o),
										N = u.length
									u.push(o, O), l && l.push(r, i.index, N, -(N + 1))
								}
						}
					})(o, r, r[ei], s, t, n, i),
					Le
				)
			}
			function zH(t, n, e, i) {
				try {
					return Ka(6, n, e), !1 !== e(i)
				} catch (r) {
					return uH(t, r), !1
				} finally {
					Ka(7, n, e)
				}
			}
			function GH(t, n, e, i, r) {
				return function o(s) {
					if (s === Function) return i
					Z_(t.componentOffset > -1 ? ea(t.index, n) : n)
					let c = zH(n, e, i, s),
						l = o.__ngNextListenerFn__
					for (; l; ) (c = zH(n, e, l, s) && c), (l = l.__ngNextListenerFn__)
					return r && !1 === c && s.preventDefault(), c
				}
			}
			function Te(t = 1) {
				return (function mA(t) {
					return (Wn.lFrame.contextLView = (function rF(t, n) {
						for (; t > 0; ) (n = n[uh]), t--
						return n
					})(t, Wn.lFrame.contextLView))[Rr]
				})(t)
			}
			function nre(t, n) {
				let e = null
				const i = (function Wp(t) {
					const n = t.attrs
					if (null != n) {
						const e = n.indexOf(5)
						if (!(1 & e)) return n[e + 1]
					}
					return null
				})(t)
				for (let r = 0; r < n.length; r++) {
					const o = n[r]
					if ("*" !== o) {
						if (null === i ? fx(t, o, !0) : px(i, o)) return r
					} else e = r
				}
				return e
			}
			function co(t) {
				const n = bt()[so][as]
				if (!n.projection) {
					const i = (n.projection = cs(t ? t.length : 1, null)),
						r = i.slice()
					let o = n.child
					for (; null !== o; ) {
						const s = t ? nre(o, t) : 0
						null !== s && (r[s] ? (r[s].projectionNext = o) : (i[s] = o), (r[s] = o)), (o = o.next)
					}
				}
			}
			function Ln(t, n = 0, e) {
				const i = bt(),
					r = Ui(),
					o = VA(r, Ei + t, 16, null, e || null)
				null === o.projection && (o.projection = n),
					aA(),
					(!i[Yc] || Zr()) &&
						32 != (32 & o.flags) &&
						(function ite(t, n, e) {
							e4(n[ei], 0, n, e, LF(t, e, n), KU(e.parent || n[as], e, n))
						})(r, i, o)
			}
			function Fa(t, n, e) {
				return lu(t, "", n, "", e), Fa
			}
			function lu(t, n, e, i, r) {
				const o = bt(),
					s = zA(o, n, e, i)
				return s !== di && qa(Ui(), Gr(), o, t, s, o[ei], r, !1), lu
			}
			function Y1(t, n) {
				return (t << 17) | (n << 2)
			}
			function Sh(t) {
				return (t >> 17) & 32767
			}
			function RB(t) {
				return 2 | t
			}
			function bm(t) {
				return (131068 & t) >> 2
			}
			function PB(t, n) {
				return (-131069 & t) | (n << 2)
			}
			function OB(t) {
				return 1 | t
			}
			function JH(t, n, e, i, r) {
				const o = t[e + 1],
					s = null === n
				let a = i ? Sh(o) : bm(o),
					c = !1
				for (; 0 !== a && (!1 === c || s); ) {
					const d = t[a + 1]
					cre(t[a], n) && ((c = !0), (t[a + 1] = i ? OB(d) : RB(d))), (a = i ? Sh(d) : bm(d))
				}
				c && (t[e + 1] = i ? RB(o) : OB(o))
			}
			function cre(t, n) {
				return (
					null === t ||
					null == n ||
					(Array.isArray(t) ? t[1] : t) === n ||
					(!(!Array.isArray(t) || "string" != typeof n) && tl(t, n) >= 0)
				)
			}
			const Jo = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }
			function e5(t) {
				return t.substring(Jo.key, Jo.keyEnd)
			}
			function lre(t) {
				return t.substring(Jo.value, Jo.valueEnd)
			}
			function t5(t, n) {
				const e = Jo.textEnd
				return e === n
					? -1
					: ((n = Jo.keyEnd =
							(function hre(t, n, e) {
								for (; n < e && t.charCodeAt(n) > 32; ) n++
								return n
							})(t, (Jo.key = n), e)),
					  ZA(t, n, e))
			}
			function n5(t, n) {
				const e = Jo.textEnd
				let i = (Jo.key = ZA(t, n, e))
				return e === i
					? -1
					: ((i = Jo.keyEnd =
							(function fre(t, n, e) {
								let i
								for (
									;
									n < e &&
									(45 === (i = t.charCodeAt(n)) ||
										95 === i ||
										((-33 & i) >= 65 && (-33 & i) <= 90) ||
										(i >= 48 && i <= 57));

								)
									n++
								return n
							})(t, i, e)),
					  (i = r5(t, i, e)),
					  (i = Jo.value = ZA(t, i, e)),
					  (i = Jo.valueEnd =
							(function mre(t, n, e) {
								let i = -1,
									r = -1,
									o = -1,
									s = n,
									a = s
								for (; s < e; ) {
									const c = t.charCodeAt(s++)
									if (59 === c) return a
									34 === c || 39 === c
										? (a = s = o5(t, c, s, e))
										: n === s - 4 && 85 === o && 82 === r && 76 === i && 40 === c
										? (a = s = o5(t, 41, s, e))
										: c > 32 && (a = s),
										(o = r),
										(r = i),
										(i = -33 & c)
								}
								return a
							})(t, i, e)),
					  r5(t, i, e))
			}
			function i5(t) {
				;(Jo.key = 0), (Jo.keyEnd = 0), (Jo.value = 0), (Jo.valueEnd = 0), (Jo.textEnd = t.length)
			}
			function ZA(t, n, e) {
				for (; n < e && t.charCodeAt(n) <= 32; ) n++
				return n
			}
			function r5(t, n, e, i) {
				return (n = ZA(t, n, e)) < e && n++, n
			}
			function o5(t, n, e, i) {
				let r = -1,
					o = e
				for (; o < i; ) {
					const s = t.charCodeAt(o++)
					if (s == n && 92 !== r) return o
					r = 92 == s && 92 === r ? 0 : s
				}
				throw new Error()
			}
			function bi(t, n, e) {
				return ol(t, n, e, !1), bi
			}
			function Zt(t, n) {
				return ol(t, n, null, !0), Zt
			}
			function es(t) {
				sl(c5, pre, t, !1)
			}
			function pre(t, n) {
				for (
					let e = (function ure(t) {
						return i5(t), n5(t, ZA(t, 0, Jo.textEnd))
					})(n);
					e >= 0;
					e = n5(n, e)
				)
					c5(t, e5(n), lre(n))
			}
			function c0(t) {
				sl(yre, ed, t, !0)
			}
			function ed(t, n) {
				for (
					let e = (function dre(t) {
						return i5(t), t5(t, ZA(t, 0, Jo.textEnd))
					})(n);
					e >= 0;
					e = t5(n, e)
				)
					Es(t, e5(n), !0)
			}
			function ol(t, n, e, i) {
				const r = bt(),
					o = Ui(),
					s = Ea(2)
				o.firstUpdatePass && a5(o, t, s, i),
					n !== di &&
						Vs(r, s, n) &&
						l5(
							o,
							o.data[Cs()],
							r,
							r[ei],
							t,
							(r[s + 1] = (function xre(t, n) {
								return (
									null == t || "" === t || ("string" == typeof n ? (t += n) : "object" == typeof t && (t = Lr(Eh(t)))), t
								)
							})(n, e)),
							i,
							s
						)
			}
			function sl(t, n, e, i) {
				const r = Ui(),
					o = Ea(2)
				r.firstUpdatePass && a5(r, null, o, i)
				const s = bt()
				if (e !== di && Vs(s, o, e)) {
					const a = r.data[Cs()]
					if (u5(a, i) && !s5(r, o)) {
						let c = i ? a.classesWithoutHost : a.stylesWithoutHost
						null !== c && (e = rh(c, e || "")), LB(r, a, s, e, i)
					} else
						!(function wre(t, n, e, i, r, o, s, a) {
							r === di && (r = oi)
							let c = 0,
								l = 0,
								d = 0 < r.length ? r[0] : null,
								u = 0 < o.length ? o[0] : null
							for (; null !== d || null !== u; ) {
								const h = c < r.length ? r[c + 1] : void 0,
									f = l < o.length ? o[l + 1] : void 0
								let y,
									_ = null
								d === u
									? ((c += 2), (l += 2), h !== f && ((_ = u), (y = f)))
									: null === u || (null !== d && d < u)
									? ((c += 2), (_ = d))
									: ((l += 2), (_ = u), (y = f)),
									null !== _ && l5(t, n, e, i, _, y, s, a),
									(d = c < r.length ? r[c] : null),
									(u = l < o.length ? o[l] : null)
							}
						})(
							r,
							a,
							s,
							s[ei],
							s[o + 1],
							(s[o + 1] = (function vre(t, n, e) {
								if (null == e || "" === e) return oi
								const i = [],
									r = Eh(e)
								if (Array.isArray(r)) for (let o = 0; o < r.length; o++) t(i, r[o], !0)
								else if ("object" == typeof r) for (const o in r) r.hasOwnProperty(o) && t(i, o, r[o])
								else "string" == typeof r && n(i, r)
								return i
							})(t, n, e)),
							i,
							o
						)
				}
			}
			function s5(t, n) {
				return n >= t.expandoStartIndex
			}
			function a5(t, n, e, i) {
				const r = t.data
				if (null === r[e + 1]) {
					const o = r[Cs()],
						s = s5(t, e)
					u5(o, i) && null === n && !s && (n = !1),
						(n = (function Are(t, n, e, i) {
							const r = (function uA(t) {
								const n = Wn.lFrame.currentDirectiveIndex
								return -1 === n ? null : t[n]
							})(t)
							let o = i ? n.residualClasses : n.residualStyles
							if (null === r)
								0 === (i ? n.classBindings : n.styleBindings) &&
									((e = l0((e = NB(null, t, n, e, i)), n.attrs, i)), (o = null))
							else {
								const s = n.directiveStylingLast
								if (-1 === s || t[s] !== r)
									if (((e = NB(r, t, n, e, i)), null === o)) {
										let c = (function gre(t, n, e) {
											const i = e ? n.classBindings : n.styleBindings
											if (0 !== bm(i)) return t[Sh(i)]
										})(t, n, i)
										void 0 !== c &&
											Array.isArray(c) &&
											((c = NB(null, t, n, c[1], i)),
											(c = l0(c, n.attrs, i)),
											(function bre(t, n, e, i) {
												t[Sh(e ? n.classBindings : n.styleBindings)] = i
											})(t, n, i, c))
									} else
										o = (function _re(t, n, e) {
											let i
											const r = n.directiveEnd
											for (let o = 1 + n.directiveStylingLast; o < r; o++) i = l0(i, t[o].hostAttrs, e)
											return l0(i, n.attrs, e)
										})(t, n, i)
							}
							return void 0 !== o && (i ? (n.residualClasses = o) : (n.residualStyles = o)), e
						})(r, o, n, i)),
						(function sre(t, n, e, i, r, o) {
							let s = o ? n.classBindings : n.styleBindings,
								a = Sh(s),
								c = bm(s)
							t[i] = e
							let d,
								l = !1
							if ((Array.isArray(e) ? ((d = e[1]), (null === d || tl(e, d) > 0) && (l = !0)) : (d = e), r))
								if (0 !== c) {
									const h = Sh(t[a + 1])
									;(t[i + 1] = Y1(h, a)),
										0 !== h && (t[h + 1] = PB(t[h + 1], i)),
										(t[a + 1] = (function rre(t, n) {
											return (131071 & t) | (n << 17)
										})(t[a + 1], i))
								} else (t[i + 1] = Y1(a, 0)), 0 !== a && (t[a + 1] = PB(t[a + 1], i)), (a = i)
							else (t[i + 1] = Y1(c, 0)), 0 === a ? (a = i) : (t[c + 1] = PB(t[c + 1], i)), (c = i)
							l && (t[i + 1] = RB(t[i + 1])),
								JH(t, d, i, !0),
								JH(t, d, i, !1),
								(function are(t, n, e, i, r) {
									const o = r ? t.residualClasses : t.residualStyles
									null != o && "string" == typeof n && tl(o, n) >= 0 && (e[i + 1] = OB(e[i + 1]))
								})(n, d, t, i, o),
								(s = Y1(a, c)),
								o ? (n.classBindings = s) : (n.styleBindings = s)
						})(r, o, n, e, s, i)
				}
			}
			function NB(t, n, e, i, r) {
				let o = null
				const s = e.directiveEnd
				let a = e.directiveStylingLast
				for (-1 === a ? (a = e.directiveStart) : a++; a < s && ((o = n[a]), (i = l0(i, o.hostAttrs, r)), o !== t); ) a++
				return null !== t && (e.directiveStylingLast = a), i
			}
			function l0(t, n, e) {
				const i = e ? 1 : 2
				let r = -1
				if (null !== n)
					for (let o = 0; o < n.length; o++) {
						const s = n[o]
						"number" == typeof s
							? (r = s)
							: r === i && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), Es(t, s, !!e || n[++o]))
					}
				return void 0 === t ? null : t
			}
			function c5(t, n, e) {
				Es(t, n, Eh(e))
			}
			function yre(t, n, e) {
				const i = String(n)
				"" !== i && !i.includes(" ") && Es(t, i, e)
			}
			function l5(t, n, e, i, r, o, s, a) {
				if (!(3 & n.type)) return
				const c = t.data,
					l = c[a + 1],
					d = (function ore(t) {
						return 1 == (1 & t)
					})(l)
						? d5(c, n, e, r, bm(l), s)
						: void 0
				q1(d) ||
					(q1(o) ||
						((function ire(t) {
							return 2 == (2 & t)
						})(l) &&
							(o = d5(c, null, e, r, a, s))),
					(function ote(t, n, e, i, r) {
						if (n) r ? t.addClass(e, i) : t.removeClass(e, i)
						else {
							let o = -1 === i.indexOf("-") ? void 0 : ls.DashCase
							null == r
								? t.removeStyle(e, i, o)
								: ("string" == typeof r && r.endsWith("!important") && ((r = r.slice(0, -10)), (o |= ls.Important)),
								  t.setStyle(e, i, r, o))
						}
					})(i, s, Jf(Cs(), e), r, o))
			}
			function d5(t, n, e, i, r, o) {
				const s = null === n
				let a
				for (; r > 0; ) {
					const c = t[r],
						l = Array.isArray(c),
						d = l ? c[1] : c,
						u = null === d
					let h = e[r + 1]
					h === di && (h = u ? oi : void 0)
					let f = u ? Xl(h, i) : d === i ? h : void 0
					if ((l && !q1(f) && (f = Xl(c, i)), q1(f) && ((a = f), s))) return a
					const _ = t[r + 1]
					r = s ? Sh(_) : bm(_)
				}
				if (null !== n) {
					let c = o ? n.residualClasses : n.residualStyles
					null != c && (a = Xl(c, i))
				}
				return a
			}
			function q1(t) {
				return void 0 !== t
			}
			function u5(t, n) {
				return 0 != (t.flags & (n ? 8 : 16))
			}
			function ge(t, n = "") {
				const e = bt(),
					i = Ui(),
					r = t + Ei,
					o = i.firstCreatePass ? VA(i, r, 1, n, null) : i.data[r],
					s = h5(i, e, o, n, t)
				;(e[r] = s), im() && x1(i, e, s, o), Sc(o, !1)
			}
			let h5 = (t, n, e, i, r) => (
				Gl(!0),
				(function _1(t, n) {
					return t.createText(n)
				})(n[ei], i)
			)
			function cr(t) {
				return Vt("", t, ""), cr
			}
			function Vt(t, n, e) {
				const i = bt(),
					r = zA(i, t, n, e)
				return r !== di && cu(i, Cs(), r), Vt
			}
			function JA(t, n, e, i, r) {
				const o = bt(),
					s = GA(o, t, n, e, i, r)
				return s !== di && cu(o, Cs(), s), JA
			}
			function du(t, n, e) {
				sl(Es, ed, zA(bt(), t, n, e), !0)
			}
			function td(t, n, e) {
				const i = bt()
				return Vs(i, mh(), n) && qa(Ui(), Gr(), i, t, n, i[ei], e, !0), td
			}
			const _m = void 0
			var zre = [
				"en",
				[["a", "p"], ["AM", "PM"], _m],
				[["AM", "PM"], _m, _m],
				[
					["S", "M", "T", "W", "T", "F", "S"],
					["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
					["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
					["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
				],
				_m,
				[
					["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
					["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
					[
						"January",
						"February",
						"March",
						"April",
						"May",
						"June",
						"July",
						"August",
						"September",
						"October",
						"November",
						"December"
					]
				],
				_m,
				[
					["B", "A"],
					["BC", "AD"],
					["Before Christ", "Anno Domini"]
				],
				0,
				[6, 0],
				["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"],
				["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"],
				["{1}, {0}", _m, "{1} 'at' {0}", _m],
				[".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"],
				["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"],
				"USD",
				"$",
				"US Dollar",
				{},
				"ltr",
				function Qre(t) {
					const e = Math.floor(Math.abs(t)),
						i = t.toString().replace(/^[^.]*\.?/, "").length
					return 1 === e && 0 === i ? 1 : 5
				}
			]
			let eg = {}
			function ia(t) {
				const n = (function Gre(t) {
					return t.toLowerCase().replace(/_/g, "-")
				})(t)
				let e = I5(n)
				if (e) return e
				const i = n.split("-")[0]
				if (((e = I5(i)), e)) return e
				if ("en" === i) return zre
				throw new ht(701, !1)
			}
			function I5(t) {
				return t in eg || (eg[t] = vr.ng && vr.ng.common && vr.ng.common.locales && vr.ng.common.locales[t]), eg[t]
			}
			var Pr = (function (t) {
				return (
					(t[(t.LocaleId = 0)] = "LocaleId"),
					(t[(t.DayPeriodsFormat = 1)] = "DayPeriodsFormat"),
					(t[(t.DayPeriodsStandalone = 2)] = "DayPeriodsStandalone"),
					(t[(t.DaysFormat = 3)] = "DaysFormat"),
					(t[(t.DaysStandalone = 4)] = "DaysStandalone"),
					(t[(t.MonthsFormat = 5)] = "MonthsFormat"),
					(t[(t.MonthsStandalone = 6)] = "MonthsStandalone"),
					(t[(t.Eras = 7)] = "Eras"),
					(t[(t.FirstDayOfWeek = 8)] = "FirstDayOfWeek"),
					(t[(t.WeekendRange = 9)] = "WeekendRange"),
					(t[(t.DateFormat = 10)] = "DateFormat"),
					(t[(t.TimeFormat = 11)] = "TimeFormat"),
					(t[(t.DateTimeFormat = 12)] = "DateTimeFormat"),
					(t[(t.NumberSymbols = 13)] = "NumberSymbols"),
					(t[(t.NumberFormats = 14)] = "NumberFormats"),
					(t[(t.CurrencyCode = 15)] = "CurrencyCode"),
					(t[(t.CurrencySymbol = 16)] = "CurrencySymbol"),
					(t[(t.CurrencyName = 17)] = "CurrencyName"),
					(t[(t.Currencies = 18)] = "Currencies"),
					(t[(t.Directionality = 19)] = "Directionality"),
					(t[(t.PluralCase = 20)] = "PluralCase"),
					(t[(t.ExtraData = 21)] = "ExtraData"),
					t
				)
			})(Pr || {})
			const tg = "en-US"
			let D5 = tg
			function VB(t, n, e, i, r) {
				if (((t = Tn(t)), Array.isArray(t))) for (let o = 0; o < t.length; o++) VB(t[o], n, e, i, r)
				else {
					const o = Ui(),
						s = bt(),
						a = Yo()
					let c = mm(t) ? t : Tn(t.provide)
					const l = v4(t),
						d = 1048575 & a.providerIndexes,
						u = a.directiveStart,
						h = a.providerIndexes >> 20
					if (mm(t) || !t.multi) {
						const f = new kc(l, r, P),
							_ = zB(c, n, r ? d : d + h, u)
						;-1 === _
							? (T_(_A(a, s), o, c),
							  QB(o, t, n.length),
							  n.push(c),
							  a.directiveStart++,
							  a.directiveEnd++,
							  r && (a.providerIndexes += 1048576),
							  e.push(f),
							  s.push(f))
							: ((e[_] = f), (s[_] = f))
					} else {
						const f = zB(c, n, d + h, u),
							_ = zB(c, n, d, d + h),
							C = _ >= 0 && e[_]
						if ((r && !C) || (!r && !(f >= 0 && e[f]))) {
							T_(_A(a, s), o, c)
							const x = (function Qoe(t, n, e, i, r) {
								const o = new kc(t, e, P)
								return (o.multi = []), (o.index = n), (o.componentProviders = 0), rV(o, r, i && !e), o
							})(r ? Voe : Hoe, e.length, r, i, l)
							!r && C && (e[_].providerFactory = x),
								QB(o, t, n.length, 0),
								n.push(c),
								a.directiveStart++,
								a.directiveEnd++,
								r && (a.providerIndexes += 1048576),
								e.push(x),
								s.push(x)
						} else QB(o, t, f > -1 ? f : _, rV(e[r ? _ : f], l, !r && i))
						!r && i && C && e[_].componentProviders++
					}
				}
			}
			function QB(t, n, e, i) {
				const r = mm(n),
					o = (function Rte(t) {
						return !!t.useClass
					})(n)
				if (r || o) {
					const c = (o ? Tn(n.useClass) : n).prototype.ngOnDestroy
					if (c) {
						const l = t.destroyHooks || (t.destroyHooks = [])
						if (!r && n.multi) {
							const d = l.indexOf(e)
							;-1 === d ? l.push(e, [i, c]) : l[d + 1].push(i, c)
						} else l.push(e, c)
					}
				}
			}
			function rV(t, n, e) {
				return e && t.componentProviders++, t.multi.push(n) - 1
			}
			function zB(t, n, e, i) {
				for (let r = e; r < i; r++) if (n[r] === t) return r
				return -1
			}
			function Hoe(t, n, e, i) {
				return GB(this.multi, [])
			}
			function Voe(t, n, e, i) {
				const r = this.multi
				let o
				if (this.providerFactory) {
					const s = this.providerFactory.componentProviders,
						a = Kl(e, e[Qt], this.providerFactory.index, i)
					;(o = a.slice(0, s)), GB(r, o)
					for (let c = s; c < a.length; c++) o.push(a[c])
				} else (o = []), GB(r, o)
				return o
			}
			function GB(t, n) {
				for (let e = 0; e < t.length; e++) n.push((0, t[e])())
				return n
			}
			function Xn(t, n = []) {
				return e => {
					e.providersResolver = (i, r) =>
						(function Uoe(t, n, e) {
							const i = Ui()
							if (i.firstCreatePass) {
								const r = Wa(t)
								VB(e, i.data, i.blueprint, r, !0), VB(n, i.data, i.blueprint, r, !1)
							}
						})(i, r ? r(t) : t, n)
				}
			}
			class vm {}
			class zoe {}
			class $B extends vm {
				constructor(n, e, i) {
					super(),
						(this._parent = e),
						(this._bootstrapComponents = []),
						(this.destroyCbs = []),
						(this.componentFactoryResolver = new bH(this))
					const r = (function Js(t, n) {
						const e = t[Xc] || null
						if (!e && !0 === n) throw new Error(`Type ${Lr(t)} does not have '\u0275mod' property.`)
						return e
					})(n)
					;(this._bootstrapComponents = (function au(t) {
						return t instanceof Function ? t() : t
					})(r.bootstrap)),
						(this._r3Injector = B4(
							n,
							e,
							[{ provide: vm, useValue: this }, { provide: RA, useValue: this.componentFactoryResolver }, ...i],
							Lr(n),
							new Set(["environment"])
						)),
						this._r3Injector.resolveInjectorInitializers(),
						(this.instance = this._r3Injector.get(n))
				}
				get injector() {
					return this._r3Injector
				}
				destroy() {
					const n = this._r3Injector
					!n.destroyed && n.destroy(), this.destroyCbs.forEach(e => e()), (this.destroyCbs = null)
				}
				onDestroy(n) {
					this.destroyCbs.push(n)
				}
			}
			class WB extends zoe {
				constructor(n) {
					super(), (this.moduleType = n)
				}
				create(n) {
					return new $B(this.moduleType, n, [])
				}
			}
			function kh(t, n, e) {
				const i = xs() + t,
					r = bt()
				return r[i] === di
					? Jl(r, i, e ? n.call(e) : n())
					: (function r0(t, n) {
							return t[n]
					  })(r, i)
			}
			function al(t, n, e, i, r) {
				return mV(bt(), xs(), t, n, e, i, r)
			}
			function p0(t, n) {
				const e = t[n]
				return e === di ? void 0 : e
			}
			function fV(t, n, e, i, r, o) {
				const s = n + e
				return Vs(t, s, r) ? Jl(t, s + 1, o ? i.call(o, r) : i(r)) : p0(t, s + 1)
			}
			function mV(t, n, e, i, r, o, s) {
				const a = n + e
				return gm(t, a, r, o) ? Jl(t, a + 2, s ? i.call(s, r, o) : i(r, o)) : p0(t, a + 2)
			}
			function AV(t, n, e, i, r, o, s, a, c) {
				const l = n + e
				return (function Ic(t, n, e, i, r, o) {
					const s = gm(t, n, e, i)
					return gm(t, n + 2, r, o) || s
				})(t, l, r, o, s, a)
					? Jl(t, l + 4, c ? i.call(c, r, o, s, a) : i(r, o, s, a))
					: p0(t, l + 4)
			}
			function Me(t, n) {
				const e = Ui()
				let i
				const r = t + Ei
				e.firstCreatePass
					? ((i = (function dse(t, n) {
							if (n)
								for (let e = n.length - 1; e >= 0; e--) {
									const i = n[e]
									if (t === i.name) return i
								}
					  })(n, e.pipeRegistry)),
					  (e.data[r] = i),
					  i.onDestroy && (e.destroyHooks ??= []).push(r, i.onDestroy))
					: (i = e.data[r])
				const o = i.factory || (i.factory = Kd(i.type)),
					a = Ns(P)
				try {
					const c = am(!1),
						l = o()
					return (
						am(c),
						(function Kie(t, n, e, i) {
							e >= t.data.length && ((t.data[e] = null), (t.blueprint[e] = null)), (n[e] = i)
						})(e, bt(), r, l),
						l
					)
				} finally {
					Ns(a)
				}
			}
			function De(t, n, e) {
				const i = t + Ei,
					r = bt(),
					o = zl(r, i)
				return A0(r, i) ? fV(r, xs(), n, o.transform, e, o) : o.transform(e)
			}
			function lo(t, n, e, i) {
				const r = t + Ei,
					o = bt(),
					s = zl(o, r)
				return A0(o, r) ? mV(o, xs(), n, s.transform, e, i, s) : s.transform(e, i)
			}
			function A0(t, n) {
				return t[Qt].data[n].pure
			}
			function fse() {
				return this._results[Symbol.iterator]()
			}
			class ym {
				get changes() {
					return this._changes || (this._changes = new _n())
				}
				constructor(n = !1) {
					;(this._emitDistinctChangesOnly = n),
						(this.dirty = !0),
						(this._results = []),
						(this._changesDetected = !1),
						(this._changes = null),
						(this.length = 0),
						(this.first = void 0),
						(this.last = void 0)
					const e = ym.prototype
					e[Symbol.iterator] || (e[Symbol.iterator] = fse)
				}
				get(n) {
					return this._results[n]
				}
				map(n) {
					return this._results.map(n)
				}
				filter(n) {
					return this._results.filter(n)
				}
				find(n) {
					return this._results.find(n)
				}
				reduce(n, e) {
					return this._results.reduce(n, e)
				}
				forEach(n) {
					this._results.forEach(n)
				}
				some(n) {
					return this._results.some(n)
				}
				toArray() {
					return this._results.slice()
				}
				toString() {
					return this._results.toString()
				}
				reset(n, e) {
					const i = this
					i.dirty = !1
					const r = (function Sa(t) {
						return t.flat(Number.POSITIVE_INFINITY)
					})(n)
					;(this._changesDetected = !(function h1(t, n, e) {
						if (t.length !== n.length) return !1
						for (let i = 0; i < t.length; i++) {
							let r = t[i],
								o = n[i]
							if ((e && ((r = e(r)), (o = e(o))), o !== r)) return !1
						}
						return !0
					})(i._results, r, e)) && ((i._results = r), (i.length = r.length), (i.last = r[this.length - 1]), (i.first = r[0]))
				}
				notifyOnChanges() {
					this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this)
				}
				setDirty() {
					this.dirty = !0
				}
				destroy() {
					this.changes.complete(), this.changes.unsubscribe()
				}
			}
			function pse(t, n, e, i = !0) {
				const r = n[Qt]
				if (
					((function qee(t, n, e, i) {
						const r = Ko + i,
							o = e.length
						i > 0 && (e[r - 1][$a] = n),
							i < o - Ko ? ((n[$a] = e[r]), f1(e, Ko + i, n)) : (e.push(n), (n[$a] = null)),
							(n[pr] = e)
						const s = n[Gf]
						null !== s &&
							e !== s &&
							(function Zee(t, n) {
								const e = t[qc]
								n[so] !== n[pr][pr][so] && (t[yx] = !0), null === e ? (t[qc] = [n]) : e.push(n)
							})(s, n)
						const a = n[xc]
						null !== a && a.insertView(t), (n[si] |= 128)
					})(r, n, t, e),
					i)
				) {
					const o = PF(e, t),
						s = n[ei],
						a = w1(s, t[Cc])
					null !== a &&
						(function Kee(t, n, e, i, r, o) {
							;(i[qr] = r), (i[as] = n), z_(t, i, e, 1, r, o)
						})(r, t[as], s, n, a, o)
				}
			}
			let Za = (() => {
				class t {
					static {
						this.__NG_ELEMENT_ID__ = bse
					}
				}
				return t
			})()
			const Ase = Za,
				gse = class extends Ase {
					constructor(n, e, i) {
						super(), (this._declarationLView = n), (this._declarationTContainer = e), (this.elementRef = i)
					}
					get ssrId() {
						return this._declarationTContainer.tView?.ssrId || null
					}
					createEmbeddedView(n, e) {
						return this.createEmbeddedViewImpl(n, e)
					}
					createEmbeddedViewImpl(n, e, i) {
						const r = (function mse(t, n, e, i) {
							const r = n.tView,
								a = U1(
									t,
									r,
									e,
									4096 & t[si] ? 4096 : 16,
									null,
									n,
									null,
									null,
									null,
									i?.injector ?? null,
									i?.hydrationInfo ?? null
								)
							a[Gf] = t[n.index]
							const l = t[xc]
							return null !== l && (a[xc] = l.createEmbeddedView(r)), SB(r, a, e), a
						})(this._declarationLView, this._declarationTContainer, n, { injector: e, hydrationInfo: i })
						return new t0(r)
					}
				}
			function bse() {
				return nC(Yo(), bt())
			}
			function nC(t, n) {
				return 4 & t.type ? new gse(n, t, PA(t, n)) : null
			}
			let ra = (() => {
				class t {
					static {
						this.__NG_ELEMENT_ID__ = Cse
					}
				}
				return t
			})()
			function Cse() {
				return EV(Yo(), bt())
			}
			const Ese = ra,
				xV = class extends Ese {
					constructor(n, e, i) {
						super(), (this._lContainer = n), (this._hostTNode = e), (this._hostLView = i)
					}
					get element() {
						return PA(this._hostTNode, this._hostLView)
					}
					get injector() {
						return new qo(this._hostTNode, this._hostLView)
					}
					get parentInjector() {
						const n = vA(this._hostTNode, this._hostLView)
						if (bA(n)) {
							const e = eu(n, this._hostLView),
								i = gh(n)
							return new qo(e[Qt].data[i + 8], e)
						}
						return new qo(null, this._hostLView)
					}
					clear() {
						for (; this.length > 0; ) this.remove(this.length - 1)
					}
					get(n) {
						const e = CV(this._lContainer)
						return (null !== e && e[n]) || null
					}
					get length() {
						return this._lContainer.length - Ko
					}
					createEmbeddedView(n, e, i) {
						let r, o
						"number" == typeof i ? (r = i) : null != i && ((r = i.index), (o = i.injector))
						const a = n.createEmbeddedViewImpl(e || {}, o, null)
						return this.insertImpl(a, r, false), a
					}
					createComponent(n, e, i, r, o) {
						const s =
							n &&
							!(function um(t) {
								return "function" == typeof t
							})(n)
						let a
						if (s) a = e
						else {
							const y = e || {}
							;(a = y.index), (i = y.injector), (r = y.projectableNodes), (o = y.environmentInjector || y.ngModuleRef)
						}
						const c = s ? n : new n0(Ni(n)),
							l = i || this.parentInjector
						if (!o && null == c.ngModule) {
							const C = (s ? l : this.parentInjector).get(Yl, null)
							C && (o = C)
						}
						Ni(c.componentType ?? {})
						const f = c.create(l, r, null, o)
						return this.insertImpl(f.hostView, a, false), f
					}
					insert(n, e) {
						return this.insertImpl(n, e, !1)
					}
					insertImpl(n, e, i) {
						const r = n._lView
						if (
							(function Ca(t) {
								return ys(t[pr])
							})(r)
						) {
							const c = this.indexOf(n)
							if (-1 !== c) this.detach(c)
							else {
								const l = r[pr],
									d = new xV(l, l[as], l[pr])
								d.detach(d.indexOf(n))
							}
						}
						const s = this._adjustIndex(e),
							a = this._lContainer
						return pse(a, r, s, !i), n.attachToViewContainerRef(), f1(KB(a), s, n), n
					}
					move(n, e) {
						return this.insert(n, e)
					}
					indexOf(n) {
						const e = CV(this._lContainer)
						return null !== e ? e.indexOf(n) : -1
					}
					remove(n) {
						const e = this._adjustIndex(n, -1),
							i = y1(this._lContainer, e)
						i && (iu(KB(this._lContainer), e), IF(i[Qt], i))
					}
					detach(n) {
						const e = this._adjustIndex(n, -1),
							i = y1(this._lContainer, e)
						return i && null != iu(KB(this._lContainer), e) ? new t0(i) : null
					}
					_adjustIndex(n, e = 0) {
						return n ?? this.length + e
					}
				}
			function CV(t) {
				return t[8]
			}
			function KB(t) {
				return t[8] || (t[8] = [])
			}
			function EV(t, n) {
				let e
				const i = n[t.index]
				return ys(i) ? (e = i) : ((e = sH(i, n, null, t)), (n[t.index] = e), H1(n, e)), MV(e, n, t, i), new xV(e, t, n)
			}
			let MV = function SV(t, n, e, i) {
				if (t[Cc]) return
				let r
				;(r =
					8 & e.type
						? ar(i)
						: (function Mse(t, n) {
								const e = t[ei],
									i = e.createComment(""),
									r = ws(n, t)
								return (
									hm(
										e,
										w1(e, r),
										i,
										(function nte(t, n) {
											return t.nextSibling(n)
										})(e, r),
										!1
									),
									i
								)
						  })(n, e)),
					(t[Cc] = r)
			}
			class XB {
				constructor(n) {
					;(this.queryList = n), (this.matches = null)
				}
				clone() {
					return new XB(this.queryList)
				}
				setDirty() {
					this.queryList.setDirty()
				}
			}
			class YB {
				constructor(n = []) {
					this.queries = n
				}
				createEmbeddedView(n) {
					const e = n.queries
					if (null !== e) {
						const i = null !== n.contentQueries ? n.contentQueries[0] : e.length,
							r = []
						for (let o = 0; o < i; o++) {
							const s = e.getByIndex(o)
							r.push(this.queries[s.indexInDeclarationView].clone())
						}
						return new YB(r)
					}
					return null
				}
				insertView(n) {
					this.dirtyQueriesWithMatches(n)
				}
				detachView(n) {
					this.dirtyQueriesWithMatches(n)
				}
				dirtyQueriesWithMatches(n) {
					for (let e = 0; e < this.queries.length; e++) null !== IV(n, e).matches && this.queries[e].setDirty()
				}
			}
			class kV {
				constructor(n, e, i = null) {
					;(this.predicate = n), (this.flags = e), (this.read = i)
				}
			}
			class qB {
				constructor(n = []) {
					this.queries = n
				}
				elementStart(n, e) {
					for (let i = 0; i < this.queries.length; i++) this.queries[i].elementStart(n, e)
				}
				elementEnd(n) {
					for (let e = 0; e < this.queries.length; e++) this.queries[e].elementEnd(n)
				}
				embeddedTView(n) {
					let e = null
					for (let i = 0; i < this.length; i++) {
						const r = null !== e ? e.length : 0,
							o = this.getByIndex(i).embeddedTView(n, r)
						o && ((o.indexInDeclarationView = i), null !== e ? e.push(o) : (e = [o]))
					}
					return null !== e ? new qB(e) : null
				}
				template(n, e) {
					for (let i = 0; i < this.queries.length; i++) this.queries[i].template(n, e)
				}
				getByIndex(n) {
					return this.queries[n]
				}
				get length() {
					return this.queries.length
				}
				track(n) {
					this.queries.push(n)
				}
			}
			class ZB {
				constructor(n, e = -1) {
					;(this.metadata = n),
						(this.matches = null),
						(this.indexInDeclarationView = -1),
						(this.crossesNgTemplate = !1),
						(this._appliesToNextNode = !0),
						(this._declarationNodeIndex = e)
				}
				elementStart(n, e) {
					this.isApplyingToNode(e) && this.matchTNode(n, e)
				}
				elementEnd(n) {
					this._declarationNodeIndex === n.index && (this._appliesToNextNode = !1)
				}
				template(n, e) {
					this.elementStart(n, e)
				}
				embeddedTView(n, e) {
					return this.isApplyingToNode(n)
						? ((this.crossesNgTemplate = !0), this.addMatch(-n.index, e), new ZB(this.metadata))
						: null
				}
				isApplyingToNode(n) {
					if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
						const e = this._declarationNodeIndex
						let i = n.parent
						for (; null !== i && 8 & i.type && i.index !== e; ) i = i.parent
						return e === (null !== i ? i.index : -1)
					}
					return this._appliesToNextNode
				}
				matchTNode(n, e) {
					const i = this.metadata.predicate
					if (Array.isArray(i))
						for (let r = 0; r < i.length; r++) {
							const o = i[r]
							this.matchTNodeWithReadOption(n, e, Tse(e, o)), this.matchTNodeWithReadOption(n, e, xA(e, n, o, !1, !1))
						}
					else
						i === Za
							? 4 & e.type && this.matchTNodeWithReadOption(n, e, -1)
							: this.matchTNodeWithReadOption(n, e, xA(e, n, i, !1, !1))
				}
				matchTNodeWithReadOption(n, e, i) {
					if (null !== i) {
						const r = this.metadata.read
						if (null !== r)
							if (r === wn || r === ra || (r === Za && 4 & e.type)) this.addMatch(e.index, -2)
							else {
								const o = xA(e, n, r, !1, !1)
								null !== o && this.addMatch(e.index, o)
							}
						else this.addMatch(e.index, i)
					}
				}
				addMatch(n, e) {
					null === this.matches ? (this.matches = [n, e]) : this.matches.push(n, e)
				}
			}
			function Tse(t, n) {
				const e = t.localNames
				if (null !== e) for (let i = 0; i < e.length; i += 2) if (e[i] === n) return e[i + 1]
				return null
			}
			function Bse(t, n, e, i) {
				return -1 === e
					? (function Fse(t, n) {
							return 11 & t.type ? PA(t, n) : 4 & t.type ? nC(t, n) : null
					  })(n, t)
					: -2 === e
					? (function Ise(t, n, e) {
							return e === wn ? PA(n, t) : e === Za ? nC(n, t) : e === ra ? EV(n, t) : void 0
					  })(t, n, i)
					: Kl(t, t[Qt], e, n)
			}
			function TV(t, n, e, i) {
				const r = n[xc].queries[i]
				if (null === r.matches) {
					const o = t.data,
						s = e.matches,
						a = []
					for (let c = 0; c < s.length; c += 2) {
						const l = s[c]
						a.push(l < 0 ? null : Bse(n, o[l], s[c + 1], e.metadata.read))
					}
					r.matches = a
				}
				return r.matches
			}
			function JB(t, n, e, i) {
				const r = t.queries.getByIndex(e),
					o = r.matches
				if (null !== o) {
					const s = TV(t, n, r, e)
					for (let a = 0; a < o.length; a += 2) {
						const c = o[a]
						if (c > 0) i.push(s[a / 2])
						else {
							const l = o[a + 1],
								d = n[-c]
							for (let u = Ko; u < d.length; u++) {
								const h = d[u]
								h[Gf] === h[pr] && JB(h[Qt], h, l, i)
							}
							if (null !== d[qc]) {
								const u = d[qc]
								for (let h = 0; h < u.length; h++) {
									const f = u[h]
									JB(f[Qt], f, l, i)
								}
							}
						}
					}
				}
				return i
			}
			function sn(t) {
				const n = bt(),
					e = Ui(),
					i = v_()
				y_(i + 1)
				const r = IV(e, i)
				if (
					t.dirty &&
					(function YT(t) {
						return 4 == (4 & t[si])
					})(n) ===
						(2 == (2 & r.metadata.flags))
				) {
					if (null === r.matches) t.reset([])
					else {
						const o = r.crossesNgTemplate ? JB(e, n, i, []) : TV(e, n, r, i)
						t.reset(o, nne), t.notifyOnChanges()
					}
					return !0
				}
				return !1
			}
			function _i(t, n, e) {
				const i = Ui()
				i.firstCreatePass && (BV(i, new kV(t, n, e), -1), 2 == (2 & n) && (i.staticViewQueries = !0)), FV(i, bt(), n)
			}
			function yr(t, n, e, i) {
				const r = Ui()
				if (r.firstCreatePass) {
					const o = Yo()
					BV(r, new kV(n, e, i), o.index),
						(function Lse(t, n) {
							const e = t.contentQueries || (t.contentQueries = [])
							n !== (e.length ? e[e.length - 1] : -1) && e.push(t.queries.length - 1, n)
						})(r, t),
						2 == (2 & e) && (r.staticContentQueries = !0)
				}
				FV(r, bt(), e)
			}
			function an() {
				return (function Dse(t, n) {
					return t[xc].queries[n].queryList
				})(bt(), v_())
			}
			function FV(t, n, e) {
				const i = new ym(4 == (4 & e))
				;(function Lne(t, n, e, i) {
					const r = cH(n)
					r.push(e), t.firstCreatePass && lH(t).push(i, r.length - 1)
				})(t, n, i, i.destroy),
					null === n[xc] && (n[xc] = new YB()),
					n[xc].queries.push(new XB(i))
			}
			function BV(t, n, e) {
				null === t.queries && (t.queries = new qB()), t.queries.track(new ZB(n, e))
			}
			function IV(t, n) {
				return t.queries.getByIndex(n)
			}
			function oa(t, n) {
				return nC(t, n)
			}
			const YV = new He("Application Initializer")
			let o2 = (() => {
				class t {
					constructor() {
						;(this.initialized = !1),
							(this.done = !1),
							(this.donePromise = new Promise((e, i) => {
								;(this.resolve = e), (this.reject = i)
							})),
							(this.appInits = Rt(YV, { optional: !0 }) ?? [])
					}
					runInitializers() {
						if (this.initialized) return
						const e = []
						for (const r of this.appInits) {
							const o = r()
							if (X1(o)) e.push(o)
							else if (HH(o)) {
								const s = new Promise((a, c) => {
									o.subscribe({ complete: a, error: c })
								})
								e.push(s)
							}
						}
						const i = () => {
							;(this.done = !0), this.resolve()
						}
						Promise.all(e)
							.then(() => {
								i()
							})
							.catch(r => {
								this.reject(r)
							}),
							0 === e.length && i(),
							(this.initialized = !0)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			const nd = new He("LocaleId", {
				providedIn: "root",
				factory: () =>
					Rt(nd, Di.Optional | Di.SkipSelf) ||
					(function nae() {
						return (typeof $localize < "u" && $localize.locale) || tg
					})()
			})
			let s2 = (() => {
				class t {
					constructor() {
						;(this.taskId = 0), (this.pendingTasks = new Set()), (this.hasPendingTasks = new zr(!1))
					}
					add() {
						this.hasPendingTasks.next(!0)
						const e = this.taskId++
						return this.pendingTasks.add(e), e
					}
					remove(e) {
						this.pendingTasks.delete(e), 0 === this.pendingTasks.size && this.hasPendingTasks.next(!1)
					}
					ngOnDestroy() {
						this.pendingTasks.clear(), this.hasPendingTasks.next(!1)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			const eQ = new He(""),
				sC = new He("")
			let u2,
				l2 = (() => {
					class t {
						constructor(e, i, r) {
							;(this._ngZone = e),
								(this.registry = i),
								(this._pendingCount = 0),
								(this._isZoneStable = !0),
								(this._didWork = !1),
								(this._callbacks = []),
								(this.taskTrackingZone = null),
								u2 ||
									((function Sae(t) {
										u2 = t
									})(r),
									r.addToWindow(i)),
								this._watchAngularEvents(),
								e.run(() => {
									this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone")
								})
						}
						_watchAngularEvents() {
							this._ngZone.onUnstable.subscribe({
								next: () => {
									;(this._didWork = !0), (this._isZoneStable = !1)
								}
							}),
								this._ngZone.runOutsideAngular(() => {
									this._ngZone.onStable.subscribe({
										next: () => {
											mn.assertNotInAngularZone(),
												queueMicrotask(() => {
													;(this._isZoneStable = !0), this._runCallbacksIfReady()
												})
										}
									})
								})
						}
						increasePendingRequestCount() {
							return (this._pendingCount += 1), (this._didWork = !0), this._pendingCount
						}
						decreasePendingRequestCount() {
							if (((this._pendingCount -= 1), this._pendingCount < 0)) throw new Error("pending async requests below zero")
							return this._runCallbacksIfReady(), this._pendingCount
						}
						isStable() {
							return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks
						}
						_runCallbacksIfReady() {
							if (this.isStable())
								queueMicrotask(() => {
									for (; 0 !== this._callbacks.length; ) {
										let e = this._callbacks.pop()
										clearTimeout(e.timeoutId), e.doneCb(this._didWork)
									}
									this._didWork = !1
								})
							else {
								let e = this.getPendingTasks()
								;(this._callbacks = this._callbacks.filter(
									i => !i.updateCb || !i.updateCb(e) || (clearTimeout(i.timeoutId), !1)
								)),
									(this._didWork = !0)
							}
						}
						getPendingTasks() {
							return this.taskTrackingZone
								? this.taskTrackingZone.macroTasks.map(e => ({
										source: e.source,
										creationLocation: e.creationLocation,
										data: e.data
								  }))
								: []
						}
						addCallback(e, i, r) {
							let o = -1
							i &&
								i > 0 &&
								(o = setTimeout(() => {
									;(this._callbacks = this._callbacks.filter(s => s.timeoutId !== o)),
										e(this._didWork, this.getPendingTasks())
								}, i)),
								this._callbacks.push({ doneCb: e, timeoutId: o, updateCb: r })
						}
						whenStable(e, i, r) {
							if (r && !this.taskTrackingZone)
								throw new Error(
									'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'
								)
							this.addCallback(e, i, r), this._runCallbacksIfReady()
						}
						getPendingRequestCount() {
							return this._pendingCount
						}
						registerApplication(e) {
							this.registry.registerApplication(e, this)
						}
						unregisterApplication(e) {
							this.registry.unregisterApplication(e)
						}
						findProviders(e, i, r) {
							return []
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(mn), re(d2), re(sC))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				d2 = (() => {
					class t {
						constructor() {
							this._applications = new Map()
						}
						registerApplication(e, i) {
							this._applications.set(e, i)
						}
						unregisterApplication(e) {
							this._applications.delete(e)
						}
						unregisterAllApplications() {
							this._applications.clear()
						}
						getTestability(e) {
							return this._applications.get(e) || null
						}
						getAllTestabilities() {
							return Array.from(this._applications.values())
						}
						getAllRootElements() {
							return Array.from(this._applications.keys())
						}
						findTestabilityInTree(e, i = !0) {
							return u2?.findTestabilityInTree(this, e, i) ?? null
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "platform" })
						}
					}
					return t
				})(),
				Th = null
			const tQ = new He("AllowMultipleToken"),
				h2 = new He("PlatformDestroyListeners"),
				nQ = new He("appBootstrapListener")
			function oQ(t, n, e = []) {
				const i = `Platform: ${n}`,
					r = new He(i)
				return (o = []) => {
					let s = f2()
					if (!s || s.injector.get(tQ, !1)) {
						const a = [...e, ...o, { provide: r, useValue: !0 }]
						t
							? t(a)
							: (function Fae(t) {
									if (Th && !Th.get(tQ, !1)) throw new ht(400, !1)
									;(function iQ() {
										!(function h_(t) {
											Tx = t
										})(() => {
											throw new ht(600, !1)
										})
									})(),
										(Th = t)
									const n = t.get(aQ)
									;(function rQ(t) {
										t.get(y4, null)?.forEach(e => e())
									})(t)
							  })(
									(function sQ(t = [], n) {
										return ks.create({
											name: n,
											providers: [
												{ provide: YF, useValue: "platform" },
												{ provide: h2, useValue: new Set([() => (Th = null)]) },
												...t
											]
										})
									})(a, i)
							  )
					}
					return (function Iae(t) {
						const n = f2()
						if (!n) throw new ht(401, !1)
						return n
					})()
				}
			}
			function f2() {
				return Th?.get(aQ) ?? null
			}
			let aQ = (() => {
				class t {
					constructor(e) {
						;(this._injector = e), (this._modules = []), (this._destroyListeners = []), (this._destroyed = !1)
					}
					bootstrapModuleFactory(e, i) {
						const r = (function Dae(t = "zone.js", n) {
							return "noop" === t ? new bne() : "zone.js" === t ? new mn(n) : t
						})(
							i?.ngZone,
							(function cQ(t) {
								return {
									enableLongStackTrace: !1,
									shouldCoalesceEventChangeDetection: t?.eventCoalescing ?? !1,
									shouldCoalesceRunChangeDetection: t?.runCoalescing ?? !1
								}
							})({ eventCoalescing: i?.ngZoneEventCoalescing, runCoalescing: i?.ngZoneRunCoalescing })
						)
						return r.run(() => {
							const o = (function $oe(t, n, e) {
									return new $B(t, n, e)
								})(
									e.moduleType,
									this.injector,
									(function fQ(t) {
										return [
											{ provide: mn, useFactory: t },
											{
												provide: FA,
												multi: !0,
												useFactory: () => {
													const n = Rt(Rae, { optional: !0 })
													return () => n.initialize()
												}
											},
											{ provide: hQ, useFactory: Lae },
											{ provide: P4, useFactory: O4 }
										]
									})(() => r)
								),
								s = o.injector.get(ql, null)
							return (
								r.runOutsideAngular(() => {
									const a = r.onError.subscribe({
										next: c => {
											s.handleError(c)
										}
									})
									o.onDestroy(() => {
										aC(this._modules, o), a.unsubscribe()
									})
								}),
								(function lQ(t, n, e) {
									try {
										const i = e()
										return X1(i)
											? i.catch(r => {
													throw (n.runOutsideAngular(() => t.handleError(r)), r)
											  })
											: i
									} catch (i) {
										throw (n.runOutsideAngular(() => t.handleError(i)), i)
									}
								})(s, r, () => {
									const a = o.injector.get(o2)
									return (
										a.runInitializers(),
										a.donePromise.then(
											() => (
												(function L5(t) {
													mr(t, "Expected localeId to be defined"),
														"string" == typeof t && (D5 = t.toLowerCase().replace(/_/g, "-"))
												})(o.injector.get(nd, tg) || tg),
												this._moduleDoBootstrap(o),
												o
											)
										)
									)
								})
							)
						})
					}
					bootstrapModule(e, i = []) {
						const r = dQ({}, i)
						return (function kae(t, n, e) {
							const i = new WB(e)
							return Promise.resolve(i)
						})(0, 0, e).then(o => this.bootstrapModuleFactory(o, r))
					}
					_moduleDoBootstrap(e) {
						const i = e.injector.get(wm)
						if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(r => i.bootstrap(r))
						else {
							if (!e.instance.ngDoBootstrap) throw new ht(-403, !1)
							e.instance.ngDoBootstrap(i)
						}
						this._modules.push(e)
					}
					onDestroy(e) {
						this._destroyListeners.push(e)
					}
					get injector() {
						return this._injector
					}
					destroy() {
						if (this._destroyed) throw new ht(404, !1)
						this._modules.slice().forEach(i => i.destroy()), this._destroyListeners.forEach(i => i())
						const e = this._injector.get(h2, null)
						e && (e.forEach(i => i()), e.clear()), (this._destroyed = !0)
					}
					get destroyed() {
						return this._destroyed
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(ks))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "platform" })
					}
				}
				return t
			})()
			function dQ(t, n) {
				return Array.isArray(n) ? n.reduce(dQ, t) : { ...t, ...n }
			}
			let wm = (() => {
				class t {
					constructor() {
						;(this._bootstrapListeners = []),
							(this._runningTick = !1),
							(this._destroyed = !1),
							(this._destroyListeners = []),
							(this._views = []),
							(this.internalErrorHandler = Rt(hQ)),
							(this.zoneIsStable = Rt(P4)),
							(this.componentTypes = []),
							(this.components = []),
							(this.isStable = Rt(s2).hasPendingTasks.pipe(
								ya(e => (e ? Wo(!1) : this.zoneIsStable)),
								Ys(),
								Rl()
							)),
							(this._injector = Rt(Yl))
					}
					get destroyed() {
						return this._destroyed
					}
					get injector() {
						return this._injector
					}
					bootstrap(e, i) {
						const r = e instanceof E4
						if (!this._injector.get(o2).done)
							throw (
								(!r &&
									(function Hf(t) {
										const n = Ni(t) || jo(t) || vs(t)
										return null !== n && n.standalone
									})(e),
								new ht(405, !1))
							)
						let s
						;(s = r ? e : this._injector.get(RA).resolveComponentFactory(e)), this.componentTypes.push(s.componentType)
						const a = (function Tae(t) {
								return t.isBoundToModule
							})(s)
								? void 0
								: this._injector.get(vm),
							l = s.create(ks.NULL, [], i || s.selector, a),
							d = l.location.nativeElement,
							u = l.injector.get(eQ, null)
						return (
							u?.registerApplication(d),
							l.onDestroy(() => {
								this.detachView(l.hostView), aC(this.components, l), u?.unregisterApplication(d)
							}),
							this._loadComponent(l),
							l
						)
					}
					tick() {
						if (this._runningTick) throw new ht(101, !1)
						try {
							this._runningTick = !0
							for (let e of this._views) e.detectChanges()
						} catch (e) {
							this.internalErrorHandler(e)
						} finally {
							this._runningTick = !1
						}
					}
					attachView(e) {
						const i = e
						this._views.push(i), i.attachToAppRef(this)
					}
					detachView(e) {
						const i = e
						aC(this._views, i), i.detachFromAppRef()
					}
					_loadComponent(e) {
						this.attachView(e.hostView), this.tick(), this.components.push(e)
						const i = this._injector.get(nQ, [])
						i.push(...this._bootstrapListeners), i.forEach(r => r(e))
					}
					ngOnDestroy() {
						if (!this._destroyed)
							try {
								this._destroyListeners.forEach(e => e()), this._views.slice().forEach(e => e.destroy())
							} finally {
								;(this._destroyed = !0), (this._views = []), (this._bootstrapListeners = []), (this._destroyListeners = [])
							}
					}
					onDestroy(e) {
						return this._destroyListeners.push(e), () => aC(this._destroyListeners, e)
					}
					destroy() {
						if (this._destroyed) throw new ht(406, !1)
						const e = this._injector
						e.destroy && !e.destroyed && e.destroy()
					}
					get viewCount() {
						return this._views.length
					}
					warnIfDestroyed() {}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			function aC(t, n) {
				const e = t.indexOf(n)
				e > -1 && t.splice(e, 1)
			}
			const hQ = new He("", { providedIn: "root", factory: () => Rt(ql).handleError.bind(void 0) })
			function Lae() {
				const t = Rt(mn),
					n = Rt(ql)
				return e => t.runOutsideAngular(() => n.handleError(e))
			}
			let Rae = (() => {
				class t {
					constructor() {
						;(this.zone = Rt(mn)), (this.applicationRef = Rt(wm))
					}
					initialize() {
						this._onMicrotaskEmptySubscription ||
							(this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
								next: () => {
									this.zone.run(() => {
										this.applicationRef.tick()
									})
								}
							}))
					}
					ngOnDestroy() {
						this._onMicrotaskEmptySubscription?.unsubscribe()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			let Jr = (() => {
				class t {
					static {
						this.__NG_ELEMENT_ID__ = Oae
					}
				}
				return t
			})()
			function Oae(t) {
				return (function Nae(t, n, e) {
					if (Ec(t) && !e) {
						const i = ea(t.index, n)
						return new t0(i, i)
					}
					return 47 & t.type ? new t0(n[so], n) : null
				})(Yo(), bt(), 16 == (16 & t))
			}
			class gQ {
				constructor() {}
				supports(n) {
					return G1(n)
				}
				create(n) {
					return new Gae(n)
				}
			}
			const zae = (t, n) => n
			class Gae {
				constructor(n) {
					;(this.length = 0),
						(this._linkedRecords = null),
						(this._unlinkedRecords = null),
						(this._previousItHead = null),
						(this._itHead = null),
						(this._itTail = null),
						(this._additionsHead = null),
						(this._additionsTail = null),
						(this._movesHead = null),
						(this._movesTail = null),
						(this._removalsHead = null),
						(this._removalsTail = null),
						(this._identityChangesHead = null),
						(this._identityChangesTail = null),
						(this._trackByFn = n || zae)
				}
				forEachItem(n) {
					let e
					for (e = this._itHead; null !== e; e = e._next) n(e)
				}
				forEachOperation(n) {
					let e = this._itHead,
						i = this._removalsHead,
						r = 0,
						o = null
					for (; e || i; ) {
						const s = !i || (e && e.currentIndex < _Q(i, r, o)) ? e : i,
							a = _Q(s, r, o),
							c = s.currentIndex
						if (s === i) r--, (i = i._nextRemoved)
						else if (((e = e._next), null == s.previousIndex)) r++
						else {
							o || (o = [])
							const l = a - r,
								d = c - r
							if (l != d) {
								for (let h = 0; h < l; h++) {
									const f = h < o.length ? o[h] : (o[h] = 0),
										_ = f + h
									d <= _ && _ < l && (o[h] = f + 1)
								}
								o[s.previousIndex] = d - l
							}
						}
						a !== c && n(s, a, c)
					}
				}
				forEachPreviousItem(n) {
					let e
					for (e = this._previousItHead; null !== e; e = e._nextPrevious) n(e)
				}
				forEachAddedItem(n) {
					let e
					for (e = this._additionsHead; null !== e; e = e._nextAdded) n(e)
				}
				forEachMovedItem(n) {
					let e
					for (e = this._movesHead; null !== e; e = e._nextMoved) n(e)
				}
				forEachRemovedItem(n) {
					let e
					for (e = this._removalsHead; null !== e; e = e._nextRemoved) n(e)
				}
				forEachIdentityChange(n) {
					let e
					for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange) n(e)
				}
				diff(n) {
					if ((null == n && (n = []), !G1(n))) throw new ht(900, !1)
					return this.check(n) ? this : null
				}
				onDestroy() {}
				check(n) {
					this._reset()
					let r,
						o,
						s,
						e = this._itHead,
						i = !1
					if (Array.isArray(n)) {
						this.length = n.length
						for (let a = 0; a < this.length; a++)
							(o = n[a]),
								(s = this._trackByFn(a, o)),
								null !== e && Object.is(e.trackById, s)
									? (i && (e = this._verifyReinsertion(e, o, s, a)),
									  Object.is(e.item, o) || this._addIdentityChange(e, o))
									: ((e = this._mismatch(e, o, s, a)), (i = !0)),
								(e = e._next)
					} else
						(r = 0),
							(function Sie(t, n) {
								if (Array.isArray(t)) for (let e = 0; e < t.length; e++) n(t[e])
								else {
									const e = t[Symbol.iterator]()
									let i
									for (; !(i = e.next()).done; ) n(i.value)
								}
							})(n, a => {
								;(s = this._trackByFn(r, a)),
									null !== e && Object.is(e.trackById, s)
										? (i && (e = this._verifyReinsertion(e, a, s, r)),
										  Object.is(e.item, a) || this._addIdentityChange(e, a))
										: ((e = this._mismatch(e, a, s, r)), (i = !0)),
									(e = e._next),
									r++
							}),
							(this.length = r)
					return this._truncate(e), (this.collection = n), this.isDirty
				}
				get isDirty() {
					return (
						null !== this._additionsHead ||
						null !== this._movesHead ||
						null !== this._removalsHead ||
						null !== this._identityChangesHead
					)
				}
				_reset() {
					if (this.isDirty) {
						let n
						for (n = this._previousItHead = this._itHead; null !== n; n = n._next) n._nextPrevious = n._next
						for (n = this._additionsHead; null !== n; n = n._nextAdded) n.previousIndex = n.currentIndex
						for (this._additionsHead = this._additionsTail = null, n = this._movesHead; null !== n; n = n._nextMoved)
							n.previousIndex = n.currentIndex
						;(this._movesHead = this._movesTail = null),
							(this._removalsHead = this._removalsTail = null),
							(this._identityChangesHead = this._identityChangesTail = null)
					}
				}
				_mismatch(n, e, i, r) {
					let o
					return (
						null === n ? (o = this._itTail) : ((o = n._prev), this._remove(n)),
						null !== (n = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null))
							? (Object.is(n.item, e) || this._addIdentityChange(n, e), this._reinsertAfter(n, o, r))
							: null !== (n = null === this._linkedRecords ? null : this._linkedRecords.get(i, r))
							? (Object.is(n.item, e) || this._addIdentityChange(n, e), this._moveAfter(n, o, r))
							: (n = this._addAfter(new $ae(e, i), o, r)),
						n
					)
				}
				_verifyReinsertion(n, e, i, r) {
					let o = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)
					return (
						null !== o
							? (n = this._reinsertAfter(o, n._prev, r))
							: n.currentIndex != r && ((n.currentIndex = r), this._addToMoves(n, r)),
						n
					)
				}
				_truncate(n) {
					for (; null !== n; ) {
						const e = n._next
						this._addToRemovals(this._unlink(n)), (n = e)
					}
					null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
						null !== this._additionsTail && (this._additionsTail._nextAdded = null),
						null !== this._movesTail && (this._movesTail._nextMoved = null),
						null !== this._itTail && (this._itTail._next = null),
						null !== this._removalsTail && (this._removalsTail._nextRemoved = null),
						null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null)
				}
				_reinsertAfter(n, e, i) {
					null !== this._unlinkedRecords && this._unlinkedRecords.remove(n)
					const r = n._prevRemoved,
						o = n._nextRemoved
					return (
						null === r ? (this._removalsHead = o) : (r._nextRemoved = o),
						null === o ? (this._removalsTail = r) : (o._prevRemoved = r),
						this._insertAfter(n, e, i),
						this._addToMoves(n, i),
						n
					)
				}
				_moveAfter(n, e, i) {
					return this._unlink(n), this._insertAfter(n, e, i), this._addToMoves(n, i), n
				}
				_addAfter(n, e, i) {
					return (
						this._insertAfter(n, e, i),
						(this._additionsTail =
							null === this._additionsTail ? (this._additionsHead = n) : (this._additionsTail._nextAdded = n)),
						n
					)
				}
				_insertAfter(n, e, i) {
					const r = null === e ? this._itHead : e._next
					return (
						(n._next = r),
						(n._prev = e),
						null === r ? (this._itTail = n) : (r._prev = n),
						null === e ? (this._itHead = n) : (e._next = n),
						null === this._linkedRecords && (this._linkedRecords = new bQ()),
						this._linkedRecords.put(n),
						(n.currentIndex = i),
						n
					)
				}
				_remove(n) {
					return this._addToRemovals(this._unlink(n))
				}
				_unlink(n) {
					null !== this._linkedRecords && this._linkedRecords.remove(n)
					const e = n._prev,
						i = n._next
					return null === e ? (this._itHead = i) : (e._next = i), null === i ? (this._itTail = e) : (i._prev = e), n
				}
				_addToMoves(n, e) {
					return (
						n.previousIndex === e ||
							(this._movesTail = null === this._movesTail ? (this._movesHead = n) : (this._movesTail._nextMoved = n)),
						n
					)
				}
				_addToRemovals(n) {
					return (
						null === this._unlinkedRecords && (this._unlinkedRecords = new bQ()),
						this._unlinkedRecords.put(n),
						(n.currentIndex = null),
						(n._nextRemoved = null),
						null === this._removalsTail
							? ((this._removalsTail = this._removalsHead = n), (n._prevRemoved = null))
							: ((n._prevRemoved = this._removalsTail), (this._removalsTail = this._removalsTail._nextRemoved = n)),
						n
					)
				}
				_addIdentityChange(n, e) {
					return (
						(n.item = e),
						(this._identityChangesTail =
							null === this._identityChangesTail
								? (this._identityChangesHead = n)
								: (this._identityChangesTail._nextIdentityChange = n)),
						n
					)
				}
			}
			class $ae {
				constructor(n, e) {
					;(this.item = n),
						(this.trackById = e),
						(this.currentIndex = null),
						(this.previousIndex = null),
						(this._nextPrevious = null),
						(this._prev = null),
						(this._next = null),
						(this._prevDup = null),
						(this._nextDup = null),
						(this._prevRemoved = null),
						(this._nextRemoved = null),
						(this._nextAdded = null),
						(this._nextMoved = null),
						(this._nextIdentityChange = null)
				}
			}
			class Wae {
				constructor() {
					;(this._head = null), (this._tail = null)
				}
				add(n) {
					null === this._head
						? ((this._head = this._tail = n), (n._nextDup = null), (n._prevDup = null))
						: ((this._tail._nextDup = n), (n._prevDup = this._tail), (n._nextDup = null), (this._tail = n))
				}
				get(n, e) {
					let i
					for (i = this._head; null !== i; i = i._nextDup)
						if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, n)) return i
					return null
				}
				remove(n) {
					const e = n._prevDup,
						i = n._nextDup
					return (
						null === e ? (this._head = i) : (e._nextDup = i),
						null === i ? (this._tail = e) : (i._prevDup = e),
						null === this._head
					)
				}
			}
			class bQ {
				constructor() {
					this.map = new Map()
				}
				put(n) {
					const e = n.trackById
					let i = this.map.get(e)
					i || ((i = new Wae()), this.map.set(e, i)), i.add(n)
				}
				get(n, e) {
					const r = this.map.get(n)
					return r ? r.get(n, e) : null
				}
				remove(n) {
					const e = n.trackById
					return this.map.get(e).remove(n) && this.map.delete(e), n
				}
				get isEmpty() {
					return 0 === this.map.size
				}
				clear() {
					this.map.clear()
				}
			}
			function _Q(t, n, e) {
				const i = t.previousIndex
				if (null === i) return i
				let r = 0
				return e && i < e.length && (r = e[i]), i + n + r
			}
			class vQ {
				constructor() {}
				supports(n) {
					return n instanceof Map || kB(n)
				}
				create() {
					return new jae()
				}
			}
			class jae {
				constructor() {
					;(this._records = new Map()),
						(this._mapHead = null),
						(this._appendAfter = null),
						(this._previousMapHead = null),
						(this._changesHead = null),
						(this._changesTail = null),
						(this._additionsHead = null),
						(this._additionsTail = null),
						(this._removalsHead = null),
						(this._removalsTail = null)
				}
				get isDirty() {
					return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead
				}
				forEachItem(n) {
					let e
					for (e = this._mapHead; null !== e; e = e._next) n(e)
				}
				forEachPreviousItem(n) {
					let e
					for (e = this._previousMapHead; null !== e; e = e._nextPrevious) n(e)
				}
				forEachChangedItem(n) {
					let e
					for (e = this._changesHead; null !== e; e = e._nextChanged) n(e)
				}
				forEachAddedItem(n) {
					let e
					for (e = this._additionsHead; null !== e; e = e._nextAdded) n(e)
				}
				forEachRemovedItem(n) {
					let e
					for (e = this._removalsHead; null !== e; e = e._nextRemoved) n(e)
				}
				diff(n) {
					if (n) {
						if (!(n instanceof Map || kB(n))) throw new ht(900, !1)
					} else n = new Map()
					return this.check(n) ? this : null
				}
				onDestroy() {}
				check(n) {
					this._reset()
					let e = this._mapHead
					if (
						((this._appendAfter = null),
						this._forEach(n, (i, r) => {
							if (e && e.key === r) this._maybeAddToChanges(e, i), (this._appendAfter = e), (e = e._next)
							else {
								const o = this._getOrCreateRecordForKey(r, i)
								e = this._insertBeforeOrAppend(e, o)
							}
						}),
						e)
					) {
						e._prev && (e._prev._next = null), (this._removalsHead = e)
						for (let i = e; null !== i; i = i._nextRemoved)
							i === this._mapHead && (this._mapHead = null),
								this._records.delete(i.key),
								(i._nextRemoved = i._next),
								(i.previousValue = i.currentValue),
								(i.currentValue = null),
								(i._prev = null),
								(i._next = null)
					}
					return (
						this._changesTail && (this._changesTail._nextChanged = null),
						this._additionsTail && (this._additionsTail._nextAdded = null),
						this.isDirty
					)
				}
				_insertBeforeOrAppend(n, e) {
					if (n) {
						const i = n._prev
						return (
							(e._next = n),
							(e._prev = i),
							(n._prev = e),
							i && (i._next = e),
							n === this._mapHead && (this._mapHead = e),
							(this._appendAfter = n),
							n
						)
					}
					return (
						this._appendAfter ? ((this._appendAfter._next = e), (e._prev = this._appendAfter)) : (this._mapHead = e),
						(this._appendAfter = e),
						null
					)
				}
				_getOrCreateRecordForKey(n, e) {
					if (this._records.has(n)) {
						const r = this._records.get(n)
						this._maybeAddToChanges(r, e)
						const o = r._prev,
							s = r._next
						return o && (o._next = s), s && (s._prev = o), (r._next = null), (r._prev = null), r
					}
					const i = new Kae(n)
					return this._records.set(n, i), (i.currentValue = e), this._addToAdditions(i), i
				}
				_reset() {
					if (this.isDirty) {
						let n
						for (this._previousMapHead = this._mapHead, n = this._previousMapHead; null !== n; n = n._next)
							n._nextPrevious = n._next
						for (n = this._changesHead; null !== n; n = n._nextChanged) n.previousValue = n.currentValue
						for (n = this._additionsHead; null != n; n = n._nextAdded) n.previousValue = n.currentValue
						;(this._changesHead = this._changesTail = null),
							(this._additionsHead = this._additionsTail = null),
							(this._removalsHead = null)
					}
				}
				_maybeAddToChanges(n, e) {
					Object.is(e, n.currentValue) || ((n.previousValue = n.currentValue), (n.currentValue = e), this._addToChanges(n))
				}
				_addToAdditions(n) {
					null === this._additionsHead
						? (this._additionsHead = this._additionsTail = n)
						: ((this._additionsTail._nextAdded = n), (this._additionsTail = n))
				}
				_addToChanges(n) {
					null === this._changesHead
						? (this._changesHead = this._changesTail = n)
						: ((this._changesTail._nextChanged = n), (this._changesTail = n))
				}
				_forEach(n, e) {
					n instanceof Map ? n.forEach(e) : Object.keys(n).forEach(i => e(n[i], i))
				}
			}
			class Kae {
				constructor(n) {
					;(this.key = n),
						(this.previousValue = null),
						(this.currentValue = null),
						(this._nextPrevious = null),
						(this._next = null),
						(this._prev = null),
						(this._nextAdded = null),
						(this._nextRemoved = null),
						(this._nextChanged = null)
				}
			}
			function yQ() {
				return new dC([new gQ()])
			}
			let dC = (() => {
				class t {
					static {
						this.ɵprov = mt({ token: t, providedIn: "root", factory: yQ })
					}
					constructor(e) {
						this.factories = e
					}
					static create(e, i) {
						if (null != i) {
							const r = i.factories.slice()
							e = e.concat(r)
						}
						return new t(e)
					}
					static extend(e) {
						return { provide: t, useFactory: i => t.create(e, i || yQ()), deps: [[t, new N_(), new O_()]] }
					}
					find(e) {
						const i = this.factories.find(r => r.supports(e))
						if (null != i) return i
						throw new ht(901, !1)
					}
				}
				return t
			})()
			function wQ() {
				return new _0([new vQ()])
			}
			let _0 = (() => {
				class t {
					static {
						this.ɵprov = mt({ token: t, providedIn: "root", factory: wQ })
					}
					constructor(e) {
						this.factories = e
					}
					static create(e, i) {
						if (i) {
							const r = i.factories.slice()
							e = e.concat(r)
						}
						return new t(e)
					}
					static extend(e) {
						return { provide: t, useFactory: i => t.create(e, i || wQ()), deps: [[t, new N_(), new O_()]] }
					}
					find(e) {
						const i = this.factories.find(r => r.supports(e))
						if (i) return i
						throw new ht(901, !1)
					}
				}
				return t
			})()
			const qae = oQ(null, "core", [])
			let Zae = (() => {
				class t {
					constructor(e) {}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(wm))
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({})
					}
				}
				return t
			})()
			function v2(t) {
				return "boolean" == typeof t ? t : null != t && "false" !== t
			}
			let y2 = null
			function Fh() {
				return y2
			}
			class uce {}
			const wi = new He("DocumentToken")
			let BQ = (() => {
					class t {
						historyGo(e) {
							throw new Error("Not implemented")
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵprov = mt({
								token: t,
								factory: function () {
									return Rt(hce)
								},
								providedIn: "platform"
							})
						}
					}
					return t
				})(),
				hce = (() => {
					class t extends BQ {
						constructor() {
							super(), (this._doc = Rt(wi)), (this._location = window.location), (this._history = window.history)
						}
						getBaseHrefFromDOM() {
							return Fh().getBaseHref(this._doc)
						}
						onPopState(e) {
							const i = Fh().getGlobalEventTarget(this._doc, "window")
							return i.addEventListener("popstate", e, !1), () => i.removeEventListener("popstate", e)
						}
						onHashChange(e) {
							const i = Fh().getGlobalEventTarget(this._doc, "window")
							return i.addEventListener("hashchange", e, !1), () => i.removeEventListener("hashchange", e)
						}
						get href() {
							return this._location.href
						}
						get protocol() {
							return this._location.protocol
						}
						get hostname() {
							return this._location.hostname
						}
						get port() {
							return this._location.port
						}
						get pathname() {
							return this._location.pathname
						}
						get search() {
							return this._location.search
						}
						get hash() {
							return this._location.hash
						}
						set pathname(e) {
							this._location.pathname = e
						}
						pushState(e, i, r) {
							this._history.pushState(e, i, r)
						}
						replaceState(e, i, r) {
							this._history.replaceState(e, i, r)
						}
						forward() {
							this._history.forward()
						}
						back() {
							this._history.back()
						}
						historyGo(e = 0) {
							this._history.go(e)
						}
						getState() {
							return this._history.state
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵprov = mt({
								token: t,
								factory: function () {
									return new t()
								},
								providedIn: "platform"
							})
						}
					}
					return t
				})()
			function IQ(t, n) {
				if (0 == t.length) return n
				if (0 == n.length) return t
				let e = 0
				return t.endsWith("/") && e++, n.startsWith("/") && e++, 2 == e ? t + n.substring(1) : 1 == e ? t + n : t + "/" + n
			}
			function DQ(t) {
				const n = t.match(/#|\?|$/),
					e = (n && n.index) || t.length
				return t.slice(0, e - ("/" === t[e - 1] ? 1 : 0)) + t.slice(e)
			}
			function Cm(t) {
				return t && "?" !== t[0] ? "?" + t : t
			}
			let w2 = (() => {
				class t {
					historyGo(e) {
						throw new Error("Not implemented")
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({
							token: t,
							factory: function () {
								return Rt(mce)
							},
							providedIn: "root"
						})
					}
				}
				return t
			})()
			const fce = new He("appBaseHref")
			let mce = (() => {
					class t extends w2 {
						constructor(e, i) {
							super(),
								(this._platformLocation = e),
								(this._removeListenerFns = []),
								(this._baseHref = i ?? this._platformLocation.getBaseHrefFromDOM() ?? Rt(wi).location?.origin ?? "")
						}
						ngOnDestroy() {
							for (; this._removeListenerFns.length; ) this._removeListenerFns.pop()()
						}
						onPopState(e) {
							this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e))
						}
						getBaseHref() {
							return this._baseHref
						}
						prepareExternalUrl(e) {
							return IQ(this._baseHref, e)
						}
						path(e = !1) {
							const i = this._platformLocation.pathname + Cm(this._platformLocation.search),
								r = this._platformLocation.hash
							return r && e ? `${i}${r}` : i
						}
						pushState(e, i, r, o) {
							const s = this.prepareExternalUrl(r + Cm(o))
							this._platformLocation.pushState(e, i, s)
						}
						replaceState(e, i, r, o) {
							const s = this.prepareExternalUrl(r + Cm(o))
							this._platformLocation.replaceState(e, i, s)
						}
						forward() {
							this._platformLocation.forward()
						}
						back() {
							this._platformLocation.back()
						}
						getState() {
							return this._platformLocation.getState()
						}
						historyGo(e = 0) {
							this._platformLocation.historyGo?.(e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(BQ), re(fce, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				x2 = (() => {
					class t {
						constructor(e) {
							;(this._subject = new _n()),
								(this._urlChangeListeners = []),
								(this._urlChangeSubscription = null),
								(this._locationStrategy = e)
							const i = this._locationStrategy.getBaseHref()
							;(this._basePath = (function gce(t) {
								if (new RegExp("^(https?:)?//").test(t)) {
									const [, e] = t.split(/\/\/[^\/]+/)
									return e
								}
								return t
							})(DQ(LQ(i)))),
								this._locationStrategy.onPopState(r => {
									this._subject.emit({ url: this.path(!0), pop: !0, state: r.state, type: r.type })
								})
						}
						ngOnDestroy() {
							this._urlChangeSubscription?.unsubscribe(), (this._urlChangeListeners = [])
						}
						path(e = !1) {
							return this.normalize(this._locationStrategy.path(e))
						}
						getState() {
							return this._locationStrategy.getState()
						}
						isCurrentPathEqualTo(e, i = "") {
							return this.path() == this.normalize(e + Cm(i))
						}
						normalize(e) {
							return t.stripTrailingSlash(
								(function Ace(t, n) {
									if (!t || !n.startsWith(t)) return n
									const e = n.substring(t.length)
									return "" === e || ["/", ";", "?", "#"].includes(e[0]) ? e : n
								})(this._basePath, LQ(e))
							)
						}
						prepareExternalUrl(e) {
							return e && "/" !== e[0] && (e = "/" + e), this._locationStrategy.prepareExternalUrl(e)
						}
						go(e, i = "", r = null) {
							this._locationStrategy.pushState(r, "", e, i),
								this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Cm(i)), r)
						}
						replaceState(e, i = "", r = null) {
							this._locationStrategy.replaceState(r, "", e, i),
								this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Cm(i)), r)
						}
						forward() {
							this._locationStrategy.forward()
						}
						back() {
							this._locationStrategy.back()
						}
						historyGo(e = 0) {
							this._locationStrategy.historyGo?.(e)
						}
						onUrlChange(e) {
							return (
								this._urlChangeListeners.push(e),
								this._urlChangeSubscription ||
									(this._urlChangeSubscription = this.subscribe(i => {
										this._notifyUrlChangeListeners(i.url, i.state)
									})),
								() => {
									const i = this._urlChangeListeners.indexOf(e)
									this._urlChangeListeners.splice(i, 1),
										0 === this._urlChangeListeners.length &&
											(this._urlChangeSubscription?.unsubscribe(), (this._urlChangeSubscription = null))
								}
							)
						}
						_notifyUrlChangeListeners(e = "", i) {
							this._urlChangeListeners.forEach(r => r(e, i))
						}
						subscribe(e, i, r) {
							return this._subject.subscribe({ next: e, error: i, complete: r })
						}
						static {
							this.normalizeQueryParams = Cm
						}
						static {
							this.joinWithSlash = IQ
						}
						static {
							this.stripTrailingSlash = DQ
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(w2))
							}
						}
						static {
							this.ɵprov = mt({
								token: t,
								factory: function () {
									return (function pce() {
										return new x2(re(w2))
									})()
								},
								providedIn: "root"
							})
						}
					}
					return t
				})()
			function LQ(t) {
				return t.replace(/\/index.html$/, "")
			}
			var hC = (function (t) {
					return (
						(t[(t.Decimal = 0)] = "Decimal"),
						(t[(t.Percent = 1)] = "Percent"),
						(t[(t.Currency = 2)] = "Currency"),
						(t[(t.Scientific = 3)] = "Scientific"),
						t
					)
				})(hC || {}),
				rg = (function (t) {
					return (
						(t[(t.Zero = 0)] = "Zero"),
						(t[(t.One = 1)] = "One"),
						(t[(t.Two = 2)] = "Two"),
						(t[(t.Few = 3)] = "Few"),
						(t[(t.Many = 4)] = "Many"),
						(t[(t.Other = 5)] = "Other"),
						t
					)
				})(rg || {}),
				Io = (function (t) {
					return (
						(t[(t.Decimal = 0)] = "Decimal"),
						(t[(t.Group = 1)] = "Group"),
						(t[(t.List = 2)] = "List"),
						(t[(t.PercentSign = 3)] = "PercentSign"),
						(t[(t.PlusSign = 4)] = "PlusSign"),
						(t[(t.MinusSign = 5)] = "MinusSign"),
						(t[(t.Exponential = 6)] = "Exponential"),
						(t[(t.SuperscriptingExponent = 7)] = "SuperscriptingExponent"),
						(t[(t.PerMille = 8)] = "PerMille"),
						(t[(t.Infinity = 9)] = "Infinity"),
						(t[(t.NaN = 10)] = "NaN"),
						(t[(t.TimeSeparator = 11)] = "TimeSeparator"),
						(t[(t.CurrencyDecimal = 12)] = "CurrencyDecimal"),
						(t[(t.CurrencyGroup = 13)] = "CurrencyGroup"),
						t
					)
				})(Io || {})
			function Dc(t, n) {
				const e = ia(t),
					i = e[Pr.NumberSymbols][n]
				if (typeof i > "u") {
					if (n === Io.CurrencyDecimal) return e[Pr.NumberSymbols][Io.Decimal]
					if (n === Io.CurrencyGroup) return e[Pr.NumberSymbols][Io.Group]
				}
				return i
			}
			const Ece = function B5(t) {
					return ia(t)[Pr.PluralCase]
				},
				Gce = /^(\d+)?\.((\d+)(-(\d+))?)?$/
			function B2(t) {
				const n = parseInt(t)
				if (isNaN(n)) throw new Error("Invalid integer literal when parsing " + t)
				return n
			}
			let I2 = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({
							token: t,
							factory: function (i) {
								let r = null
								return i ? (r = new i()) : ((o = re(nd)), (r = new ele(o))), r
								var o
							},
							providedIn: "root"
						})
					}
				}
				return t
			})()
			let ele = (() => {
				class t extends I2 {
					constructor(e) {
						super(), (this.locale = e)
					}
					getPluralCategory(e, i) {
						switch (Ece(i || this.locale)(e)) {
							case rg.Zero:
								return "zero"
							case rg.One:
								return "one"
							case rg.Two:
								return "two"
							case rg.Few:
								return "few"
							case rg.Many:
								return "many"
							default:
								return "other"
						}
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(nd))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			function zQ(t, n) {
				n = encodeURIComponent(n)
				for (const e of t.split(";")) {
					const i = e.indexOf("="),
						[r, o] = -1 == i ? [e, ""] : [e.slice(0, i), e.slice(i + 1)]
					if (r.trim() === n) return decodeURIComponent(o)
				}
				return null
			}
			const D2 = /\s+/,
				GQ = []
			let Em = (() => {
				class t {
					constructor(e, i, r, o) {
						;(this._iterableDiffers = e),
							(this._keyValueDiffers = i),
							(this._ngEl = r),
							(this._renderer = o),
							(this.initialClasses = GQ),
							(this.stateMap = new Map())
					}
					set klass(e) {
						this.initialClasses = null != e ? e.trim().split(D2) : GQ
					}
					set ngClass(e) {
						this.rawClass = "string" == typeof e ? e.trim().split(D2) : e
					}
					ngDoCheck() {
						for (const i of this.initialClasses) this._updateState(i, !0)
						const e = this.rawClass
						if (Array.isArray(e) || e instanceof Set) for (const i of e) this._updateState(i, !0)
						else if (null != e) for (const i of Object.keys(e)) this._updateState(i, !!e[i])
						this._applyStateDiff()
					}
					_updateState(e, i) {
						const r = this.stateMap.get(e)
						void 0 !== r
							? (r.enabled !== i && ((r.changed = !0), (r.enabled = i)), (r.touched = !0))
							: this.stateMap.set(e, { enabled: i, changed: !0, touched: !0 })
					}
					_applyStateDiff() {
						for (const e of this.stateMap) {
							const i = e[0],
								r = e[1]
							r.changed
								? (this._toggleClass(i, r.enabled), (r.changed = !1))
								: r.touched || (r.enabled && this._toggleClass(i, !1), this.stateMap.delete(i)),
								(r.touched = !1)
						}
					}
					_toggleClass(e, i) {
						;(e = e.trim()).length > 0 &&
							e.split(D2).forEach(r => {
								i
									? this._renderer.addClass(this._ngEl.nativeElement, r)
									: this._renderer.removeClass(this._ngEl.nativeElement, r)
							})
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(dC), P(_0), P(wn), P(pm))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [["", "ngClass", ""]],
							inputs: { klass: ["class", "klass"], ngClass: "ngClass" },
							standalone: !0
						})
					}
				}
				return t
			})()
			class nle {
				constructor(n, e, i, r) {
					;(this.$implicit = n), (this.ngForOf = e), (this.index = i), (this.count = r)
				}
				get first() {
					return 0 === this.index
				}
				get last() {
					return this.index === this.count - 1
				}
				get even() {
					return this.index % 2 == 0
				}
				get odd() {
					return !this.even
				}
			}
			let _o = (() => {
				class t {
					set ngForOf(e) {
						;(this._ngForOf = e), (this._ngForOfDirty = !0)
					}
					set ngForTrackBy(e) {
						this._trackByFn = e
					}
					get ngForTrackBy() {
						return this._trackByFn
					}
					constructor(e, i, r) {
						;(this._viewContainer = e),
							(this._template = i),
							(this._differs = r),
							(this._ngForOf = null),
							(this._ngForOfDirty = !0),
							(this._differ = null)
					}
					set ngForTemplate(e) {
						e && (this._template = e)
					}
					ngDoCheck() {
						if (this._ngForOfDirty) {
							this._ngForOfDirty = !1
							const e = this._ngForOf
							!this._differ && e && (this._differ = this._differs.find(e).create(this.ngForTrackBy))
						}
						if (this._differ) {
							const e = this._differ.diff(this._ngForOf)
							e && this._applyChanges(e)
						}
					}
					_applyChanges(e) {
						const i = this._viewContainer
						e.forEachOperation((r, o, s) => {
							if (null == r.previousIndex)
								i.createEmbeddedView(this._template, new nle(r.item, this._ngForOf, -1, -1), null === s ? void 0 : s)
							else if (null == s) i.remove(null === o ? void 0 : o)
							else if (null !== o) {
								const a = i.get(o)
								i.move(a, s), WQ(a, r)
							}
						})
						for (let r = 0, o = i.length; r < o; r++) {
							const a = i.get(r).context
							;(a.index = r), (a.count = o), (a.ngForOf = this._ngForOf)
						}
						e.forEachIdentityChange(r => {
							WQ(i.get(r.currentIndex), r)
						})
					}
					static ngTemplateContextGuard(e, i) {
						return !0
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(ra), P(Za), P(dC))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [["", "ngFor", "", "ngForOf", ""]],
							inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" },
							standalone: !0
						})
					}
				}
				return t
			})()
			function WQ(t, n) {
				t.context.$implicit = n.item
			}
			let En = (() => {
				class t {
					constructor(e, i) {
						;(this._viewContainer = e),
							(this._context = new ile()),
							(this._thenTemplateRef = null),
							(this._elseTemplateRef = null),
							(this._thenViewRef = null),
							(this._elseViewRef = null),
							(this._thenTemplateRef = i)
					}
					set ngIf(e) {
						;(this._context.$implicit = this._context.ngIf = e), this._updateView()
					}
					set ngIfThen(e) {
						jQ("ngIfThen", e), (this._thenTemplateRef = e), (this._thenViewRef = null), this._updateView()
					}
					set ngIfElse(e) {
						jQ("ngIfElse", e), (this._elseTemplateRef = e), (this._elseViewRef = null), this._updateView()
					}
					_updateView() {
						this._context.$implicit
							? this._thenViewRef ||
							  (this._viewContainer.clear(),
							  (this._elseViewRef = null),
							  this._thenTemplateRef &&
									(this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context)))
							: this._elseViewRef ||
							  (this._viewContainer.clear(),
							  (this._thenViewRef = null),
							  this._elseTemplateRef &&
									(this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
					}
					static ngTemplateContextGuard(e, i) {
						return !0
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(ra), P(Za))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [["", "ngIf", ""]],
							inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" },
							standalone: !0
						})
					}
				}
				return t
			})()
			class ile {
				constructor() {
					;(this.$implicit = null), (this.ngIf = null)
				}
			}
			function jQ(t, n) {
				if (n && !n.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${Lr(n)}'.`)
			}
			class L2 {
				constructor(n, e) {
					;(this._viewContainerRef = n), (this._templateRef = e), (this._created = !1)
				}
				create() {
					;(this._created = !0), this._viewContainerRef.createEmbeddedView(this._templateRef)
				}
				destroy() {
					;(this._created = !1), this._viewContainerRef.clear()
				}
				enforceState(n) {
					n && !this._created ? this.create() : !n && this._created && this.destroy()
				}
			}
			let w0 = (() => {
					class t {
						constructor() {
							;(this._defaultViews = []),
								(this._defaultUsed = !1),
								(this._caseCount = 0),
								(this._lastCaseCheckIndex = 0),
								(this._lastCasesMatched = !1)
						}
						set ngSwitch(e) {
							;(this._ngSwitch = e), 0 === this._caseCount && this._updateDefaultCases(!0)
						}
						_addCase() {
							return this._caseCount++
						}
						_addDefault(e) {
							this._defaultViews.push(e)
						}
						_matchCase(e) {
							const i = e == this._ngSwitch
							return (
								(this._lastCasesMatched = this._lastCasesMatched || i),
								this._lastCaseCheckIndex++,
								this._lastCaseCheckIndex === this._caseCount &&
									(this._updateDefaultCases(!this._lastCasesMatched),
									(this._lastCaseCheckIndex = 0),
									(this._lastCasesMatched = !1)),
								i
							)
						}
						_updateDefaultCases(e) {
							if (this._defaultViews.length > 0 && e !== this._defaultUsed) {
								this._defaultUsed = e
								for (const i of this._defaultViews) i.enforceState(e)
							}
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({ type: t, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" }, standalone: !0 })
						}
					}
					return t
				})(),
				R2 = (() => {
					class t {
						constructor(e, i, r) {
							;(this.ngSwitch = r), r._addCase(), (this._view = new L2(e, i))
						}
						ngDoCheck() {
							this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(ra), P(Za), P(w0, 9))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "ngSwitchCase", ""]],
								inputs: { ngSwitchCase: "ngSwitchCase" },
								standalone: !0
							})
						}
					}
					return t
				})(),
				KQ = (() => {
					class t {
						constructor(e, i, r) {
							r._addDefault(new L2(e, i))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(ra), P(Za), P(w0, 9))
							}
						}
						static {
							this.ɵdir = yt({ type: t, selectors: [["", "ngSwitchDefault", ""]], standalone: !0 })
						}
					}
					return t
				})(),
				P2 = (() => {
					class t {
						constructor(e) {
							;(this._localization = e), (this._caseViews = {})
						}
						set ngPlural(e) {
							this._updateView(e)
						}
						addCase(e, i) {
							this._caseViews[e] = i
						}
						_updateView(e) {
							this._clearViews()
							const r = (function QQ(t, n, e, i) {
								let r = `=${t}`
								if (n.indexOf(r) > -1 || ((r = e.getPluralCategory(t, i)), n.indexOf(r) > -1)) return r
								if (n.indexOf("other") > -1) return "other"
								throw new Error(`No plural message found for value "${t}"`)
							})(e, Object.keys(this._caseViews), this._localization)
							this._activateView(this._caseViews[r])
						}
						_clearViews() {
							this._activeView && this._activeView.destroy()
						}
						_activateView(e) {
							e && ((this._activeView = e), this._activeView.create())
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(I2))
							}
						}
						static {
							this.ɵdir = yt({ type: t, selectors: [["", "ngPlural", ""]], inputs: { ngPlural: "ngPlural" }, standalone: !0 })
						}
					}
					return t
				})(),
				XQ = (() => {
					class t {
						constructor(e, i, r, o) {
							this.value = e
							const s = !isNaN(Number(e))
							o.addCase(s ? `=${e}` : e, new L2(r, i))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(Ma("ngPluralCase"), P(Za), P(ra), P(P2, 1))
							}
						}
						static {
							this.ɵdir = yt({ type: t, selectors: [["", "ngPluralCase", ""]], standalone: !0 })
						}
					}
					return t
				})(),
				og = (() => {
					class t {
						constructor(e, i, r) {
							;(this._ngEl = e), (this._differs = i), (this._renderer = r), (this._ngStyle = null), (this._differ = null)
						}
						set ngStyle(e) {
							;(this._ngStyle = e), !this._differ && e && (this._differ = this._differs.find(e).create())
						}
						ngDoCheck() {
							if (this._differ) {
								const e = this._differ.diff(this._ngStyle)
								e && this._applyChanges(e)
							}
						}
						_setStyle(e, i) {
							const [r, o] = e.split("."),
								s = -1 === r.indexOf("-") ? void 0 : ls.DashCase
							null != i
								? this._renderer.setStyle(this._ngEl.nativeElement, r, o ? `${i}${o}` : i, s)
								: this._renderer.removeStyle(this._ngEl.nativeElement, r, s)
						}
						_applyChanges(e) {
							e.forEachRemovedItem(i => this._setStyle(i.key, null)),
								e.forEachAddedItem(i => this._setStyle(i.key, i.currentValue)),
								e.forEachChangedItem(i => this._setStyle(i.key, i.currentValue))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(_0), P(pm))
							}
						}
						static {
							this.ɵdir = yt({ type: t, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" }, standalone: !0 })
						}
					}
					return t
				})(),
				x0 = (() => {
					class t {
						constructor(e) {
							;(this._viewContainerRef = e),
								(this._viewRef = null),
								(this.ngTemplateOutletContext = null),
								(this.ngTemplateOutlet = null),
								(this.ngTemplateOutletInjector = null)
						}
						ngOnChanges(e) {
							if (e.ngTemplateOutlet || e.ngTemplateOutletInjector) {
								const i = this._viewContainerRef
								if ((this._viewRef && i.remove(i.indexOf(this._viewRef)), this.ngTemplateOutlet)) {
									const { ngTemplateOutlet: r, ngTemplateOutletContext: o, ngTemplateOutletInjector: s } = this
									this._viewRef = i.createEmbeddedView(r, o, s ? { injector: s } : void 0)
								} else this._viewRef = null
							} else
								this._viewRef &&
									e.ngTemplateOutletContext &&
									this.ngTemplateOutletContext &&
									(this._viewRef.context = this.ngTemplateOutletContext)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(ra))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "ngTemplateOutlet", ""]],
								inputs: {
									ngTemplateOutletContext: "ngTemplateOutletContext",
									ngTemplateOutlet: "ngTemplateOutlet",
									ngTemplateOutletInjector: "ngTemplateOutletInjector"
								},
								standalone: !0,
								features: [Ar]
							})
						}
					}
					return t
				})()
			function ll(t, n) {
				return new ht(2100, !1)
			}
			class rle {
				createSubscription(n, e) {
					return Ix(() =>
						n.subscribe({
							next: e,
							error: i => {
								throw i
							}
						})
					)
				}
				dispose(n) {
					Ix(() => n.unsubscribe())
				}
			}
			class ole {
				createSubscription(n, e) {
					return n.then(e, i => {
						throw i
					})
				}
				dispose(n) {}
			}
			const sle = new ole(),
				ale = new rle()
			let Bn = (() => {
				class t {
					constructor(e) {
						;(this._latestValue = null),
							(this._subscription = null),
							(this._obj = null),
							(this._strategy = null),
							(this._ref = e)
					}
					ngOnDestroy() {
						this._subscription && this._dispose(), (this._ref = null)
					}
					transform(e) {
						return this._obj
							? e !== this._obj
								? (this._dispose(), this.transform(e))
								: this._latestValue
							: (e && this._subscribe(e), this._latestValue)
					}
					_subscribe(e) {
						;(this._obj = e),
							(this._strategy = this._selectStrategy(e)),
							(this._subscription = this._strategy.createSubscription(e, i => this._updateLatestValue(e, i)))
					}
					_selectStrategy(e) {
						if (X1(e)) return sle
						if (HH(e)) return ale
						throw ll()
					}
					_dispose() {
						this._strategy.dispose(this._subscription),
							(this._latestValue = null),
							(this._subscription = null),
							(this._obj = null)
					}
					_updateLatestValue(e, i) {
						e === this._obj && ((this._latestValue = i), this._ref.markForCheck())
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Jr, 16))
						}
					}
					static {
						this.ɵpipe = Zi({ name: "async", type: t, pure: !1, standalone: !0 })
					}
				}
				return t
			})()
			const lle =
				/(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g
			let YQ = (() => {
					class t {
						transform(e) {
							if (null == e) return null
							if ("string" != typeof e) throw ll()
							return e.replace(lle, i => i[0].toUpperCase() + i.slice(1).toLowerCase())
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "titlecase", type: t, pure: !0, standalone: !0 })
						}
					}
					return t
				})(),
				qQ = (() => {
					class t {
						transform(e) {
							if (null == e) return null
							if ("string" != typeof e) throw ll()
							return e.toUpperCase()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "uppercase", type: t, pure: !0, standalone: !0 })
						}
					}
					return t
				})(),
				wC = (() => {
					class t {
						constructor(e) {
							;(this.differs = e), (this.keyValues = []), (this.compareFn = ZQ)
						}
						transform(e, i = ZQ) {
							if (!e || (!(e instanceof Map) && "object" != typeof e)) return null
							this.differ || (this.differ = this.differs.find(e).create())
							const r = this.differ.diff(e),
								o = i !== this.compareFn
							return (
								r &&
									((this.keyValues = []),
									r.forEachItem(s => {
										this.keyValues.push(
											(function ble(t, n) {
												return { key: t, value: n }
											})(s.key, s.currentValue)
										)
									})),
								(r || o) && (this.keyValues.sort(i), (this.compareFn = i)),
								this.keyValues
							)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(_0, 16))
							}
						}
						static {
							this.ɵpipe = Zi({ name: "keyvalue", type: t, pure: !1, standalone: !0 })
						}
					}
					return t
				})()
			function ZQ(t, n) {
				const e = t.key,
					i = n.key
				if (e === i) return 0
				if (void 0 === e) return 1
				if (void 0 === i) return -1
				if (null === e) return 1
				if (null === i) return -1
				if ("string" == typeof e && "string" == typeof i) return e < i ? -1 : 1
				if ("number" == typeof e && "number" == typeof i) return e - i
				if ("boolean" == typeof e && "boolean" == typeof i) return e < i ? -1 : 1
				const r = String(e),
					o = String(i)
				return r == o ? 0 : r < o ? -1 : 1
			}
			let C0 = (() => {
				class t {
					constructor(e) {
						this._locale = e
					}
					transform(e, i, r) {
						if (
							!(function O2(t) {
								return !(null == t || "" === t || t != t)
							})(e)
						)
							return null
						r = r || this._locale
						try {
							return (function Yce(t, n, e) {
								return (function T2(t, n, e, i, r, o, s = !1) {
									let a = "",
										c = !1
									if (isFinite(t)) {
										let l = (function Zce(t) {
											let i,
												r,
												o,
												s,
												a,
												n = Math.abs(t) + "",
												e = 0
											for (
												(r = n.indexOf(".")) > -1 && (n = n.replace(".", "")),
													(o = n.search(/e/i)) > 0
														? (r < 0 && (r = o), (r += +n.slice(o + 1)), (n = n.substring(0, o)))
														: r < 0 && (r = n.length),
													o = 0;
												"0" === n.charAt(o);
												o++
											);
											if (o === (a = n.length)) (i = [0]), (r = 1)
											else {
												for (a--; "0" === n.charAt(a); ) a--
												for (r -= o, i = [], s = 0; o <= a; o++, s++) i[s] = Number(n.charAt(o))
											}
											return (
												r > 22 && ((i = i.splice(0, 21)), (e = r - 1), (r = 1)),
												{ digits: i, exponent: e, integerLen: r }
											)
										})(t)
										s &&
											(l = (function qce(t) {
												if (0 === t.digits[0]) return t
												const n = t.digits.length - t.integerLen
												return (
													t.exponent
														? (t.exponent += 2)
														: (0 === n ? t.digits.push(0, 0) : 1 === n && t.digits.push(0),
														  (t.integerLen += 2)),
													t
												)
											})(l))
										let d = n.minInt,
											u = n.minFrac,
											h = n.maxFrac
										if (o) {
											const w = o.match(Gce)
											if (null === w) throw new Error(`${o} is not a valid digit info`)
											const S = w[1],
												M = w[3],
												O = w[5]
											null != S && (d = B2(S)),
												null != M && (u = B2(M)),
												null != O ? (h = B2(O)) : null != M && u > h && (h = u)
										}
										!(function Jce(t, n, e) {
											if (n > e)
												throw new Error(
													`The minimum number of digits after fraction (${n}) is higher than the maximum (${e}).`
												)
											let i = t.digits,
												r = i.length - t.integerLen
											const o = Math.min(Math.max(n, r), e)
											let s = o + t.integerLen,
												a = i[s]
											if (s > 0) {
												i.splice(Math.max(t.integerLen, s))
												for (let u = s; u < i.length; u++) i[u] = 0
											} else {
												;(r = Math.max(0, r)), (t.integerLen = 1), (i.length = Math.max(1, (s = o + 1))), (i[0] = 0)
												for (let u = 1; u < s; u++) i[u] = 0
											}
											if (a >= 5)
												if (s - 1 < 0) {
													for (let u = 0; u > s; u--) i.unshift(0), t.integerLen++
													i.unshift(1), t.integerLen++
												} else i[s - 1]++
											for (; r < Math.max(0, o); r++) i.push(0)
											let c = 0 !== o
											const l = n + t.integerLen,
												d = i.reduceRight(function (u, h, f, _) {
													return (
														(_[f] = (h += u) < 10 ? h : h - 10),
														c && (0 === _[f] && f >= l ? _.pop() : (c = !1)),
														h >= 10 ? 1 : 0
													)
												}, 0)
											d && (i.unshift(d), t.integerLen++)
										})(l, u, h)
										let f = l.digits,
											_ = l.integerLen
										const y = l.exponent
										let C = []
										for (c = f.every(w => !w); _ < d; _++) f.unshift(0)
										for (; _ < 0; _++) f.unshift(0)
										_ > 0 ? (C = f.splice(_, f.length)) : ((C = f), (f = [0]))
										const x = []
										for (
											f.length >= n.lgSize && x.unshift(f.splice(-n.lgSize, f.length).join(""));
											f.length > n.gSize;

										)
											x.unshift(f.splice(-n.gSize, f.length).join(""))
										f.length && x.unshift(f.join("")),
											(a = x.join(Dc(e, i))),
											C.length && (a += Dc(e, r) + C.join("")),
											y && (a += Dc(e, Io.Exponential) + "+" + y)
									} else a = Dc(e, Io.Infinity)
									return (a = t < 0 && !c ? n.negPre + a + n.negSuf : n.posPre + a + n.posSuf), a
								})(
									t,
									(function F2(t, n = "-") {
										const e = {
												minInt: 1,
												minFrac: 0,
												maxFrac: 0,
												posPre: "",
												posSuf: "",
												negPre: "",
												negSuf: "",
												gSize: 0,
												lgSize: 0
											},
											i = t.split(";"),
											r = i[0],
											o = i[1],
											s =
												-1 !== r.indexOf(".")
													? r.split(".")
													: [r.substring(0, r.lastIndexOf("0") + 1), r.substring(r.lastIndexOf("0") + 1)],
											a = s[0],
											c = s[1] || ""
										e.posPre = a.substring(0, a.indexOf("#"))
										for (let d = 0; d < c.length; d++) {
											const u = c.charAt(d)
											"0" === u ? (e.minFrac = e.maxFrac = d + 1) : "#" === u ? (e.maxFrac = d + 1) : (e.posSuf += u)
										}
										const l = a.split(",")
										if (
											((e.gSize = l[1] ? l[1].length : 0), (e.lgSize = l[2] || l[1] ? (l[2] || l[1]).length : 0), o)
										) {
											const d = r.length - e.posPre.length - e.posSuf.length,
												u = o.indexOf("#")
											;(e.negPre = o.substring(0, u).replace(/'/g, "")), (e.negSuf = o.slice(u + d).replace(/'/g, ""))
										} else (e.negPre = n + e.posPre), (e.negSuf = e.posSuf)
										return e
									})(
										(function C2(t, n) {
											return ia(t)[Pr.NumberFormats][n]
										})(n, hC.Decimal),
										Dc(n, Io.MinusSign)
									),
									n,
									Io.Group,
									Io.Decimal,
									e
								)
							})(
								(function N2(t) {
									if ("string" == typeof t && !isNaN(Number(t) - parseFloat(t))) return Number(t)
									if ("number" != typeof t) throw new Error(`${t} is not a number`)
									return t
								})(e),
								r,
								i
							)
						} catch (o) {
							throw ll()
						}
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(nd, 16))
						}
					}
					static {
						this.ɵpipe = Zi({ name: "number", type: t, pure: !0, standalone: !0 })
					}
				}
				return t
			})()
			let Ot = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({})
					}
				}
				return t
			})()
			const JQ = "browser"
			function ez(t) {
				return "server" === t
			}
			class tz {}
			class Kle extends uce {
				constructor() {
					super(...arguments), (this.supportsDOMEvents = !0)
				}
			}
			class V2 extends Kle {
				static makeCurrent() {
					!(function dce(t) {
						y2 || (y2 = t)
					})(new V2())
				}
				onAndCancel(n, e, i) {
					return (
						n.addEventListener(e, i),
						() => {
							n.removeEventListener(e, i)
						}
					)
				}
				dispatchEvent(n, e) {
					n.dispatchEvent(e)
				}
				remove(n) {
					n.parentNode && n.parentNode.removeChild(n)
				}
				createElement(n, e) {
					return (e = e || this.getDefaultDocument()).createElement(n)
				}
				createHtmlDocument() {
					return document.implementation.createHTMLDocument("fakeTitle")
				}
				getDefaultDocument() {
					return document
				}
				isElementNode(n) {
					return n.nodeType === Node.ELEMENT_NODE
				}
				isShadowRoot(n) {
					return n instanceof DocumentFragment
				}
				getGlobalEventTarget(n, e) {
					return "window" === e ? window : "document" === e ? n : "body" === e ? n.body : null
				}
				getBaseHref(n) {
					const e = (function Xle() {
						return (M0 = M0 || document.querySelector("base")), M0 ? M0.getAttribute("href") : null
					})()
					return null == e
						? null
						: (function Yle(t) {
								;(EC = EC || document.createElement("a")), EC.setAttribute("href", t)
								const n = EC.pathname
								return "/" === n.charAt(0) ? n : `/${n}`
						  })(e)
				}
				resetBaseElement() {
					M0 = null
				}
				getUserAgent() {
					return window.navigator.userAgent
				}
				getCookie(n) {
					return zQ(document.cookie, n)
				}
			}
			let EC,
				M0 = null,
				Zle = (() => {
					class t {
						build() {
							return new XMLHttpRequest()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})()
			const Q2 = new He("EventManagerPlugins")
			let sz = (() => {
				class t {
					constructor(e, i) {
						;(this._zone = i),
							(this._eventNameToPlugin = new Map()),
							e.forEach(r => {
								r.manager = this
							}),
							(this._plugins = e.slice().reverse())
					}
					addEventListener(e, i, r) {
						return this._findPluginFor(i).addEventListener(e, i, r)
					}
					getZone() {
						return this._zone
					}
					_findPluginFor(e) {
						let i = this._eventNameToPlugin.get(e)
						if (i) return i
						if (((i = this._plugins.find(o => o.supports(e))), !i)) throw new ht(5101, !1)
						return this._eventNameToPlugin.set(e, i), i
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Q2), re(mn))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			class az {
				constructor(n) {
					this._doc = n
				}
			}
			const z2 = "ng-app-id"
			let cz = (() => {
				class t {
					constructor(e, i, r, o = {}) {
						;(this.doc = e),
							(this.appId = i),
							(this.nonce = r),
							(this.platformId = o),
							(this.styleRef = new Map()),
							(this.hostNodes = new Set()),
							(this.styleNodesInDOM = this.collectServerRenderedStyles()),
							(this.platformIsServer = ez(o)),
							this.resetHostNodes()
					}
					addStyles(e) {
						for (const i of e) 1 === this.changeUsageCount(i, 1) && this.onStyleAdded(i)
					}
					removeStyles(e) {
						for (const i of e) this.changeUsageCount(i, -1) <= 0 && this.onStyleRemoved(i)
					}
					ngOnDestroy() {
						const e = this.styleNodesInDOM
						e && (e.forEach(i => i.remove()), e.clear())
						for (const i of this.getAllStyles()) this.onStyleRemoved(i)
						this.resetHostNodes()
					}
					addHost(e) {
						this.hostNodes.add(e)
						for (const i of this.getAllStyles()) this.addStyleToHost(e, i)
					}
					removeHost(e) {
						this.hostNodes.delete(e)
					}
					getAllStyles() {
						return this.styleRef.keys()
					}
					onStyleAdded(e) {
						for (const i of this.hostNodes) this.addStyleToHost(i, e)
					}
					onStyleRemoved(e) {
						const i = this.styleRef
						i.get(e)?.elements?.forEach(r => r.remove()), i.delete(e)
					}
					collectServerRenderedStyles() {
						const e = this.doc.head?.querySelectorAll(`style[${z2}="${this.appId}"]`)
						if (e?.length) {
							const i = new Map()
							return (
								e.forEach(r => {
									null != r.textContent && i.set(r.textContent, r)
								}),
								i
							)
						}
						return null
					}
					changeUsageCount(e, i) {
						const r = this.styleRef
						if (r.has(e)) {
							const o = r.get(e)
							return (o.usage += i), o.usage
						}
						return r.set(e, { usage: i, elements: [] }), i
					}
					getStyleElement(e, i) {
						const r = this.styleNodesInDOM,
							o = r?.get(i)
						if (o?.parentNode === e) return r.delete(i), o.removeAttribute(z2), o
						{
							const s = this.doc.createElement("style")
							return (
								this.nonce && s.setAttribute("nonce", this.nonce),
								(s.textContent = i),
								this.platformIsServer && s.setAttribute(z2, this.appId),
								s
							)
						}
					}
					addStyleToHost(e, i) {
						const r = this.getStyleElement(e, i)
						e.appendChild(r)
						const o = this.styleRef,
							s = o.get(i)?.elements
						s ? s.push(r) : o.set(i, { elements: [r], usage: 1 })
					}
					resetHostNodes() {
						const e = this.hostNodes
						e.clear(), e.add(this.doc.head)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(wi), re(j_), re(eB, 8), re(Mh))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const G2 = {
					svg: "http://www.w3.org/2000/svg",
					xhtml: "http://www.w3.org/1999/xhtml",
					xlink: "http://www.w3.org/1999/xlink",
					xml: "http://www.w3.org/XML/1998/namespace",
					xmlns: "http://www.w3.org/2000/xmlns/",
					math: "http://www.w3.org/1998/MathML/"
				},
				$2 = /%COMP%/g,
				nde = new He("RemoveStylesOnCompDestroy", { providedIn: "root", factory: () => !1 })
			function dz(t, n) {
				return n.map(e => e.replace($2, t))
			}
			let W2 = (() => {
				class t {
					constructor(e, i, r, o, s, a, c, l = null) {
						;(this.eventManager = e),
							(this.sharedStylesHost = i),
							(this.appId = r),
							(this.removeStylesOnCompDestroy = o),
							(this.doc = s),
							(this.platformId = a),
							(this.ngZone = c),
							(this.nonce = l),
							(this.rendererByCompId = new Map()),
							(this.platformIsServer = ez(a)),
							(this.defaultRenderer = new j2(e, s, c, this.platformIsServer))
					}
					createRenderer(e, i) {
						if (!e || !i) return this.defaultRenderer
						this.platformIsServer && i.encapsulation === Zs.ShadowDom && (i = { ...i, encapsulation: Zs.Emulated })
						const r = this.getOrCreateRenderer(e, i)
						return r instanceof hz ? r.applyToHost(e) : r instanceof K2 && r.applyStyles(), r
					}
					getOrCreateRenderer(e, i) {
						const r = this.rendererByCompId
						let o = r.get(i.id)
						if (!o) {
							const s = this.doc,
								a = this.ngZone,
								c = this.eventManager,
								l = this.sharedStylesHost,
								d = this.removeStylesOnCompDestroy,
								u = this.platformIsServer
							switch (i.encapsulation) {
								case Zs.Emulated:
									o = new hz(c, l, i, this.appId, d, s, a, u)
									break
								case Zs.ShadowDom:
									return new sde(c, l, e, i, s, a, this.nonce, u)
								default:
									o = new K2(c, l, i, d, s, a, u)
							}
							r.set(i.id, o)
						}
						return o
					}
					ngOnDestroy() {
						this.rendererByCompId.clear()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(sz), re(cz), re(j_), re(nde), re(wi), re(Mh), re(mn), re(eB))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			class j2 {
				constructor(n, e, i, r) {
					;(this.eventManager = n),
						(this.doc = e),
						(this.ngZone = i),
						(this.platformIsServer = r),
						(this.data = Object.create(null)),
						(this.destroyNode = null)
				}
				destroy() {}
				createElement(n, e) {
					return e ? this.doc.createElementNS(G2[e] || e, n) : this.doc.createElement(n)
				}
				createComment(n) {
					return this.doc.createComment(n)
				}
				createText(n) {
					return this.doc.createTextNode(n)
				}
				appendChild(n, e) {
					;(uz(n) ? n.content : n).appendChild(e)
				}
				insertBefore(n, e, i) {
					n && (uz(n) ? n.content : n).insertBefore(e, i)
				}
				removeChild(n, e) {
					n && n.removeChild(e)
				}
				selectRootElement(n, e) {
					let i = "string" == typeof n ? this.doc.querySelector(n) : n
					if (!i) throw new ht(-5104, !1)
					return e || (i.textContent = ""), i
				}
				parentNode(n) {
					return n.parentNode
				}
				nextSibling(n) {
					return n.nextSibling
				}
				setAttribute(n, e, i, r) {
					if (r) {
						e = r + ":" + e
						const o = G2[r]
						o ? n.setAttributeNS(o, e, i) : n.setAttribute(e, i)
					} else n.setAttribute(e, i)
				}
				removeAttribute(n, e, i) {
					if (i) {
						const r = G2[i]
						r ? n.removeAttributeNS(r, e) : n.removeAttribute(`${i}:${e}`)
					} else n.removeAttribute(e)
				}
				addClass(n, e) {
					n.classList.add(e)
				}
				removeClass(n, e) {
					n.classList.remove(e)
				}
				setStyle(n, e, i, r) {
					r & (ls.DashCase | ls.Important) ? n.style.setProperty(e, i, r & ls.Important ? "important" : "") : (n.style[e] = i)
				}
				removeStyle(n, e, i) {
					i & ls.DashCase ? n.style.removeProperty(e) : (n.style[e] = "")
				}
				setProperty(n, e, i) {
					n[e] = i
				}
				setValue(n, e) {
					n.nodeValue = e
				}
				listen(n, e, i) {
					if ("string" == typeof n && !(n = Fh().getGlobalEventTarget(this.doc, n)))
						throw new Error(`Unsupported event target ${n} for event ${e}`)
					return this.eventManager.addEventListener(n, e, this.decoratePreventDefault(i))
				}
				decoratePreventDefault(n) {
					return e => {
						if ("__ngUnwrap__" === e) return n
						!1 === (this.platformIsServer ? this.ngZone.runGuarded(() => n(e)) : n(e)) && e.preventDefault()
					}
				}
			}
			function uz(t) {
				return "TEMPLATE" === t.tagName && void 0 !== t.content
			}
			class sde extends j2 {
				constructor(n, e, i, r, o, s, a, c) {
					super(n, o, s, c),
						(this.sharedStylesHost = e),
						(this.hostEl = i),
						(this.shadowRoot = i.attachShadow({ mode: "open" })),
						this.sharedStylesHost.addHost(this.shadowRoot)
					const l = dz(r.id, r.styles)
					for (const d of l) {
						const u = document.createElement("style")
						a && u.setAttribute("nonce", a), (u.textContent = d), this.shadowRoot.appendChild(u)
					}
				}
				nodeOrShadowRoot(n) {
					return n === this.hostEl ? this.shadowRoot : n
				}
				appendChild(n, e) {
					return super.appendChild(this.nodeOrShadowRoot(n), e)
				}
				insertBefore(n, e, i) {
					return super.insertBefore(this.nodeOrShadowRoot(n), e, i)
				}
				removeChild(n, e) {
					return super.removeChild(this.nodeOrShadowRoot(n), e)
				}
				parentNode(n) {
					return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))
				}
				destroy() {
					this.sharedStylesHost.removeHost(this.shadowRoot)
				}
			}
			class K2 extends j2 {
				constructor(n, e, i, r, o, s, a, c) {
					super(n, o, s, a),
						(this.sharedStylesHost = e),
						(this.removeStylesOnCompDestroy = r),
						(this.styles = c ? dz(c, i.styles) : i.styles)
				}
				applyStyles() {
					this.sharedStylesHost.addStyles(this.styles)
				}
				destroy() {
					this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles)
				}
			}
			class hz extends K2 {
				constructor(n, e, i, r, o, s, a, c) {
					const l = r + "-" + i.id
					super(n, e, i, o, s, a, c, l),
						(this.contentAttr = (function ide(t) {
							return "_ngcontent-%COMP%".replace($2, t)
						})(l)),
						(this.hostAttr = (function rde(t) {
							return "_nghost-%COMP%".replace($2, t)
						})(l))
				}
				applyToHost(n) {
					this.applyStyles(), this.setAttribute(n, this.hostAttr, "")
				}
				createElement(n, e) {
					const i = super.createElement(n, e)
					return super.setAttribute(i, this.contentAttr, ""), i
				}
			}
			let ade = (() => {
				class t extends az {
					constructor(e) {
						super(e)
					}
					supports(e) {
						return !0
					}
					addEventListener(e, i, r) {
						return e.addEventListener(i, r, !1), () => this.removeEventListener(e, i, r)
					}
					removeEventListener(e, i, r) {
						return e.removeEventListener(i, r)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(wi))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const fz = ["alt", "control", "meta", "shift"],
				cde = {
					"\b": "Backspace",
					"\t": "Tab",
					"\x7f": "Delete",
					"\x1b": "Escape",
					Del: "Delete",
					Esc: "Escape",
					Left: "ArrowLeft",
					Right: "ArrowRight",
					Up: "ArrowUp",
					Down: "ArrowDown",
					Menu: "ContextMenu",
					Scroll: "ScrollLock",
					Win: "OS"
				},
				lde = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }
			let dde = (() => {
				class t extends az {
					constructor(e) {
						super(e)
					}
					supports(e) {
						return null != t.parseEventName(e)
					}
					addEventListener(e, i, r) {
						const o = t.parseEventName(i),
							s = t.eventCallback(o.fullKey, r, this.manager.getZone())
						return this.manager.getZone().runOutsideAngular(() => Fh().onAndCancel(e, o.domEventName, s))
					}
					static parseEventName(e) {
						const i = e.toLowerCase().split("."),
							r = i.shift()
						if (0 === i.length || ("keydown" !== r && "keyup" !== r)) return null
						const o = t._normalizeKey(i.pop())
						let s = "",
							a = i.indexOf("code")
						if (
							(a > -1 && (i.splice(a, 1), (s = "code.")),
							fz.forEach(l => {
								const d = i.indexOf(l)
								d > -1 && (i.splice(d, 1), (s += l + "."))
							}),
							(s += o),
							0 != i.length || 0 === o.length)
						)
							return null
						const c = {}
						return (c.domEventName = r), (c.fullKey = s), c
					}
					static matchEventFullKeyCode(e, i) {
						let r = cde[e.key] || e.key,
							o = ""
						return (
							i.indexOf("code.") > -1 && ((r = e.code), (o = "code.")),
							!(null == r || !r) &&
								((r = r.toLowerCase()),
								" " === r ? (r = "space") : "." === r && (r = "dot"),
								fz.forEach(s => {
									s !== r && (0, lde[s])(e) && (o += s + ".")
								}),
								(o += r),
								o === i)
						)
					}
					static eventCallback(e, i, r) {
						return o => {
							t.matchEventFullKeyCode(o, e) && r.runGuarded(() => i(o))
						}
					}
					static _normalizeKey(e) {
						return "esc" === e ? "escape" : e
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(wi))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const pz = [
					{ provide: Mh, useValue: JQ },
					{
						provide: y4,
						useValue: function ude() {
							V2.makeCurrent()
						},
						multi: !0
					},
					{
						provide: wi,
						useFactory: function fde() {
							return (
								(function dte(t) {
									UF = t
								})(document),
								document
							)
						},
						deps: []
					}
				],
				mde = oQ(qae, "browser", pz),
				pde = new He(""),
				Az = [
					{
						provide: sC,
						useClass: class qle {
							addToWindow(n) {
								;(vr.getAngularTestability = (i, r = !0) => {
									const o = n.findTestabilityInTree(i, r)
									if (null == o) throw new ht(5103, !1)
									return o
								}),
									(vr.getAllAngularTestabilities = () => n.getAllTestabilities()),
									(vr.getAllAngularRootElements = () => n.getAllRootElements()),
									vr.frameworkStabilizers || (vr.frameworkStabilizers = []),
									vr.frameworkStabilizers.push(i => {
										const r = vr.getAllAngularTestabilities()
										let o = r.length,
											s = !1
										const a = function (c) {
											;(s = s || c), o--, 0 == o && i(s)
										}
										r.forEach(c => {
											c.whenStable(a)
										})
									})
							}
							findTestabilityInTree(n, e, i) {
								return null == e
									? null
									: n.getTestability(e) ??
											(i
												? Fh().isShadowRoot(e)
													? this.findTestabilityInTree(n, e.host, !0)
													: this.findTestabilityInTree(n, e.parentElement, !0)
												: null)
							}
						},
						deps: []
					},
					{ provide: eQ, useClass: l2, deps: [mn, d2, sC] },
					{ provide: l2, useClass: l2, deps: [mn, d2, sC] }
				],
				gz = [
					{ provide: YF, useValue: "root" },
					{
						provide: ql,
						useFactory: function hde() {
							return new ql()
						},
						deps: []
					},
					{ provide: Q2, useClass: ade, multi: !0, deps: [wi, mn, Mh] },
					{ provide: Q2, useClass: dde, multi: !0, deps: [wi] },
					W2,
					cz,
					sz,
					{ provide: Y_, useExisting: W2 },
					{ provide: tz, useClass: Zle, deps: [] },
					[]
				]
			let bz = (() => {
				class t {
					constructor(e) {}
					static withServerTransition(e) {
						return { ngModule: t, providers: [{ provide: j_, useValue: e.appId }] }
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(pde, 12))
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({ providers: [...gz, ...Az], imports: [Ot, Zae] })
					}
				}
				return t
			})()
			function xi(t, n) {
				return Wt((e, i) => {
					let r = 0
					e.subscribe(we(i, o => t.call(n, o, r++) && i.next(o)))
				})
			}
			function wz(t) {
				return Wt((n, e) => {
					try {
						n.subscribe(e)
					} finally {
						e.add(t)
					}
				})
			}
			typeof window < "u" && window
			class MC {}
			class SC {}
			class id {
				constructor(n) {
					;(this.normalizedNames = new Map()),
						(this.lazyUpdate = null),
						n
							? "string" == typeof n
								? (this.lazyInit = () => {
										;(this.headers = new Map()),
											n.split("\n").forEach(e => {
												const i = e.indexOf(":")
												if (i > 0) {
													const r = e.slice(0, i),
														o = r.toLowerCase(),
														s = e.slice(i + 1).trim()
													this.maybeSetNormalizedName(r, o),
														this.headers.has(o) ? this.headers.get(o).push(s) : this.headers.set(o, [s])
												}
											})
								  })
								: typeof Headers < "u" && n instanceof Headers
								? ((this.headers = new Map()),
								  n.forEach((e, i) => {
										this.setHeaderEntries(i, e)
								  }))
								: (this.lazyInit = () => {
										;(this.headers = new Map()),
											Object.entries(n).forEach(([e, i]) => {
												this.setHeaderEntries(e, i)
											})
								  })
							: (this.headers = new Map())
				}
				has(n) {
					return this.init(), this.headers.has(n.toLowerCase())
				}
				get(n) {
					this.init()
					const e = this.headers.get(n.toLowerCase())
					return e && e.length > 0 ? e[0] : null
				}
				keys() {
					return this.init(), Array.from(this.normalizedNames.values())
				}
				getAll(n) {
					return this.init(), this.headers.get(n.toLowerCase()) || null
				}
				append(n, e) {
					return this.clone({ name: n, value: e, op: "a" })
				}
				set(n, e) {
					return this.clone({ name: n, value: e, op: "s" })
				}
				delete(n, e) {
					return this.clone({ name: n, value: e, op: "d" })
				}
				maybeSetNormalizedName(n, e) {
					this.normalizedNames.has(e) || this.normalizedNames.set(e, n)
				}
				init() {
					this.lazyInit &&
						(this.lazyInit instanceof id ? this.copyFrom(this.lazyInit) : this.lazyInit(),
						(this.lazyInit = null),
						this.lazyUpdate && (this.lazyUpdate.forEach(n => this.applyUpdate(n)), (this.lazyUpdate = null)))
				}
				copyFrom(n) {
					n.init(),
						Array.from(n.headers.keys()).forEach(e => {
							this.headers.set(e, n.headers.get(e)), this.normalizedNames.set(e, n.normalizedNames.get(e))
						})
				}
				clone(n) {
					const e = new id()
					return (
						(e.lazyInit = this.lazyInit && this.lazyInit instanceof id ? this.lazyInit : this),
						(e.lazyUpdate = (this.lazyUpdate || []).concat([n])),
						e
					)
				}
				applyUpdate(n) {
					const e = n.name.toLowerCase()
					switch (n.op) {
						case "a":
						case "s":
							let i = n.value
							if (("string" == typeof i && (i = [i]), 0 === i.length)) return
							this.maybeSetNormalizedName(n.name, e)
							const r = ("a" === n.op ? this.headers.get(e) : void 0) || []
							r.push(...i), this.headers.set(e, r)
							break
						case "d":
							const o = n.value
							if (o) {
								let s = this.headers.get(e)
								if (!s) return
								;(s = s.filter(a => -1 === o.indexOf(a))),
									0 === s.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, s)
							} else this.headers.delete(e), this.normalizedNames.delete(e)
					}
				}
				setHeaderEntries(n, e) {
					const i = (Array.isArray(e) ? e : [e]).map(o => o.toString()),
						r = n.toLowerCase()
					this.headers.set(r, i), this.maybeSetNormalizedName(n, r)
				}
				forEach(n) {
					this.init(), Array.from(this.normalizedNames.keys()).forEach(e => n(this.normalizedNames.get(e), this.headers.get(e)))
				}
			}
			class xde {
				encodeKey(n) {
					return xz(n)
				}
				encodeValue(n) {
					return xz(n)
				}
				decodeKey(n) {
					return decodeURIComponent(n)
				}
				decodeValue(n) {
					return decodeURIComponent(n)
				}
			}
			const Ede = /%(\d[a-f0-9])/gi,
				Mde = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }
			function xz(t) {
				return encodeURIComponent(t).replace(Ede, (n, e) => Mde[e] ?? n)
			}
			function kC(t) {
				return `${t}`
			}
			class Ih {
				constructor(n = {}) {
					if (((this.updates = null), (this.cloneFrom = null), (this.encoder = n.encoder || new xde()), n.fromString)) {
						if (n.fromObject) throw new Error("Cannot specify both fromString and fromObject.")
						this.map = (function Cde(t, n) {
							const e = new Map()
							return (
								t.length > 0 &&
									t
										.replace(/^\?/, "")
										.split("&")
										.forEach(r => {
											const o = r.indexOf("="),
												[s, a] =
													-1 == o
														? [n.decodeKey(r), ""]
														: [n.decodeKey(r.slice(0, o)), n.decodeValue(r.slice(o + 1))],
												c = e.get(s) || []
											c.push(a), e.set(s, c)
										}),
								e
							)
						})(n.fromString, this.encoder)
					} else
						n.fromObject
							? ((this.map = new Map()),
							  Object.keys(n.fromObject).forEach(e => {
									const i = n.fromObject[e],
										r = Array.isArray(i) ? i.map(kC) : [kC(i)]
									this.map.set(e, r)
							  }))
							: (this.map = null)
				}
				has(n) {
					return this.init(), this.map.has(n)
				}
				get(n) {
					this.init()
					const e = this.map.get(n)
					return e ? e[0] : null
				}
				getAll(n) {
					return this.init(), this.map.get(n) || null
				}
				keys() {
					return this.init(), Array.from(this.map.keys())
				}
				append(n, e) {
					return this.clone({ param: n, value: e, op: "a" })
				}
				appendAll(n) {
					const e = []
					return (
						Object.keys(n).forEach(i => {
							const r = n[i]
							Array.isArray(r)
								? r.forEach(o => {
										e.push({ param: i, value: o, op: "a" })
								  })
								: e.push({ param: i, value: r, op: "a" })
						}),
						this.clone(e)
					)
				}
				set(n, e) {
					return this.clone({ param: n, value: e, op: "s" })
				}
				delete(n, e) {
					return this.clone({ param: n, value: e, op: "d" })
				}
				toString() {
					return (
						this.init(),
						this.keys()
							.map(n => {
								const e = this.encoder.encodeKey(n)
								return this.map
									.get(n)
									.map(i => e + "=" + this.encoder.encodeValue(i))
									.join("&")
							})
							.filter(n => "" !== n)
							.join("&")
					)
				}
				clone(n) {
					const e = new Ih({ encoder: this.encoder })
					return (e.cloneFrom = this.cloneFrom || this), (e.updates = (this.updates || []).concat(n)), e
				}
				init() {
					null === this.map && (this.map = new Map()),
						null !== this.cloneFrom &&
							(this.cloneFrom.init(),
							this.cloneFrom.keys().forEach(n => this.map.set(n, this.cloneFrom.map.get(n))),
							this.updates.forEach(n => {
								switch (n.op) {
									case "a":
									case "s":
										const e = ("a" === n.op ? this.map.get(n.param) : void 0) || []
										e.push(kC(n.value)), this.map.set(n.param, e)
										break
									case "d":
										if (void 0 === n.value) {
											this.map.delete(n.param)
											break
										}
										{
											let i = this.map.get(n.param) || []
											const r = i.indexOf(kC(n.value))
											;-1 !== r && i.splice(r, 1), i.length > 0 ? this.map.set(n.param, i) : this.map.delete(n.param)
										}
								}
							}),
							(this.cloneFrom = this.updates = null))
				}
			}
			class Sde {
				constructor() {
					this.map = new Map()
				}
				set(n, e) {
					return this.map.set(n, e), this
				}
				get(n) {
					return this.map.has(n) || this.map.set(n, n.defaultValue()), this.map.get(n)
				}
				delete(n) {
					return this.map.delete(n), this
				}
				has(n) {
					return this.map.has(n)
				}
				keys() {
					return this.map.keys()
				}
			}
			function Cz(t) {
				return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer
			}
			function Ez(t) {
				return typeof Blob < "u" && t instanceof Blob
			}
			function Mz(t) {
				return typeof FormData < "u" && t instanceof FormData
			}
			class S0 {
				constructor(n, e, i, r) {
					let o
					if (
						((this.url = e),
						(this.body = null),
						(this.reportProgress = !1),
						(this.withCredentials = !1),
						(this.responseType = "json"),
						(this.method = n.toUpperCase()),
						(function kde(t) {
							switch (t) {
								case "DELETE":
								case "GET":
								case "HEAD":
								case "OPTIONS":
								case "JSONP":
									return !1
								default:
									return !0
							}
						})(this.method) || r
							? ((this.body = void 0 !== i ? i : null), (o = r))
							: (o = i),
						o &&
							((this.reportProgress = !!o.reportProgress),
							(this.withCredentials = !!o.withCredentials),
							o.responseType && (this.responseType = o.responseType),
							o.headers && (this.headers = o.headers),
							o.context && (this.context = o.context),
							o.params && (this.params = o.params)),
						this.headers || (this.headers = new id()),
						this.context || (this.context = new Sde()),
						this.params)
					) {
						const s = this.params.toString()
						if (0 === s.length) this.urlWithParams = e
						else {
							const a = e.indexOf("?")
							this.urlWithParams = e + (-1 === a ? "?" : a < e.length - 1 ? "&" : "") + s
						}
					} else (this.params = new Ih()), (this.urlWithParams = e)
				}
				serializeBody() {
					return null === this.body
						? null
						: Cz(this.body) ||
						  Ez(this.body) ||
						  Mz(this.body) ||
						  (function Tde(t) {
								return typeof URLSearchParams < "u" && t instanceof URLSearchParams
						  })(this.body) ||
						  "string" == typeof this.body
						? this.body
						: this.body instanceof Ih
						? this.body.toString()
						: "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body)
						? JSON.stringify(this.body)
						: this.body.toString()
				}
				detectContentTypeHeader() {
					return null === this.body || Mz(this.body)
						? null
						: Ez(this.body)
						? this.body.type || null
						: Cz(this.body)
						? null
						: "string" == typeof this.body
						? "text/plain"
						: this.body instanceof Ih
						? "application/x-www-form-urlencoded;charset=UTF-8"
						: "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body
						? "application/json"
						: null
				}
				clone(n = {}) {
					const e = n.method || this.method,
						i = n.url || this.url,
						r = n.responseType || this.responseType,
						o = void 0 !== n.body ? n.body : this.body,
						s = void 0 !== n.withCredentials ? n.withCredentials : this.withCredentials,
						a = void 0 !== n.reportProgress ? n.reportProgress : this.reportProgress
					let c = n.headers || this.headers,
						l = n.params || this.params
					const d = n.context ?? this.context
					return (
						void 0 !== n.setHeaders && (c = Object.keys(n.setHeaders).reduce((u, h) => u.set(h, n.setHeaders[h]), c)),
						n.setParams && (l = Object.keys(n.setParams).reduce((u, h) => u.set(h, n.setParams[h]), l)),
						new S0(e, i, o, { params: l, headers: c, context: d, reportProgress: a, responseType: r, withCredentials: s })
					)
				}
			}
			var sg = (function (t) {
				return (
					(t[(t.Sent = 0)] = "Sent"),
					(t[(t.UploadProgress = 1)] = "UploadProgress"),
					(t[(t.ResponseHeader = 2)] = "ResponseHeader"),
					(t[(t.DownloadProgress = 3)] = "DownloadProgress"),
					(t[(t.Response = 4)] = "Response"),
					(t[(t.User = 5)] = "User"),
					t
				)
			})(sg || {})
			class Y2 {
				constructor(n, e = 200, i = "OK") {
					;(this.headers = n.headers || new id()),
						(this.status = void 0 !== n.status ? n.status : e),
						(this.statusText = n.statusText || i),
						(this.url = n.url || null),
						(this.ok = this.status >= 200 && this.status < 300)
				}
			}
			class q2 extends Y2 {
				constructor(n = {}) {
					super(n), (this.type = sg.ResponseHeader)
				}
				clone(n = {}) {
					return new q2({
						headers: n.headers || this.headers,
						status: void 0 !== n.status ? n.status : this.status,
						statusText: n.statusText || this.statusText,
						url: n.url || this.url || void 0
					})
				}
			}
			class ag extends Y2 {
				constructor(n = {}) {
					super(n), (this.type = sg.Response), (this.body = void 0 !== n.body ? n.body : null)
				}
				clone(n = {}) {
					return new ag({
						body: void 0 !== n.body ? n.body : this.body,
						headers: n.headers || this.headers,
						status: void 0 !== n.status ? n.status : this.status,
						statusText: n.statusText || this.statusText,
						url: n.url || this.url || void 0
					})
				}
			}
			class Sz extends Y2 {
				constructor(n) {
					super(n, 0, "Unknown Error"),
						(this.name = "HttpErrorResponse"),
						(this.ok = !1),
						(this.message =
							this.status >= 200 && this.status < 300
								? `Http failure during parsing for ${n.url || "(unknown url)"}`
								: `Http failure response for ${n.url || "(unknown url)"}: ${n.status} ${n.statusText}`),
						(this.error = n.error || null)
				}
			}
			function Z2(t, n) {
				return {
					body: n,
					headers: t.headers,
					context: t.context,
					observe: t.observe,
					params: t.params,
					reportProgress: t.reportProgress,
					responseType: t.responseType,
					withCredentials: t.withCredentials
				}
			}
			let J2 = (() => {
				class t {
					constructor(e) {
						this.handler = e
					}
					request(e, i, r = {}) {
						let o
						if (e instanceof S0) o = e
						else {
							let c, l
							;(c = r.headers instanceof id ? r.headers : new id(r.headers)),
								r.params && (l = r.params instanceof Ih ? r.params : new Ih({ fromObject: r.params })),
								(o = new S0(e, i, void 0 !== r.body ? r.body : null, {
									headers: c,
									context: r.context,
									params: l,
									reportProgress: r.reportProgress,
									responseType: r.responseType || "json",
									withCredentials: r.withCredentials
								}))
						}
						const s = Wo(o).pipe(
							(function wde(t, n) {
								return q(n) ? ir(t, n, 1) : ir(t, 1)
							})(c => this.handler.handle(c))
						)
						if (e instanceof S0 || "events" === r.observe) return s
						const a = s.pipe(xi(c => c instanceof ag))
						switch (r.observe || "body") {
							case "body":
								switch (o.responseType) {
									case "arraybuffer":
										return a.pipe(
											Ke(c => {
												if (null !== c.body && !(c.body instanceof ArrayBuffer))
													throw new Error("Response is not an ArrayBuffer.")
												return c.body
											})
										)
									case "blob":
										return a.pipe(
											Ke(c => {
												if (null !== c.body && !(c.body instanceof Blob)) throw new Error("Response is not a Blob.")
												return c.body
											})
										)
									case "text":
										return a.pipe(
											Ke(c => {
												if (null !== c.body && "string" != typeof c.body)
													throw new Error("Response is not a string.")
												return c.body
											})
										)
									default:
										return a.pipe(Ke(c => c.body))
								}
							case "response":
								return a
							default:
								throw new Error(`Unreachable: unhandled observe type ${r.observe}}`)
						}
					}
					delete(e, i = {}) {
						return this.request("DELETE", e, i)
					}
					get(e, i = {}) {
						return this.request("GET", e, i)
					}
					head(e, i = {}) {
						return this.request("HEAD", e, i)
					}
					jsonp(e, i) {
						return this.request("JSONP", e, {
							params: new Ih().append(i, "JSONP_CALLBACK"),
							observe: "body",
							responseType: "json"
						})
					}
					options(e, i = {}) {
						return this.request("OPTIONS", e, i)
					}
					patch(e, i, r = {}) {
						return this.request("PATCH", e, Z2(r, i))
					}
					post(e, i, r = {}) {
						return this.request("POST", e, Z2(r, i))
					}
					put(e, i, r = {}) {
						return this.request("PUT", e, Z2(r, i))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(MC))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			function Fz(t, n) {
				return n(t)
			}
			function Bde(t, n) {
				return (e, i) => n.intercept(e, { handle: r => t(r, i) })
			}
			const Dde = new He(""),
				k0 = new He(""),
				Bz = new He("")
			function Lde() {
				let t = null
				return (n, e) => {
					null === t && (t = (Rt(Dde, { optional: !0 }) ?? []).reduceRight(Bde, Fz))
					const i = Rt(s2),
						r = i.add()
					return t(n, e).pipe(wz(() => i.remove(r)))
				}
			}
			let Iz = (() => {
				class t extends MC {
					constructor(e, i) {
						super(), (this.backend = e), (this.injector = i), (this.chain = null), (this.pendingTasks = Rt(s2))
					}
					handle(e) {
						if (null === this.chain) {
							const r = Array.from(new Set([...this.injector.get(k0), ...this.injector.get(Bz, [])]))
							this.chain = r.reduceRight(
								(o, s) =>
									(function Ide(t, n, e) {
										return (i, r) => e.runInContext(() => n(i, o => t(o, r)))
									})(o, s, this.injector),
								Fz
							)
						}
						const i = this.pendingTasks.add()
						return this.chain(e, r => this.backend.handle(r)).pipe(wz(() => this.pendingTasks.remove(i)))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(SC), re(Yl))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const Nde = /^\)\]\}',?\n/
			let Lz = (() => {
				class t {
					constructor(e) {
						this.xhrFactory = e
					}
					handle(e) {
						if ("JSONP" === e.method) throw new ht(-2800, !1)
						const i = this.xhrFactory
						return (i.ɵloadImpl ? ro(i.ɵloadImpl()) : Wo(null)).pipe(
							ya(
								() =>
									new Ge(o => {
										const s = i.build()
										if (
											(s.open(e.method, e.urlWithParams),
											e.withCredentials && (s.withCredentials = !0),
											e.headers.forEach((y, C) => s.setRequestHeader(y, C.join(","))),
											e.headers.has("Accept") || s.setRequestHeader("Accept", "application/json, text/plain, */*"),
											!e.headers.has("Content-Type"))
										) {
											const y = e.detectContentTypeHeader()
											null !== y && s.setRequestHeader("Content-Type", y)
										}
										if (e.responseType) {
											const y = e.responseType.toLowerCase()
											s.responseType = "json" !== y ? y : "text"
										}
										const a = e.serializeBody()
										let c = null
										const l = () => {
												if (null !== c) return c
												const y = s.statusText || "OK",
													C = new id(s.getAllResponseHeaders()),
													x =
														(function Ude(t) {
															return "responseURL" in t && t.responseURL
																? t.responseURL
																: /^X-Request-URL:/m.test(t.getAllResponseHeaders())
																? t.getResponseHeader("X-Request-URL")
																: null
														})(s) || e.url
												return (c = new q2({ headers: C, status: s.status, statusText: y, url: x })), c
											},
											d = () => {
												let { headers: y, status: C, statusText: x, url: w } = l(),
													S = null
												204 !== C && (S = typeof s.response > "u" ? s.responseText : s.response),
													0 === C && (C = S ? 200 : 0)
												let M = C >= 200 && C < 300
												if ("json" === e.responseType && "string" == typeof S) {
													const O = S
													S = S.replace(Nde, "")
													try {
														S = "" !== S ? JSON.parse(S) : null
													} catch (N) {
														;(S = O), M && ((M = !1), (S = { error: N, text: S }))
													}
												}
												M
													? (o.next(new ag({ body: S, headers: y, status: C, statusText: x, url: w || void 0 })),
													  o.complete())
													: o.error(new Sz({ error: S, headers: y, status: C, statusText: x, url: w || void 0 }))
											},
											u = y => {
												const { url: C } = l(),
													x = new Sz({
														error: y,
														status: s.status || 0,
														statusText: s.statusText || "Unknown Error",
														url: C || void 0
													})
												o.error(x)
											}
										let h = !1
										const f = y => {
												h || (o.next(l()), (h = !0))
												let C = { type: sg.DownloadProgress, loaded: y.loaded }
												y.lengthComputable && (C.total = y.total),
													"text" === e.responseType && s.responseText && (C.partialText = s.responseText),
													o.next(C)
											},
											_ = y => {
												let C = { type: sg.UploadProgress, loaded: y.loaded }
												y.lengthComputable && (C.total = y.total), o.next(C)
											}
										return (
											s.addEventListener("load", d),
											s.addEventListener("error", u),
											s.addEventListener("timeout", u),
											s.addEventListener("abort", u),
											e.reportProgress &&
												(s.addEventListener("progress", f),
												null !== a && s.upload && s.upload.addEventListener("progress", _)),
											s.send(a),
											o.next({ type: sg.Sent }),
											() => {
												s.removeEventListener("error", u),
													s.removeEventListener("abort", u),
													s.removeEventListener("load", d),
													s.removeEventListener("timeout", u),
													e.reportProgress &&
														(s.removeEventListener("progress", f),
														null !== a && s.upload && s.upload.removeEventListener("progress", _)),
													s.readyState !== s.DONE && s.abort()
											}
										)
									})
							)
						)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(tz))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const eI = new He("XSRF_ENABLED"),
				Rz = new He("XSRF_COOKIE_NAME", { providedIn: "root", factory: () => "XSRF-TOKEN" }),
				Pz = new He("XSRF_HEADER_NAME", { providedIn: "root", factory: () => "X-XSRF-TOKEN" })
			class Oz {}
			let Qde = (() => {
				class t {
					constructor(e, i, r) {
						;(this.doc = e),
							(this.platform = i),
							(this.cookieName = r),
							(this.lastCookieString = ""),
							(this.lastToken = null),
							(this.parseCount = 0)
					}
					getToken() {
						if ("server" === this.platform) return null
						const e = this.doc.cookie || ""
						return (
							e !== this.lastCookieString &&
								(this.parseCount++, (this.lastToken = zQ(e, this.cookieName)), (this.lastCookieString = e)),
							this.lastToken
						)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(wi), re(Mh), re(Rz))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			function zde(t, n) {
				const e = t.url.toLowerCase()
				if (!Rt(eI) || "GET" === t.method || "HEAD" === t.method || e.startsWith("http://") || e.startsWith("https://")) return n(t)
				const i = Rt(Oz).getToken(),
					r = Rt(Pz)
				return null != i && !t.headers.has(r) && (t = t.clone({ headers: t.headers.set(r, i) })), n(t)
			}
			var Dh = (function (t) {
				return (
					(t[(t.Interceptors = 0)] = "Interceptors"),
					(t[(t.LegacyInterceptors = 1)] = "LegacyInterceptors"),
					(t[(t.CustomXsrfConfiguration = 2)] = "CustomXsrfConfiguration"),
					(t[(t.NoXsrfProtection = 3)] = "NoXsrfProtection"),
					(t[(t.JsonpSupport = 4)] = "JsonpSupport"),
					(t[(t.RequestsMadeViaParent = 5)] = "RequestsMadeViaParent"),
					(t[(t.Fetch = 6)] = "Fetch"),
					t
				)
			})(Dh || {})
			function Mm(t, n) {
				return { ɵkind: t, ɵproviders: n }
			}
			function Gde(...t) {
				const n = [
					J2,
					Lz,
					Iz,
					{ provide: MC, useExisting: Iz },
					{ provide: SC, useExisting: Lz },
					{ provide: k0, useValue: zde, multi: !0 },
					{ provide: eI, useValue: !0 },
					{ provide: Oz, useClass: Qde }
				]
				for (const e of t) n.push(...e.ɵproviders)
				return (function jF(t) {
					return { ɵproviders: t }
				})(n)
			}
			const Nz = new He("LEGACY_INTERCEPTOR_FN")
			let Wde = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({
							providers: [
								Gde(
									Mm(Dh.LegacyInterceptors, [
										{ provide: Nz, useFactory: Lde },
										{ provide: k0, useExisting: Nz, multi: !0 }
									])
								)
							]
						})
					}
				}
				return t
			})()
			const { isArray: Zde } = Array,
				{ getPrototypeOf: Jde, prototype: eue, keys: tue } = Object
			function Uz(t) {
				if (1 === t.length) {
					const n = t[0]
					if (Zde(n)) return { args: n, keys: null }
					if (
						(function nue(t) {
							return t && "object" == typeof t && Jde(t) === eue
						})(n)
					) {
						const e = tue(n)
						return { args: e.map(i => n[i]), keys: e }
					}
				}
				return { args: t, keys: null }
			}
			const { isArray: iue } = Array
			function tI(t) {
				return Ke(n =>
					(function rue(t, n) {
						return iue(n) ? t(...n) : t(n)
					})(t, n)
				)
			}
			function Hz(t, n) {
				return t.reduce((e, i, r) => ((e[i] = n[r]), e), {})
			}
			let Vz = (() => {
					class t {
						constructor(e, i) {
							;(this._renderer = e), (this._elementRef = i), (this.onChange = r => {}), (this.onTouched = () => {})
						}
						setProperty(e, i) {
							this._renderer.setProperty(this._elementRef.nativeElement, e, i)
						}
						registerOnTouched(e) {
							this.onTouched = e
						}
						registerOnChange(e) {
							this.onChange = e
						}
						setDisabledState(e) {
							this.setProperty("disabled", e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(pm), P(wn))
							}
						}
						static {
							this.ɵdir = yt({ type: t })
						}
					}
					return t
				})(),
				Sm = (() => {
					class t extends Vz {
						static {
							this.ɵfac = (function () {
								let e
								return function (r) {
									return (e || (e = gr(t)))(r || t)
								}
							})()
						}
						static {
							this.ɵdir = yt({ type: t, features: [pn] })
						}
					}
					return t
				})()
			const ds = new He("NgValueAccessor"),
				aue = { provide: ds, useExisting: Kn(() => km), multi: !0 },
				lue = new He("CompositionEventMode")
			let km = (() => {
				class t extends Vz {
					constructor(e, i, r) {
						super(e, i),
							(this._compositionMode = r),
							(this._composing = !1),
							null == this._compositionMode &&
								(this._compositionMode = !(function cue() {
									const t = Fh() ? Fh().getUserAgent() : ""
									return /android (\d+)/.test(t.toLowerCase())
								})())
					}
					writeValue(e) {
						this.setProperty("value", e ?? "")
					}
					_handleInput(e) {
						;(!this._compositionMode || (this._compositionMode && !this._composing)) && this.onChange(e)
					}
					_compositionStart() {
						this._composing = !0
					}
					_compositionEnd(e) {
						;(this._composing = !1), this._compositionMode && this.onChange(e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(pm), P(wn), P(lue, 8))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [
								["input", "formControlName", "", 3, "type", "checkbox"],
								["textarea", "formControlName", ""],
								["input", "formControl", "", 3, "type", "checkbox"],
								["textarea", "formControl", ""],
								["input", "ngModel", "", 3, "type", "checkbox"],
								["textarea", "ngModel", ""],
								["", "ngDefaultControl", ""]
							],
							hostBindings: function (i, r) {
								1 & i &&
									Le("input", function (s) {
										return r._handleInput(s.target.value)
									})("blur", function () {
										return r.onTouched()
									})("compositionstart", function () {
										return r._compositionStart()
									})("compositionend", function (s) {
										return r._compositionEnd(s.target.value)
									})
							},
							features: [Xn([aue]), pn]
						})
					}
				}
				return t
			})()
			function Lh(t) {
				return null == t || (("string" == typeof t || Array.isArray(t)) && 0 === t.length)
			}
			function zz(t) {
				return null != t && "number" == typeof t.length
			}
			const us = new He("NgValidators"),
				Rh = new He("NgAsyncValidators"),
				due =
					/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
			class nI {
				static min(n) {
					return (function Gz(t) {
						return n => {
							if (Lh(n.value) || Lh(t)) return null
							const e = parseFloat(n.value)
							return !isNaN(e) && e < t ? { min: { min: t, actual: n.value } } : null
						}
					})(n)
				}
				static max(n) {
					return (function $z(t) {
						return n => {
							if (Lh(n.value) || Lh(t)) return null
							const e = parseFloat(n.value)
							return !isNaN(e) && e > t ? { max: { max: t, actual: n.value } } : null
						}
					})(n)
				}
				static required(n) {
					return Wz(n)
				}
				static requiredTrue(n) {
					return (function jz(t) {
						return !0 === t.value ? null : { required: !0 }
					})(n)
				}
				static email(n) {
					return (function Kz(t) {
						return Lh(t.value) || due.test(t.value) ? null : { email: !0 }
					})(n)
				}
				static minLength(n) {
					return (function Xz(t) {
						return n =>
							Lh(n.value) || !zz(n.value)
								? null
								: n.value.length < t
								? { minlength: { requiredLength: t, actualLength: n.value.length } }
								: null
					})(n)
				}
				static maxLength(n) {
					return (function Yz(t) {
						return n =>
							zz(n.value) && n.value.length > t ? { maxlength: { requiredLength: t, actualLength: n.value.length } } : null
					})(n)
				}
				static pattern(n) {
					return (function qz(t) {
						if (!t) return FC
						let n, e
						return (
							"string" == typeof t
								? ((e = ""),
								  "^" !== t.charAt(0) && (e += "^"),
								  (e += t),
								  "$" !== t.charAt(t.length - 1) && (e += "$"),
								  (n = new RegExp(e)))
								: ((e = t.toString()), (n = t)),
							i => {
								if (Lh(i.value)) return null
								const r = i.value
								return n.test(r) ? null : { pattern: { requiredPattern: e, actualValue: r } }
							}
						)
					})(n)
				}
				static nullValidator(n) {
					return null
				}
				static compose(n) {
					return i8(n)
				}
				static composeAsync(n) {
					return r8(n)
				}
			}
			function Wz(t) {
				return Lh(t.value) ? { required: !0 } : null
			}
			function FC(t) {
				return null
			}
			function Zz(t) {
				return null != t
			}
			function Jz(t) {
				return X1(t) ? ro(t) : t
			}
			function e8(t) {
				let n = {}
				return (
					t.forEach(e => {
						n = null != e ? { ...n, ...e } : n
					}),
					0 === Object.keys(n).length ? null : n
				)
			}
			function t8(t, n) {
				return n.map(e => e(t))
			}
			function n8(t) {
				return t.map(n =>
					(function uue(t) {
						return !t.validate
					})(n)
						? n
						: e => n.validate(e)
				)
			}
			function i8(t) {
				if (!t) return null
				const n = t.filter(Zz)
				return 0 == n.length
					? null
					: function (e) {
							return e8(t8(e, n))
					  }
			}
			function iI(t) {
				return null != t ? i8(n8(t)) : null
			}
			function r8(t) {
				if (!t) return null
				const n = t.filter(Zz)
				return 0 == n.length
					? null
					: function (e) {
							return (function oue(...t) {
								const n = ko(t),
									{ args: e, keys: i } = Uz(t),
									r = new Ge(o => {
										const { length: s } = e
										if (!s) return void o.complete()
										const a = new Array(s)
										let c = s,
											l = s
										for (let d = 0; d < s; d++) {
											let u = !1
											_e(e[d]).subscribe(
												we(
													o,
													h => {
														u || ((u = !0), l--), (a[d] = h)
													},
													() => c--,
													void 0,
													() => {
														;(!c || !u) && (l || o.next(i ? Hz(i, a) : a), o.complete())
													}
												)
											)
										}
									})
								return n ? r.pipe(tI(n)) : r
							})(t8(e, n).map(Jz)).pipe(Ke(e8))
					  }
			}
			function rI(t) {
				return null != t ? r8(n8(t)) : null
			}
			function o8(t, n) {
				return null === t ? [n] : Array.isArray(t) ? [...t, n] : [t, n]
			}
			function s8(t) {
				return t._rawValidators
			}
			function a8(t) {
				return t._rawAsyncValidators
			}
			function oI(t) {
				return t ? (Array.isArray(t) ? t : [t]) : []
			}
			function BC(t, n) {
				return Array.isArray(t) ? t.includes(n) : t === n
			}
			function c8(t, n) {
				const e = oI(n)
				return (
					oI(t).forEach(r => {
						BC(e, r) || e.push(r)
					}),
					e
				)
			}
			function l8(t, n) {
				return oI(n).filter(e => !BC(t, e))
			}
			class d8 {
				constructor() {
					;(this._rawValidators = []), (this._rawAsyncValidators = []), (this._onDestroyCallbacks = [])
				}
				get value() {
					return this.control ? this.control.value : null
				}
				get valid() {
					return this.control ? this.control.valid : null
				}
				get invalid() {
					return this.control ? this.control.invalid : null
				}
				get pending() {
					return this.control ? this.control.pending : null
				}
				get disabled() {
					return this.control ? this.control.disabled : null
				}
				get enabled() {
					return this.control ? this.control.enabled : null
				}
				get errors() {
					return this.control ? this.control.errors : null
				}
				get pristine() {
					return this.control ? this.control.pristine : null
				}
				get dirty() {
					return this.control ? this.control.dirty : null
				}
				get touched() {
					return this.control ? this.control.touched : null
				}
				get status() {
					return this.control ? this.control.status : null
				}
				get untouched() {
					return this.control ? this.control.untouched : null
				}
				get statusChanges() {
					return this.control ? this.control.statusChanges : null
				}
				get valueChanges() {
					return this.control ? this.control.valueChanges : null
				}
				get path() {
					return null
				}
				_setValidators(n) {
					;(this._rawValidators = n || []), (this._composedValidatorFn = iI(this._rawValidators))
				}
				_setAsyncValidators(n) {
					;(this._rawAsyncValidators = n || []), (this._composedAsyncValidatorFn = rI(this._rawAsyncValidators))
				}
				get validator() {
					return this._composedValidatorFn || null
				}
				get asyncValidator() {
					return this._composedAsyncValidatorFn || null
				}
				_registerOnDestroy(n) {
					this._onDestroyCallbacks.push(n)
				}
				_invokeOnDestroyCallbacks() {
					this._onDestroyCallbacks.forEach(n => n()), (this._onDestroyCallbacks = [])
				}
				reset(n = void 0) {
					this.control && this.control.reset(n)
				}
				hasError(n, e) {
					return !!this.control && this.control.hasError(n, e)
				}
				getError(n, e) {
					return this.control ? this.control.getError(n, e) : null
				}
			}
			class ca extends d8 {
				get formDirective() {
					return null
				}
				get path() {
					return null
				}
			}
			class rd extends d8 {
				constructor() {
					super(...arguments), (this._parent = null), (this.name = null), (this.valueAccessor = null)
				}
			}
			class u8 {
				constructor(n) {
					this._cd = n
				}
				get isTouched() {
					return !!this._cd?.control?.touched
				}
				get isUntouched() {
					return !!this._cd?.control?.untouched
				}
				get isPristine() {
					return !!this._cd?.control?.pristine
				}
				get isDirty() {
					return !!this._cd?.control?.dirty
				}
				get isValid() {
					return !!this._cd?.control?.valid
				}
				get isInvalid() {
					return !!this._cd?.control?.invalid
				}
				get isPending() {
					return !!this._cd?.control?.pending
				}
				get isSubmitted() {
					return !!this._cd?.submitted
				}
			}
			let T0 = (() => {
				class t extends u8 {
					constructor(e) {
						super(e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(rd, 2))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [
								["", "formControlName", ""],
								["", "ngModel", ""],
								["", "formControl", ""]
							],
							hostVars: 14,
							hostBindings: function (i, r) {
								2 & i &&
									Zt("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)(
										"ng-dirty",
										r.isDirty
									)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending)
							},
							features: [pn]
						})
					}
				}
				return t
			})()
			const F0 = "VALID",
				DC = "INVALID",
				cg = "PENDING",
				B0 = "DISABLED"
			function cI(t) {
				return (LC(t) ? t.validators : t) || null
			}
			function lI(t, n) {
				return (LC(n) ? n.asyncValidators : t) || null
			}
			function LC(t) {
				return null != t && !Array.isArray(t) && "object" == typeof t
			}
			class p8 {
				constructor(n, e) {
					;(this._pendingDirty = !1),
						(this._hasOwnPendingAsyncValidator = !1),
						(this._pendingTouched = !1),
						(this._onCollectionChange = () => {}),
						(this._parent = null),
						(this.pristine = !0),
						(this.touched = !1),
						(this._onDisabledChange = []),
						this._assignValidators(n),
						this._assignAsyncValidators(e)
				}
				get validator() {
					return this._composedValidatorFn
				}
				set validator(n) {
					this._rawValidators = this._composedValidatorFn = n
				}
				get asyncValidator() {
					return this._composedAsyncValidatorFn
				}
				set asyncValidator(n) {
					this._rawAsyncValidators = this._composedAsyncValidatorFn = n
				}
				get parent() {
					return this._parent
				}
				get valid() {
					return this.status === F0
				}
				get invalid() {
					return this.status === DC
				}
				get pending() {
					return this.status == cg
				}
				get disabled() {
					return this.status === B0
				}
				get enabled() {
					return this.status !== B0
				}
				get dirty() {
					return !this.pristine
				}
				get untouched() {
					return !this.touched
				}
				get updateOn() {
					return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change"
				}
				setValidators(n) {
					this._assignValidators(n)
				}
				setAsyncValidators(n) {
					this._assignAsyncValidators(n)
				}
				addValidators(n) {
					this.setValidators(c8(n, this._rawValidators))
				}
				addAsyncValidators(n) {
					this.setAsyncValidators(c8(n, this._rawAsyncValidators))
				}
				removeValidators(n) {
					this.setValidators(l8(n, this._rawValidators))
				}
				removeAsyncValidators(n) {
					this.setAsyncValidators(l8(n, this._rawAsyncValidators))
				}
				hasValidator(n) {
					return BC(this._rawValidators, n)
				}
				hasAsyncValidator(n) {
					return BC(this._rawAsyncValidators, n)
				}
				clearValidators() {
					this.validator = null
				}
				clearAsyncValidators() {
					this.asyncValidator = null
				}
				markAsTouched(n = {}) {
					;(this.touched = !0), this._parent && !n.onlySelf && this._parent.markAsTouched(n)
				}
				markAllAsTouched() {
					this.markAsTouched({ onlySelf: !0 }), this._forEachChild(n => n.markAllAsTouched())
				}
				markAsUntouched(n = {}) {
					;(this.touched = !1),
						(this._pendingTouched = !1),
						this._forEachChild(e => {
							e.markAsUntouched({ onlySelf: !0 })
						}),
						this._parent && !n.onlySelf && this._parent._updateTouched(n)
				}
				markAsDirty(n = {}) {
					;(this.pristine = !1), this._parent && !n.onlySelf && this._parent.markAsDirty(n)
				}
				markAsPristine(n = {}) {
					;(this.pristine = !0),
						(this._pendingDirty = !1),
						this._forEachChild(e => {
							e.markAsPristine({ onlySelf: !0 })
						}),
						this._parent && !n.onlySelf && this._parent._updatePristine(n)
				}
				markAsPending(n = {}) {
					;(this.status = cg),
						!1 !== n.emitEvent && this.statusChanges.emit(this.status),
						this._parent && !n.onlySelf && this._parent.markAsPending(n)
				}
				disable(n = {}) {
					const e = this._parentMarkedDirty(n.onlySelf)
					;(this.status = B0),
						(this.errors = null),
						this._forEachChild(i => {
							i.disable({ ...n, onlySelf: !0 })
						}),
						this._updateValue(),
						!1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)),
						this._updateAncestors({ ...n, skipPristineCheck: e }),
						this._onDisabledChange.forEach(i => i(!0))
				}
				enable(n = {}) {
					const e = this._parentMarkedDirty(n.onlySelf)
					;(this.status = F0),
						this._forEachChild(i => {
							i.enable({ ...n, onlySelf: !0 })
						}),
						this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }),
						this._updateAncestors({ ...n, skipPristineCheck: e }),
						this._onDisabledChange.forEach(i => i(!1))
				}
				_updateAncestors(n) {
					this._parent &&
						!n.onlySelf &&
						(this._parent.updateValueAndValidity(n),
						n.skipPristineCheck || this._parent._updatePristine(),
						this._parent._updateTouched())
				}
				setParent(n) {
					this._parent = n
				}
				getRawValue() {
					return this.value
				}
				updateValueAndValidity(n = {}) {
					this._setInitialStatus(),
						this._updateValue(),
						this.enabled &&
							(this._cancelExistingSubscription(),
							(this.errors = this._runValidator()),
							(this.status = this._calculateStatus()),
							(this.status === F0 || this.status === cg) && this._runAsyncValidator(n.emitEvent)),
						!1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)),
						this._parent && !n.onlySelf && this._parent.updateValueAndValidity(n)
				}
				_updateTreeValidity(n = { emitEvent: !0 }) {
					this._forEachChild(e => e._updateTreeValidity(n)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent })
				}
				_setInitialStatus() {
					this.status = this._allControlsDisabled() ? B0 : F0
				}
				_runValidator() {
					return this.validator ? this.validator(this) : null
				}
				_runAsyncValidator(n) {
					if (this.asyncValidator) {
						;(this.status = cg), (this._hasOwnPendingAsyncValidator = !0)
						const e = Jz(this.asyncValidator(this))
						this._asyncValidationSubscription = e.subscribe(i => {
							;(this._hasOwnPendingAsyncValidator = !1), this.setErrors(i, { emitEvent: n })
						})
					}
				}
				_cancelExistingSubscription() {
					this._asyncValidationSubscription &&
						(this._asyncValidationSubscription.unsubscribe(), (this._hasOwnPendingAsyncValidator = !1))
				}
				setErrors(n, e = {}) {
					;(this.errors = n), this._updateControlsErrors(!1 !== e.emitEvent)
				}
				get(n) {
					let e = n
					return null == e || (Array.isArray(e) || (e = e.split(".")), 0 === e.length)
						? null
						: e.reduce((i, r) => i && i._find(r), this)
				}
				getError(n, e) {
					const i = e ? this.get(e) : this
					return i && i.errors ? i.errors[n] : null
				}
				hasError(n, e) {
					return !!this.getError(n, e)
				}
				get root() {
					let n = this
					for (; n._parent; ) n = n._parent
					return n
				}
				_updateControlsErrors(n) {
					;(this.status = this._calculateStatus()),
						n && this.statusChanges.emit(this.status),
						this._parent && this._parent._updateControlsErrors(n)
				}
				_initObservables() {
					;(this.valueChanges = new _n()), (this.statusChanges = new _n())
				}
				_calculateStatus() {
					return this._allControlsDisabled()
						? B0
						: this.errors
						? DC
						: this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(cg)
						? cg
						: this._anyControlsHaveStatus(DC)
						? DC
						: F0
				}
				_anyControlsHaveStatus(n) {
					return this._anyControls(e => e.status === n)
				}
				_anyControlsDirty() {
					return this._anyControls(n => n.dirty)
				}
				_anyControlsTouched() {
					return this._anyControls(n => n.touched)
				}
				_updatePristine(n = {}) {
					;(this.pristine = !this._anyControlsDirty()), this._parent && !n.onlySelf && this._parent._updatePristine(n)
				}
				_updateTouched(n = {}) {
					;(this.touched = this._anyControlsTouched()), this._parent && !n.onlySelf && this._parent._updateTouched(n)
				}
				_registerOnCollectionChange(n) {
					this._onCollectionChange = n
				}
				_setUpdateStrategy(n) {
					LC(n) && null != n.updateOn && (this._updateOn = n.updateOn)
				}
				_parentMarkedDirty(n) {
					return !n && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty()
				}
				_find(n) {
					return null
				}
				_assignValidators(n) {
					;(this._rawValidators = Array.isArray(n) ? n.slice() : n),
						(this._composedValidatorFn = (function Aue(t) {
							return Array.isArray(t) ? iI(t) : t || null
						})(this._rawValidators))
				}
				_assignAsyncValidators(n) {
					;(this._rawAsyncValidators = Array.isArray(n) ? n.slice() : n),
						(this._composedAsyncValidatorFn = (function gue(t) {
							return Array.isArray(t) ? rI(t) : t || null
						})(this._rawAsyncValidators))
				}
			}
			class dI extends p8 {
				constructor(n, e, i) {
					super(cI(e), lI(i, e)),
						(this.controls = n),
						this._initObservables(),
						this._setUpdateStrategy(e),
						this._setUpControls(),
						this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator })
				}
				registerControl(n, e) {
					return this.controls[n]
						? this.controls[n]
						: ((this.controls[n] = e), e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e)
				}
				addControl(n, e, i = {}) {
					this.registerControl(n, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange()
				}
				removeControl(n, e = {}) {
					this.controls[n] && this.controls[n]._registerOnCollectionChange(() => {}),
						delete this.controls[n],
						this.updateValueAndValidity({ emitEvent: e.emitEvent }),
						this._onCollectionChange()
				}
				setControl(n, e, i = {}) {
					this.controls[n] && this.controls[n]._registerOnCollectionChange(() => {}),
						delete this.controls[n],
						e && this.registerControl(n, e),
						this.updateValueAndValidity({ emitEvent: i.emitEvent }),
						this._onCollectionChange()
				}
				contains(n) {
					return this.controls.hasOwnProperty(n) && this.controls[n].enabled
				}
				setValue(n, e = {}) {
					;(function m8(t, n, e) {
						t._forEachChild((i, r) => {
							if (void 0 === e[r]) throw new ht(1002, "")
						})
					})(this, 0, n),
						Object.keys(n).forEach(i => {
							;(function f8(t, n, e) {
								const i = t.controls
								if (!(n ? Object.keys(i) : i).length) throw new ht(1e3, "")
								if (!i[e]) throw new ht(1001, "")
							})(this, !0, i),
								this.controls[i].setValue(n[i], { onlySelf: !0, emitEvent: e.emitEvent })
						}),
						this.updateValueAndValidity(e)
				}
				patchValue(n, e = {}) {
					null != n &&
						(Object.keys(n).forEach(i => {
							const r = this.controls[i]
							r && r.patchValue(n[i], { onlySelf: !0, emitEvent: e.emitEvent })
						}),
						this.updateValueAndValidity(e))
				}
				reset(n = {}, e = {}) {
					this._forEachChild((i, r) => {
						i.reset(n ? n[r] : null, { onlySelf: !0, emitEvent: e.emitEvent })
					}),
						this._updatePristine(e),
						this._updateTouched(e),
						this.updateValueAndValidity(e)
				}
				getRawValue() {
					return this._reduceChildren({}, (n, e, i) => ((n[i] = e.getRawValue()), n))
				}
				_syncPendingControls() {
					let n = this._reduceChildren(!1, (e, i) => !!i._syncPendingControls() || e)
					return n && this.updateValueAndValidity({ onlySelf: !0 }), n
				}
				_forEachChild(n) {
					Object.keys(this.controls).forEach(e => {
						const i = this.controls[e]
						i && n(i, e)
					})
				}
				_setUpControls() {
					this._forEachChild(n => {
						n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange)
					})
				}
				_updateValue() {
					this.value = this._reduceValue()
				}
				_anyControls(n) {
					for (const [e, i] of Object.entries(this.controls)) if (this.contains(e) && n(i)) return !0
					return !1
				}
				_reduceValue() {
					return this._reduceChildren({}, (e, i, r) => ((i.enabled || this.disabled) && (e[r] = i.value), e))
				}
				_reduceChildren(n, e) {
					let i = n
					return (
						this._forEachChild((r, o) => {
							i = e(i, r, o)
						}),
						i
					)
				}
				_allControlsDisabled() {
					for (const n of Object.keys(this.controls)) if (this.controls[n].enabled) return !1
					return Object.keys(this.controls).length > 0 || this.disabled
				}
				_find(n) {
					return this.controls.hasOwnProperty(n) ? this.controls[n] : null
				}
			}
			const Tm = new He("CallSetDisabledState", { providedIn: "root", factory: () => I0 }),
				I0 = "always"
			function D0(t, n, e = I0) {
				uI(t, n),
					n.valueAccessor.writeValue(t.value),
					(t.disabled || "always" === e) && n.valueAccessor.setDisabledState?.(t.disabled),
					(function vue(t, n) {
						n.valueAccessor.registerOnChange(e => {
							;(t._pendingValue = e), (t._pendingChange = !0), (t._pendingDirty = !0), "change" === t.updateOn && A8(t, n)
						})
					})(t, n),
					(function wue(t, n) {
						const e = (i, r) => {
							n.valueAccessor.writeValue(i), r && n.viewToModelUpdate(i)
						}
						t.registerOnChange(e),
							n._registerOnDestroy(() => {
								t._unregisterOnChange(e)
							})
					})(t, n),
					(function yue(t, n) {
						n.valueAccessor.registerOnTouched(() => {
							;(t._pendingTouched = !0),
								"blur" === t.updateOn && t._pendingChange && A8(t, n),
								"submit" !== t.updateOn && t.markAsTouched()
						})
					})(t, n),
					(function _ue(t, n) {
						if (n.valueAccessor.setDisabledState) {
							const e = i => {
								n.valueAccessor.setDisabledState(i)
							}
							t.registerOnDisabledChange(e),
								n._registerOnDestroy(() => {
									t._unregisterOnDisabledChange(e)
								})
						}
					})(t, n)
			}
			function PC(t, n, e = !0) {
				const i = () => {}
				n.valueAccessor && (n.valueAccessor.registerOnChange(i), n.valueAccessor.registerOnTouched(i)),
					NC(t, n),
					t && (n._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => {}))
			}
			function OC(t, n) {
				t.forEach(e => {
					e.registerOnValidatorChange && e.registerOnValidatorChange(n)
				})
			}
			function uI(t, n) {
				const e = s8(t)
				null !== n.validator ? t.setValidators(o8(e, n.validator)) : "function" == typeof e && t.setValidators([e])
				const i = a8(t)
				null !== n.asyncValidator
					? t.setAsyncValidators(o8(i, n.asyncValidator))
					: "function" == typeof i && t.setAsyncValidators([i])
				const r = () => t.updateValueAndValidity()
				OC(n._rawValidators, r), OC(n._rawAsyncValidators, r)
			}
			function NC(t, n) {
				let e = !1
				if (null !== t) {
					if (null !== n.validator) {
						const r = s8(t)
						if (Array.isArray(r) && r.length > 0) {
							const o = r.filter(s => s !== n.validator)
							o.length !== r.length && ((e = !0), t.setValidators(o))
						}
					}
					if (null !== n.asyncValidator) {
						const r = a8(t)
						if (Array.isArray(r) && r.length > 0) {
							const o = r.filter(s => s !== n.asyncValidator)
							o.length !== r.length && ((e = !0), t.setAsyncValidators(o))
						}
					}
				}
				const i = () => {}
				return OC(n._rawValidators, i), OC(n._rawAsyncValidators, i), e
			}
			function A8(t, n) {
				t._pendingDirty && t.markAsDirty(),
					t.setValue(t._pendingValue, { emitModelToViewChange: !1 }),
					n.viewToModelUpdate(t._pendingValue),
					(t._pendingChange = !1)
			}
			function g8(t, n) {
				uI(t, n)
			}
			function fI(t, n) {
				if (!t.hasOwnProperty("model")) return !1
				const e = t.model
				return !!e.isFirstChange() || !Object.is(n, e.currentValue)
			}
			function b8(t, n) {
				t._syncPendingControls(),
					n.forEach(e => {
						const i = e.control
						"submit" === i.updateOn && i._pendingChange && (e.viewToModelUpdate(i._pendingValue), (i._pendingChange = !1))
					})
			}
			function mI(t, n) {
				if (!n) return null
				let e, i, r
				return (
					Array.isArray(n),
					n.forEach(o => {
						o.constructor === km
							? (e = o)
							: (function Eue(t) {
									return Object.getPrototypeOf(t.constructor) === Sm
							  })(o)
							? (i = o)
							: (r = o)
					}),
					r || i || e || null
				)
			}
			const Sue = { provide: ca, useExisting: Kn(() => R0) },
				L0 = (() => Promise.resolve())()
			let R0 = (() => {
				class t extends ca {
					constructor(e, i, r) {
						super(),
							(this.callSetDisabledState = r),
							(this.submitted = !1),
							(this._directives = new Set()),
							(this.ngSubmit = new _n()),
							(this.form = new dI({}, iI(e), rI(i)))
					}
					ngAfterViewInit() {
						this._setUpdateStrategy()
					}
					get formDirective() {
						return this
					}
					get control() {
						return this.form
					}
					get path() {
						return []
					}
					get controls() {
						return this.form.controls
					}
					addControl(e) {
						L0.then(() => {
							const i = this._findContainer(e.path)
							;(e.control = i.registerControl(e.name, e.control)),
								D0(e.control, e, this.callSetDisabledState),
								e.control.updateValueAndValidity({ emitEvent: !1 }),
								this._directives.add(e)
						})
					}
					getControl(e) {
						return this.form.get(e.path)
					}
					removeControl(e) {
						L0.then(() => {
							const i = this._findContainer(e.path)
							i && i.removeControl(e.name), this._directives.delete(e)
						})
					}
					addFormGroup(e) {
						L0.then(() => {
							const i = this._findContainer(e.path),
								r = new dI({})
							g8(r, e), i.registerControl(e.name, r), r.updateValueAndValidity({ emitEvent: !1 })
						})
					}
					removeFormGroup(e) {
						L0.then(() => {
							const i = this._findContainer(e.path)
							i && i.removeControl(e.name)
						})
					}
					getFormGroup(e) {
						return this.form.get(e.path)
					}
					updateModel(e, i) {
						L0.then(() => {
							this.form.get(e.path).setValue(i)
						})
					}
					setValue(e) {
						this.control.setValue(e)
					}
					onSubmit(e) {
						return (this.submitted = !0), b8(this.form, this._directives), this.ngSubmit.emit(e), "dialog" === e?.target?.method
					}
					onReset() {
						this.resetForm()
					}
					resetForm(e = void 0) {
						this.form.reset(e), (this.submitted = !1)
					}
					_setUpdateStrategy() {
						this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn)
					}
					_findContainer(e) {
						return e.pop(), e.length ? this.form.get(e) : this.form
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(us, 10), P(Rh, 10), P(Tm, 8))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
							hostBindings: function (i, r) {
								1 & i &&
									Le("submit", function (s) {
										return r.onSubmit(s)
									})("reset", function () {
										return r.onReset()
									})
							},
							inputs: { options: ["ngFormOptions", "options"] },
							outputs: { ngSubmit: "ngSubmit" },
							exportAs: ["ngForm"],
							features: [Xn([Sue]), pn]
						})
					}
				}
				return t
			})()
			function _8(t, n) {
				const e = t.indexOf(n)
				e > -1 && t.splice(e, 1)
			}
			function v8(t) {
				return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t
			}
			const pI = class extends p8 {
					constructor(n = null, e, i) {
						super(cI(e), lI(i, e)),
							(this.defaultValue = null),
							(this._onChange = []),
							(this._pendingChange = !1),
							this._applyFormState(n),
							this._setUpdateStrategy(e),
							this._initObservables(),
							this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }),
							LC(e) && (e.nonNullable || e.initialValueIsDefault) && (this.defaultValue = v8(n) ? n.value : n)
					}
					setValue(n, e = {}) {
						;(this.value = this._pendingValue = n),
							this._onChange.length &&
								!1 !== e.emitModelToViewChange &&
								this._onChange.forEach(i => i(this.value, !1 !== e.emitViewToModelChange)),
							this.updateValueAndValidity(e)
					}
					patchValue(n, e = {}) {
						this.setValue(n, e)
					}
					reset(n = this.defaultValue, e = {}) {
						this._applyFormState(n),
							this.markAsPristine(e),
							this.markAsUntouched(e),
							this.setValue(this.value, e),
							(this._pendingChange = !1)
					}
					_updateValue() {}
					_anyControls(n) {
						return !1
					}
					_allControlsDisabled() {
						return this.disabled
					}
					registerOnChange(n) {
						this._onChange.push(n)
					}
					_unregisterOnChange(n) {
						_8(this._onChange, n)
					}
					registerOnDisabledChange(n) {
						this._onDisabledChange.push(n)
					}
					_unregisterOnDisabledChange(n) {
						_8(this._onDisabledChange, n)
					}
					_forEachChild(n) {}
					_syncPendingControls() {
						return !(
							"submit" !== this.updateOn ||
							(this._pendingDirty && this.markAsDirty(),
							this._pendingTouched && this.markAsTouched(),
							!this._pendingChange) ||
							(this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)
						)
					}
					_applyFormState(n) {
						v8(n)
							? ((this.value = this._pendingValue = n.value),
							  n.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 }))
							: (this.value = this._pendingValue = n)
					}
				},
				y8 = pI,
				Fue = { provide: rd, useExisting: Kn(() => P0) },
				C8 = (() => Promise.resolve())()
			let P0 = (() => {
					class t extends rd {
						constructor(e, i, r, o, s, a) {
							super(),
								(this._changeDetectorRef = s),
								(this.callSetDisabledState = a),
								(this.control = new pI()),
								(this._registered = !1),
								(this.name = ""),
								(this.update = new _n()),
								(this._parent = e),
								this._setValidators(i),
								this._setAsyncValidators(r),
								(this.valueAccessor = mI(0, o))
						}
						ngOnChanges(e) {
							if ((this._checkForErrors(), !this._registered || "name" in e)) {
								if (this._registered && (this._checkName(), this.formDirective)) {
									const i = e.name.previousValue
									this.formDirective.removeControl({ name: i, path: this._getPath(i) })
								}
								this._setUpControl()
							}
							"isDisabled" in e && this._updateDisabled(e),
								fI(e, this.viewModel) && (this._updateValue(this.model), (this.viewModel = this.model))
						}
						ngOnDestroy() {
							this.formDirective && this.formDirective.removeControl(this)
						}
						get path() {
							return this._getPath(this.name)
						}
						get formDirective() {
							return this._parent ? this._parent.formDirective : null
						}
						viewToModelUpdate(e) {
							;(this.viewModel = e), this.update.emit(e)
						}
						_setUpControl() {
							this._setUpdateStrategy(),
								this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this),
								(this._registered = !0)
						}
						_setUpdateStrategy() {
							this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn)
						}
						_isStandalone() {
							return !this._parent || !(!this.options || !this.options.standalone)
						}
						_setUpStandalone() {
							D0(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 })
						}
						_checkForErrors() {
							this._isStandalone() || this._checkParentType(), this._checkName()
						}
						_checkParentType() {}
						_checkName() {
							this.options && this.options.name && (this.name = this.options.name), this._isStandalone()
						}
						_updateValue(e) {
							C8.then(() => {
								this.control.setValue(e, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck()
							})
						}
						_updateDisabled(e) {
							const i = e.isDisabled.currentValue,
								r = 0 !== i && v2(i)
							C8.then(() => {
								r && !this.control.disabled ? this.control.disable() : !r && this.control.disabled && this.control.enable(),
									this._changeDetectorRef?.markForCheck()
							})
						}
						_getPath(e) {
							return this._parent
								? (function RC(t, n) {
										return [...n.path, t]
								  })(e, this._parent)
								: [e]
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(ca, 9), P(us, 10), P(Rh, 10), P(ds, 10), P(Jr, 8), P(Tm, 8))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
								inputs: {
									name: "name",
									isDisabled: ["disabled", "isDisabled"],
									model: ["ngModel", "model"],
									options: ["ngModelOptions", "options"]
								},
								outputs: { update: "ngModelChange" },
								exportAs: ["ngModel"],
								features: [Xn([Fue]), pn, Ar]
							})
						}
					}
					return t
				})(),
				M8 = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})()
			const AI = new He("NgModelWithFormControlWarning"),
				Pue = { provide: rd, useExisting: Kn(() => UC) }
			let UC = (() => {
				class t extends rd {
					set isDisabled(e) {}
					static {
						this._ngModelWarningSentOnce = !1
					}
					constructor(e, i, r, o, s) {
						super(),
							(this._ngModelWarningConfig = o),
							(this.callSetDisabledState = s),
							(this.update = new _n()),
							(this._ngModelWarningSent = !1),
							this._setValidators(e),
							this._setAsyncValidators(i),
							(this.valueAccessor = mI(0, r))
					}
					ngOnChanges(e) {
						if (this._isControlChanged(e)) {
							const i = e.form.previousValue
							i && PC(i, this, !1),
								D0(this.form, this, this.callSetDisabledState),
								this.form.updateValueAndValidity({ emitEvent: !1 })
						}
						fI(e, this.viewModel) && (this.form.setValue(this.model), (this.viewModel = this.model))
					}
					ngOnDestroy() {
						this.form && PC(this.form, this, !1)
					}
					get path() {
						return []
					}
					get control() {
						return this.form
					}
					viewToModelUpdate(e) {
						;(this.viewModel = e), this.update.emit(e)
					}
					_isControlChanged(e) {
						return e.hasOwnProperty("form")
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(us, 10), P(Rh, 10), P(ds, 10), P(AI, 8), P(Tm, 8))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [["", "formControl", ""]],
							inputs: { form: ["formControl", "form"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] },
							outputs: { update: "ngModelChange" },
							exportAs: ["ngForm"],
							features: [Xn([Pue]), pn, Ar]
						})
					}
				}
				return t
			})()
			const Oue = { provide: ca, useExisting: Kn(() => O0) }
			let O0 = (() => {
					class t extends ca {
						constructor(e, i, r) {
							super(),
								(this.callSetDisabledState = r),
								(this.submitted = !1),
								(this._onCollectionChange = () => this._updateDomValue()),
								(this.directives = []),
								(this.form = null),
								(this.ngSubmit = new _n()),
								this._setValidators(e),
								this._setAsyncValidators(i)
						}
						ngOnChanges(e) {
							this._checkFormPresent(),
								e.hasOwnProperty("form") &&
									(this._updateValidators(),
									this._updateDomValue(),
									this._updateRegistrations(),
									(this._oldForm = this.form))
						}
						ngOnDestroy() {
							this.form &&
								(NC(this.form, this),
								this.form._onCollectionChange === this._onCollectionChange &&
									this.form._registerOnCollectionChange(() => {}))
						}
						get formDirective() {
							return this
						}
						get control() {
							return this.form
						}
						get path() {
							return []
						}
						addControl(e) {
							const i = this.form.get(e.path)
							return (
								D0(i, e, this.callSetDisabledState), i.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(e), i
							)
						}
						getControl(e) {
							return this.form.get(e.path)
						}
						removeControl(e) {
							PC(e.control || null, e, !1),
								(function Mue(t, n) {
									const e = t.indexOf(n)
									e > -1 && t.splice(e, 1)
								})(this.directives, e)
						}
						addFormGroup(e) {
							this._setUpFormContainer(e)
						}
						removeFormGroup(e) {
							this._cleanUpFormContainer(e)
						}
						getFormGroup(e) {
							return this.form.get(e.path)
						}
						addFormArray(e) {
							this._setUpFormContainer(e)
						}
						removeFormArray(e) {
							this._cleanUpFormContainer(e)
						}
						getFormArray(e) {
							return this.form.get(e.path)
						}
						updateModel(e, i) {
							this.form.get(e.path).setValue(i)
						}
						onSubmit(e) {
							return (
								(this.submitted = !0), b8(this.form, this.directives), this.ngSubmit.emit(e), "dialog" === e?.target?.method
							)
						}
						onReset() {
							this.resetForm()
						}
						resetForm(e = void 0) {
							this.form.reset(e), (this.submitted = !1)
						}
						_updateDomValue() {
							this.directives.forEach(e => {
								const i = e.control,
									r = this.form.get(e.path)
								i !== r &&
									(PC(i || null, e), (t => t instanceof pI)(r) && (D0(r, e, this.callSetDisabledState), (e.control = r)))
							}),
								this.form._updateTreeValidity({ emitEvent: !1 })
						}
						_setUpFormContainer(e) {
							const i = this.form.get(e.path)
							g8(i, e), i.updateValueAndValidity({ emitEvent: !1 })
						}
						_cleanUpFormContainer(e) {
							if (this.form) {
								const i = this.form.get(e.path)
								i &&
									(function xue(t, n) {
										return NC(t, n)
									})(i, e) &&
									i.updateValueAndValidity({ emitEvent: !1 })
							}
						}
						_updateRegistrations() {
							this.form._registerOnCollectionChange(this._onCollectionChange),
								this._oldForm && this._oldForm._registerOnCollectionChange(() => {})
						}
						_updateValidators() {
							uI(this.form, this), this._oldForm && NC(this._oldForm, this)
						}
						_checkFormPresent() {}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(us, 10), P(Rh, 10), P(Tm, 8))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "formGroup", ""]],
								hostBindings: function (i, r) {
									1 & i &&
										Le("submit", function (s) {
											return r.onSubmit(s)
										})("reset", function () {
											return r.onReset()
										})
								},
								inputs: { form: ["formGroup", "form"] },
								outputs: { ngSubmit: "ngSubmit" },
								exportAs: ["ngForm"],
								features: [Xn([Oue]), pn, Ar]
							})
						}
					}
					return t
				})(),
				Fm = (() => {
					class t {
						constructor() {
							this._validator = FC
						}
						ngOnChanges(e) {
							if (this.inputName in e) {
								const i = this.normalizeInput(e[this.inputName].currentValue)
								;(this._enabled = this.enabled(i)),
									(this._validator = this._enabled ? this.createValidator(i) : FC),
									this._onChange && this._onChange()
							}
						}
						validate(e) {
							return this._validator(e)
						}
						registerOnValidatorChange(e) {
							this._onChange = e
						}
						enabled(e) {
							return null != e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({ type: t, features: [Ar] })
						}
					}
					return t
				})()
			const Xue = { provide: us, useExisting: Kn(() => HC), multi: !0 }
			let HC = (() => {
					class t extends Fm {
						constructor() {
							super(...arguments), (this.inputName = "required"), (this.normalizeInput = v2), (this.createValidator = e => Wz)
						}
						enabled(e) {
							return e
						}
						static {
							this.ɵfac = (function () {
								let e
								return function (r) {
									return (e || (e = gr(t)))(r || t)
								}
							})()
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [
									["", "required", "", "formControlName", "", 3, "type", "checkbox"],
									["", "required", "", "formControl", "", 3, "type", "checkbox"],
									["", "required", "", "ngModel", "", 3, "type", "checkbox"]
								],
								hostVars: 1,
								hostBindings: function (i, r) {
									2 & i && qn("required", r._enabled ? "" : null)
								},
								inputs: { required: "required" },
								features: [Xn([Xue]), pn]
							})
						}
					}
					return t
				})(),
				V8 = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [M8] })
						}
					}
					return t
				})(),
				od = (() => {
					class t {
						static withConfig(e) {
							return { ngModule: t, providers: [{ provide: Tm, useValue: e.callSetDisabledState ?? I0 }] }
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [V8] })
						}
					}
					return t
				})(),
				N0 = (() => {
					class t {
						static withConfig(e) {
							return {
								ngModule: t,
								providers: [
									{ provide: AI, useValue: e.warnOnNgModelWithFormControl ?? "always" },
									{ provide: Tm, useValue: e.callSetDisabledState ?? I0 }
								]
							}
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [V8] })
						}
					}
					return t
				})()
			function Q8() {
				return Wt((t, n) => {
					t.subscribe(we(n, G))
				})
			}
			class fu {
				constructor(n, e, i) {
					;(this.kind = n), (this.value = e), (this.error = i), (this.hasValue = "N" === n)
				}
				observe(n) {
					return z8(this, n)
				}
				do(n, e, i) {
					const { kind: r, value: o, error: s } = this
					return "N" === r ? n?.(o) : "E" === r ? e?.(s) : i?.()
				}
				accept(n, e, i) {
					var r
					return q(null === (r = n) || void 0 === r ? void 0 : r.next) ? this.observe(n) : this.do(n, e, i)
				}
				toObservable() {
					const { kind: n, value: e, error: i } = this,
						r =
							"N" === n
								? Wo(e)
								: "E" === n
								? (function nhe(t, n) {
										const e = q(t) ? t : () => t,
											i = r => r.error(e())
										return new Ge(n ? r => n.schedule(i, 0, r) : i)
								  })(() => i)
								: "C" === n
								? Ai
								: 0
					if (!r) throw new TypeError(`Unexpected notification kind ${n}`)
					return r
				}
				static createNext(n) {
					return new fu("N", n)
				}
				static createError(n) {
					return new fu("E", void 0, n)
				}
				static createComplete() {
					return fu.completeNotification
				}
			}
			function z8(t, n) {
				var e, i, r
				const { kind: o, value: s, error: a } = t
				if ("string" != typeof o) throw new TypeError('Invalid notification, missing "kind"')
				"N" === o
					? null === (e = n.next) || void 0 === e || e.call(n, s)
					: "E" === o
					? null === (i = n.error) || void 0 === i || i.call(n, a)
					: null === (r = n.complete) || void 0 === r || r.call(n)
			}
			function G8(t) {
				return Wt((n, e) => {
					let o,
						i = null,
						r = !1
					;(i = n.subscribe(
						we(e, void 0, void 0, s => {
							;(o = _e(t(s, G8(t)(n)))), i ? (i.unsubscribe(), (i = null), o.subscribe(e)) : (r = !0)
						})
					)),
						r && (i.unsubscribe(), (i = null), o.subscribe(e))
				})
			}
			function $8(t, n, e, i) {
				return Wt((r, o) => {
					let s
					n && "function" != typeof n ? ({ duration: e, element: s, connector: i } = n) : (s = n)
					const a = new Map(),
						c = _ => {
							a.forEach(_), _(o)
						},
						l = _ => c(y => y.error(_))
					let d = 0,
						u = !1
					const h = new gt(
						o,
						_ => {
							try {
								const y = t(_)
								let C = a.get(y)
								if (!C) {
									a.set(y, (C = i ? i() : new vt()))
									const x = (function f(_, y) {
										const C = new Ge(x => {
											d++
											const w = y.subscribe(x)
											return () => {
												w.unsubscribe(), 0 == --d && u && h.unsubscribe()
											}
										})
										return (C.key = _), C
									})(y, C)
									if ((o.next(x), e)) {
										const w = we(
											C,
											() => {
												C.complete(), w?.unsubscribe()
											},
											void 0,
											void 0,
											() => a.delete(y)
										)
										h.add(_e(e(x)).subscribe(w))
									}
								}
								C.next(s ? s(_) : _)
							} catch (y) {
								l(y)
							}
						},
						() => c(_ => _.complete()),
						l,
						() => a.clear(),
						() => ((u = !0), 0 === d)
					)
					r.subscribe(h)
				})
			}
			function W8(t, n) {
				return n
					? e => e.pipe(W8((i, r) => _e(t(i, r)).pipe(Ke((o, s) => n(i, o, r, s)))))
					: Wt((e, i) => {
							let r = 0,
								o = null,
								s = !1
							e.subscribe(
								we(
									i,
									a => {
										o ||
											((o = we(i, void 0, () => {
												;(o = null), s && i.complete()
											})),
											_e(t(a, r++)).subscribe(o))
									},
									() => {
										;(s = !0), !o && i.complete()
									}
								)
							)
					  })
			}
			function Do(t) {
				return t <= 0
					? () => Ai
					: Wt((n, e) => {
							let i = 0
							n.subscribe(
								we(e, r => {
									++i <= t && (e.next(r), t <= i && e.complete())
								})
							)
					  })
			}
			fu.completeNotification = new fu("C")
			class she extends D {
				constructor(n, e) {
					super()
				}
				schedule(n, e = 0) {
					return this
				}
			}
			const QC = {
				setInterval(t, n, ...e) {
					const { delegate: i } = QC
					return i?.setInterval ? i.setInterval(t, n, ...e) : setInterval(t, n, ...e)
				},
				clearInterval(t) {
					const { delegate: n } = QC
					return (n?.clearInterval || clearInterval)(t)
				},
				delegate: void 0
			}
			class zC extends she {
				constructor(n, e) {
					super(n, e), (this.scheduler = n), (this.work = e), (this.pending = !1)
				}
				schedule(n, e = 0) {
					var i
					if (this.closed) return this
					this.state = n
					const r = this.id,
						o = this.scheduler
					return (
						null != r && (this.id = this.recycleAsyncId(o, r, e)),
						(this.pending = !0),
						(this.delay = e),
						(this.id = null !== (i = this.id) && void 0 !== i ? i : this.requestAsyncId(o, this.id, e)),
						this
					)
				}
				requestAsyncId(n, e, i = 0) {
					return QC.setInterval(n.flush.bind(n, this), i)
				}
				recycleAsyncId(n, e, i = 0) {
					if (null != i && this.delay === i && !1 === this.pending) return e
					null != e && QC.clearInterval(e)
				}
				execute(n, e) {
					if (this.closed) return new Error("executing a cancelled action")
					this.pending = !1
					const i = this._execute(n, e)
					if (i) return i
					!1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
				}
				_execute(n, e) {
					let r,
						i = !1
					try {
						this.work(n)
					} catch (o) {
						;(i = !0), (r = o || new Error("Scheduled action threw falsy error"))
					}
					if (i) return this.unsubscribe(), r
				}
				unsubscribe() {
					if (!this.closed) {
						const { id: n, scheduler: e } = this,
							{ actions: i } = e
						;(this.work = this.state = this.scheduler = null),
							(this.pending = !1),
							Q(i, this),
							null != n && (this.id = this.recycleAsyncId(e, n, null)),
							(this.delay = null),
							super.unsubscribe()
					}
				}
			}
			const yI = { now: () => (yI.delegate || Date).now(), delegate: void 0 }
			class U0 {
				constructor(n, e = U0.now) {
					;(this.schedulerActionCtor = n), (this.now = e)
				}
				schedule(n, e = 0, i) {
					return new this.schedulerActionCtor(this, n).schedule(i, e)
				}
			}
			U0.now = yI.now
			class GC extends U0 {
				constructor(n, e = U0.now) {
					super(n, e), (this.actions = []), (this._active = !1)
				}
				flush(n) {
					const { actions: e } = this
					if (this._active) return void e.push(n)
					let i
					this._active = !0
					do {
						if ((i = n.execute(n.state, n.delay))) break
					} while ((n = e.shift()))
					if (((this._active = !1), i)) {
						for (; (n = e.shift()); ) n.unsubscribe()
						throw i
					}
				}
			}
			const lhe = new (class che extends GC {})(
				class ahe extends zC {
					constructor(n, e) {
						super(n, e), (this.scheduler = n), (this.work = e)
					}
					schedule(n, e = 0) {
						return e > 0 ? super.schedule(n, e) : ((this.delay = e), (this.state = n), this.scheduler.flush(this), this)
					}
					execute(n, e) {
						return e > 0 || this.closed ? super.execute(n, e) : this._execute(n, e)
					}
					requestAsyncId(n, e, i = 0) {
						return (null != i && i > 0) || (null == i && this.delay > 0) ? super.requestAsyncId(n, e, i) : (n.flush(this), 0)
					}
				}
			)
			function mu(...t) {
				const n = ko(t)
				return Wt((e, i) => {
					const r = t.length,
						o = new Array(r)
					let s = t.map(() => !1),
						a = !1
					for (let c = 0; c < r; c++)
						_e(t[c]).subscribe(
							we(
								i,
								l => {
									;(o[c] = l), !a && !s[c] && ((s[c] = !0), (a = s.every(Re)) && (s = null))
								},
								G
							)
						)
					e.subscribe(
						we(i, c => {
							if (a) {
								const l = [c, ...o]
								i.next(n ? n(...l) : l)
							}
						})
					)
				})
			}
			class phe extends Error {
				constructor(n, e) {
					super(
						(function Ahe(t, n) {
							return `NG0${Math.abs(t)}${n ? ": " + n : ""}`
						})(n, e)
					),
						(this.code = n)
				}
			}
			let Ts = null
			function WC(t) {
				const n = Ts
				return (Ts = t), n
			}
			function i6(t, n) {
				const e = !n?.manualCleanup
				e &&
					!n?.injector &&
					(function P1(t) {
						if (
							!nx() &&
							!(function ET() {
								return bs
							})()
						)
							throw new ht(-203, !1)
					})()
				const i = e ? n?.injector?.get(NA) ?? Rt(NA) : null
				let r
				return (
					(r = (function Fx(t, n) {
						const e = Object.create(VT)
						function i() {
							return Cx(e), e.value
						}
						return (
							(e.value = t),
							n?.equal && (e.equal = n.equal),
							(i.set = Bx),
							(i.update = QT),
							(i.mutate = zT),
							(i.asReadonly = GT),
							(i[Vl] = e),
							i
						)
					})(n?.requireSync ? { kind: 0 } : { kind: 1, value: n?.initialValue })),
					(function Mhe(t) {
						const n = WC(null)
						try {
							return t()
						} finally {
							WC(n)
						}
					})(() => {
						const o = t.subscribe({ next: s => r.set({ kind: 1, value: s }), error: s => r.set({ kind: 2, error: s }) })
						i?.onDestroy(o.unsubscribe.bind(o))
					}),
					kx(() => {
						const o = r()
						switch (o.kind) {
							case 1:
								return o.value
							case 2:
								throw o.error
							case 0:
								throw new phe(601, "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.")
						}
					})
				)
			}
			const V0 = {}
			function Nt(t, n) {
				if (((V0[t] = (V0[t] || 0) + 1), "function" == typeof n)) return EI(t, (...i) => ({ ...n(...i), type: t }))
				switch (n ? n._as : "empty") {
					case "empty":
						return EI(t, () => ({ type: t }))
					case "props":
						return EI(t, i => ({ ...i, type: t }))
					default:
						throw new Error("Unexpected config.")
				}
			}
			function EI(t, n) {
				return Object.defineProperty(n, "type", { value: t, writable: !1 })
			}
			const r6 = "@ngrx/store/init"
			let Bm = (() => {
				class t extends zr {
					constructor() {
						super({ type: r6 })
					}
					next(e) {
						if ("function" == typeof e)
							throw new TypeError(
								"\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction()."
							)
						if (typeof e > "u") throw new TypeError("Actions must be objects")
						if (typeof e.type > "u") throw new TypeError("Actions must have a type property")
						super.next(e)
					}
					complete() {}
					ngOnDestroy() {
						super.complete()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const Ihe = [Bm],
				SI = new He("@ngrx/store Internal Root Guard"),
				o6 = new He("@ngrx/store Internal Initial State"),
				kI = new He("@ngrx/store Initial State"),
				s6 = new He("@ngrx/store Reducer Factory"),
				a6 = new He("@ngrx/store Internal Reducer Factory Provider"),
				c6 = new He("@ngrx/store Initial Reducers"),
				TI = new He("@ngrx/store Internal Initial Reducers"),
				l6 = new He("@ngrx/store Store Features"),
				d6 = new He("@ngrx/store Internal Store Reducers"),
				FI = new He("@ngrx/store Internal Feature Reducers"),
				u6 = new He("@ngrx/store Internal Feature Configs"),
				BI = new He("@ngrx/store Internal Store Features"),
				h6 = new He("@ngrx/store Internal Feature Reducers Token"),
				II = new He("@ngrx/store Feature Reducers"),
				f6 = new He("@ngrx/store User Provided Meta Reducers"),
				KC = new He("@ngrx/store Meta Reducers"),
				m6 = new He("@ngrx/store Internal Resolved Meta Reducers"),
				p6 = new He("@ngrx/store User Runtime Checks Config"),
				A6 = new He("@ngrx/store Internal User Runtime Checks Config"),
				Q0 = new He("@ngrx/store Internal Runtime Checks"),
				z0 = new He("@ngrx/store Check if Action types are unique")
			function Im(t, n = {}) {
				const e = Object.keys(t),
					i = {}
				for (let o = 0; o < e.length; o++) {
					const s = e[o]
					"function" == typeof t[s] && (i[s] = t[s])
				}
				const r = Object.keys(i)
				return function (s, a) {
					s = void 0 === s ? n : s
					let c = !1
					const l = {}
					for (let d = 0; d < r.length; d++) {
						const u = r[d],
							f = s[u],
							_ = (0, i[u])(f, a)
						;(l[u] = _), (c = c || _ !== f)
					}
					return c ? l : s
				}
			}
			function b6(...t) {
				return function (n) {
					if (0 === t.length) return n
					const e = t[t.length - 1]
					return t.slice(0, -1).reduceRight((r, o) => o(r), e(n))
				}
			}
			function _6(t, n) {
				return (
					Array.isArray(n) && n.length > 0 && (t = b6.apply(null, [...n, t])),
					(e, i) => {
						const r = t(e)
						return (o, s) => r((o = void 0 === o ? i : o), s)
					}
				)
			}
			new He("@ngrx/store Root Store Provider"), new He("@ngrx/store Feature State Provider")
			class XC extends Ge {}
			class v6 extends Bm {}
			let G0 = (() => {
				class t extends zr {
					get currentReducers() {
						return this.reducers
					}
					constructor(e, i, r, o) {
						super(o(r, i)), (this.dispatcher = e), (this.initialState = i), (this.reducers = r), (this.reducerFactory = o)
					}
					addFeature(e) {
						this.addFeatures([e])
					}
					addFeatures(e) {
						const i = e.reduce((r, { reducers: o, reducerFactory: s, metaReducers: a, initialState: c, key: l }) => {
							const d =
								"function" == typeof o
									? (function Lhe(t) {
											const n = Array.isArray(t) && t.length > 0 ? b6(...t) : e => e
											return (e, i) => ((e = n(e)), (r, o) => e((r = void 0 === r ? i : r), o))
									  })(a)(o, c)
									: _6(s, a)(o, c)
							return (r[l] = d), r
						}, {})
						this.addReducers(i)
					}
					removeFeature(e) {
						this.removeFeatures([e])
					}
					removeFeatures(e) {
						this.removeReducers(e.map(i => i.key))
					}
					addReducer(e, i) {
						this.addReducers({ [e]: i })
					}
					addReducers(e) {
						;(this.reducers = { ...this.reducers, ...e }), this.updateReducers(Object.keys(e))
					}
					removeReducer(e) {
						this.removeReducers([e])
					}
					removeReducers(e) {
						e.forEach(i => {
							this.reducers = (function Dhe(t, n) {
								return Object.keys(t)
									.filter(e => e !== n)
									.reduce((e, i) => Object.assign(e, { [i]: t[i] }), {})
							})(this.reducers, i)
						}),
							this.updateReducers(e)
					}
					updateReducers(e) {
						this.next(this.reducerFactory(this.reducers, this.initialState)),
							this.dispatcher.next({ type: "@ngrx/store/update-reducers", features: e })
					}
					ngOnDestroy() {
						this.complete()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(v6), re(kI), re(c6), re(s6))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const Phe = [G0, { provide: XC, useExisting: G0 }, { provide: v6, useExisting: Bm }]
			let $0 = (() => {
				class t extends vt {
					ngOnDestroy() {
						this.complete()
					}
					static {
						this.ɵfac = (function () {
							let e
							return function (r) {
								return (e || (e = gr(t)))(r || t)
							}
						})()
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const Ohe = [$0]
			class y6 extends Ge {}
			let Sr = (() => {
				class t extends zr {
					static {
						this.INIT = r6
					}
					constructor(e, i, r, o) {
						super(o)
						const l = e
							.pipe(ss(lhe))
							.pipe(mu(i))
							.pipe(
								(function uhe(t, n) {
									return Wt(
										(function dhe(t, n, e, i, r) {
											return (o, s) => {
												let a = e,
													c = n,
													l = 0
												o.subscribe(
													we(
														s,
														d => {
															const u = l++
															;(c = a ? t(c, d, u) : ((a = !0), d)), i && s.next(c)
														},
														r &&
															(() => {
																a && s.next(c), s.complete()
															})
													)
												)
											}
										})(t, n, arguments.length >= 2, !0)
									)
								})(Nhe, { state: o })
							)
						;(this.stateSubscription = l.subscribe(({ state: d, action: u }) => {
							this.next(d), r.next(u)
						})),
							(this.state = i6(this, { manualCleanup: !0, requireSync: !0 }))
					}
					ngOnDestroy() {
						this.stateSubscription.unsubscribe(), this.complete()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Bm), re(XC), re($0), re(kI))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			function Nhe(t = { state: void 0 }, [n, e]) {
				const { state: i } = t
				return { state: e(i, n), action: n }
			}
			const Uhe = [Sr, { provide: y6, useExisting: Sr }]
			let Ct = (() => {
				class t extends Ge {
					constructor(e, i, r) {
						super(), (this.actionsObserver = i), (this.reducerManager = r), (this.source = e), (this.state = e.state)
					}
					select(e, ...i) {
						return Vhe.call(null, e, ...i)(this)
					}
					selectSignal(e, i) {
						return kx(() => e(this.state()), { equal: i?.equal || ((r, o) => r === o) })
					}
					lift(e) {
						const i = new t(this, this.actionsObserver, this.reducerManager)
						return (i.operator = e), i
					}
					dispatch(e) {
						this.actionsObserver.next(e)
					}
					next(e) {
						this.actionsObserver.next(e)
					}
					error(e) {
						this.actionsObserver.error(e)
					}
					complete() {
						this.actionsObserver.complete()
					}
					addReducer(e, i) {
						this.reducerManager.addReducer(e, i)
					}
					removeReducer(e) {
						this.reducerManager.removeReducer(e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(y6), re(Bm), re(G0))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const Hhe = [Ct]
			function Vhe(t, n, ...e) {
				return function (r) {
					let o
					if ("string" == typeof t) {
						const s = [n, ...e].filter(Boolean)
						o = r.pipe(
							(function hhe(...t) {
								const n = t.length
								if (0 === n) throw new Error("list of properties cannot be empty.")
								return Ke(e => {
									let i = e
									for (let r = 0; r < n; r++) {
										const o = i?.[t[r]]
										if (!(typeof o < "u")) return
										i = o
									}
									return i
								})
							})(t, ...s)
						)
					} else {
						if ("function" != typeof t)
							throw new TypeError(`Unexpected type '${typeof t}' in select operator, expected 'string' or 'function'`)
						o = r.pipe(Ke(s => t(s, n)))
					}
					return o.pipe(Ys())
				}
			}
			const LI = "https://ngrx.io/guide/store/configuration/runtime-checks"
			function w6(t) {
				return void 0 === t
			}
			function x6(t) {
				return null === t
			}
			function C6(t) {
				return Array.isArray(t)
			}
			function E6(t) {
				return "object" == typeof t && null !== t
			}
			function RI(t) {
				return "function" == typeof t
			}
			function PI(t, n) {
				return t === n
			}
			function OI(t, n = PI, e = PI) {
				let o,
					i = null,
					r = null
				return {
					memoized: function l() {
						if (void 0 !== o) return o.result
						if (!i) return (r = t.apply(null, arguments)), (i = arguments), r
						if (
							!(function Xhe(t, n, e) {
								for (let i = 0; i < t.length; i++) if (!e(t[i], n[i])) return !0
								return !1
							})(arguments, i, n)
						)
							return r
						const d = t.apply(null, arguments)
						return (i = arguments), e(r, d) ? r : ((r = d), d)
					},
					reset: function s() {
						;(i = null), (r = null)
					},
					setResult: function a(d = void 0) {
						o = { result: d }
					},
					clearResult: function c() {
						o = void 0
					}
				}
			}
			function Mt(...t) {
				return (function qhe(t, n = { stateFn: Yhe }) {
					return function (...e) {
						let i = e
						if (Array.isArray(i[0])) {
							const [d, ...u] = i
							i = [...d, ...u]
						} else
							1 === i.length &&
								(function Jhe(t) {
									return !!t && "object" == typeof t && Object.values(t).every(n => "function" == typeof n)
								})(i[0]) &&
								(i = (function efe(t) {
									const n = Object.values(t),
										e = Object.keys(t)
									return [...n, (...r) => e.reduce((o, s, a) => ({ ...o, [s]: r[a] }), {})]
								})(i[0]))
						const r = i.slice(0, i.length - 1),
							o = i[i.length - 1],
							s = r.filter(d => d.release && "function" == typeof d.release),
							a = t(function (...d) {
								return o.apply(null, d)
							}),
							c = OI(function (d, u) {
								return n.stateFn.apply(null, [d, r, u, a])
							})
						return Object.assign(c.memoized, {
							release: function l() {
								c.reset(), a.reset(), s.forEach(d => d.release())
							},
							projector: a.memoized,
							setResult: c.setResult,
							clearResult: c.clearResult
						})
					}
				})(OI)(...t)
			}
			function Yhe(t, n, e, i) {
				if (void 0 === e) {
					const o = n.map(s => s(t))
					return i.memoized.apply(null, o)
				}
				const r = n.map(o => o(t, e))
				return i.memoized.apply(null, [...r, e])
			}
			function ife(t) {
				return t instanceof He ? Rt(t) : t
			}
			function rfe(t, n) {
				return n.map((e, i) => {
					if (t[i] instanceof He) {
						const r = Rt(t[i])
						return {
							key: e.key,
							reducerFactory: r.reducerFactory ? r.reducerFactory : Im,
							metaReducers: r.metaReducers ? r.metaReducers : [],
							initialState: r.initialState
						}
					}
					return e
				})
			}
			function ofe(t) {
				return t.map(n => (n instanceof He ? Rt(n) : n))
			}
			function NI(t) {
				return "function" == typeof t ? t() : t
			}
			function sfe(t, n) {
				return t.concat(n)
			}
			function afe() {
				if (Rt(Ct, { optional: !0, skipSelf: !0 }))
					throw new TypeError(
						"The root Store has been provided more than once. Feature modules should provide feature states instead."
					)
				return "guarded"
			}
			function UI(t) {
				Object.freeze(t)
				const n = RI(t)
				return (
					Object.getOwnPropertyNames(t).forEach(e => {
						if (
							!e.startsWith("\u0275") &&
							(function jhe(t, n) {
								return Object.prototype.hasOwnProperty.call(t, n)
							})(t, e) &&
							(!n || ("caller" !== e && "callee" !== e && "arguments" !== e))
						) {
							const i = t[e]
							;(E6(i) || RI(i)) && !Object.isFrozen(i) && UI(i)
						}
					}),
					t
				)
			}
			function HI(t, n = []) {
				return (w6(t) || x6(t)) && 0 === n.length
					? { path: ["root"], value: t }
					: Object.keys(t).reduce((i, r) => {
							if (i) return i
							const o = t[r]
							return (function Whe(t) {
								return RI(t) && t.hasOwnProperty("\u0275cmp")
							})(o)
								? i
								: !(
										w6(o) ||
										x6(o) ||
										(function Ghe(t) {
											return "number" == typeof t
										})(o) ||
										(function zhe(t) {
											return "boolean" == typeof t
										})(o) ||
										(function Qhe(t) {
											return "string" == typeof t
										})(o) ||
										C6(o)
								  ) &&
										((function M6(t) {
											if (
												!(function $he(t) {
													return E6(t) && !C6(t)
												})(t)
											)
												return !1
											const n = Object.getPrototypeOf(t)
											return n === Object.prototype || null === n
										})(o)
											? HI(o, [...n, r])
											: { path: [...n, r], value: o })
					  }, !1)
			}
			function k6(t, n) {
				if (!1 === t) return
				const e = t.path.join("."),
					i = new Error(`Detected unserializable ${n} at "${e}". ${LI}#strict${n}serializability`)
				throw ((i.value = t.value), (i.unserializablePath = e), i)
			}
			function ufe(t) {
				return {
					strictStateSerializability: !1,
					strictActionSerializability: !1,
					strictStateImmutability: !1,
					strictActionImmutability: !1,
					strictActionWithinNgZone: !1,
					strictActionTypeUniqueness: !1
				}
			}
			function hfe({ strictActionSerializability: t, strictStateSerializability: n }) {
				return e =>
					t || n
						? (function lfe(t, n) {
								return function (e, i) {
									n.action(i) && k6(HI(i), "action")
									const r = t(e, i)
									return n.state() && k6(HI(r), "state"), r
								}
						  })(e, { action: i => t && !VI(i), state: () => n })
						: e
			}
			function ffe({ strictActionImmutability: t, strictStateImmutability: n }) {
				return e =>
					t || n
						? (function cfe(t, n) {
								return function (e, i) {
									const r = n.action(i) ? UI(i) : i,
										o = t(e, r)
									return n.state() ? UI(o) : o
								}
						  })(e, { action: i => t && !VI(i), state: () => n })
						: e
			}
			function VI(t) {
				return t.type.startsWith("@ngrx")
			}
			function mfe({ strictActionWithinNgZone: t }) {
				return n =>
					t
						? (function dfe(t, n) {
								return function (e, i) {
									if (n.action(i) && !mn.isInAngularZone())
										throw new Error(`Action '${i.type}' running outside NgZone. ${LI}#strictactionwithinngzone`)
									return t(e, i)
								}
						  })(n, { action: e => t && !VI(e) })
						: n
			}
			function pfe(t) {
				return [
					{ provide: A6, useValue: t },
					{ provide: p6, useFactory: Afe, deps: [A6] },
					{ provide: Q0, deps: [p6], useFactory: ufe },
					{ provide: KC, multi: !0, deps: [Q0], useFactory: ffe },
					{ provide: KC, multi: !0, deps: [Q0], useFactory: hfe },
					{ provide: KC, multi: !0, deps: [Q0], useFactory: mfe }
				]
			}
			function T6() {
				return [{ provide: z0, multi: !0, deps: [Q0], useFactory: gfe }]
			}
			function Afe(t) {
				return t
			}
			function gfe(t) {
				if (!t.strictActionTypeUniqueness) return
				const n = Object.entries(V0)
					.filter(([, e]) => e > 1)
					.map(([e]) => e)
				if (n.length)
					throw new Error(
						`Action types are registered more than once, ${n.map(e => `"${e}"`).join(", ")}. ${LI}#strictactiontypeuniqueness`
					)
			}
			function F6(t = {}, n = {}) {
				return [
					{ provide: SI, useFactory: afe },
					{ provide: o6, useValue: n.initialState },
					{ provide: kI, useFactory: NI, deps: [o6] },
					{ provide: TI, useValue: t },
					{ provide: d6, useExisting: t instanceof He ? t : TI },
					{ provide: c6, deps: [TI, [new P_(d6)]], useFactory: ife },
					{ provide: f6, useValue: n.metaReducers ? n.metaReducers : [] },
					{ provide: m6, deps: [KC, f6], useFactory: sfe },
					{ provide: a6, useValue: n.reducerFactory ? n.reducerFactory : Im },
					{ provide: s6, deps: [a6, m6], useFactory: _6 },
					Ihe,
					Phe,
					Ohe,
					Uhe,
					Hhe,
					pfe(n.runtimeChecks),
					T6()
				]
			}
			function B6(t, n, e = {}) {
				return [
					{ provide: u6, multi: !0, useValue: t instanceof Object ? {} : e },
					{
						provide: l6,
						multi: !0,
						useValue: {
							key: t instanceof Object ? t.name : t,
							reducerFactory: e instanceof He || !e.reducerFactory ? Im : e.reducerFactory,
							metaReducers: e instanceof He || !e.metaReducers ? [] : e.metaReducers,
							initialState: e instanceof He || !e.initialState ? void 0 : e.initialState
						}
					},
					{ provide: BI, deps: [u6, l6], useFactory: rfe },
					{ provide: FI, multi: !0, useValue: t instanceof Object ? t.reducer : n },
					{ provide: h6, multi: !0, useExisting: n instanceof He ? n : FI },
					{ provide: II, multi: !0, deps: [FI, [new P_(h6)]], useFactory: ofe },
					T6()
				]
			}
			let YC = (() => {
					class t {
						constructor(e, i, r, o, s, a) {}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Bm), re(XC), re($0), re(Ct), re(SI, 8), re(z0, 8))
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				QI = (() => {
					class t {
						constructor(e, i, r, o, s) {
							;(this.features = e), (this.featureReducers = i), (this.reducerManager = r)
							const a = e.map((c, l) => {
								const u = i.shift()[l]
								return { ...c, reducers: u, initialState: NI(c.initialState) }
							})
							r.addFeatures(a)
						}
						ngOnDestroy() {
							this.reducerManager.removeFeatures(this.features)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(BI), re(II), re(G0), re(YC), re(z0, 8))
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				wfe = (() => {
					class t {
						static forRoot(e, i) {
							return { ngModule: YC, providers: [...F6(e, i)] }
						}
						static forFeature(e, i, r = {}) {
							return { ngModule: QI, providers: [...B6(e, i, r)] }
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})()
			function Gt(...t) {
				return { reducer: t.pop(), types: t.map(i => i.type) }
			}
			function ni(t, ...n) {
				const e = new Map()
				for (const i of n)
					for (const r of i.types) {
						const o = e.get(r)
						e.set(r, o ? (a, c) => i.reducer(o(a, c), c) : i.reducer)
					}
				return function (i = t, r) {
					const o = e.get(r.type)
					return o ? o(i, r) : i
				}
			}
			const xfe = { dispatch: !0, functional: !1, useEffectsErrorHandler: !0 },
				qC = "__@ngrx/effects_create__"
			function yo(t, n = {}) {
				const e = n.functional ? t : t(),
					i = { ...xfe, ...n }
				return Object.defineProperty(e, qC, { value: i }), e
			}
			function D6(t) {
				return Object.getPrototypeOf(t)
			}
			function zI(t) {
				return "function" == typeof t
			}
			function GI(t) {
				return t.filter(zI)
			}
			function Sfe(t, n, e) {
				const i = D6(t),
					o = i && "Object" !== i.constructor.name ? i.constructor.name : null,
					s = (function I6(t) {
						return (function Cfe(t) {
							return Object.getOwnPropertyNames(t)
								.filter(i => !(!t[i] || !t[i].hasOwnProperty(qC)) && t[i][qC].hasOwnProperty("dispatch"))
								.map(i => ({ propertyName: i, ...t[i][qC] }))
						})(t)
					})(t).map(({ propertyName: a, dispatch: c, useEffectsErrorHandler: l }) => {
						const d = "function" == typeof t[a] ? t[a]() : t[a],
							u = l ? e(d, n) : d
						return !1 === c
							? u.pipe(Q8())
							: u
									.pipe(
										(function rhe() {
											return Wt((t, n) => {
												t.subscribe(
													we(
														n,
														e => {
															n.next(fu.createNext(e))
														},
														() => {
															n.next(fu.createComplete()), n.complete()
														},
														e => {
															n.next(fu.createError(e)), n.complete()
														}
													)
												)
											})
										})()
									)
									.pipe(Ke(f => ({ effect: t[a], notification: f, propertyName: a, sourceName: o, sourceInstance: t })))
					})
				return oo(...s)
			}
			function L6(t, n, e = 10) {
				return t.pipe(G8(i => (n && n.handleError(i), e <= 1 ? t : L6(t, n, e - 1))))
			}
			let pu = (() => {
				class t extends Ge {
					constructor(e) {
						super(), e && (this.source = e)
					}
					lift(e) {
						const i = new t()
						return (i.source = this), (i.operator = e), i
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re($0))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			function dl(...t) {
				return xi(n => t.some(e => ("string" == typeof e ? e === n.type : e.type === n.type)))
			}
			const R6 = new He("@ngrx/effects Internal Root Guard"),
				ZC = new He("@ngrx/effects User Provided Effects"),
				$I = new He("@ngrx/effects Internal Root Effects"),
				P6 = new He("@ngrx/effects Internal Root Effects Instances"),
				O6 = new He("@ngrx/effects Internal Feature Effects"),
				N6 = new He("@ngrx/effects Internal Feature Effects Instance Groups"),
				Tfe = new He("@ngrx/effects Effects Error Handler", { providedIn: "root", factory: () => L6 }),
				U6 = "@ngrx/effects/init"
			Nt(U6)
			function Hfe(t) {
				return WI(t, "ngrxOnInitEffects")
			}
			function WI(t, n) {
				return t && n in t && "function" == typeof t[n]
			}
			let jI = (() => {
				class t extends vt {
					constructor(e, i) {
						super(), (this.errorHandler = e), (this.effectsErrorHandler = i)
					}
					addEffects(e) {
						this.next(e)
					}
					toActions() {
						return this.pipe(
							$8(e =>
								(function Efe(t) {
									return !!t.constructor && "Object" !== t.constructor.name && "Function" !== t.constructor.name
								})(e)
									? D6(e)
									: e
							),
							ir(e => e.pipe($8(Vfe))),
							ir(e => {
								const i = e.pipe(
									W8(o =>
										(function Qfe(t, n) {
											return e => {
												const i = Sfe(e, t, n)
												return (function Nfe(t) {
													return WI(t, "ngrxOnRunEffects")
												})(e)
													? e.ngrxOnRunEffects(i)
													: i
											}
										})(
											this.errorHandler,
											this.effectsErrorHandler
										)(o)
									),
									Ke(
										o => (
											(function Bfe(t, n) {
												if ("N" === t.notification.kind) {
													const e = t.notification.value
													!(function Ife(t) {
														return "function" != typeof t && t && t.type && "string" == typeof t.type
													})(e) &&
														n.handleError(
															new Error(
																`Effect ${(function Dfe({
																	propertyName: t,
																	sourceInstance: n,
																	sourceName: e
																}) {
																	const i = "function" == typeof n[t]
																	return e ? `"${e}.${String(t)}${i ? "()" : ""}"` : `"${String(t)}()"`
																})(t)} dispatched an invalid action: ${(function Lfe(t) {
																	try {
																		return JSON.stringify(t)
																	} catch {
																		return t
																	}
																})(e)}`
															)
														)
												}
											})(o, this.errorHandler),
											o.notification
										)
									),
									xi(o => "N" === o.kind && null != o.value),
									(function ohe() {
										return Wt((t, n) => {
											t.subscribe(we(n, e => z8(e, n)))
										})
									})()
								)
								return oo(
									i,
									e.pipe(
										Do(1),
										xi(Hfe),
										Ke(o => o.ngrxOnInitEffects())
									)
								)
							})
						)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(ql), re(Tfe))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			function Vfe(t) {
				return (function Pfe(t) {
					return WI(t, "ngrxOnIdentifyEffects")
				})(t)
					? t.ngrxOnIdentifyEffects()
					: ""
			}
			let KI = (() => {
					class t {
						get isStarted() {
							return !!this.effectsSubscription
						}
						constructor(e, i) {
							;(this.effectSources = e), (this.store = i), (this.effectsSubscription = null)
						}
						start() {
							this.effectsSubscription || (this.effectsSubscription = this.effectSources.toActions().subscribe(this.store))
						}
						ngOnDestroy() {
							this.effectsSubscription && (this.effectsSubscription.unsubscribe(), (this.effectsSubscription = null))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(jI), re(Ct))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				H6 = (() => {
					class t {
						constructor(e, i, r, o, s, a, c) {
							;(this.sources = e), i.start()
							for (const l of o) e.addEffects(l)
							r.dispatch({ type: U6 })
						}
						addEffects(e) {
							this.sources.addEffects(e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(jI), re(KI), re(Ct), re(P6), re(YC, 8), re(QI, 8), re(R6, 8))
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				zfe = (() => {
					class t {
						constructor(e, i, r, o) {
							const s = i.flat()
							for (const a of s) e.addEffects(a)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(H6), re(N6), re(YC, 8), re(QI, 8))
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				Gfe = (() => {
					class t {
						static forFeature(...e) {
							const i = e.flat(),
								r = GI(i)
							return {
								ngModule: zfe,
								providers: [
									r,
									{ provide: O6, multi: !0, useValue: i },
									{ provide: ZC, multi: !0, useValue: [] },
									{ provide: N6, multi: !0, useFactory: V6, deps: [O6, ZC] }
								]
							}
						}
						static forRoot(...e) {
							const i = e.flat(),
								r = GI(i)
							return {
								ngModule: H6,
								providers: [
									r,
									{ provide: $I, useValue: [i] },
									{ provide: R6, useFactory: $fe },
									{ provide: ZC, multi: !0, useValue: [] },
									{ provide: P6, useFactory: V6, deps: [$I, ZC] }
								]
							}
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})()
			function V6(t, n) {
				const e = []
				for (const i of t) e.push(...i)
				for (const i of n) e.push(...i)
				return e.map(i =>
					(function Mfe(t) {
						return t instanceof He || zI(t)
					})(i)
						? Rt(i)
						: i
				)
			}
			function $fe() {
				const t = Rt(KI, { optional: !0, skipSelf: !0 }),
					n = Rt($I, { self: !0 })
				if ((1 !== n.length || 0 !== n[0].length) && t)
					throw new TypeError(
						"EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead."
					)
				return "guarded"
			}
			function Q6(t, n, e, i, r, o, s) {
				try {
					var a = t[o](s),
						c = a.value
				} catch (l) {
					return void e(l)
				}
				a.done ? n(c) : Promise.resolve(c).then(i, r)
			}
			function _r(t) {
				return function () {
					var n = this,
						e = arguments
					return new Promise(function (i, r) {
						var o = t.apply(n, e)
						function s(c) {
							Q6(o, i, r, s, a, "next", c)
						}
						function a(c) {
							Q6(o, i, r, s, a, "throw", c)
						}
						s(void 0)
					})
				}
			}
			const Dm = Nt("SET_IS_LOADING_FILE", { _as: "props", _p: void 0 })
			const ul = A(5158),
				Lm = Nt("SET_AMOUNT_OF_TOP_LABELS", { _as: "props", _p: void 0 }),
				W0 = Nt("SET_COLOR_LABELS", { _as: "props", _p: void 0 }),
				j0 = Nt("SET_EDGE_HEIGHT", { _as: "props", _p: void 0 }),
				JC = Nt("SET_SCREENSHOT_TO_CLIPBOARD_ENABLED", { _as: "props", _p: void 0 }),
				eE = Nt("SET_EXPERIMENTAL_FEATURES_ENABLED", { _as: "props", _p: void 0 }),
				K0 = Nt("SET_ENABLE_FLOOR_LABELS", { _as: "props", _p: void 0 }),
				X0 = Nt("SET_HIDE_FLAT_BUILDINGS", { _as: "props", _p: void 0 }),
				Y0 = Nt("SET_INVERT_AREA", { _as: "props", _p: void 0 }),
				q0 = Nt("SET_INVERT_HEIGHT", { _as: "props", _p: void 0 }),
				XI = Nt("SET_IS_EDGE_METRIC_VISIBLE", { _as: "props", _p: void 0 }),
				tE = Nt("TOGGLE_IS_EDGE_METRIC_VISIBLE"),
				YI = Nt("SET_IS_COLOR_METRIC_LINKED_TO_HEIGHT_METRIC", { _as: "props", _p: void 0 }),
				qI = Nt("TOGGLE_IS_COLOR_METRIC_LINKED_TO_HEIGHT_METRIC"),
				nE = Nt("SET_PRESENTATION_MODE", { _as: "props", _p: void 0 }),
				Z0 = Nt("SET_IS_WHITE_BACKGROUND", { _as: "props", _p: void 0 }),
				J0 = Nt("SET_LAYOUT_ALGORITHM", { _as: "props", _p: void 0 }),
				Au = Nt("SET_MAP_COLORS", { _as: "props", _p: void 0 }),
				iE = Nt("INVERT_COLOR_RANGE"),
				rE = Nt("INVERT_DELTA_COLORS"),
				ev = Nt("SET_MAX_TREE_MAP_FILES", { _as: "props", _p: void 0 }),
				oE = Nt("SET_RESET_CAMERA_IF_NEW_FILE_IS_LOADED", { _as: "props", _p: void 0 }),
				tv = Nt("SET_SCALING", { _as: "props", _p: void 0 }),
				nv = Nt("SET_SHARPNESS_MODE", { _as: "props", _p: void 0 }),
				iv = Nt("SET_SHOW_METRIC_LABEL_NAME_VALUE", { _as: "props", _p: void 0 }),
				rv = Nt("SET_SHOW_METRIC_LABEL_NODE_NAME", { _as: "props", _p: void 0 }),
				ov = Nt("SET_SHOW_ONLY_BUILDINGS_WITH_EDGES", { _as: "props", _p: void 0 }),
				gu = Nt("SET_AREA_METRIC", { _as: "props", _p: void 0 }),
				hl = Nt("SET_COLOR_METRIC", { _as: "props", _p: void 0 }),
				sv = Nt("SET_COLOR_MODE", { _as: "props", _p: void 0 }),
				sd = Nt("SET_COLOR_RANGE", { _as: "props", _p: void 0 }),
				av = Nt("SET_DISTRIBUTION_METRIC", { _as: "props", _p: void 0 }),
				Oh = Nt("SET_EDGE_METRIC", { _as: "props", _p: void 0 }),
				sE = Nt("SET_ALL_FOCUSED_NODES", { _as: "props", _p: void 0 }),
				aE = Nt("FOCUS_NODE", { _as: "props", _p: void 0 }),
				cv = Nt("UNFOCUS_ALL_NODES"),
				cE = Nt("UNFOCUS_NODE"),
				bu = Nt("SET_HEIGHT_METRIC", { _as: "props", _p: void 0 }),
				lv = Nt("SET_MARGIN", { _as: "props", _p: void 0 }),
				Nh = Nt("SET_SEARCH_PATTERN", { _as: "props", _p: void 0 }),
				lE = Nt("SET_SORTING_OPTION", { _as: "props", _p: void 0 }),
				ZI = Nt("SET_ATTRIBUTE_DESCRIPTORS", { _as: "props", _p: void 0 }),
				JI = Nt("SET_ATTRIBUTE_TYPES", { _as: "props", _p: void 0 }),
				eD = Nt("UPDATE_ATTRIBUTE_TYPE", { _as: "props", _p: void 0 }),
				tD = Nt("SET_BLACKLIST", { _as: "props", _p: void 0 }),
				nD = Nt("ADD_BLACKLIST_ITEM", { _as: "props", _p: void 0 }),
				dE = Nt("ADD_BLACKLIST_ITEMS", { _as: "props", _p: void 0 }),
				uE = Nt("REMOVE_BLACKLIST_ITEM", { _as: "props", _p: void 0 }),
				iD = Nt("ADD_BLACKLIST_ITEMS_IF_NOT_RESULTS_IN_EMPTY_MAP", { _as: "props", _p: void 0 }),
				rD = Nt("SET_EDGES", { _as: "props", _p: void 0 }),
				G6 = Nt("ADD_EDGE", { _as: "props", _p: void 0 }),
				$6 = Nt("REMOVE_EDGE", { _as: "props", _p: void 0 }),
				hE = Nt("SET_MARKED_PACKAGES", { _as: "props", _p: void 0 }),
				dv = Nt("MARK_PACKAGES", { _as: "props", _p: void 0 }),
				fE = Nt("UNMARK_PACKAGE", { _as: "props", _p: void 0 })
			function W6(t, n) {
				;(this.v = t), (this.k = n)
			}
			function j6(t) {
				return new W6(t, 0)
			}
			function uv(t) {
				var n, e
				function i(o, s) {
					try {
						var a = t[o](s),
							c = a.value,
							l = c instanceof W6
						Promise.resolve(l ? c.v : c).then(
							function (d) {
								if (l) {
									var u = "return" === o ? "return" : "next"
									if (!c.k || d.done) return i(u, d)
									d = t[u](d).value
								}
								r(a.done ? "return" : "normal", d)
							},
							function (d) {
								i("throw", d)
							}
						)
					} catch (d) {
						r("throw", d)
					}
				}
				function r(o, s) {
					switch (o) {
						case "return":
							n.resolve({ value: s, done: !0 })
							break
						case "throw":
							n.reject(s)
							break
						default:
							n.resolve({ value: s, done: !1 })
					}
					;(n = n.next) ? i(n.key, n.arg) : (e = null)
				}
				;(this._invoke = function (o, s) {
					return new Promise(function (a, c) {
						var l = { key: o, arg: s, resolve: a, reject: c, next: null }
						e ? (e = e.next = l) : ((n = e = l), i(o, s))
					})
				}),
					"function" != typeof t.return && (this.return = void 0)
			}
			;(uv.prototype[("function" == typeof Symbol && Symbol.asyncIterator) || "@@asyncIterator"] = function () {
				return this
			}),
				(uv.prototype.next = function (t) {
					return this._invoke("next", t)
				}),
				(uv.prototype.throw = function (t) {
					return this._invoke("throw", t)
				}),
				(uv.prototype.return = function (t) {
					return this._invoke("return", t)
				})
			const oD = (t, n) => n.some(e => t instanceof e)
			let K6, X6
			const sD = new WeakMap(),
				aD = new WeakMap(),
				mE = new WeakMap()
			let cD = {
				get(t, n, e) {
					if (t instanceof IDBTransaction) {
						if ("done" === n) return sD.get(t)
						if ("store" === n) return e.objectStoreNames[1] ? void 0 : e.objectStore(e.objectStoreNames[0])
					}
					return Uh(t[n])
				},
				set: (t, n, e) => ((t[n] = e), !0),
				has: (t, n) => (t instanceof IDBTransaction && ("done" === n || "store" === n)) || n in t
			}
			function Y6(t) {
				cD = t(cD)
			}
			function Zfe(t) {
				return "function" == typeof t
					? (function qfe(t) {
							return (function Kfe() {
								return (
									X6 ||
									(X6 = [
										IDBCursor.prototype.advance,
										IDBCursor.prototype.continue,
										IDBCursor.prototype.continuePrimaryKey
									])
								)
							})().includes(t)
								? function (...n) {
										return t.apply(lD(this), n), Uh(this.request)
								  }
								: function (...n) {
										return Uh(t.apply(lD(this), n))
								  }
					  })(t)
					: (t instanceof IDBTransaction &&
							(function Yfe(t) {
								if (sD.has(t)) return
								const n = new Promise((e, i) => {
									const r = () => {
											t.removeEventListener("complete", o),
												t.removeEventListener("error", s),
												t.removeEventListener("abort", s)
										},
										o = () => {
											e(), r()
										},
										s = () => {
											i(t.error || new DOMException("AbortError", "AbortError")), r()
										}
									t.addEventListener("complete", o), t.addEventListener("error", s), t.addEventListener("abort", s)
								})
								sD.set(t, n)
							})(t),
					  oD(
							t,
							(function jfe() {
								return K6 || (K6 = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
							})()
					  )
							? new Proxy(t, cD)
							: t)
			}
			function Uh(t) {
				if (t instanceof IDBRequest)
					return (function Xfe(t) {
						const n = new Promise((e, i) => {
							const r = () => {
									t.removeEventListener("success", o), t.removeEventListener("error", s)
								},
								o = () => {
									e(Uh(t.result)), r()
								},
								s = () => {
									i(t.error), r()
								}
							t.addEventListener("success", o), t.addEventListener("error", s)
						})
						return mE.set(n, t), n
					})(t)
				if (aD.has(t)) return aD.get(t)
				const n = Zfe(t)
				return n !== t && (aD.set(t, n), mE.set(n, t)), n
			}
			const lD = t => mE.get(t),
				eme = ["get", "getKey", "getAll", "getAllKeys", "count"],
				tme = ["put", "add", "delete", "clear"],
				dD = new Map()
			function q6(t, n) {
				if (!(t instanceof IDBDatabase) || n in t || "string" != typeof n) return
				if (dD.get(n)) return dD.get(n)
				const e = n.replace(/FromIndex$/, ""),
					i = n !== e,
					r = tme.includes(e)
				if (!(e in (i ? IDBIndex : IDBObjectStore).prototype) || (!r && !eme.includes(e))) return
				const o = (function () {
					var s = _r(function* (a, ...c) {
						const l = this.transaction(a, r ? "readwrite" : "readonly")
						let d = l.store
						return i && (d = d.index(c.shift())), (yield Promise.all([d[e](...c), r && l.done]))[0]
					})
					return function (c) {
						return s.apply(this, arguments)
					}
				})()
				return dD.set(n, o), o
			}
			Y6(t => ({ ...t, get: (n, e, i) => q6(n, e) || t.get(n, e, i), has: (n, e) => !!q6(n, e) || t.has(n, e) }))
			const nme = ["continue", "continuePrimaryKey", "advance"],
				Z6 = {},
				uD = new WeakMap(),
				J6 = new WeakMap(),
				ime = {
					get(t, n) {
						if (!nme.includes(n)) return t[n]
						let e = Z6[n]
						return (
							e ||
								(e = Z6[n] =
									function (...i) {
										uD.set(this, J6.get(this)[n](...i))
									}),
							e
						)
					}
				}
			function rme() {
				return hD.apply(this, arguments)
			}
			function hD() {
				return (
					(hD = (function Wfe(t) {
						return function () {
							return new uv(t.apply(this, arguments))
						}
					})(function* (...t) {
						let n = this
						if ((n instanceof IDBCursor || (n = yield j6(n.openCursor(...t))), !n)) return
						const e = new Proxy(n, ime)
						for (J6.set(e, n), mE.set(e, lD(n)); n; ) yield e, (n = yield j6(uD.get(e) || n.continue())), uD.delete(e)
					})),
					hD.apply(this, arguments)
				)
			}
			function eG(t, n) {
				return (
					(n === Symbol.asyncIterator && oD(t, [IDBIndex, IDBObjectStore, IDBCursor])) ||
					("iterate" === n && oD(t, [IDBIndex, IDBObjectStore]))
				)
			}
			Y6(t => ({ ...t, get: (n, e, i) => (eG(n, e) ? rme : t.get(n, e, i)), has: (n, e) => eG(n, e) || t.has(n, e) }))
			const ome = "CodeCharta",
				sme = 1,
				hv = "ccstate",
				tG = "id",
				fD = 1001
			function mD() {
				return (mD = _r(function* (t) {
					const e = (yield bD()).transaction(hv, "readwrite")
					yield e.store.put({ [tG]: fD, state: t }), yield e.done
				})).apply(this, arguments)
			}
			function pD() {
				return AD.apply(this, arguments)
			}
			function AD() {
				return (AD = _r(function* () {
					return (yield (yield bD()).get(hv, fD))?.state || null
				})).apply(this, arguments)
			}
			function gD() {
				return (gD = _r(function* () {
					const n = (yield bD()).transaction(hv, "readwrite")
					yield n.store.delete(fD), yield n.done
				})).apply(this, arguments)
			}
			function bD() {
				return _D.apply(this, arguments)
			}
			function _D() {
				return (_D = _r(function* () {
					return (function Jfe(t, n, { blocked: e, upgrade: i, blocking: r, terminated: o } = {}) {
						const s = indexedDB.open(t, n),
							a = Uh(s)
						return (
							i &&
								s.addEventListener("upgradeneeded", c => {
									i(Uh(s.result), c.oldVersion, c.newVersion, Uh(s.transaction), c)
								}),
							e && s.addEventListener("blocked", c => e(c.oldVersion, c.newVersion, c)),
							a
								.then(c => {
									o && c.addEventListener("close", () => o()),
										r && c.addEventListener("versionchange", l => r(l.oldVersion, l.newVersion, l))
								})
								.catch(() => {}),
							a
						)
					})(ome, sme, {
						upgrade(t) {
							t.objectStoreNames.contains(hv) || t.createObjectStore(hv, { keyPath: tG })
						}
					})
				})).apply(this, arguments)
			}
			const lme = JSON.parse(
					'{"projectName":"Sample Project with Edges","apiVersion":"1.2","fileChecksum":"valid-md5-sample1","nodes":[{"name":"root","type":"Folder","attributes":{},"children":[{"name":"sample1OnlyLeaf.scss","type":"File","attributes":{"rloc":400,"functions":10,"mcc":100,"pairingRate":32,"avgCommits":17},"link":"http://www.google.de"},{"name":"bigLeaf.ts","type":"File","attributes":{"rloc":100,"functions":10,"mcc":1,"pairingRate":77,"avgCommits":56},"link":"http://www.google.de"},{"name":"ParentLeaf","type":"Folder","attributes":{},"children":[{"name":"smallLeaf.html","type":"File","attributes":{"rloc":30,"functions":100,"mcc":100,"pairingRate":60,"avgCommits":51}},{"name":"otherSmallLeaf.ts","type":"File","attributes":{"rloc":70,"functions":1000,"mcc":10,"pairingRate":65,"avgCommits":22}}]}]}],"edges":[{"fromNodeName":"/root/bigLeaf.ts","toNodeName":"/root/ParentLeaf/smallLeaf.html","attributes":{"pairingRate":89,"avgCommits":34}},{"fromNodeName":"/root/sample1OnlyLeaf.scss","toNodeName":"/root/ParentLeaf/smallLeaf.html","attributes":{"pairingRate":32,"avgCommits":17}},{"fromNodeName":"/root/ParentLeaf/otherSmallLeaf.ts","toNodeName":"/root/bigLeaf.ts","attributes":{"pairingRate":65,"avgCommits":22}}],"attributeTypes":{"nodes":{"rloc":"absolute","functions":"absolute","mcc":"absolute","pairingRate":"relative"},"edges":{"pairingRate":"relative","avgCommits":"absolute"}}}'
				),
				dme = JSON.parse(
					'{"projectName":"Sample Project","apiVersion":"1.2","fileChecksum":"valid-md5-sample2","nodes":[{"name":"root","type":"Folder","attributes":{},"children":[{"name":"bigLeaf.ts","type":"File","attributes":{"rloc":120,"functions":10,"mcc":1},"link":"http://www.google.de"},{"name":"ParentLeaf","type":"Folder","attributes":{},"children":[{"name":"smallLeaf.html","type":"File","attributes":{"rloc":30,"functions":101,"mcc":80}},{"name":"otherSmallLeaf.ts","type":"File","attributes":{"rloc":70,"functions":10,"mcc":100}},{"name":"sample2LeafMergedIn.kt","type":"File","attributes":{"rloc":600,"functions":10,"mcc":1},"link":"http://www.google.de"}]}]}],"attributeTypes":{"nodes":{"rloc":"absolute","functions":"absolute","mcc":"absolute"}}}'
				)
			var Fi = (function (t) {
				return (t.Reference = "Reference"), (t.Comparison = "Comparison"), (t.Partial = "Partial"), (t.None = "None"), t
			})(Fi || {})
			const vD = ".png",
				nG = "~",
				pE = "_"
			function iG(t) {
				return t.some(n => n.selectedAs !== Fi.None)
			}
			function yD(t) {
				return t.filter(n => n.selectedAs !== Fi.None)
			}
			function ad(t) {
				return t.some(n => n.selectedAs === Fi.Reference)
			}
			function rG(t) {
				return t.some(n => n.selectedAs === Fi.Partial)
			}
			function AE(t, n) {
				return t.fileMeta.fileChecksum === n.fileMeta.fileChecksum
			}
			const dg = new GC(zC),
				bme = dg
			function ug(t, n = dg) {
				return Wt((e, i) => {
					let r = null,
						o = null,
						s = null
					const a = () => {
						if (r) {
							r.unsubscribe(), (r = null)
							const l = o
							;(o = null), i.next(l)
						}
					}
					function c() {
						const l = s + t,
							d = n.now()
						if (d < l) return (r = this.schedule(void 0, l - d)), void i.add(r)
						a()
					}
					e.subscribe(
						we(
							i,
							l => {
								;(o = l), (s = n.now()), r || ((r = n.schedule(c, t)), i.add(r))
							},
							() => {
								a(), i.complete()
							},
							void 0,
							() => {
								o = r = null
							}
						)
					)
				})
			}
			function eo(t, n, e) {
				const i = q(t) || n || e ? { next: t, error: n, complete: e } : t
				return i
					? Wt((r, o) => {
							var s
							null === (s = i.subscribe) || void 0 === s || s.call(i)
							let a = !0
							r.subscribe(
								we(
									o,
									c => {
										var l
										null === (l = i.next) || void 0 === l || l.call(i, c), o.next(c)
									},
									() => {
										var c
										;(a = !1), null === (c = i.complete) || void 0 === c || c.call(i), o.complete()
									},
									c => {
										var l
										;(a = !1), null === (l = i.error) || void 0 === l || l.call(i, c), o.error(c)
									},
									() => {
										var c, l
										a && (null === (c = i.unsubscribe) || void 0 === c || c.call(i)),
											null === (l = i.finalize) || void 0 === l || l.call(i)
									}
								)
							)
					  })
					: Re
			}
			const fv = t => t.fileSettings,
				cd = Mt(fv, t => t.blacklist),
				_u = t => t.files,
				ld = Mt(_u, yD)
			function _me(t) {
				var n = 0,
					e = t.children,
					i = e && e.length
				if (i) for (; --i >= 0; ) n += e[i].value
				else n = 1
				t.value = n
			}
			function $r(t, n) {
				t instanceof Map ? ((t = [void 0, t]), void 0 === n && (n = Pme)) : void 0 === n && (n = Rme)
				for (var i, o, s, a, c, e = new gE(t), r = [e]; (i = r.pop()); )
					if ((s = n(i.data)) && (c = (s = Array.from(s)).length))
						for (i.children = s, a = c - 1; a >= 0; --a)
							r.push((o = s[a] = new gE(s[a]))), (o.parent = i), (o.depth = i.depth + 1)
				return e.eachBefore(Nme)
			}
			function Rme(t) {
				return t.children
			}
			function Pme(t) {
				return Array.isArray(t) ? t[1] : null
			}
			function Ome(t) {
				void 0 !== t.data.value && (t.value = t.data.value), (t.data = t.data.data)
			}
			function Nme(t) {
				var n = 0
				do {
					t.height = n
				} while ((t = t.parent) && t.height < ++n)
			}
			function gE(t) {
				;(this.data = t), (this.depth = this.height = 0), (this.parent = null)
			}
			gE.prototype = $r.prototype = {
				constructor: gE,
				count: function vme() {
					return this.eachAfter(_me)
				},
				each: function yme(t, n) {
					let e = -1
					for (const i of this) t.call(n, i, ++e, this)
					return this
				},
				eachAfter: function xme(t, n) {
					for (var o, s, a, e = this, i = [e], r = [], c = -1; (e = i.pop()); )
						if ((r.push(e), (o = e.children))) for (s = 0, a = o.length; s < a; ++s) i.push(o[s])
					for (; (e = r.pop()); ) t.call(n, e, ++c, this)
					return this
				},
				eachBefore: function wme(t, n) {
					for (var r, o, e = this, i = [e], s = -1; (e = i.pop()); )
						if ((t.call(n, e, ++s, this), (r = e.children))) for (o = r.length - 1; o >= 0; --o) i.push(r[o])
					return this
				},
				find: function Cme(t, n) {
					let e = -1
					for (const i of this) if (t.call(n, i, ++e, this)) return i
				},
				sum: function Eme(t) {
					return this.eachAfter(function (n) {
						for (var e = +t(n.data) || 0, i = n.children, r = i && i.length; --r >= 0; ) e += i[r].value
						n.value = e
					})
				},
				sort: function Mme(t) {
					return this.eachBefore(function (n) {
						n.children && n.children.sort(t)
					})
				},
				path: function Sme(t) {
					for (
						var n = this,
							e = (function kme(t, n) {
								if (t === n) return t
								var e = t.ancestors(),
									i = n.ancestors(),
									r = null
								for (t = e.pop(), n = i.pop(); t === n; ) (r = t), (t = e.pop()), (n = i.pop())
								return r
							})(n, t),
							i = [n];
						n !== e;

					)
						i.push((n = n.parent))
					for (var r = i.length; t !== e; ) i.splice(r, 0, t), (t = t.parent)
					return i
				},
				ancestors: function Tme() {
					for (var t = this, n = [t]; (t = t.parent); ) n.push(t)
					return n
				},
				descendants: function Fme() {
					return Array.from(this)
				},
				leaves: function Bme() {
					var t = []
					return (
						this.eachBefore(function (n) {
							n.children || t.push(n)
						}),
						t
					)
				},
				links: function Ime() {
					var t = this,
						n = []
					return (
						t.each(function (e) {
							e !== t && n.push({ source: e.parent, target: e })
						}),
						n
					)
				},
				copy: function Lme() {
					return $r(this).eachBefore(Ome)
				},
				[Symbol.iterator]: function* Dme() {
					var n,
						i,
						r,
						o,
						t = this,
						e = [t]
					do {
						for (n = e.reverse(), e = []; (t = n.pop()); )
							if ((yield t, (i = t.children))) for (r = 0, o = i.length; r < o; ++r) e.push(i[r])
					} while (e.length)
				}
			}
			var Ume = A(4244),
				oG = A.n(Ume),
				sG = (function (t) {
					return (t.hide = "hide"), (t.exclude = "exclude"), t
				})(sG || {}),
				Vme = A(9095),
				bE = A.n(Vme)
			function _E(t) {
				var n, e, i
				if (Array.isArray(t)) {
					for (e = Array((n = t.length)); n--; ) e[n] = (i = t[n]) && "object" == typeof i ? _E(i) : i
					return e
				}
				if ("[object Object]" === Object.prototype.toString.call(t)) {
					for (n in ((e = {}), t))
						"__proto__" === n
							? Object.defineProperty(e, n, { value: _E(t[n]), configurable: !0, enumerable: !0, writable: !0 })
							: (e[n] = (i = t[n]) && "object" == typeof i ? _E(i) : i)
					return e
				}
				return t
			}
			function dd(t) {
				return _E(t)
			}
			function zme(t) {
				return !t || Array.isArray(t.nodes) || Array.isArray(t.edges)
					? { nodes: {}, edges: {} }
					: { nodes: t.nodes ?? {}, edges: t.edges ?? {} }
			}
			function Gme(t) {
				return t || {}
			}
			function $me(t) {
				for (const n of t) n.type === sG.hide && (n.type = "flatten")
				return t
			}
			function wD(t) {
				let n = null
				try {
					const e = "string" == typeof t ? JSON.parse(t) : t
					if ("data" in e && "checksum" in e)
						return (n = e.data), (n.fileChecksum = e.checksum || bE()(JSON.stringify(e.data))), n
					if (!e.fileChecksum) {
						const i = "string" == typeof t ? t : JSON.stringify(t)
						e.fileChecksum = bE()(i)
					}
					return e
				} catch {}
				return n
			}
			function hg(t) {
				let n = 2
				if (t.startsWith("/")) n = 1
				else if (!t.startsWith("./")) return t
				return t.slice(n)
			}
			function aG(t, n) {
				const e = cG(n)
				return e.ignoredNodePaths.ignores(hg(t.path)) === e.condition
			}
			function cG(t) {
				let n = !0
				;(t = hg(t.trimStart())).startsWith("!") && ((t = t.slice(1)), (n = !1))
				const e = oG()()
				for (let i of t.split(","))
					(i = i.trimStart()),
						!i.startsWith("*") && !i.endsWith("*") && (i = i.startsWith('"') && i.endsWith('"') ? i.slice(1, -1) : `*${i}*`),
						0 !== i.length && e.add(hg(i))
				return { ignoredNodePaths: e, condition: n }
			}
			function vu(t, n, e) {
				if (0 === n.length) return !1
				const i = oG()()
				for (const r of n) r.type === e && i.add(hg(r.path))
				return i.ignores(hg(t))
			}
			function vE(t, n) {
				if (n) {
					let e
					for (const i of n) (!e || e.path.length < i.path.length) && t.path.startsWith(i.path) && (e = i)
					if (e) return e.color
				}
			}
			function uo(t) {
				return void 0 === t.children || 0 === t.children.length
			}
			var yE = (function (t) {
				return (
					(t[(t.SMALL_MAP = 1)] = "SMALL_MAP"), (t[(t.MEDIUM_MAP = 0.5)] = "MEDIUM_MAP"), (t[(t.BIG_MAP = 0.25)] = "BIG_MAP"), t
				)
			})(yE || {})
			function wE(t) {
				const e = (function Wme(t) {
					let n = 0
					for (const e of t) e.selectedAs !== Fi.None && (n += e.file.fileMeta.exportedFileSize)
					return n
				})(t)
				switch (!0) {
					case e >= 7340032:
						return yE.BIG_MAP
					case e >= 2097152:
						return yE.MEDIUM_MAP
					default:
						return yE.SMALL_MAP
				}
			}
			const lG = t => {
				t.sort((n, e) => {
					const i = n.name.toLowerCase(),
						r = e.name.toLowerCase()
					return i > r ? 1 : r > i ? -1 : 0
				})
			}
			function Xme(t, n) {
				const e = new Map(),
					i = new Set()
				for (const { file: o } of t) for (const { data: s } of $r(o.map)) i.add(s.path)
				for (const o of t)
					for (const s of o.file.settings.fileSettings.edges)
						if (Yme(s, i, n)) for (const a of Object.keys(s.attributes)) Zme(qme(e, a), s.fromNodeName, s.toNodeName)
				const r = (function Jme(t) {
					const n = []
					for (const [e, i] of t) {
						const r = []
						let o = 0,
							s = Number.MAX_SAFE_INTEGER
						for (const a of i.values()) {
							const c = a.incoming + a.outgoing
							r.push(c), c > o && (o = c), c <= s && (s = c)
						}
						n.push({ name: e, values: r, maxValue: o, minValue: s })
					}
					return n
				})(e)
				return lG(r), { edgeMetricData: r, nodeEdgeMetricsMap: e }
			}
			function Yme(t, n, e) {
				return !(
					!n.has(t.fromNodeName) ||
					!n.has(t.toNodeName) ||
					vu(t.fromNodeName, e, "exclude") ||
					vu(t.toNodeName, e, "exclude")
				)
			}
			function qme(t, n) {
				let e = t.get(n)
				return e || ((e = new Map()), t.set(n, e)), e
			}
			function Zme(t, n, e) {
				const i = t.get(n)
				void 0 === i ? t.set(n, { incoming: 0, outgoing: 1 }) : (i.outgoing += 1)
				const r = t.get(e)
				void 0 === r ? t.set(e, { incoming: 1, outgoing: 0 }) : (r.incoming += 1)
			}
			const xE = "unary",
				epe = (t, n) => {
					if (0 === t.length) return []
					const e = new Map(),
						i = new Map(),
						r = new Map()
					for (const { file: s } of t)
						for (const a of $r(s.map))
							if (uo(a) && a.data.path && !vu(a.data.path, n, "exclude"))
								for (const c of Object.keys(a.data.attributes)) {
									const l = i.get(c),
										d = r.get(c)
									e.get(c) || e.set(c, []),
										e.get(c).push(a.data.attributes[c]),
										(void 0 === d || d >= a.data.attributes[c]) && r.set(c, a.data.attributes[c]),
										(void 0 === l || l <= a.data.attributes[c]) && i.set(c, a.data.attributes[c])
								}
					const o = []
					i.set(xE, 1), r.set(xE, 1)
					for (const [s, a] of i) o.push({ name: s, values: e.get(s), maxValue: a, minValue: r.get(s) })
					return lG(o), o
				},
				Fs = Mt(ld, cd, (t, n) => ({ nodeMetricData: epe(t, n), ...Xme(t, n) })),
				tpe = [Oh, bu, hl, gu]
			var ud = (function (t) {
				return (t.areaMetric = "area"), (t.heightMetric = "height"), (t.colorMetric = "color"), (t.edgeMetric = "edge"), t
			})(ud || {})
			let npe = (() => {
				class t {
					constructor(e, i, r, o) {
						;(this.loadInitialFileService = e),
							(this.actions$ = i),
							(this.state = r),
							(this.store = o),
							(this.saveMetricsInQueryParameters$ = yo(
								() =>
									this.actions$.pipe(
										dl(...tpe),
										mu(this.store.select(Fs)),
										Ke(s => s[1].edgeMetricData && s[1].edgeMetricData.length > 0),
										ug(100),
										eo(s => {
											this.updateMetricQueryParameters(s)
										})
									),
								{ dispatch: !1 }
							))
					}
					updateMetricQueryParameters(e) {
						const i = this.state.getValue(),
							{ edgeMetric: r, heightMetric: o, colorMetric: s, areaMetric: a } = i.dynamicSettings
						this.loadInitialFileService.checkFileQueryParameterPresent() &&
							(this.addOrUpdateQueryParameter(ud.areaMetric, a),
							this.addOrUpdateQueryParameter(ud.heightMetric, o),
							this.addOrUpdateQueryParameter(ud.colorMetric, s),
							e ? this.addOrUpdateQueryParameter(ud.edgeMetric, r) : this.deleteQueryParameterIfExists(ud.edgeMetric))
					}
					addOrUpdateQueryParameter(e, i) {
						const r = new URL(window.location.href),
							o = r.search.slice(1),
							s = o.length > 0 ? o.split("&") : [],
							a = []
						let c = !1
						for (const l of s) l.split("=")[0] === e ? (a.push(`${e}=${encodeURIComponent(i)}`), (c = !0)) : a.push(l)
						c || a.push(`${e}=${encodeURIComponent(i)}`),
							(r.search = a.join("&")),
							window.history.replaceState(null, "", r.toString())
					}
					deleteQueryParameterIfExists(e) {
						const i = new URL(window.location.href),
							r = i.search.slice(1),
							o = r.length > 0 ? r.split("&") : [],
							s = []
						for (const a of o) {
							const [c, l] = a.split("=")
							c !== e && s.push(`${c}=${l}`)
						}
						;(i.search = s.join("&")), window.history.replaceState(null, "", i.toString())
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(WL), re(pu), re(Sr), re(Ct))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const fg = Nt("SET_IS_LOADING_MAP", { _as: "props", _p: void 0 }),
				mv = Nt("SET_FILES", { _as: "props", _p: void 0 }),
				dG = Nt("ADD_FILE", { _as: "props", _p: void 0 }),
				xD = Nt("REMOVE_FILE", { _as: "props", _p: void 0 }),
				pv = Nt("SET_STANDARD", { _as: "props", _p: void 0 }),
				CD = Nt("SET_STANDARD_BY_NAMES", { _as: "props", _p: void 0 }),
				ED = Nt("SET_ALL"),
				MD = Nt("INVERT_STANDARD"),
				SD = Nt("SWITCH_REFERENCE_AND_COMPARISON"),
				kD = Nt("SET_DELTA_COMPARISON", { _as: "props", _p: void 0 }),
				TD = Nt("SET_DELTA_REFERENCE", { _as: "props", _p: void 0 }),
				CE = Nt("SET_DELTA", { _as: "props", _p: void 0 }),
				EE = [mv, dG, xD, pv, CD, ED, MD, SD, kD, TD, CE]
			function Mn(t) {
				return null != t && "false" != `${t}`
			}
			function to(t, n = 0) {
				return (function ipe(t) {
					return !isNaN(parseFloat(t)) && !isNaN(Number(t))
				})(t)
					? Number(t)
					: n
			}
			function ME(t) {
				return Array.isArray(t) ? t : [t]
			}
			function Qo(t) {
				return null == t ? "" : "string" == typeof t ? t : `${t}px`
			}
			function yu(t) {
				return t instanceof wn ? t.nativeElement : t
			}
			const rpe = ["addListener", "removeListener"],
				ope = ["addEventListener", "removeEventListener"],
				spe = ["on", "off"]
			function mg(t, n, e, i) {
				if ((q(e) && ((i = e), (e = void 0)), i)) return mg(t, n, e).pipe(tI(i))
				const [r, o] = (function lpe(t) {
					return q(t.addEventListener) && q(t.removeEventListener)
				})(t)
					? ope.map(s => a => t[s](n, a, e))
					: (function ape(t) {
							return q(t.addListener) && q(t.removeListener)
					  })(t)
					? rpe.map(uG(t, n))
					: (function cpe(t) {
							return q(t.on) && q(t.off)
					  })(t)
					? spe.map(uG(t, n))
					: []
				if (!r && Wc(t)) return ir(s => mg(s, n, e))(_e(t))
				if (!r) throw new TypeError("Invalid event target")
				return new Ge(s => {
					const a = (...c) => s.next(1 < c.length ? c : c[0])
					return r(a), () => o(a)
				})
			}
			function uG(t, n) {
				return e => i => t[e](n, i)
			}
			const Av = {
				schedule(t) {
					let n = requestAnimationFrame,
						e = cancelAnimationFrame
					const { delegate: i } = Av
					i && ((n = i.requestAnimationFrame), (e = i.cancelAnimationFrame))
					const r = n(o => {
						;(e = void 0), t(o)
					})
					return new D(() => e?.(r))
				},
				requestAnimationFrame(...t) {
					const { delegate: n } = Av
					return (n?.requestAnimationFrame || requestAnimationFrame)(...t)
				},
				cancelAnimationFrame(...t) {
					const { delegate: n } = Av
					return (n?.cancelAnimationFrame || cancelAnimationFrame)(...t)
				},
				delegate: void 0
			}
			new (class upe extends GC {
				flush(n) {
					this._active = !0
					const e = this._scheduled
					this._scheduled = void 0
					const { actions: i } = this
					let r
					n = n || i.shift()
					do {
						if ((r = n.execute(n.state, n.delay))) break
					} while ((n = i[0]) && n.id === e && i.shift())
					if (((this._active = !1), r)) {
						for (; (n = i[0]) && n.id === e && i.shift(); ) n.unsubscribe()
						throw r
					}
				}
			})(
				class dpe extends zC {
					constructor(n, e) {
						super(n, e), (this.scheduler = n), (this.work = e)
					}
					requestAsyncId(n, e, i = 0) {
						return null !== i && i > 0
							? super.requestAsyncId(n, e, i)
							: (n.actions.push(this), n._scheduled || (n._scheduled = Av.requestAnimationFrame(() => n.flush(void 0))))
					}
					recycleAsyncId(n, e, i = 0) {
						var r
						if (null != i ? i > 0 : this.delay > 0) return super.recycleAsyncId(n, e, i)
						const { actions: o } = n
						null != e &&
							(null === (r = o[o.length - 1]) || void 0 === r ? void 0 : r.id) !== e &&
							(Av.cancelAnimationFrame(e), (n._scheduled = void 0))
					}
				}
			)
			let FD,
				fpe = 1
			const SE = {}
			function hG(t) {
				return t in SE && (delete SE[t], !0)
			}
			const mpe = {
					setImmediate(t) {
						const n = fpe++
						return (SE[n] = !0), FD || (FD = Promise.resolve()), FD.then(() => hG(n) && t()), n
					},
					clearImmediate(t) {
						hG(t)
					}
				},
				{ setImmediate: ppe, clearImmediate: Ape } = mpe,
				kE = {
					setImmediate(...t) {
						const { delegate: n } = kE
						return (n?.setImmediate || ppe)(...t)
					},
					clearImmediate(t) {
						const { delegate: n } = kE
						return (n?.clearImmediate || Ape)(t)
					},
					delegate: void 0
				},
				BD = new (class bpe extends GC {
					flush(n) {
						this._active = !0
						const e = this._scheduled
						this._scheduled = void 0
						const { actions: i } = this
						let r
						n = n || i.shift()
						do {
							if ((r = n.execute(n.state, n.delay))) break
						} while ((n = i[0]) && n.id === e && i.shift())
						if (((this._active = !1), r)) {
							for (; (n = i[0]) && n.id === e && i.shift(); ) n.unsubscribe()
							throw r
						}
					}
				})(
					class gpe extends zC {
						constructor(n, e) {
							super(n, e), (this.scheduler = n), (this.work = e)
						}
						requestAsyncId(n, e, i = 0) {
							return null !== i && i > 0
								? super.requestAsyncId(n, e, i)
								: (n.actions.push(this), n._scheduled || (n._scheduled = kE.setImmediate(n.flush.bind(n, void 0))))
						}
						recycleAsyncId(n, e, i = 0) {
							var r
							if (null != i ? i > 0 : this.delay > 0) return super.recycleAsyncId(n, e, i)
							const { actions: o } = n
							null != e &&
								(null === (r = o[o.length - 1]) || void 0 === r ? void 0 : r.id) !== e &&
								(kE.clearImmediate(e), n._scheduled === e && (n._scheduled = void 0))
						}
					}
				)
			function ID(t = 0, n, e = bme) {
				let i = -1
				return (
					null != n && (Ps(n) ? (e = n) : (i = n)),
					new Ge(r => {
						let o = (function vpe(t) {
							return t instanceof Date && !isNaN(t)
						})(t)
							? +t - e.now()
							: t
						o < 0 && (o = 0)
						let s = 0
						return e.schedule(function () {
							r.closed || (r.next(s++), 0 <= i ? this.schedule(void 0, i) : r.complete())
						}, o)
					})
				)
			}
			function DD(t, n = dg) {
				return (function _pe(t) {
					return Wt((n, e) => {
						let i = !1,
							r = null,
							o = null,
							s = !1
						const a = () => {
								if ((o?.unsubscribe(), (o = null), i)) {
									i = !1
									const l = r
									;(r = null), e.next(l)
								}
								s && e.complete()
							},
							c = () => {
								;(o = null), s && e.complete()
							}
						n.subscribe(
							we(
								e,
								l => {
									;(i = !0), (r = l), o || _e(t(l)).subscribe((o = we(e, a, c)))
								},
								() => {
									;(s = !0), (!i || !o || o.closed) && e.complete()
								}
							)
						)
					})
				})(() => ID(t, n))
			}
			let LD
			try {
				LD = typeof Intl < "u" && Intl.v8BreakIterator
			} catch {
				LD = !1
			}
			let pg,
				Wr = (() => {
					class t {
						constructor(e) {
							;(this._platformId = e),
								(this.isBrowser = this._platformId
									? (function Cle(t) {
											return t === JQ
									  })(this._platformId)
									: "object" == typeof document && !!document),
								(this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent)),
								(this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent)),
								(this.BLINK =
									this.isBrowser && !(!window.chrome && !LD) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT),
								(this.WEBKIT =
									this.isBrowser &&
									/AppleWebKit/i.test(navigator.userAgent) &&
									!this.BLINK &&
									!this.EDGE &&
									!this.TRIDENT),
								(this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window)),
								(this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent)),
								(this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT),
								(this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Mh))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			const fG = [
				"color",
				"button",
				"checkbox",
				"date",
				"datetime-local",
				"email",
				"file",
				"hidden",
				"image",
				"month",
				"number",
				"password",
				"radio",
				"range",
				"reset",
				"search",
				"submit",
				"tel",
				"text",
				"time",
				"url",
				"week"
			]
			function mG() {
				if (pg) return pg
				if ("object" != typeof document || !document) return (pg = new Set(fG)), pg
				let t = document.createElement("input")
				return (pg = new Set(fG.filter(n => (t.setAttribute("type", n), t.type === n)))), pg
			}
			let gv, Pm, RD
			function Rm(t) {
				return (function ype() {
					if (null == gv && typeof window < "u")
						try {
							window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => (gv = !0) }))
						} finally {
							gv = gv || !1
						}
					return gv
				})()
					? t
					: !!t.capture
			}
			function wpe() {
				if (null == Pm) {
					if ("object" != typeof document || !document || "function" != typeof Element || !Element) return (Pm = !1), Pm
					if ("scrollBehavior" in document.documentElement.style) Pm = !0
					else {
						const t = Element.prototype.scrollTo
						Pm = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString())
					}
				}
				return Pm
			}
			function FE() {
				let t = typeof document < "u" && document ? document.activeElement : null
				for (; t && t.shadowRoot; ) {
					const n = t.shadowRoot.activeElement
					if (n === t) break
					t = n
				}
				return t
			}
			function Hh(t) {
				return t.composedPath ? t.composedPath()[0] : t.target
			}
			function PD() {
				return (
					(typeof __karma__ < "u" && !!__karma__) ||
					(typeof jasmine < "u" && !!jasmine) ||
					(typeof jest < "u" && !!jest) ||
					(typeof Mocha < "u" && !!Mocha)
				)
			}
			const Epe = new He("cdk-dir-doc", {
					providedIn: "root",
					factory: function Mpe() {
						return Rt(wi)
					}
				}),
				Spe = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i
			let wu = (() => {
					class t {
						constructor(e) {
							;(this.value = "ltr"),
								(this.change = new _n()),
								e &&
									(this.value = (function kpe(t) {
										const n = t?.toLowerCase() || ""
										return "auto" === n && typeof navigator < "u" && navigator?.language
											? Spe.test(navigator.language)
												? "rtl"
												: "ltr"
											: "rtl" === n
											? "rtl"
											: "ltr"
									})((e.body ? e.body.dir : null) || (e.documentElement ? e.documentElement.dir : null) || "ltr"))
						}
						ngOnDestroy() {
							this.change.complete()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Epe, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				bv = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				pG = (() => {
					class t {
						constructor(e, i, r) {
							;(this._ngZone = e),
								(this._platform = i),
								(this._scrolled = new vt()),
								(this._globalSubscription = null),
								(this._scrolledCount = 0),
								(this.scrollContainers = new Map()),
								(this._document = r)
						}
						register(e) {
							this.scrollContainers.has(e) ||
								this.scrollContainers.set(
									e,
									e.elementScrolled().subscribe(() => this._scrolled.next(e))
								)
						}
						deregister(e) {
							const i = this.scrollContainers.get(e)
							i && (i.unsubscribe(), this.scrollContainers.delete(e))
						}
						scrolled(e = 20) {
							return this._platform.isBrowser
								? new Ge(i => {
										this._globalSubscription || this._addGlobalListener()
										const r = e > 0 ? this._scrolled.pipe(DD(e)).subscribe(i) : this._scrolled.subscribe(i)
										return (
											this._scrolledCount++,
											() => {
												r.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener()
											}
										)
								  })
								: Wo()
						}
						ngOnDestroy() {
							this._removeGlobalListener(),
								this.scrollContainers.forEach((e, i) => this.deregister(i)),
								this._scrolled.complete()
						}
						ancestorScrolled(e, i) {
							const r = this.getAncestorScrollContainers(e)
							return this.scrolled(i).pipe(xi(o => !o || r.indexOf(o) > -1))
						}
						getAncestorScrollContainers(e) {
							const i = []
							return (
								this.scrollContainers.forEach((r, o) => {
									this._scrollableContainsElement(o, e) && i.push(o)
								}),
								i
							)
						}
						_getWindow() {
							return this._document.defaultView || window
						}
						_scrollableContainsElement(e, i) {
							let r = yu(i),
								o = e.getElementRef().nativeElement
							do {
								if (r == o) return !0
							} while ((r = r.parentElement))
							return !1
						}
						_addGlobalListener() {
							this._globalSubscription = this._ngZone.runOutsideAngular(() =>
								mg(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())
							)
						}
						_removeGlobalListener() {
							this._globalSubscription && (this._globalSubscription.unsubscribe(), (this._globalSubscription = null))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(mn), re(Wr), re(wi, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				OD = (() => {
					class t {
						constructor(e, i, r) {
							;(this._platform = e),
								(this._change = new vt()),
								(this._changeListener = o => {
									this._change.next(o)
								}),
								(this._document = r),
								i.runOutsideAngular(() => {
									if (e.isBrowser) {
										const o = this._getWindow()
										o.addEventListener("resize", this._changeListener),
											o.addEventListener("orientationchange", this._changeListener)
									}
									this.change().subscribe(() => (this._viewportSize = null))
								})
						}
						ngOnDestroy() {
							if (this._platform.isBrowser) {
								const e = this._getWindow()
								e.removeEventListener("resize", this._changeListener),
									e.removeEventListener("orientationchange", this._changeListener)
							}
							this._change.complete()
						}
						getViewportSize() {
							this._viewportSize || this._updateViewportSize()
							const e = { width: this._viewportSize.width, height: this._viewportSize.height }
							return this._platform.isBrowser || (this._viewportSize = null), e
						}
						getViewportRect() {
							const e = this.getViewportScrollPosition(),
								{ width: i, height: r } = this.getViewportSize()
							return { top: e.top, left: e.left, bottom: e.top + r, right: e.left + i, height: r, width: i }
						}
						getViewportScrollPosition() {
							if (!this._platform.isBrowser) return { top: 0, left: 0 }
							const e = this._document,
								i = this._getWindow(),
								r = e.documentElement,
								o = r.getBoundingClientRect()
							return {
								top: -o.top || e.body.scrollTop || i.scrollY || r.scrollTop || 0,
								left: -o.left || e.body.scrollLeft || i.scrollX || r.scrollLeft || 0
							}
						}
						change(e = 20) {
							return e > 0 ? this._change.pipe(DD(e)) : this._change
						}
						_getWindow() {
							return this._document.defaultView || window
						}
						_updateViewportSize() {
							const e = this._getWindow()
							this._viewportSize = this._platform.isBrowser
								? { width: e.innerWidth, height: e.innerHeight }
								: { width: 0, height: 0 }
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Wr), re(mn), re(wi, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				_v = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				AG = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [bv, _v, bv, _v] })
						}
					}
					return t
				})()
			function kr(t) {
				return Wt((n, e) => {
					_e(t).subscribe(we(e, () => e.complete(), G)), !e.closed && n.subscribe(e)
				})
			}
			class ND {
				attach(n) {
					return (this._attachedHost = n), n.attach(this)
				}
				detach() {
					let n = this._attachedHost
					null != n && ((this._attachedHost = null), n.detach())
				}
				get isAttached() {
					return null != this._attachedHost
				}
				setAttachedHost(n) {
					this._attachedHost = n
				}
			}
			class vv extends ND {
				constructor(n, e, i, r, o) {
					super(),
						(this.component = n),
						(this.viewContainerRef = e),
						(this.injector = i),
						(this.componentFactoryResolver = r),
						(this.projectableNodes = o)
				}
			}
			class yv extends ND {
				constructor(n, e, i, r) {
					super(), (this.templateRef = n), (this.viewContainerRef = e), (this.context = i), (this.injector = r)
				}
				get origin() {
					return this.templateRef.elementRef
				}
				attach(n, e = this.context) {
					return (this.context = e), super.attach(n)
				}
				detach() {
					return (this.context = void 0), super.detach()
				}
			}
			class Ipe extends ND {
				constructor(n) {
					super(), (this.element = n instanceof wn ? n.nativeElement : n)
				}
			}
			class UD {
				constructor() {
					;(this._isDisposed = !1), (this.attachDomPortal = null)
				}
				hasAttached() {
					return !!this._attachedPortal
				}
				attach(n) {
					return n instanceof vv
						? ((this._attachedPortal = n), this.attachComponentPortal(n))
						: n instanceof yv
						? ((this._attachedPortal = n), this.attachTemplatePortal(n))
						: this.attachDomPortal && n instanceof Ipe
						? ((this._attachedPortal = n), this.attachDomPortal(n))
						: void 0
				}
				detach() {
					this._attachedPortal && (this._attachedPortal.setAttachedHost(null), (this._attachedPortal = null)),
						this._invokeDisposeFn()
				}
				dispose() {
					this.hasAttached() && this.detach(), this._invokeDisposeFn(), (this._isDisposed = !0)
				}
				setDisposeFn(n) {
					this._disposeFn = n
				}
				_invokeDisposeFn() {
					this._disposeFn && (this._disposeFn(), (this._disposeFn = null))
				}
			}
			class Dpe extends UD {
				constructor(n, e, i, r, o) {
					super(),
						(this.outletElement = n),
						(this._componentFactoryResolver = e),
						(this._appRef = i),
						(this._defaultInjector = r),
						(this.attachDomPortal = s => {
							const a = s.element,
								c = this._document.createComment("dom-portal")
							a.parentNode.insertBefore(c, a),
								this.outletElement.appendChild(a),
								(this._attachedPortal = s),
								super.setDisposeFn(() => {
									c.parentNode && c.parentNode.replaceChild(a, c)
								})
						}),
						(this._document = o)
				}
				attachComponentPortal(n) {
					const i = (n.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(n.component)
					let r
					return (
						n.viewContainerRef
							? ((r = n.viewContainerRef.createComponent(
									i,
									n.viewContainerRef.length,
									n.injector || n.viewContainerRef.injector,
									n.projectableNodes || void 0
							  )),
							  this.setDisposeFn(() => r.destroy()))
							: ((r = i.create(n.injector || this._defaultInjector || ks.NULL)),
							  this._appRef.attachView(r.hostView),
							  this.setDisposeFn(() => {
									this._appRef.viewCount > 0 && this._appRef.detachView(r.hostView), r.destroy()
							  })),
						this.outletElement.appendChild(this._getComponentRootNode(r)),
						(this._attachedPortal = n),
						r
					)
				}
				attachTemplatePortal(n) {
					let e = n.viewContainerRef,
						i = e.createEmbeddedView(n.templateRef, n.context, { injector: n.injector })
					return (
						i.rootNodes.forEach(r => this.outletElement.appendChild(r)),
						i.detectChanges(),
						this.setDisposeFn(() => {
							let r = e.indexOf(i)
							;-1 !== r && e.remove(r)
						}),
						(this._attachedPortal = n),
						i
					)
				}
				dispose() {
					super.dispose(), this.outletElement.remove()
				}
				_getComponentRootNode(n) {
					return n.hostView.rootNodes[0]
				}
			}
			let BE = (() => {
					class t extends UD {
						constructor(e, i, r) {
							super(),
								(this._componentFactoryResolver = e),
								(this._viewContainerRef = i),
								(this._isInitialized = !1),
								(this.attached = new _n()),
								(this.attachDomPortal = o => {
									const s = o.element,
										a = this._document.createComment("dom-portal")
									o.setAttachedHost(this),
										s.parentNode.insertBefore(a, s),
										this._getRootNode().appendChild(s),
										(this._attachedPortal = o),
										super.setDisposeFn(() => {
											a.parentNode && a.parentNode.replaceChild(s, a)
										})
								}),
								(this._document = r)
						}
						get portal() {
							return this._attachedPortal
						}
						set portal(e) {
							;(this.hasAttached() && !e && !this._isInitialized) ||
								(this.hasAttached() && super.detach(), e && super.attach(e), (this._attachedPortal = e || null))
						}
						get attachedRef() {
							return this._attachedRef
						}
						ngOnInit() {
							this._isInitialized = !0
						}
						ngOnDestroy() {
							super.dispose(), (this._attachedRef = this._attachedPortal = null)
						}
						attachComponentPortal(e) {
							e.setAttachedHost(this)
							const i = null != e.viewContainerRef ? e.viewContainerRef : this._viewContainerRef,
								o = (e.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(e.component),
								s = i.createComponent(o, i.length, e.injector || i.injector, e.projectableNodes || void 0)
							return (
								i !== this._viewContainerRef && this._getRootNode().appendChild(s.hostView.rootNodes[0]),
								super.setDisposeFn(() => s.destroy()),
								(this._attachedPortal = e),
								(this._attachedRef = s),
								this.attached.emit(s),
								s
							)
						}
						attachTemplatePortal(e) {
							e.setAttachedHost(this)
							const i = this._viewContainerRef.createEmbeddedView(e.templateRef, e.context, { injector: e.injector })
							return (
								super.setDisposeFn(() => this._viewContainerRef.clear()),
								(this._attachedPortal = e),
								(this._attachedRef = i),
								this.attached.emit(i),
								i
							)
						}
						_getRootNode() {
							const e = this._viewContainerRef.element.nativeElement
							return e.nodeType === e.ELEMENT_NODE ? e : e.parentNode
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(RA), P(ra), P(wi))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "cdkPortalOutlet", ""]],
								inputs: { portal: ["cdkPortalOutlet", "portal"] },
								outputs: { attached: "attached" },
								exportAs: ["cdkPortalOutlet"],
								features: [pn]
							})
						}
					}
					return t
				})(),
				wv = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})()
			function fl(t, ...n) {
				return n.length ? n.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey
			}
			const gG = wpe()
			class jpe {
				constructor(n, e) {
					;(this._viewportRuler = n),
						(this._previousHTMLStyles = { top: "", left: "" }),
						(this._isEnabled = !1),
						(this._document = e)
				}
				attach() {}
				enable() {
					if (this._canBeEnabled()) {
						const n = this._document.documentElement
						;(this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition()),
							(this._previousHTMLStyles.left = n.style.left || ""),
							(this._previousHTMLStyles.top = n.style.top || ""),
							(n.style.left = Qo(-this._previousScrollPosition.left)),
							(n.style.top = Qo(-this._previousScrollPosition.top)),
							n.classList.add("cdk-global-scrollblock"),
							(this._isEnabled = !0)
					}
				}
				disable() {
					if (this._isEnabled) {
						const n = this._document.documentElement,
							i = n.style,
							r = this._document.body.style,
							o = i.scrollBehavior || "",
							s = r.scrollBehavior || ""
						;(this._isEnabled = !1),
							(i.left = this._previousHTMLStyles.left),
							(i.top = this._previousHTMLStyles.top),
							n.classList.remove("cdk-global-scrollblock"),
							gG && (i.scrollBehavior = r.scrollBehavior = "auto"),
							window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top),
							gG && ((i.scrollBehavior = o), (r.scrollBehavior = s))
					}
				}
				_canBeEnabled() {
					if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1
					const e = this._document.body,
						i = this._viewportRuler.getViewportSize()
					return e.scrollHeight > i.height || e.scrollWidth > i.width
				}
			}
			class Kpe {
				constructor(n, e, i, r) {
					;(this._scrollDispatcher = n),
						(this._ngZone = e),
						(this._viewportRuler = i),
						(this._config = r),
						(this._scrollSubscription = null),
						(this._detach = () => {
							this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach())
						})
				}
				attach(n) {
					this._overlayRef = n
				}
				enable() {
					if (this._scrollSubscription) return
					const n = this._scrollDispatcher
						.scrolled(0)
						.pipe(xi(e => !e || !this._overlayRef.overlayElement.contains(e.getElementRef().nativeElement)))
					this._config && this._config.threshold && this._config.threshold > 1
						? ((this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top),
						  (this._scrollSubscription = n.subscribe(() => {
								const e = this._viewportRuler.getViewportScrollPosition().top
								Math.abs(e - this._initialScrollPosition) > this._config.threshold
									? this._detach()
									: this._overlayRef.updatePosition()
						  })))
						: (this._scrollSubscription = n.subscribe(this._detach))
				}
				disable() {
					this._scrollSubscription && (this._scrollSubscription.unsubscribe(), (this._scrollSubscription = null))
				}
				detach() {
					this.disable(), (this._overlayRef = null)
				}
			}
			class bG {
				enable() {}
				disable() {}
				attach() {}
			}
			function VD(t, n) {
				return n.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right)
			}
			function _G(t, n) {
				return n.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right)
			}
			class Xpe {
				constructor(n, e, i, r) {
					;(this._scrollDispatcher = n),
						(this._viewportRuler = e),
						(this._ngZone = i),
						(this._config = r),
						(this._scrollSubscription = null)
				}
				attach(n) {
					this._overlayRef = n
				}
				enable() {
					this._scrollSubscription ||
						(this._scrollSubscription = this._scrollDispatcher
							.scrolled(this._config ? this._config.scrollThrottle : 0)
							.subscribe(() => {
								if ((this._overlayRef.updatePosition(), this._config && this._config.autoClose)) {
									const e = this._overlayRef.overlayElement.getBoundingClientRect(),
										{ width: i, height: r } = this._viewportRuler.getViewportSize()
									VD(e, [{ width: i, height: r, bottom: r, right: i, top: 0, left: 0 }]) &&
										(this.disable(), this._ngZone.run(() => this._overlayRef.detach()))
								}
							}))
				}
				disable() {
					this._scrollSubscription && (this._scrollSubscription.unsubscribe(), (this._scrollSubscription = null))
				}
				detach() {
					this.disable(), (this._overlayRef = null)
				}
			}
			let Ype = (() => {
				class t {
					constructor(e, i, r, o) {
						;(this._scrollDispatcher = e),
							(this._viewportRuler = i),
							(this._ngZone = r),
							(this.noop = () => new bG()),
							(this.close = s => new Kpe(this._scrollDispatcher, this._ngZone, this._viewportRuler, s)),
							(this.block = () => new jpe(this._viewportRuler, this._document)),
							(this.reposition = s => new Xpe(this._scrollDispatcher, this._viewportRuler, this._ngZone, s)),
							(this._document = o)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(pG), re(OD), re(mn), re(wi))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			class PE {
				constructor(n) {
					if (
						((this.scrollStrategy = new bG()),
						(this.panelClass = ""),
						(this.hasBackdrop = !1),
						(this.backdropClass = "cdk-overlay-dark-backdrop"),
						(this.disposeOnNavigation = !1),
						n)
					) {
						const e = Object.keys(n)
						for (const i of e) void 0 !== n[i] && (this[i] = n[i])
					}
				}
			}
			class qpe {
				constructor(n, e) {
					;(this.connectionPair = n), (this.scrollableViewProperties = e)
				}
			}
			let vG = (() => {
					class t {
						constructor(e) {
							;(this._attachedOverlays = []), (this._document = e)
						}
						ngOnDestroy() {
							this.detach()
						}
						add(e) {
							this.remove(e), this._attachedOverlays.push(e)
						}
						remove(e) {
							const i = this._attachedOverlays.indexOf(e)
							i > -1 && this._attachedOverlays.splice(i, 1), 0 === this._attachedOverlays.length && this.detach()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(wi))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				Zpe = (() => {
					class t extends vG {
						constructor(e, i) {
							super(e),
								(this._ngZone = i),
								(this._keydownListener = r => {
									const o = this._attachedOverlays
									for (let s = o.length - 1; s > -1; s--)
										if (o[s]._keydownEvents.observers.length > 0) {
											const a = o[s]._keydownEvents
											this._ngZone ? this._ngZone.run(() => a.next(r)) : a.next(r)
											break
										}
								})
						}
						add(e) {
							super.add(e),
								this._isAttached ||
									(this._ngZone
										? this._ngZone.runOutsideAngular(() =>
												this._document.body.addEventListener("keydown", this._keydownListener)
										  )
										: this._document.body.addEventListener("keydown", this._keydownListener),
									(this._isAttached = !0))
						}
						detach() {
							this._isAttached &&
								(this._document.body.removeEventListener("keydown", this._keydownListener), (this._isAttached = !1))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(wi), re(mn, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				Jpe = (() => {
					class t extends vG {
						constructor(e, i, r) {
							super(e),
								(this._platform = i),
								(this._ngZone = r),
								(this._cursorStyleIsSet = !1),
								(this._pointerDownListener = o => {
									this._pointerDownEventTarget = Hh(o)
								}),
								(this._clickListener = o => {
									const s = Hh(o),
										a = "click" === o.type && this._pointerDownEventTarget ? this._pointerDownEventTarget : s
									this._pointerDownEventTarget = null
									const c = this._attachedOverlays.slice()
									for (let l = c.length - 1; l > -1; l--) {
										const d = c[l]
										if (d._outsidePointerEvents.observers.length < 1 || !d.hasAttached()) continue
										if (d.overlayElement.contains(s) || d.overlayElement.contains(a)) break
										const u = d._outsidePointerEvents
										this._ngZone ? this._ngZone.run(() => u.next(o)) : u.next(o)
									}
								})
						}
						add(e) {
							if ((super.add(e), !this._isAttached)) {
								const i = this._document.body
								this._ngZone
									? this._ngZone.runOutsideAngular(() => this._addEventListeners(i))
									: this._addEventListeners(i),
									this._platform.IOS &&
										!this._cursorStyleIsSet &&
										((this._cursorOriginalValue = i.style.cursor),
										(i.style.cursor = "pointer"),
										(this._cursorStyleIsSet = !0)),
									(this._isAttached = !0)
							}
						}
						detach() {
							if (this._isAttached) {
								const e = this._document.body
								e.removeEventListener("pointerdown", this._pointerDownListener, !0),
									e.removeEventListener("click", this._clickListener, !0),
									e.removeEventListener("auxclick", this._clickListener, !0),
									e.removeEventListener("contextmenu", this._clickListener, !0),
									this._platform.IOS &&
										this._cursorStyleIsSet &&
										((e.style.cursor = this._cursorOriginalValue), (this._cursorStyleIsSet = !1)),
									(this._isAttached = !1)
							}
						}
						_addEventListeners(e) {
							e.addEventListener("pointerdown", this._pointerDownListener, !0),
								e.addEventListener("click", this._clickListener, !0),
								e.addEventListener("auxclick", this._clickListener, !0),
								e.addEventListener("contextmenu", this._clickListener, !0)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(wi), re(Wr), re(mn, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				OE = (() => {
					class t {
						constructor(e, i) {
							;(this._platform = i), (this._document = e)
						}
						ngOnDestroy() {
							this._containerElement?.remove()
						}
						getContainerElement() {
							return this._containerElement || this._createContainer(), this._containerElement
						}
						_createContainer() {
							const e = "cdk-overlay-container"
							if (this._platform.isBrowser || PD()) {
								const r = this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`)
								for (let o = 0; o < r.length; o++) r[o].remove()
							}
							const i = this._document.createElement("div")
							i.classList.add(e),
								PD()
									? i.setAttribute("platform", "test")
									: this._platform.isBrowser || i.setAttribute("platform", "server"),
								this._document.body.appendChild(i),
								(this._containerElement = i)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(wi), re(Wr))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			class Cv {
				constructor(n, e, i, r, o, s, a, c, l, d = !1) {
					;(this._portalOutlet = n),
						(this._host = e),
						(this._pane = i),
						(this._config = r),
						(this._ngZone = o),
						(this._keyboardDispatcher = s),
						(this._document = a),
						(this._location = c),
						(this._outsideClickDispatcher = l),
						(this._animationsDisabled = d),
						(this._backdropElement = null),
						(this._backdropClick = new vt()),
						(this._attachments = new vt()),
						(this._detachments = new vt()),
						(this._locationChanges = D.EMPTY),
						(this._backdropClickHandler = u => this._backdropClick.next(u)),
						(this._backdropTransitionendHandler = u => {
							this._disposeBackdrop(u.target)
						}),
						(this._keydownEvents = new vt()),
						(this._outsidePointerEvents = new vt()),
						r.scrollStrategy && ((this._scrollStrategy = r.scrollStrategy), this._scrollStrategy.attach(this)),
						(this._positionStrategy = r.positionStrategy)
				}
				get overlayElement() {
					return this._pane
				}
				get backdropElement() {
					return this._backdropElement
				}
				get hostElement() {
					return this._host
				}
				attach(n) {
					!this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host)
					const e = this._portalOutlet.attach(n)
					return (
						this._positionStrategy && this._positionStrategy.attach(this),
						this._updateStackingOrder(),
						this._updateElementSize(),
						this._updateElementDirection(),
						this._scrollStrategy && this._scrollStrategy.enable(),
						this._ngZone.onStable.pipe(Do(1)).subscribe(() => {
							this.hasAttached() && this.updatePosition()
						}),
						this._togglePointerEvents(!0),
						this._config.hasBackdrop && this._attachBackdrop(),
						this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0),
						this._attachments.next(),
						this._keyboardDispatcher.add(this),
						this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())),
						this._outsideClickDispatcher.add(this),
						"function" == typeof e?.onDestroy &&
							e.onDestroy(() => {
								this.hasAttached() && this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()))
							}),
						e
					)
				}
				detach() {
					if (!this.hasAttached()) return
					this.detachBackdrop(),
						this._togglePointerEvents(!1),
						this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(),
						this._scrollStrategy && this._scrollStrategy.disable()
					const n = this._portalOutlet.detach()
					return (
						this._detachments.next(),
						this._keyboardDispatcher.remove(this),
						this._detachContentWhenStable(),
						this._locationChanges.unsubscribe(),
						this._outsideClickDispatcher.remove(this),
						n
					)
				}
				dispose() {
					const n = this.hasAttached()
					this._positionStrategy && this._positionStrategy.dispose(),
						this._disposeScrollStrategy(),
						this._disposeBackdrop(this._backdropElement),
						this._locationChanges.unsubscribe(),
						this._keyboardDispatcher.remove(this),
						this._portalOutlet.dispose(),
						this._attachments.complete(),
						this._backdropClick.complete(),
						this._keydownEvents.complete(),
						this._outsidePointerEvents.complete(),
						this._outsideClickDispatcher.remove(this),
						this._host?.remove(),
						(this._previousHostParent = this._pane = this._host = null),
						n && this._detachments.next(),
						this._detachments.complete()
				}
				hasAttached() {
					return this._portalOutlet.hasAttached()
				}
				backdropClick() {
					return this._backdropClick
				}
				attachments() {
					return this._attachments
				}
				detachments() {
					return this._detachments
				}
				keydownEvents() {
					return this._keydownEvents
				}
				outsidePointerEvents() {
					return this._outsidePointerEvents
				}
				getConfig() {
					return this._config
				}
				updatePosition() {
					this._positionStrategy && this._positionStrategy.apply()
				}
				updatePositionStrategy(n) {
					n !== this._positionStrategy &&
						(this._positionStrategy && this._positionStrategy.dispose(),
						(this._positionStrategy = n),
						this.hasAttached() && (n.attach(this), this.updatePosition()))
				}
				updateSize(n) {
					;(this._config = { ...this._config, ...n }), this._updateElementSize()
				}
				setDirection(n) {
					;(this._config = { ...this._config, direction: n }), this._updateElementDirection()
				}
				addPanelClass(n) {
					this._pane && this._toggleClasses(this._pane, n, !0)
				}
				removePanelClass(n) {
					this._pane && this._toggleClasses(this._pane, n, !1)
				}
				getDirection() {
					const n = this._config.direction
					return n ? ("string" == typeof n ? n : n.value) : "ltr"
				}
				updateScrollStrategy(n) {
					n !== this._scrollStrategy &&
						(this._disposeScrollStrategy(), (this._scrollStrategy = n), this.hasAttached() && (n.attach(this), n.enable()))
				}
				_updateElementDirection() {
					this._host.setAttribute("dir", this.getDirection())
				}
				_updateElementSize() {
					if (!this._pane) return
					const n = this._pane.style
					;(n.width = Qo(this._config.width)),
						(n.height = Qo(this._config.height)),
						(n.minWidth = Qo(this._config.minWidth)),
						(n.minHeight = Qo(this._config.minHeight)),
						(n.maxWidth = Qo(this._config.maxWidth)),
						(n.maxHeight = Qo(this._config.maxHeight))
				}
				_togglePointerEvents(n) {
					this._pane.style.pointerEvents = n ? "" : "none"
				}
				_attachBackdrop() {
					const n = "cdk-overlay-backdrop-showing"
					;(this._backdropElement = this._document.createElement("div")),
						this._backdropElement.classList.add("cdk-overlay-backdrop"),
						this._animationsDisabled && this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),
						this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0),
						this._host.parentElement.insertBefore(this._backdropElement, this._host),
						this._backdropElement.addEventListener("click", this._backdropClickHandler),
						!this._animationsDisabled && typeof requestAnimationFrame < "u"
							? this._ngZone.runOutsideAngular(() => {
									requestAnimationFrame(() => {
										this._backdropElement && this._backdropElement.classList.add(n)
									})
							  })
							: this._backdropElement.classList.add(n)
				}
				_updateStackingOrder() {
					this._host.nextSibling && this._host.parentNode.appendChild(this._host)
				}
				detachBackdrop() {
					const n = this._backdropElement
					if (n) {
						if (this._animationsDisabled) return void this._disposeBackdrop(n)
						n.classList.remove("cdk-overlay-backdrop-showing"),
							this._ngZone.runOutsideAngular(() => {
								n.addEventListener("transitionend", this._backdropTransitionendHandler)
							}),
							(n.style.pointerEvents = "none"),
							(this._backdropTimeout = this._ngZone.runOutsideAngular(() =>
								setTimeout(() => {
									this._disposeBackdrop(n)
								}, 500)
							))
					}
				}
				_toggleClasses(n, e, i) {
					const r = ME(e || []).filter(o => !!o)
					r.length && (i ? n.classList.add(...r) : n.classList.remove(...r))
				}
				_detachContentWhenStable() {
					this._ngZone.runOutsideAngular(() => {
						const n = this._ngZone.onStable.pipe(kr(oo(this._attachments, this._detachments))).subscribe(() => {
							;(!this._pane || !this._host || 0 === this._pane.children.length) &&
								(this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1),
								this._host &&
									this._host.parentElement &&
									((this._previousHostParent = this._host.parentElement), this._host.remove()),
								n.unsubscribe())
						})
					})
				}
				_disposeScrollStrategy() {
					const n = this._scrollStrategy
					n && (n.disable(), n.detach && n.detach())
				}
				_disposeBackdrop(n) {
					n &&
						(n.removeEventListener("click", this._backdropClickHandler),
						n.removeEventListener("transitionend", this._backdropTransitionendHandler),
						n.remove(),
						this._backdropElement === n && (this._backdropElement = null)),
						this._backdropTimeout && (clearTimeout(this._backdropTimeout), (this._backdropTimeout = void 0))
				}
			}
			const yG = "cdk-overlay-connected-position-bounding-box",
				eAe = /([A-Za-z%]+)$/
			class tAe {
				get positions() {
					return this._preferredPositions
				}
				constructor(n, e, i, r, o) {
					;(this._viewportRuler = e),
						(this._document = i),
						(this._platform = r),
						(this._overlayContainer = o),
						(this._lastBoundingBoxSize = { width: 0, height: 0 }),
						(this._isPushed = !1),
						(this._canPush = !0),
						(this._growAfterOpen = !1),
						(this._hasFlexibleDimensions = !0),
						(this._positionLocked = !1),
						(this._viewportMargin = 0),
						(this._scrollables = []),
						(this._preferredPositions = []),
						(this._positionChanges = new vt()),
						(this._resizeSubscription = D.EMPTY),
						(this._offsetX = 0),
						(this._offsetY = 0),
						(this._appliedPanelClasses = []),
						(this.positionChanges = this._positionChanges),
						this.setOrigin(n)
				}
				attach(n) {
					this._validatePositions(),
						n.hostElement.classList.add(yG),
						(this._overlayRef = n),
						(this._boundingBox = n.hostElement),
						(this._pane = n.overlayElement),
						(this._isDisposed = !1),
						(this._isInitialRender = !0),
						(this._lastPosition = null),
						this._resizeSubscription.unsubscribe(),
						(this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
							;(this._isInitialRender = !0), this.apply()
						}))
				}
				apply() {
					if (this._isDisposed || !this._platform.isBrowser) return
					if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition()
					this._clearPanelClasses(),
						this._resetOverlayElementStyles(),
						this._resetBoundingBoxStyles(),
						(this._viewportRect = this._getNarrowedViewportRect()),
						(this._originRect = this._getOriginRect()),
						(this._overlayRect = this._pane.getBoundingClientRect()),
						(this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect())
					const n = this._originRect,
						e = this._overlayRect,
						i = this._viewportRect,
						r = this._containerRect,
						o = []
					let s
					for (let a of this._preferredPositions) {
						let c = this._getOriginPoint(n, r, a),
							l = this._getOverlayPoint(c, e, a),
							d = this._getOverlayFit(l, e, i, a)
						if (d.isCompletelyWithinViewport) return (this._isPushed = !1), void this._applyPosition(a, c)
						this._canFitWithFlexibleDimensions(d, l, i)
							? o.push({ position: a, origin: c, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(c, a) })
							: (!s || s.overlayFit.visibleArea < d.visibleArea) &&
							  (s = { overlayFit: d, overlayPoint: l, originPoint: c, position: a, overlayRect: e })
					}
					if (o.length) {
						let a = null,
							c = -1
						for (const l of o) {
							const d = l.boundingBoxRect.width * l.boundingBoxRect.height * (l.position.weight || 1)
							d > c && ((c = d), (a = l))
						}
						return (this._isPushed = !1), void this._applyPosition(a.position, a.origin)
					}
					if (this._canPush) return (this._isPushed = !0), void this._applyPosition(s.position, s.originPoint)
					this._applyPosition(s.position, s.originPoint)
				}
				detach() {
					this._clearPanelClasses(),
						(this._lastPosition = null),
						(this._previousPushAmount = null),
						this._resizeSubscription.unsubscribe()
				}
				dispose() {
					this._isDisposed ||
						(this._boundingBox &&
							Om(this._boundingBox.style, {
								top: "",
								left: "",
								right: "",
								bottom: "",
								height: "",
								width: "",
								alignItems: "",
								justifyContent: ""
							}),
						this._pane && this._resetOverlayElementStyles(),
						this._overlayRef && this._overlayRef.hostElement.classList.remove(yG),
						this.detach(),
						this._positionChanges.complete(),
						(this._overlayRef = this._boundingBox = null),
						(this._isDisposed = !0))
				}
				reapplyLastPosition() {
					if (this._isDisposed || !this._platform.isBrowser) return
					const n = this._lastPosition
					if (n) {
						;(this._originRect = this._getOriginRect()),
							(this._overlayRect = this._pane.getBoundingClientRect()),
							(this._viewportRect = this._getNarrowedViewportRect()),
							(this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect())
						const e = this._getOriginPoint(this._originRect, this._containerRect, n)
						this._applyPosition(n, e)
					} else this.apply()
				}
				withScrollableContainers(n) {
					return (this._scrollables = n), this
				}
				withPositions(n) {
					return (
						(this._preferredPositions = n),
						-1 === n.indexOf(this._lastPosition) && (this._lastPosition = null),
						this._validatePositions(),
						this
					)
				}
				withViewportMargin(n) {
					return (this._viewportMargin = n), this
				}
				withFlexibleDimensions(n = !0) {
					return (this._hasFlexibleDimensions = n), this
				}
				withGrowAfterOpen(n = !0) {
					return (this._growAfterOpen = n), this
				}
				withPush(n = !0) {
					return (this._canPush = n), this
				}
				withLockedPosition(n = !0) {
					return (this._positionLocked = n), this
				}
				setOrigin(n) {
					return (this._origin = n), this
				}
				withDefaultOffsetX(n) {
					return (this._offsetX = n), this
				}
				withDefaultOffsetY(n) {
					return (this._offsetY = n), this
				}
				withTransformOriginOn(n) {
					return (this._transformOriginSelector = n), this
				}
				_getOriginPoint(n, e, i) {
					let r, o
					if ("center" == i.originX) r = n.left + n.width / 2
					else {
						const s = this._isRtl() ? n.right : n.left,
							a = this._isRtl() ? n.left : n.right
						r = "start" == i.originX ? s : a
					}
					return (
						e.left < 0 && (r -= e.left),
						(o = "center" == i.originY ? n.top + n.height / 2 : "top" == i.originY ? n.top : n.bottom),
						e.top < 0 && (o -= e.top),
						{ x: r, y: o }
					)
				}
				_getOverlayPoint(n, e, i) {
					let r, o
					return (
						(r =
							"center" == i.overlayX
								? -e.width / 2
								: "start" === i.overlayX
								? this._isRtl()
									? -e.width
									: 0
								: this._isRtl()
								? 0
								: -e.width),
						(o = "center" == i.overlayY ? -e.height / 2 : "top" == i.overlayY ? 0 : -e.height),
						{ x: n.x + r, y: n.y + o }
					)
				}
				_getOverlayFit(n, e, i, r) {
					const o = xG(e)
					let { x: s, y: a } = n,
						c = this._getOffset(r, "x"),
						l = this._getOffset(r, "y")
					c && (s += c), l && (a += l)
					let h = 0 - a,
						f = a + o.height - i.height,
						_ = this._subtractOverflows(o.width, 0 - s, s + o.width - i.width),
						y = this._subtractOverflows(o.height, h, f),
						C = _ * y
					return {
						visibleArea: C,
						isCompletelyWithinViewport: o.width * o.height === C,
						fitsInViewportVertically: y === o.height,
						fitsInViewportHorizontally: _ == o.width
					}
				}
				_canFitWithFlexibleDimensions(n, e, i) {
					if (this._hasFlexibleDimensions) {
						const r = i.bottom - e.y,
							o = i.right - e.x,
							s = wG(this._overlayRef.getConfig().minHeight),
							a = wG(this._overlayRef.getConfig().minWidth)
						return (
							(n.fitsInViewportVertically || (null != s && s <= r)) && (n.fitsInViewportHorizontally || (null != a && a <= o))
						)
					}
					return !1
				}
				_pushOverlayOnScreen(n, e, i) {
					if (this._previousPushAmount && this._positionLocked)
						return { x: n.x + this._previousPushAmount.x, y: n.y + this._previousPushAmount.y }
					const r = xG(e),
						o = this._viewportRect,
						s = Math.max(n.x + r.width - o.width, 0),
						a = Math.max(n.y + r.height - o.height, 0),
						c = Math.max(o.top - i.top - n.y, 0),
						l = Math.max(o.left - i.left - n.x, 0)
					let d = 0,
						u = 0
					return (
						(d = r.width <= o.width ? l || -s : n.x < this._viewportMargin ? o.left - i.left - n.x : 0),
						(u = r.height <= o.height ? c || -a : n.y < this._viewportMargin ? o.top - i.top - n.y : 0),
						(this._previousPushAmount = { x: d, y: u }),
						{ x: n.x + d, y: n.y + u }
					)
				}
				_applyPosition(n, e) {
					if (
						(this._setTransformOrigin(n),
						this._setOverlayElementStyles(e, n),
						this._setBoundingBoxStyles(e, n),
						n.panelClass && this._addPanelClasses(n.panelClass),
						(this._lastPosition = n),
						this._positionChanges.observers.length)
					) {
						const i = this._getScrollVisibility(),
							r = new qpe(n, i)
						this._positionChanges.next(r)
					}
					this._isInitialRender = !1
				}
				_setTransformOrigin(n) {
					if (!this._transformOriginSelector) return
					const e = this._boundingBox.querySelectorAll(this._transformOriginSelector)
					let i,
						r = n.overlayY
					i =
						"center" === n.overlayX
							? "center"
							: this._isRtl()
							? "start" === n.overlayX
								? "right"
								: "left"
							: "start" === n.overlayX
							? "left"
							: "right"
					for (let o = 0; o < e.length; o++) e[o].style.transformOrigin = `${i} ${r}`
				}
				_calculateBoundingBoxRect(n, e) {
					const i = this._viewportRect,
						r = this._isRtl()
					let o, s, a, d, u, h
					if ("top" === e.overlayY) (s = n.y), (o = i.height - s + this._viewportMargin)
					else if ("bottom" === e.overlayY)
						(a = i.height - n.y + 2 * this._viewportMargin), (o = i.height - a + this._viewportMargin)
					else {
						const f = Math.min(i.bottom - n.y + i.top, n.y),
							_ = this._lastBoundingBoxSize.height
						;(o = 2 * f), (s = n.y - f), o > _ && !this._isInitialRender && !this._growAfterOpen && (s = n.y - _ / 2)
					}
					if (("end" === e.overlayX && !r) || ("start" === e.overlayX && r))
						(h = i.width - n.x + this._viewportMargin), (d = n.x - this._viewportMargin)
					else if (("start" === e.overlayX && !r) || ("end" === e.overlayX && r)) (u = n.x), (d = i.right - n.x)
					else {
						const f = Math.min(i.right - n.x + i.left, n.x),
							_ = this._lastBoundingBoxSize.width
						;(d = 2 * f), (u = n.x - f), d > _ && !this._isInitialRender && !this._growAfterOpen && (u = n.x - _ / 2)
					}
					return { top: s, left: u, bottom: a, right: h, width: d, height: o }
				}
				_setBoundingBoxStyles(n, e) {
					const i = this._calculateBoundingBoxRect(n, e)
					!this._isInitialRender &&
						!this._growAfterOpen &&
						((i.height = Math.min(i.height, this._lastBoundingBoxSize.height)),
						(i.width = Math.min(i.width, this._lastBoundingBoxSize.width)))
					const r = {}
					if (this._hasExactPosition())
						(r.top = r.left = "0"), (r.bottom = r.right = r.maxHeight = r.maxWidth = ""), (r.width = r.height = "100%")
					else {
						const o = this._overlayRef.getConfig().maxHeight,
							s = this._overlayRef.getConfig().maxWidth
						;(r.height = Qo(i.height)),
							(r.top = Qo(i.top)),
							(r.bottom = Qo(i.bottom)),
							(r.width = Qo(i.width)),
							(r.left = Qo(i.left)),
							(r.right = Qo(i.right)),
							(r.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start"),
							(r.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start"),
							o && (r.maxHeight = Qo(o)),
							s && (r.maxWidth = Qo(s))
					}
					;(this._lastBoundingBoxSize = i), Om(this._boundingBox.style, r)
				}
				_resetBoundingBoxStyles() {
					Om(this._boundingBox.style, {
						top: "0",
						left: "0",
						right: "0",
						bottom: "0",
						height: "",
						width: "",
						alignItems: "",
						justifyContent: ""
					})
				}
				_resetOverlayElementStyles() {
					Om(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" })
				}
				_setOverlayElementStyles(n, e) {
					const i = {},
						r = this._hasExactPosition(),
						o = this._hasFlexibleDimensions,
						s = this._overlayRef.getConfig()
					if (r) {
						const d = this._viewportRuler.getViewportScrollPosition()
						Om(i, this._getExactOverlayY(e, n, d)), Om(i, this._getExactOverlayX(e, n, d))
					} else i.position = "static"
					let a = "",
						c = this._getOffset(e, "x"),
						l = this._getOffset(e, "y")
					c && (a += `translateX(${c}px) `),
						l && (a += `translateY(${l}px)`),
						(i.transform = a.trim()),
						s.maxHeight && (r ? (i.maxHeight = Qo(s.maxHeight)) : o && (i.maxHeight = "")),
						s.maxWidth && (r ? (i.maxWidth = Qo(s.maxWidth)) : o && (i.maxWidth = "")),
						Om(this._pane.style, i)
				}
				_getExactOverlayY(n, e, i) {
					let r = { top: "", bottom: "" },
						o = this._getOverlayPoint(e, this._overlayRect, n)
					return (
						this._isPushed && (o = this._pushOverlayOnScreen(o, this._overlayRect, i)),
						"bottom" === n.overlayY
							? (r.bottom = this._document.documentElement.clientHeight - (o.y + this._overlayRect.height) + "px")
							: (r.top = Qo(o.y)),
						r
					)
				}
				_getExactOverlayX(n, e, i) {
					let s,
						r = { left: "", right: "" },
						o = this._getOverlayPoint(e, this._overlayRect, n)
					return (
						this._isPushed && (o = this._pushOverlayOnScreen(o, this._overlayRect, i)),
						(s = this._isRtl() ? ("end" === n.overlayX ? "left" : "right") : "end" === n.overlayX ? "right" : "left"),
						"right" === s
							? (r.right = this._document.documentElement.clientWidth - (o.x + this._overlayRect.width) + "px")
							: (r.left = Qo(o.x)),
						r
					)
				}
				_getScrollVisibility() {
					const n = this._getOriginRect(),
						e = this._pane.getBoundingClientRect(),
						i = this._scrollables.map(r => r.getElementRef().nativeElement.getBoundingClientRect())
					return {
						isOriginClipped: _G(n, i),
						isOriginOutsideView: VD(n, i),
						isOverlayClipped: _G(e, i),
						isOverlayOutsideView: VD(e, i)
					}
				}
				_subtractOverflows(n, ...e) {
					return e.reduce((i, r) => i - Math.max(r, 0), n)
				}
				_getNarrowedViewportRect() {
					const n = this._document.documentElement.clientWidth,
						e = this._document.documentElement.clientHeight,
						i = this._viewportRuler.getViewportScrollPosition()
					return {
						top: i.top + this._viewportMargin,
						left: i.left + this._viewportMargin,
						right: i.left + n - this._viewportMargin,
						bottom: i.top + e - this._viewportMargin,
						width: n - 2 * this._viewportMargin,
						height: e - 2 * this._viewportMargin
					}
				}
				_isRtl() {
					return "rtl" === this._overlayRef.getDirection()
				}
				_hasExactPosition() {
					return !this._hasFlexibleDimensions || this._isPushed
				}
				_getOffset(n, e) {
					return "x" === e ? (null == n.offsetX ? this._offsetX : n.offsetX) : null == n.offsetY ? this._offsetY : n.offsetY
				}
				_validatePositions() {}
				_addPanelClasses(n) {
					this._pane &&
						ME(n).forEach(e => {
							"" !== e &&
								-1 === this._appliedPanelClasses.indexOf(e) &&
								(this._appliedPanelClasses.push(e), this._pane.classList.add(e))
						})
				}
				_clearPanelClasses() {
					this._pane &&
						(this._appliedPanelClasses.forEach(n => {
							this._pane.classList.remove(n)
						}),
						(this._appliedPanelClasses = []))
				}
				_getOriginRect() {
					const n = this._origin
					if (n instanceof wn) return n.nativeElement.getBoundingClientRect()
					if (n instanceof Element) return n.getBoundingClientRect()
					const e = n.width || 0,
						i = n.height || 0
					return { top: n.y, bottom: n.y + i, left: n.x, right: n.x + e, height: i, width: e }
				}
			}
			function Om(t, n) {
				for (let e in n) n.hasOwnProperty(e) && (t[e] = n[e])
				return t
			}
			function wG(t) {
				if ("number" != typeof t && null != t) {
					const [n, e] = t.split(eAe)
					return e && "px" !== e ? null : parseFloat(n)
				}
				return t || null
			}
			function xG(t) {
				return {
					top: Math.floor(t.top),
					right: Math.floor(t.right),
					bottom: Math.floor(t.bottom),
					left: Math.floor(t.left),
					width: Math.floor(t.width),
					height: Math.floor(t.height)
				}
			}
			const CG = "cdk-global-overlay-wrapper"
			class nAe {
				constructor() {
					;(this._cssPosition = "static"),
						(this._topOffset = ""),
						(this._bottomOffset = ""),
						(this._alignItems = ""),
						(this._xPosition = ""),
						(this._xOffset = ""),
						(this._width = ""),
						(this._height = ""),
						(this._isDisposed = !1)
				}
				attach(n) {
					const e = n.getConfig()
					;(this._overlayRef = n),
						this._width && !e.width && n.updateSize({ width: this._width }),
						this._height && !e.height && n.updateSize({ height: this._height }),
						n.hostElement.classList.add(CG),
						(this._isDisposed = !1)
				}
				top(n = "") {
					return (this._bottomOffset = ""), (this._topOffset = n), (this._alignItems = "flex-start"), this
				}
				left(n = "") {
					return (this._xOffset = n), (this._xPosition = "left"), this
				}
				bottom(n = "") {
					return (this._topOffset = ""), (this._bottomOffset = n), (this._alignItems = "flex-end"), this
				}
				right(n = "") {
					return (this._xOffset = n), (this._xPosition = "right"), this
				}
				start(n = "") {
					return (this._xOffset = n), (this._xPosition = "start"), this
				}
				end(n = "") {
					return (this._xOffset = n), (this._xPosition = "end"), this
				}
				width(n = "") {
					return this._overlayRef ? this._overlayRef.updateSize({ width: n }) : (this._width = n), this
				}
				height(n = "") {
					return this._overlayRef ? this._overlayRef.updateSize({ height: n }) : (this._height = n), this
				}
				centerHorizontally(n = "") {
					return this.left(n), (this._xPosition = "center"), this
				}
				centerVertically(n = "") {
					return this.top(n), (this._alignItems = "center"), this
				}
				apply() {
					if (!this._overlayRef || !this._overlayRef.hasAttached()) return
					const n = this._overlayRef.overlayElement.style,
						e = this._overlayRef.hostElement.style,
						i = this._overlayRef.getConfig(),
						{ width: r, height: o, maxWidth: s, maxHeight: a } = i,
						c = !(("100%" !== r && "100vw" !== r) || (s && "100%" !== s && "100vw" !== s)),
						l = !(("100%" !== o && "100vh" !== o) || (a && "100%" !== a && "100vh" !== a)),
						d = this._xPosition,
						u = this._xOffset,
						h = "rtl" === this._overlayRef.getConfig().direction
					let f = "",
						_ = "",
						y = ""
					c
						? (y = "flex-start")
						: "center" === d
						? ((y = "center"), h ? (_ = u) : (f = u))
						: h
						? "left" === d || "end" === d
							? ((y = "flex-end"), (f = u))
							: ("right" === d || "start" === d) && ((y = "flex-start"), (_ = u))
						: "left" === d || "start" === d
						? ((y = "flex-start"), (f = u))
						: ("right" === d || "end" === d) && ((y = "flex-end"), (_ = u)),
						(n.position = this._cssPosition),
						(n.marginLeft = c ? "0" : f),
						(n.marginTop = l ? "0" : this._topOffset),
						(n.marginBottom = this._bottomOffset),
						(n.marginRight = c ? "0" : _),
						(e.justifyContent = y),
						(e.alignItems = l ? "flex-start" : this._alignItems)
				}
				dispose() {
					if (this._isDisposed || !this._overlayRef) return
					const n = this._overlayRef.overlayElement.style,
						e = this._overlayRef.hostElement,
						i = e.style
					e.classList.remove(CG),
						(i.justifyContent = i.alignItems = n.marginTop = n.marginBottom = n.marginLeft = n.marginRight = n.position = ""),
						(this._overlayRef = null),
						(this._isDisposed = !0)
				}
			}
			let iAe = (() => {
					class t {
						constructor(e, i, r, o) {
							;(this._viewportRuler = e), (this._document = i), (this._platform = r), (this._overlayContainer = o)
						}
						global() {
							return new nAe()
						}
						flexibleConnectedTo(e) {
							return new tAe(e, this._viewportRuler, this._document, this._platform, this._overlayContainer)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(OD), re(wi), re(Wr), re(OE))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				rAe = 0,
				ec = (() => {
					class t {
						constructor(e, i, r, o, s, a, c, l, d, u, h, f) {
							;(this.scrollStrategies = e),
								(this._overlayContainer = i),
								(this._componentFactoryResolver = r),
								(this._positionBuilder = o),
								(this._keyboardDispatcher = s),
								(this._injector = a),
								(this._ngZone = c),
								(this._document = l),
								(this._directionality = d),
								(this._location = u),
								(this._outsideClickDispatcher = h),
								(this._animationsModuleType = f)
						}
						create(e) {
							const i = this._createHostElement(),
								r = this._createPaneElement(i),
								o = this._createPortalOutlet(r),
								s = new PE(e)
							return (
								(s.direction = s.direction || this._directionality.value),
								new Cv(
									o,
									i,
									r,
									s,
									this._ngZone,
									this._keyboardDispatcher,
									this._document,
									this._location,
									this._outsideClickDispatcher,
									"NoopAnimations" === this._animationsModuleType
								)
							)
						}
						position() {
							return this._positionBuilder
						}
						_createPaneElement(e) {
							const i = this._document.createElement("div")
							return (i.id = "cdk-overlay-" + rAe++), i.classList.add("cdk-overlay-pane"), e.appendChild(i), i
						}
						_createHostElement() {
							const e = this._document.createElement("div")
							return this._overlayContainer.getContainerElement().appendChild(e), e
						}
						_createPortalOutlet(e) {
							return (
								this._appRef || (this._appRef = this._injector.get(wm)),
								new Dpe(e, this._componentFactoryResolver, this._appRef, this._injector, this._document)
							)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(
									re(Ype),
									re(OE),
									re(RA),
									re(iAe),
									re(Zpe),
									re(ks),
									re(mn),
									re(wi),
									re(wu),
									re(x2),
									re(Jpe),
									re(Bo, 8)
								)
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			const oAe = [
					{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" },
					{ originX: "start", originY: "top", overlayX: "start", overlayY: "bottom" },
					{ originX: "end", originY: "top", overlayX: "end", overlayY: "bottom" },
					{ originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }
				],
				EG = new He("cdk-connected-overlay-scroll-strategy")
			let QD = (() => {
					class t {
						constructor(e) {
							this.elementRef = e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [
									["", "cdk-overlay-origin", ""],
									["", "overlay-origin", ""],
									["", "cdkOverlayOrigin", ""]
								],
								exportAs: ["cdkOverlayOrigin"],
								standalone: !0
							})
						}
					}
					return t
				})(),
				MG = (() => {
					class t {
						get offsetX() {
							return this._offsetX
						}
						set offsetX(e) {
							;(this._offsetX = e), this._position && this._updatePositionStrategy(this._position)
						}
						get offsetY() {
							return this._offsetY
						}
						set offsetY(e) {
							;(this._offsetY = e), this._position && this._updatePositionStrategy(this._position)
						}
						get hasBackdrop() {
							return this._hasBackdrop
						}
						set hasBackdrop(e) {
							this._hasBackdrop = Mn(e)
						}
						get lockPosition() {
							return this._lockPosition
						}
						set lockPosition(e) {
							this._lockPosition = Mn(e)
						}
						get flexibleDimensions() {
							return this._flexibleDimensions
						}
						set flexibleDimensions(e) {
							this._flexibleDimensions = Mn(e)
						}
						get growAfterOpen() {
							return this._growAfterOpen
						}
						set growAfterOpen(e) {
							this._growAfterOpen = Mn(e)
						}
						get push() {
							return this._push
						}
						set push(e) {
							this._push = Mn(e)
						}
						constructor(e, i, r, o, s) {
							;(this._overlay = e),
								(this._dir = s),
								(this._hasBackdrop = !1),
								(this._lockPosition = !1),
								(this._growAfterOpen = !1),
								(this._flexibleDimensions = !1),
								(this._push = !1),
								(this._backdropSubscription = D.EMPTY),
								(this._attachSubscription = D.EMPTY),
								(this._detachSubscription = D.EMPTY),
								(this._positionSubscription = D.EMPTY),
								(this.viewportMargin = 0),
								(this.open = !1),
								(this.disableClose = !1),
								(this.backdropClick = new _n()),
								(this.positionChange = new _n()),
								(this.attach = new _n()),
								(this.detach = new _n()),
								(this.overlayKeydown = new _n()),
								(this.overlayOutsideClick = new _n()),
								(this._templatePortal = new yv(i, r)),
								(this._scrollStrategyFactory = o),
								(this.scrollStrategy = this._scrollStrategyFactory())
						}
						get overlayRef() {
							return this._overlayRef
						}
						get dir() {
							return this._dir ? this._dir.value : "ltr"
						}
						ngOnDestroy() {
							this._attachSubscription.unsubscribe(),
								this._detachSubscription.unsubscribe(),
								this._backdropSubscription.unsubscribe(),
								this._positionSubscription.unsubscribe(),
								this._overlayRef && this._overlayRef.dispose()
						}
						ngOnChanges(e) {
							this._position &&
								(this._updatePositionStrategy(this._position),
								this._overlayRef.updateSize({
									width: this.width,
									minWidth: this.minWidth,
									height: this.height,
									minHeight: this.minHeight
								}),
								e.origin && this.open && this._position.apply()),
								e.open && (this.open ? this._attachOverlay() : this._detachOverlay())
						}
						_createOverlay() {
							;(!this.positions || !this.positions.length) && (this.positions = oAe)
							const e = (this._overlayRef = this._overlay.create(this._buildConfig()))
							;(this._attachSubscription = e.attachments().subscribe(() => this.attach.emit())),
								(this._detachSubscription = e.detachments().subscribe(() => this.detach.emit())),
								e.keydownEvents().subscribe(i => {
									this.overlayKeydown.next(i),
										27 === i.keyCode && !this.disableClose && !fl(i) && (i.preventDefault(), this._detachOverlay())
								}),
								this._overlayRef.outsidePointerEvents().subscribe(i => {
									this.overlayOutsideClick.next(i)
								})
						}
						_buildConfig() {
							const e = (this._position = this.positionStrategy || this._createPositionStrategy()),
								i = new PE({
									direction: this._dir,
									positionStrategy: e,
									scrollStrategy: this.scrollStrategy,
									hasBackdrop: this.hasBackdrop
								})
							return (
								(this.width || 0 === this.width) && (i.width = this.width),
								(this.height || 0 === this.height) && (i.height = this.height),
								(this.minWidth || 0 === this.minWidth) && (i.minWidth = this.minWidth),
								(this.minHeight || 0 === this.minHeight) && (i.minHeight = this.minHeight),
								this.backdropClass && (i.backdropClass = this.backdropClass),
								this.panelClass && (i.panelClass = this.panelClass),
								i
							)
						}
						_updatePositionStrategy(e) {
							const i = this.positions.map(r => ({
								originX: r.originX,
								originY: r.originY,
								overlayX: r.overlayX,
								overlayY: r.overlayY,
								offsetX: r.offsetX || this.offsetX,
								offsetY: r.offsetY || this.offsetY,
								panelClass: r.panelClass || void 0
							}))
							return e
								.setOrigin(this._getFlexibleConnectedPositionStrategyOrigin())
								.withPositions(i)
								.withFlexibleDimensions(this.flexibleDimensions)
								.withPush(this.push)
								.withGrowAfterOpen(this.growAfterOpen)
								.withViewportMargin(this.viewportMargin)
								.withLockedPosition(this.lockPosition)
								.withTransformOriginOn(this.transformOriginSelector)
						}
						_createPositionStrategy() {
							const e = this._overlay.position().flexibleConnectedTo(this._getFlexibleConnectedPositionStrategyOrigin())
							return this._updatePositionStrategy(e), e
						}
						_getFlexibleConnectedPositionStrategyOrigin() {
							return this.origin instanceof QD ? this.origin.elementRef : this.origin
						}
						_attachOverlay() {
							this._overlayRef ? (this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop) : this._createOverlay(),
								this._overlayRef.hasAttached() || this._overlayRef.attach(this._templatePortal),
								this.hasBackdrop
									? (this._backdropSubscription = this._overlayRef.backdropClick().subscribe(e => {
											this.backdropClick.emit(e)
									  }))
									: this._backdropSubscription.unsubscribe(),
								this._positionSubscription.unsubscribe(),
								this.positionChange.observers.length > 0 &&
									(this._positionSubscription = this._position.positionChanges
										.pipe(
											(function Bpe(t, n = !1) {
												return Wt((e, i) => {
													let r = 0
													e.subscribe(
														we(i, o => {
															const s = t(o, r++)
															;(s || n) && i.next(o), !s && i.complete()
														})
													)
												})
											})(() => this.positionChange.observers.length > 0)
										)
										.subscribe(e => {
											this.positionChange.emit(e),
												0 === this.positionChange.observers.length && this._positionSubscription.unsubscribe()
										}))
						}
						_detachOverlay() {
							this._overlayRef && this._overlayRef.detach(),
								this._backdropSubscription.unsubscribe(),
								this._positionSubscription.unsubscribe()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(ec), P(Za), P(ra), P(EG), P(wu, 8))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [
									["", "cdk-connected-overlay", ""],
									["", "connected-overlay", ""],
									["", "cdkConnectedOverlay", ""]
								],
								inputs: {
									origin: ["cdkConnectedOverlayOrigin", "origin"],
									positions: ["cdkConnectedOverlayPositions", "positions"],
									positionStrategy: ["cdkConnectedOverlayPositionStrategy", "positionStrategy"],
									offsetX: ["cdkConnectedOverlayOffsetX", "offsetX"],
									offsetY: ["cdkConnectedOverlayOffsetY", "offsetY"],
									width: ["cdkConnectedOverlayWidth", "width"],
									height: ["cdkConnectedOverlayHeight", "height"],
									minWidth: ["cdkConnectedOverlayMinWidth", "minWidth"],
									minHeight: ["cdkConnectedOverlayMinHeight", "minHeight"],
									backdropClass: ["cdkConnectedOverlayBackdropClass", "backdropClass"],
									panelClass: ["cdkConnectedOverlayPanelClass", "panelClass"],
									viewportMargin: ["cdkConnectedOverlayViewportMargin", "viewportMargin"],
									scrollStrategy: ["cdkConnectedOverlayScrollStrategy", "scrollStrategy"],
									open: ["cdkConnectedOverlayOpen", "open"],
									disableClose: ["cdkConnectedOverlayDisableClose", "disableClose"],
									transformOriginSelector: ["cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"],
									hasBackdrop: ["cdkConnectedOverlayHasBackdrop", "hasBackdrop"],
									lockPosition: ["cdkConnectedOverlayLockPosition", "lockPosition"],
									flexibleDimensions: ["cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions"],
									growAfterOpen: ["cdkConnectedOverlayGrowAfterOpen", "growAfterOpen"],
									push: ["cdkConnectedOverlayPush", "push"]
								},
								outputs: {
									backdropClick: "backdropClick",
									positionChange: "positionChange",
									attach: "attach",
									detach: "detach",
									overlayKeydown: "overlayKeydown",
									overlayOutsideClick: "overlayOutsideClick"
								},
								exportAs: ["cdkConnectedOverlay"],
								standalone: !0,
								features: [Ar]
							})
						}
					}
					return t
				})()
			const aAe = {
				provide: EG,
				deps: [ec],
				useFactory: function sAe(t) {
					return () => t.scrollStrategies.reposition()
				}
			}
			let Ev = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({ providers: [ec, aAe], imports: [bv, wv, AG, AG] })
					}
				}
				return t
			})()
			function Mv(t) {
				return xi((n, e) => t <= e)
			}
			let SG = (() => {
					class t {
						create(e) {
							return typeof MutationObserver > "u" ? null : new MutationObserver(e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				cAe = (() => {
					class t {
						constructor(e) {
							;(this._mutationObserverFactory = e), (this._observedElements = new Map())
						}
						ngOnDestroy() {
							this._observedElements.forEach((e, i) => this._cleanupObserver(i))
						}
						observe(e) {
							const i = yu(e)
							return new Ge(r => {
								const s = this._observeElement(i).subscribe(r)
								return () => {
									s.unsubscribe(), this._unobserveElement(i)
								}
							})
						}
						_observeElement(e) {
							if (this._observedElements.has(e)) this._observedElements.get(e).count++
							else {
								const i = new vt(),
									r = this._mutationObserverFactory.create(o => i.next(o))
								r && r.observe(e, { characterData: !0, childList: !0, subtree: !0 }),
									this._observedElements.set(e, { observer: r, stream: i, count: 1 })
							}
							return this._observedElements.get(e).stream
						}
						_unobserveElement(e) {
							this._observedElements.has(e) &&
								(this._observedElements.get(e).count--, this._observedElements.get(e).count || this._cleanupObserver(e))
						}
						_cleanupObserver(e) {
							if (this._observedElements.has(e)) {
								const { observer: i, stream: r } = this._observedElements.get(e)
								i && i.disconnect(), r.complete(), this._observedElements.delete(e)
							}
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(SG))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				kG = (() => {
					class t {
						get disabled() {
							return this._disabled
						}
						set disabled(e) {
							;(this._disabled = Mn(e)), this._disabled ? this._unsubscribe() : this._subscribe()
						}
						get debounce() {
							return this._debounce
						}
						set debounce(e) {
							;(this._debounce = to(e)), this._subscribe()
						}
						constructor(e, i, r) {
							;(this._contentObserver = e),
								(this._elementRef = i),
								(this._ngZone = r),
								(this.event = new _n()),
								(this._disabled = !1),
								(this._currentSubscription = null)
						}
						ngAfterContentInit() {
							!this._currentSubscription && !this.disabled && this._subscribe()
						}
						ngOnDestroy() {
							this._unsubscribe()
						}
						_subscribe() {
							this._unsubscribe()
							const e = this._contentObserver.observe(this._elementRef)
							this._ngZone.runOutsideAngular(() => {
								this._currentSubscription = (this.debounce ? e.pipe(ug(this.debounce)) : e).subscribe(this.event)
							})
						}
						_unsubscribe() {
							this._currentSubscription?.unsubscribe()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(cAe), P(wn), P(mn))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "cdkObserveContent", ""]],
								inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" },
								outputs: { event: "cdkObserveContent" },
								exportAs: ["cdkObserveContent"]
							})
						}
					}
					return t
				})(),
				zD = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [SG] })
						}
					}
					return t
				})()
			function xu(...t) {
				const n = Oi(t),
					e = ko(t),
					{ args: i, keys: r } = Uz(t)
				if (0 === i.length) return ro([], n)
				const o = new Ge(
					(function lAe(t, n, e = Re) {
						return i => {
							TG(
								n,
								() => {
									const { length: r } = t,
										o = new Array(r)
									let s = r,
										a = r
									for (let c = 0; c < r; c++)
										TG(
											n,
											() => {
												const l = ro(t[c], n)
												let d = !1
												l.subscribe(
													we(
														i,
														u => {
															;(o[c] = u), d || ((d = !0), a--), a || i.next(e(o.slice()))
														},
														() => {
															--s || i.complete()
														}
													)
												)
											},
											i
										)
								},
								i
							)
						}
					})(i, n, r ? s => Hz(r, s) : Re)
				)
				return e ? o.pipe(tI(e)) : o
			}
			function TG(t, n, e) {
				t ? Jn(e, t, n) : n()
			}
			function NE(...t) {
				return (function dAe() {
					return fr(1)
				})()(ro(t, Oi(t)))
			}
			function hd(...t) {
				const n = Oi(t)
				return Wt((e, i) => {
					;(n ? NE(t, e, n) : NE(t, e)).subscribe(i)
				})
			}
			const FG = new Set()
			let Nm,
				uAe = (() => {
					class t {
						constructor(e, i) {
							;(this._platform = e),
								(this._nonce = i),
								(this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : fAe)
						}
						matchMedia(e) {
							return (
								(this._platform.WEBKIT || this._platform.BLINK) &&
									(function hAe(t, n) {
										if (!FG.has(t))
											try {
												Nm ||
													((Nm = document.createElement("style")),
													n && (Nm.nonce = n),
													Nm.setAttribute("type", "text/css"),
													document.head.appendChild(Nm)),
													Nm.sheet && (Nm.sheet.insertRule(`@media ${t} {body{ }}`, 0), FG.add(t))
											} catch (e) {
												console.error(e)
											}
									})(e, this._nonce),
								this._matchMedia(e)
							)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Wr), re(eB, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			function fAe(t) {
				return { matches: "all" === t || "" === t, media: t, addListener: () => {}, removeListener: () => {} }
			}
			let mAe = (() => {
				class t {
					constructor(e, i) {
						;(this._mediaMatcher = e), (this._zone = i), (this._queries = new Map()), (this._destroySubject = new vt())
					}
					ngOnDestroy() {
						this._destroySubject.next(), this._destroySubject.complete()
					}
					isMatched(e) {
						return BG(ME(e)).some(r => this._registerQuery(r).mql.matches)
					}
					observe(e) {
						let o = xu(BG(ME(e)).map(s => this._registerQuery(s).observable))
						return (
							(o = NE(o.pipe(Do(1)), o.pipe(Mv(1), ug(0)))),
							o.pipe(
								Ke(s => {
									const a = { matches: !1, breakpoints: {} }
									return (
										s.forEach(({ matches: c, query: l }) => {
											;(a.matches = a.matches || c), (a.breakpoints[l] = c)
										}),
										a
									)
								})
							)
						)
					}
					_registerQuery(e) {
						if (this._queries.has(e)) return this._queries.get(e)
						const i = this._mediaMatcher.matchMedia(e),
							o = {
								observable: new Ge(s => {
									const a = c => this._zone.run(() => s.next(c))
									return (
										i.addListener(a),
										() => {
											i.removeListener(a)
										}
									)
								}).pipe(
									hd(i),
									Ke(({ matches: s }) => ({ query: e, matches: s })),
									kr(this._destroySubject)
								),
								mql: i
							}
						return this._queries.set(e, o), o
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(uAe), re(mn))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			function BG(t) {
				return t
					.map(n => n.split(","))
					.reduce((n, e) => n.concat(e))
					.map(n => n.trim())
			}
			function DG(t, n, e) {
				const i = UE(t, n)
				i.some(r => r.trim() == e.trim()) || (i.push(e.trim()), t.setAttribute(n, i.join(" ")))
			}
			function GD(t, n, e) {
				const r = UE(t, n).filter(o => o != e.trim())
				r.length ? t.setAttribute(n, r.join(" ")) : t.removeAttribute(n)
			}
			function UE(t, n) {
				return (t.getAttribute(n) || "").match(/\S+/g) || []
			}
			const LG = "cdk-describedby-message",
				HE = "cdk-describedby-host"
			let $D = 0,
				pAe = (() => {
					class t {
						constructor(e, i) {
							;(this._platform = i),
								(this._messageRegistry = new Map()),
								(this._messagesContainer = null),
								(this._id = "" + $D++),
								(this._document = e),
								(this._id = Rt(j_) + "-" + $D++)
						}
						describe(e, i, r) {
							if (!this._canBeDescribed(e, i)) return
							const o = WD(i, r)
							"string" != typeof i
								? (RG(i, this._id), this._messageRegistry.set(o, { messageElement: i, referenceCount: 0 }))
								: this._messageRegistry.has(o) || this._createMessageElement(i, r),
								this._isElementDescribedByMessage(e, o) || this._addMessageReference(e, o)
						}
						removeDescription(e, i, r) {
							if (!i || !this._isElementNode(e)) return
							const o = WD(i, r)
							if ((this._isElementDescribedByMessage(e, o) && this._removeMessageReference(e, o), "string" == typeof i)) {
								const s = this._messageRegistry.get(o)
								s && 0 === s.referenceCount && this._deleteMessageElement(o)
							}
							0 === this._messagesContainer?.childNodes.length &&
								(this._messagesContainer.remove(), (this._messagesContainer = null))
						}
						ngOnDestroy() {
							const e = this._document.querySelectorAll(`[${HE}="${this._id}"]`)
							for (let i = 0; i < e.length; i++) this._removeCdkDescribedByReferenceIds(e[i]), e[i].removeAttribute(HE)
							this._messagesContainer?.remove(), (this._messagesContainer = null), this._messageRegistry.clear()
						}
						_createMessageElement(e, i) {
							const r = this._document.createElement("div")
							RG(r, this._id),
								(r.textContent = e),
								i && r.setAttribute("role", i),
								this._createMessagesContainer(),
								this._messagesContainer.appendChild(r),
								this._messageRegistry.set(WD(e, i), { messageElement: r, referenceCount: 0 })
						}
						_deleteMessageElement(e) {
							this._messageRegistry.get(e)?.messageElement?.remove(), this._messageRegistry.delete(e)
						}
						_createMessagesContainer() {
							if (this._messagesContainer) return
							const e = "cdk-describedby-message-container",
								i = this._document.querySelectorAll(`.${e}[platform="server"]`)
							for (let o = 0; o < i.length; o++) i[o].remove()
							const r = this._document.createElement("div")
							;(r.style.visibility = "hidden"),
								r.classList.add(e),
								r.classList.add("cdk-visually-hidden"),
								this._platform && !this._platform.isBrowser && r.setAttribute("platform", "server"),
								this._document.body.appendChild(r),
								(this._messagesContainer = r)
						}
						_removeCdkDescribedByReferenceIds(e) {
							const i = UE(e, "aria-describedby").filter(r => 0 != r.indexOf(LG))
							e.setAttribute("aria-describedby", i.join(" "))
						}
						_addMessageReference(e, i) {
							const r = this._messageRegistry.get(i)
							DG(e, "aria-describedby", r.messageElement.id), e.setAttribute(HE, this._id), r.referenceCount++
						}
						_removeMessageReference(e, i) {
							const r = this._messageRegistry.get(i)
							r.referenceCount--, GD(e, "aria-describedby", r.messageElement.id), e.removeAttribute(HE)
						}
						_isElementDescribedByMessage(e, i) {
							const r = UE(e, "aria-describedby"),
								o = this._messageRegistry.get(i),
								s = o && o.messageElement.id
							return !!s && -1 != r.indexOf(s)
						}
						_canBeDescribed(e, i) {
							if (!this._isElementNode(e)) return !1
							if (i && "object" == typeof i) return !0
							const r = null == i ? "" : `${i}`.trim(),
								o = e.getAttribute("aria-label")
							return !(!r || (o && o.trim() === r))
						}
						_isElementNode(e) {
							return e.nodeType === this._document.ELEMENT_NODE
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(wi), re(Wr))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			function WD(t, n) {
				return "string" == typeof t ? `${n || ""}/${t}` : t
			}
			function RG(t, n) {
				t.id || (t.id = `${LG}-${n}-${$D++}`)
			}
			class PG {
				constructor(n) {
					;(this._items = n),
						(this._activeItemIndex = -1),
						(this._activeItem = null),
						(this._wrap = !1),
						(this._letterKeyStream = new vt()),
						(this._typeaheadSubscription = D.EMPTY),
						(this._vertical = !0),
						(this._allowedModifierKeys = []),
						(this._homeAndEnd = !1),
						(this._pageUpAndDown = { enabled: !1, delta: 10 }),
						(this._skipPredicateFn = e => e.disabled),
						(this._pressedLetters = []),
						(this.tabOut = new vt()),
						(this.change = new vt()),
						n instanceof ym &&
							(this._itemChangesSubscription = n.changes.subscribe(e => {
								if (this._activeItem) {
									const r = e.toArray().indexOf(this._activeItem)
									r > -1 && r !== this._activeItemIndex && (this._activeItemIndex = r)
								}
							}))
				}
				skipPredicate(n) {
					return (this._skipPredicateFn = n), this
				}
				withWrap(n = !0) {
					return (this._wrap = n), this
				}
				withVerticalOrientation(n = !0) {
					return (this._vertical = n), this
				}
				withHorizontalOrientation(n) {
					return (this._horizontal = n), this
				}
				withAllowedModifierKeys(n) {
					return (this._allowedModifierKeys = n), this
				}
				withTypeAhead(n = 200) {
					return (
						this._typeaheadSubscription.unsubscribe(),
						(this._typeaheadSubscription = this._letterKeyStream
							.pipe(
								eo(e => this._pressedLetters.push(e)),
								ug(n),
								xi(() => this._pressedLetters.length > 0),
								Ke(() => this._pressedLetters.join(""))
							)
							.subscribe(e => {
								const i = this._getItemsArray()
								for (let r = 1; r < i.length + 1; r++) {
									const o = (this._activeItemIndex + r) % i.length,
										s = i[o]
									if (!this._skipPredicateFn(s) && 0 === s.getLabel().toUpperCase().trim().indexOf(e)) {
										this.setActiveItem(o)
										break
									}
								}
								this._pressedLetters = []
							})),
						this
					)
				}
				cancelTypeahead() {
					return (this._pressedLetters = []), this
				}
				withHomeAndEnd(n = !0) {
					return (this._homeAndEnd = n), this
				}
				withPageUpDown(n = !0, e = 10) {
					return (this._pageUpAndDown = { enabled: n, delta: e }), this
				}
				setActiveItem(n) {
					const e = this._activeItem
					this.updateActiveItem(n), this._activeItem !== e && this.change.next(this._activeItemIndex)
				}
				onKeydown(n) {
					const e = n.keyCode,
						r = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(o => !n[o] || this._allowedModifierKeys.indexOf(o) > -1)
					switch (e) {
						case 9:
							return void this.tabOut.next()
						case 40:
							if (this._vertical && r) {
								this.setNextItemActive()
								break
							}
							return
						case 38:
							if (this._vertical && r) {
								this.setPreviousItemActive()
								break
							}
							return
						case 39:
							if (this._horizontal && r) {
								"rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive()
								break
							}
							return
						case 37:
							if (this._horizontal && r) {
								"rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive()
								break
							}
							return
						case 36:
							if (this._homeAndEnd && r) {
								this.setFirstItemActive()
								break
							}
							return
						case 35:
							if (this._homeAndEnd && r) {
								this.setLastItemActive()
								break
							}
							return
						case 33:
							if (this._pageUpAndDown.enabled && r) {
								const o = this._activeItemIndex - this._pageUpAndDown.delta
								this._setActiveItemByIndex(o > 0 ? o : 0, 1)
								break
							}
							return
						case 34:
							if (this._pageUpAndDown.enabled && r) {
								const o = this._activeItemIndex + this._pageUpAndDown.delta,
									s = this._getItemsArray().length
								this._setActiveItemByIndex(o < s ? o : s - 1, -1)
								break
							}
							return
						default:
							return void (
								(r || fl(n, "shiftKey")) &&
								(n.key && 1 === n.key.length
									? this._letterKeyStream.next(n.key.toLocaleUpperCase())
									: ((e >= 65 && e <= 90) || (e >= 48 && e <= 57)) && this._letterKeyStream.next(String.fromCharCode(e)))
							)
					}
					;(this._pressedLetters = []), n.preventDefault()
				}
				get activeItemIndex() {
					return this._activeItemIndex
				}
				get activeItem() {
					return this._activeItem
				}
				isTyping() {
					return this._pressedLetters.length > 0
				}
				setFirstItemActive() {
					this._setActiveItemByIndex(0, 1)
				}
				setLastItemActive() {
					this._setActiveItemByIndex(this._items.length - 1, -1)
				}
				setNextItemActive() {
					this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1)
				}
				setPreviousItemActive() {
					this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1)
				}
				updateActiveItem(n) {
					const e = this._getItemsArray(),
						i = "number" == typeof n ? n : e.indexOf(n)
					;(this._activeItem = e[i] ?? null), (this._activeItemIndex = i)
				}
				destroy() {
					this._typeaheadSubscription.unsubscribe(),
						this._itemChangesSubscription?.unsubscribe(),
						this._letterKeyStream.complete(),
						this.tabOut.complete(),
						this.change.complete(),
						(this._pressedLetters = [])
				}
				_setActiveItemByDelta(n) {
					this._wrap ? this._setActiveInWrapMode(n) : this._setActiveInDefaultMode(n)
				}
				_setActiveInWrapMode(n) {
					const e = this._getItemsArray()
					for (let i = 1; i <= e.length; i++) {
						const r = (this._activeItemIndex + n * i + e.length) % e.length
						if (!this._skipPredicateFn(e[r])) return void this.setActiveItem(r)
					}
				}
				_setActiveInDefaultMode(n) {
					this._setActiveItemByIndex(this._activeItemIndex + n, n)
				}
				_setActiveItemByIndex(n, e) {
					const i = this._getItemsArray()
					if (i[n]) {
						for (; this._skipPredicateFn(i[n]); ) if (!i[(n += e)]) return
						this.setActiveItem(n)
					}
				}
				_getItemsArray() {
					return this._items instanceof ym ? this._items.toArray() : this._items
				}
			}
			class AAe extends PG {
				setActiveItem(n) {
					this.activeItem && this.activeItem.setInactiveStyles(),
						super.setActiveItem(n),
						this.activeItem && this.activeItem.setActiveStyles()
				}
			}
			class jD extends PG {
				constructor() {
					super(...arguments), (this._origin = "program")
				}
				setFocusOrigin(n) {
					return (this._origin = n), this
				}
				setActiveItem(n) {
					super.setActiveItem(n), this.activeItem && this.activeItem.focus(this._origin)
				}
			}
			let VE = (() => {
				class t {
					constructor(e) {
						this._platform = e
					}
					isDisabled(e) {
						return e.hasAttribute("disabled")
					}
					isVisible(e) {
						return (
							(function bAe(t) {
								return !!(
									t.offsetWidth ||
									t.offsetHeight ||
									("function" == typeof t.getClientRects && t.getClientRects().length)
								)
							})(e) && "visible" === getComputedStyle(e).visibility
						)
					}
					isTabbable(e) {
						if (!this._platform.isBrowser) return !1
						const i = (function gAe(t) {
							try {
								return t.frameElement
							} catch {
								return null
							}
						})(
							(function MAe(t) {
								return (t.ownerDocument && t.ownerDocument.defaultView) || window
							})(e)
						)
						if (i && (-1 === NG(i) || !this.isVisible(i))) return !1
						let r = e.nodeName.toLowerCase(),
							o = NG(e)
						return e.hasAttribute("contenteditable")
							? -1 !== o
							: !(
									"iframe" === r ||
									"object" === r ||
									(this._platform.WEBKIT &&
										this._platform.IOS &&
										!(function CAe(t) {
											let n = t.nodeName.toLowerCase(),
												e = "input" === n && t.type
											return "text" === e || "password" === e || "select" === n || "textarea" === n
										})(e))
							  ) &&
									("audio" === r
										? !!e.hasAttribute("controls") && -1 !== o
										: "video" === r
										? -1 !== o && (null !== o || this._platform.FIREFOX || e.hasAttribute("controls"))
										: e.tabIndex >= 0)
					}
					isFocusable(e, i) {
						return (
							(function EAe(t) {
								return (
									!(function vAe(t) {
										return (
											(function wAe(t) {
												return "input" == t.nodeName.toLowerCase()
											})(t) && "hidden" == t.type
										)
									})(t) &&
									((function _Ae(t) {
										let n = t.nodeName.toLowerCase()
										return "input" === n || "select" === n || "button" === n || "textarea" === n
									})(t) ||
										(function yAe(t) {
											return (
												(function xAe(t) {
													return "a" == t.nodeName.toLowerCase()
												})(t) && t.hasAttribute("href")
											)
										})(t) ||
										t.hasAttribute("contenteditable") ||
										OG(t))
								)
							})(e) &&
							!this.isDisabled(e) &&
							(i?.ignoreVisibility || this.isVisible(e))
						)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Wr))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			function OG(t) {
				if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1
				let n = t.getAttribute("tabindex")
				return !(!n || isNaN(parseInt(n, 10)))
			}
			function NG(t) {
				if (!OG(t)) return null
				const n = parseInt(t.getAttribute("tabindex") || "", 10)
				return isNaN(n) ? -1 : n
			}
			class SAe {
				get enabled() {
					return this._enabled
				}
				set enabled(n) {
					;(this._enabled = n),
						this._startAnchor &&
							this._endAnchor &&
							(this._toggleAnchorTabIndex(n, this._startAnchor), this._toggleAnchorTabIndex(n, this._endAnchor))
				}
				constructor(n, e, i, r, o = !1) {
					;(this._element = n),
						(this._checker = e),
						(this._ngZone = i),
						(this._document = r),
						(this._hasAttached = !1),
						(this.startAnchorListener = () => this.focusLastTabbableElement()),
						(this.endAnchorListener = () => this.focusFirstTabbableElement()),
						(this._enabled = !0),
						o || this.attachAnchors()
				}
				destroy() {
					const n = this._startAnchor,
						e = this._endAnchor
					n && (n.removeEventListener("focus", this.startAnchorListener), n.remove()),
						e && (e.removeEventListener("focus", this.endAnchorListener), e.remove()),
						(this._startAnchor = this._endAnchor = null),
						(this._hasAttached = !1)
				}
				attachAnchors() {
					return (
						!!this._hasAttached ||
						(this._ngZone.runOutsideAngular(() => {
							this._startAnchor ||
								((this._startAnchor = this._createAnchor()),
								this._startAnchor.addEventListener("focus", this.startAnchorListener)),
								this._endAnchor ||
									((this._endAnchor = this._createAnchor()),
									this._endAnchor.addEventListener("focus", this.endAnchorListener))
						}),
						this._element.parentNode &&
							(this._element.parentNode.insertBefore(this._startAnchor, this._element),
							this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling),
							(this._hasAttached = !0)),
						this._hasAttached)
					)
				}
				focusInitialElementWhenReady(n) {
					return new Promise(e => {
						this._executeOnStable(() => e(this.focusInitialElement(n)))
					})
				}
				focusFirstTabbableElementWhenReady(n) {
					return new Promise(e => {
						this._executeOnStable(() => e(this.focusFirstTabbableElement(n)))
					})
				}
				focusLastTabbableElementWhenReady(n) {
					return new Promise(e => {
						this._executeOnStable(() => e(this.focusLastTabbableElement(n)))
					})
				}
				_getRegionBoundary(n) {
					const e = this._element.querySelectorAll(`[cdk-focus-region-${n}], [cdkFocusRegion${n}], [cdk-focus-${n}]`)
					return "start" == n
						? e.length
							? e[0]
							: this._getFirstTabbableElement(this._element)
						: e.length
						? e[e.length - 1]
						: this._getLastTabbableElement(this._element)
				}
				focusInitialElement(n) {
					const e = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]")
					if (e) {
						if (!this._checker.isFocusable(e)) {
							const i = this._getFirstTabbableElement(e)
							return i?.focus(n), !!i
						}
						return e.focus(n), !0
					}
					return this.focusFirstTabbableElement(n)
				}
				focusFirstTabbableElement(n) {
					const e = this._getRegionBoundary("start")
					return e && e.focus(n), !!e
				}
				focusLastTabbableElement(n) {
					const e = this._getRegionBoundary("end")
					return e && e.focus(n), !!e
				}
				hasAttached() {
					return this._hasAttached
				}
				_getFirstTabbableElement(n) {
					if (this._checker.isFocusable(n) && this._checker.isTabbable(n)) return n
					const e = n.children
					for (let i = 0; i < e.length; i++) {
						const r = e[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[i]) : null
						if (r) return r
					}
					return null
				}
				_getLastTabbableElement(n) {
					if (this._checker.isFocusable(n) && this._checker.isTabbable(n)) return n
					const e = n.children
					for (let i = e.length - 1; i >= 0; i--) {
						const r = e[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[i]) : null
						if (r) return r
					}
					return null
				}
				_createAnchor() {
					const n = this._document.createElement("div")
					return (
						this._toggleAnchorTabIndex(this._enabled, n),
						n.classList.add("cdk-visually-hidden"),
						n.classList.add("cdk-focus-trap-anchor"),
						n.setAttribute("aria-hidden", "true"),
						n
					)
				}
				_toggleAnchorTabIndex(n, e) {
					n ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex")
				}
				toggleAnchors(n) {
					this._startAnchor &&
						this._endAnchor &&
						(this._toggleAnchorTabIndex(n, this._startAnchor), this._toggleAnchorTabIndex(n, this._endAnchor))
				}
				_executeOnStable(n) {
					this._ngZone.isStable ? n() : this._ngZone.onStable.pipe(Do(1)).subscribe(n)
				}
			}
			let KD = (() => {
				class t {
					constructor(e, i, r) {
						;(this._checker = e), (this._ngZone = i), (this._document = r)
					}
					create(e, i = !1) {
						return new SAe(e, this._checker, this._ngZone, this._document, i)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(VE), re(mn), re(wi))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			function XD(t) {
				return 0 === t.buttons || 0 === t.detail
			}
			function YD(t) {
				const n = (t.touches && t.touches[0]) || (t.changedTouches && t.changedTouches[0])
				return !(!n || -1 !== n.identifier || (null != n.radiusX && 1 !== n.radiusX) || (null != n.radiusY && 1 !== n.radiusY))
			}
			const kAe = new He("cdk-input-modality-detector-options"),
				TAe = { ignoreKeys: [18, 17, 224, 91, 16] },
				bg = Rm({ passive: !0, capture: !0 })
			let FAe = (() => {
				class t {
					get mostRecentModality() {
						return this._modality.value
					}
					constructor(e, i, r, o) {
						;(this._platform = e),
							(this._mostRecentTarget = null),
							(this._modality = new zr(null)),
							(this._lastTouchMs = 0),
							(this._onKeydown = s => {
								this._options?.ignoreKeys?.some(a => a === s.keyCode) ||
									(this._modality.next("keyboard"), (this._mostRecentTarget = Hh(s)))
							}),
							(this._onMousedown = s => {
								Date.now() - this._lastTouchMs < 650 ||
									(this._modality.next(XD(s) ? "keyboard" : "mouse"), (this._mostRecentTarget = Hh(s)))
							}),
							(this._onTouchstart = s => {
								YD(s)
									? this._modality.next("keyboard")
									: ((this._lastTouchMs = Date.now()), this._modality.next("touch"), (this._mostRecentTarget = Hh(s)))
							}),
							(this._options = { ...TAe, ...o }),
							(this.modalityDetected = this._modality.pipe(Mv(1))),
							(this.modalityChanged = this.modalityDetected.pipe(Ys())),
							e.isBrowser &&
								i.runOutsideAngular(() => {
									r.addEventListener("keydown", this._onKeydown, bg),
										r.addEventListener("mousedown", this._onMousedown, bg),
										r.addEventListener("touchstart", this._onTouchstart, bg)
								})
					}
					ngOnDestroy() {
						this._modality.complete(),
							this._platform.isBrowser &&
								(document.removeEventListener("keydown", this._onKeydown, bg),
								document.removeEventListener("mousedown", this._onMousedown, bg),
								document.removeEventListener("touchstart", this._onTouchstart, bg))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Wr), re(mn), re(wi), re(kAe, 8))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			const BAe = new He("liveAnnouncerElement", {
					providedIn: "root",
					factory: function IAe() {
						return null
					}
				}),
				DAe = new He("LIVE_ANNOUNCER_DEFAULT_OPTIONS")
			let LAe = 0,
				RAe = (() => {
					class t {
						constructor(e, i, r, o) {
							;(this._ngZone = i),
								(this._defaultOptions = o),
								(this._document = r),
								(this._liveElement = e || this._createLiveElement())
						}
						announce(e, ...i) {
							const r = this._defaultOptions
							let o, s
							return (
								1 === i.length && "number" == typeof i[0] ? (s = i[0]) : ([o, s] = i),
								this.clear(),
								clearTimeout(this._previousTimeout),
								o || (o = r && r.politeness ? r.politeness : "polite"),
								null == s && r && (s = r.duration),
								this._liveElement.setAttribute("aria-live", o),
								this._liveElement.id && this._exposeAnnouncerToModals(this._liveElement.id),
								this._ngZone.runOutsideAngular(
									() => (
										this._currentPromise || (this._currentPromise = new Promise(a => (this._currentResolve = a))),
										clearTimeout(this._previousTimeout),
										(this._previousTimeout = setTimeout(() => {
											;(this._liveElement.textContent = e),
												"number" == typeof s && (this._previousTimeout = setTimeout(() => this.clear(), s)),
												this._currentResolve(),
												(this._currentPromise = this._currentResolve = void 0)
										}, 100)),
										this._currentPromise
									)
								)
							)
						}
						clear() {
							this._liveElement && (this._liveElement.textContent = "")
						}
						ngOnDestroy() {
							clearTimeout(this._previousTimeout),
								this._liveElement?.remove(),
								(this._liveElement = null),
								this._currentResolve?.(),
								(this._currentPromise = this._currentResolve = void 0)
						}
						_createLiveElement() {
							const e = "cdk-live-announcer-element",
								i = this._document.getElementsByClassName(e),
								r = this._document.createElement("div")
							for (let o = 0; o < i.length; o++) i[o].remove()
							return (
								r.classList.add(e),
								r.classList.add("cdk-visually-hidden"),
								r.setAttribute("aria-atomic", "true"),
								r.setAttribute("aria-live", "polite"),
								(r.id = "cdk-live-announcer-" + LAe++),
								this._document.body.appendChild(r),
								r
							)
						}
						_exposeAnnouncerToModals(e) {
							const i = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]')
							for (let r = 0; r < i.length; r++) {
								const o = i[r],
									s = o.getAttribute("aria-owns")
								s ? -1 === s.indexOf(e) && o.setAttribute("aria-owns", s + " " + e) : o.setAttribute("aria-owns", e)
							}
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(BAe, 8), re(mn), re(wi), re(DAe, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			const PAe = new He("cdk-focus-monitor-default-options"),
				QE = Rm({ passive: !0, capture: !0 })
			let fd = (() => {
				class t {
					constructor(e, i, r, o, s) {
						;(this._ngZone = e),
							(this._platform = i),
							(this._inputModalityDetector = r),
							(this._origin = null),
							(this._windowFocused = !1),
							(this._originFromTouchInteraction = !1),
							(this._elementInfo = new Map()),
							(this._monitoredElementCount = 0),
							(this._rootNodeFocusListenerCount = new Map()),
							(this._windowFocusListener = () => {
								;(this._windowFocused = !0),
									(this._windowFocusTimeoutId = window.setTimeout(() => (this._windowFocused = !1)))
							}),
							(this._stopInputModalityDetector = new vt()),
							(this._rootNodeFocusAndBlurListener = a => {
								for (let l = Hh(a); l; l = l.parentElement) "focus" === a.type ? this._onFocus(a, l) : this._onBlur(a, l)
							}),
							(this._document = o),
							(this._detectionMode = s?.detectionMode || 0)
					}
					monitor(e, i = !1) {
						const r = yu(e)
						if (!this._platform.isBrowser || 1 !== r.nodeType) return Wo()
						const o =
								(function Cpe(t) {
									if (
										(function xpe() {
											if (null == RD) {
												const t = typeof document < "u" ? document.head : null
												RD = !(!t || (!t.createShadowRoot && !t.attachShadow))
											}
											return RD
										})()
									) {
										const n = t.getRootNode ? t.getRootNode() : null
										if (typeof ShadowRoot < "u" && ShadowRoot && n instanceof ShadowRoot) return n
									}
									return null
								})(r) || this._getDocument(),
							s = this._elementInfo.get(r)
						if (s) return i && (s.checkChildren = !0), s.subject
						const a = { checkChildren: i, subject: new vt(), rootNode: o }
						return this._elementInfo.set(r, a), this._registerGlobalListeners(a), a.subject
					}
					stopMonitoring(e) {
						const i = yu(e),
							r = this._elementInfo.get(i)
						r && (r.subject.complete(), this._setClasses(i), this._elementInfo.delete(i), this._removeGlobalListeners(r))
					}
					focusVia(e, i, r) {
						const o = yu(e)
						o === this._getDocument().activeElement
							? this._getClosestElementsInfo(o).forEach(([a, c]) => this._originChanged(a, i, c))
							: (this._setOrigin(i), "function" == typeof o.focus && o.focus(r))
					}
					ngOnDestroy() {
						this._elementInfo.forEach((e, i) => this.stopMonitoring(i))
					}
					_getDocument() {
						return this._document || document
					}
					_getWindow() {
						return this._getDocument().defaultView || window
					}
					_getFocusOrigin(e) {
						return this._origin
							? this._originFromTouchInteraction
								? this._shouldBeAttributedToTouch(e)
									? "touch"
									: "program"
								: this._origin
							: this._windowFocused && this._lastFocusOrigin
							? this._lastFocusOrigin
							: e && this._isLastInteractionFromInputLabel(e)
							? "mouse"
							: "program"
					}
					_shouldBeAttributedToTouch(e) {
						return 1 === this._detectionMode || !!e?.contains(this._inputModalityDetector._mostRecentTarget)
					}
					_setClasses(e, i) {
						e.classList.toggle("cdk-focused", !!i),
							e.classList.toggle("cdk-touch-focused", "touch" === i),
							e.classList.toggle("cdk-keyboard-focused", "keyboard" === i),
							e.classList.toggle("cdk-mouse-focused", "mouse" === i),
							e.classList.toggle("cdk-program-focused", "program" === i)
					}
					_setOrigin(e, i = !1) {
						this._ngZone.runOutsideAngular(() => {
							;(this._origin = e),
								(this._originFromTouchInteraction = "touch" === e && i),
								0 === this._detectionMode &&
									(clearTimeout(this._originTimeoutId),
									(this._originTimeoutId = setTimeout(
										() => (this._origin = null),
										this._originFromTouchInteraction ? 650 : 1
									)))
						})
					}
					_onFocus(e, i) {
						const r = this._elementInfo.get(i),
							o = Hh(e)
						!r || (!r.checkChildren && i !== o) || this._originChanged(i, this._getFocusOrigin(o), r)
					}
					_onBlur(e, i) {
						const r = this._elementInfo.get(i)
						!r ||
							(r.checkChildren && e.relatedTarget instanceof Node && i.contains(e.relatedTarget)) ||
							(this._setClasses(i), this._emitOrigin(r, null))
					}
					_emitOrigin(e, i) {
						e.subject.observers.length && this._ngZone.run(() => e.subject.next(i))
					}
					_registerGlobalListeners(e) {
						if (!this._platform.isBrowser) return
						const i = e.rootNode,
							r = this._rootNodeFocusListenerCount.get(i) || 0
						r ||
							this._ngZone.runOutsideAngular(() => {
								i.addEventListener("focus", this._rootNodeFocusAndBlurListener, QE),
									i.addEventListener("blur", this._rootNodeFocusAndBlurListener, QE)
							}),
							this._rootNodeFocusListenerCount.set(i, r + 1),
							1 == ++this._monitoredElementCount &&
								(this._ngZone.runOutsideAngular(() => {
									this._getWindow().addEventListener("focus", this._windowFocusListener)
								}),
								this._inputModalityDetector.modalityDetected.pipe(kr(this._stopInputModalityDetector)).subscribe(o => {
									this._setOrigin(o, !0)
								}))
					}
					_removeGlobalListeners(e) {
						const i = e.rootNode
						if (this._rootNodeFocusListenerCount.has(i)) {
							const r = this._rootNodeFocusListenerCount.get(i)
							r > 1
								? this._rootNodeFocusListenerCount.set(i, r - 1)
								: (i.removeEventListener("focus", this._rootNodeFocusAndBlurListener, QE),
								  i.removeEventListener("blur", this._rootNodeFocusAndBlurListener, QE),
								  this._rootNodeFocusListenerCount.delete(i))
						}
						--this._monitoredElementCount ||
							(this._getWindow().removeEventListener("focus", this._windowFocusListener),
							this._stopInputModalityDetector.next(),
							clearTimeout(this._windowFocusTimeoutId),
							clearTimeout(this._originTimeoutId))
					}
					_originChanged(e, i, r) {
						this._setClasses(e, i), this._emitOrigin(r, i), (this._lastFocusOrigin = i)
					}
					_getClosestElementsInfo(e) {
						const i = []
						return (
							this._elementInfo.forEach((r, o) => {
								;(o === e || (r.checkChildren && o.contains(e))) && i.push([o, r])
							}),
							i
						)
					}
					_isLastInteractionFromInputLabel(e) {
						const { _mostRecentTarget: i, mostRecentModality: r } = this._inputModalityDetector
						if ("mouse" !== r || !i || i === e || ("INPUT" !== e.nodeName && "TEXTAREA" !== e.nodeName) || e.disabled) return !1
						const o = e.labels
						if (o) for (let s = 0; s < o.length; s++) if (o[s].contains(i)) return !0
						return !1
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(mn), re(Wr), re(FAe), re(wi, 8), re(PAe, 8))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			const HG = "cdk-high-contrast-black-on-white",
				VG = "cdk-high-contrast-white-on-black",
				qD = "cdk-high-contrast-active"
			let QG = (() => {
					class t {
						constructor(e, i) {
							;(this._platform = e),
								(this._document = i),
								(this._breakpointSubscription = Rt(mAe)
									.observe("(forced-colors: active)")
									.subscribe(() => {
										this._hasCheckedHighContrastMode &&
											((this._hasCheckedHighContrastMode = !1), this._applyBodyHighContrastModeCssClasses())
									}))
						}
						getHighContrastMode() {
							if (!this._platform.isBrowser) return 0
							const e = this._document.createElement("div")
							;(e.style.backgroundColor = "rgb(1,2,3)"), (e.style.position = "absolute"), this._document.body.appendChild(e)
							const i = this._document.defaultView || window,
								r = i && i.getComputedStyle ? i.getComputedStyle(e) : null,
								o = ((r && r.backgroundColor) || "").replace(/ /g, "")
							switch ((e.remove(), o)) {
								case "rgb(0,0,0)":
								case "rgb(45,50,54)":
								case "rgb(32,32,32)":
									return 2
								case "rgb(255,255,255)":
								case "rgb(255,250,239)":
									return 1
							}
							return 0
						}
						ngOnDestroy() {
							this._breakpointSubscription.unsubscribe()
						}
						_applyBodyHighContrastModeCssClasses() {
							if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
								const e = this._document.body.classList
								e.remove(qD, HG, VG), (this._hasCheckedHighContrastMode = !0)
								const i = this.getHighContrastMode()
								1 === i ? e.add(qD, HG) : 2 === i && e.add(qD, VG)
							}
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Wr), re(wi))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				ZD = (() => {
					class t {
						constructor(e) {
							e._applyBodyHighContrastModeCssClasses()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(QG))
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [zD] })
						}
					}
					return t
				})()
			function JD(t) {
				return new Ge(n => {
					_e(t()).subscribe(n)
				})
			}
			function OAe(t, n) {}
			class zE {
				constructor() {
					;(this.role = "dialog"),
						(this.panelClass = ""),
						(this.hasBackdrop = !0),
						(this.backdropClass = ""),
						(this.disableClose = !1),
						(this.width = ""),
						(this.height = ""),
						(this.data = null),
						(this.ariaDescribedBy = null),
						(this.ariaLabelledBy = null),
						(this.ariaLabel = null),
						(this.ariaModal = !0),
						(this.autoFocus = "first-tabbable"),
						(this.restoreFocus = !0),
						(this.closeOnNavigation = !0),
						(this.closeOnDestroy = !0),
						(this.closeOnOverlayDetachments = !0)
				}
			}
			let zG = (() => {
				class t extends UD {
					constructor(e, i, r, o, s, a, c, l) {
						super(),
							(this._elementRef = e),
							(this._focusTrapFactory = i),
							(this._config = o),
							(this._interactivityChecker = s),
							(this._ngZone = a),
							(this._overlayRef = c),
							(this._focusMonitor = l),
							(this._elementFocusedBeforeDialogWasOpened = null),
							(this._closeInteractionType = null),
							(this._ariaLabelledByQueue = []),
							(this.attachDomPortal = d => {
								this._portalOutlet.hasAttached()
								const u = this._portalOutlet.attachDomPortal(d)
								return this._contentAttached(), u
							}),
							(this._document = r),
							this._config.ariaLabelledBy && this._ariaLabelledByQueue.push(this._config.ariaLabelledBy)
					}
					_contentAttached() {
						this._initializeFocusTrap(), this._handleBackdropClicks(), this._captureInitialFocus()
					}
					_captureInitialFocus() {
						this._trapFocus()
					}
					ngOnDestroy() {
						this._restoreFocus()
					}
					attachComponentPortal(e) {
						this._portalOutlet.hasAttached()
						const i = this._portalOutlet.attachComponentPortal(e)
						return this._contentAttached(), i
					}
					attachTemplatePortal(e) {
						this._portalOutlet.hasAttached()
						const i = this._portalOutlet.attachTemplatePortal(e)
						return this._contentAttached(), i
					}
					_recaptureFocus() {
						this._containsFocus() || this._trapFocus()
					}
					_forceFocus(e, i) {
						this._interactivityChecker.isFocusable(e) ||
							((e.tabIndex = -1),
							this._ngZone.runOutsideAngular(() => {
								const r = () => {
									e.removeEventListener("blur", r), e.removeEventListener("mousedown", r), e.removeAttribute("tabindex")
								}
								e.addEventListener("blur", r), e.addEventListener("mousedown", r)
							})),
							e.focus(i)
					}
					_focusByCssSelector(e, i) {
						let r = this._elementRef.nativeElement.querySelector(e)
						r && this._forceFocus(r, i)
					}
					_trapFocus() {
						const e = this._elementRef.nativeElement
						switch (this._config.autoFocus) {
							case !1:
							case "dialog":
								this._containsFocus() || e.focus()
								break
							case !0:
							case "first-tabbable":
								this._focusTrap.focusInitialElementWhenReady().then(i => {
									i || this._focusDialogContainer()
								})
								break
							case "first-heading":
								this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]')
								break
							default:
								this._focusByCssSelector(this._config.autoFocus)
						}
					}
					_restoreFocus() {
						const e = this._config.restoreFocus
						let i = null
						if (
							("string" == typeof e
								? (i = this._document.querySelector(e))
								: "boolean" == typeof e
								? (i = e ? this._elementFocusedBeforeDialogWasOpened : null)
								: e && (i = e),
							this._config.restoreFocus && i && "function" == typeof i.focus)
						) {
							const r = FE(),
								o = this._elementRef.nativeElement
							;(!r || r === this._document.body || r === o || o.contains(r)) &&
								(this._focusMonitor
									? (this._focusMonitor.focusVia(i, this._closeInteractionType), (this._closeInteractionType = null))
									: i.focus())
						}
						this._focusTrap && this._focusTrap.destroy()
					}
					_focusDialogContainer() {
						this._elementRef.nativeElement.focus && this._elementRef.nativeElement.focus()
					}
					_containsFocus() {
						const e = this._elementRef.nativeElement,
							i = FE()
						return e === i || e.contains(i)
					}
					_initializeFocusTrap() {
						;(this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement)),
							this._document && (this._elementFocusedBeforeDialogWasOpened = FE())
					}
					_handleBackdropClicks() {
						this._overlayRef.backdropClick().subscribe(() => {
							this._config.disableClose && this._recaptureFocus()
						})
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(wn), P(KD), P(wi, 8), P(zE), P(VE), P(mn), P(Cv), P(fd))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cdk-dialog-container"]],
							viewQuery: function (i, r) {
								if ((1 & i && _i(BE, 7), 2 & i)) {
									let o
									sn((o = an())) && (r._portalOutlet = o.first)
								}
							},
							hostAttrs: ["tabindex", "-1", 1, "cdk-dialog-container"],
							hostVars: 6,
							hostBindings: function (i, r) {
								2 & i &&
									qn("id", r._config.id || null)("role", r._config.role)("aria-modal", r._config.ariaModal)(
										"aria-labelledby",
										r._config.ariaLabel ? null : r._ariaLabelledByQueue[0]
									)("aria-label", r._config.ariaLabel)("aria-describedby", r._config.ariaDescribedBy || null)
							},
							features: [pn],
							decls: 1,
							vars: 0,
							consts: [["cdkPortalOutlet", ""]],
							template: function (i, r) {
								1 & i && Ee(0, OAe, 0, 0, "ng-template", 0)
							},
							dependencies: [BE],
							styles: [".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			class eL {
				constructor(n, e) {
					;(this.overlayRef = n),
						(this.config = e),
						(this.closed = new vt()),
						(this.disableClose = e.disableClose),
						(this.backdropClick = n.backdropClick()),
						(this.keydownEvents = n.keydownEvents()),
						(this.outsidePointerEvents = n.outsidePointerEvents()),
						(this.id = e.id),
						this.keydownEvents.subscribe(i => {
							27 === i.keyCode &&
								!this.disableClose &&
								!fl(i) &&
								(i.preventDefault(), this.close(void 0, { focusOrigin: "keyboard" }))
						}),
						this.backdropClick.subscribe(() => {
							this.disableClose || this.close(void 0, { focusOrigin: "mouse" })
						}),
						(this._detachSubscription = n.detachments().subscribe(() => {
							!1 !== e.closeOnOverlayDetachments && this.close()
						}))
				}
				close(n, e) {
					if (this.containerInstance) {
						const i = this.closed
						;(this.containerInstance._closeInteractionType = e?.focusOrigin || "program"),
							this._detachSubscription.unsubscribe(),
							this.overlayRef.dispose(),
							i.next(n),
							i.complete(),
							(this.componentInstance = this.containerInstance = null)
					}
				}
				updatePosition() {
					return this.overlayRef.updatePosition(), this
				}
				updateSize(n = "", e = "") {
					return this.overlayRef.updateSize({ width: n, height: e }), this
				}
				addPanelClass(n) {
					return this.overlayRef.addPanelClass(n), this
				}
				removePanelClass(n) {
					return this.overlayRef.removePanelClass(n), this
				}
			}
			const GG = new He("DialogScrollStrategy"),
				NAe = new He("DialogData"),
				UAe = new He("DefaultDialogConfig"),
				VAe = {
					provide: GG,
					deps: [ec],
					useFactory: function HAe(t) {
						return () => t.scrollStrategies.block()
					}
				}
			let QAe = 0,
				$G = (() => {
					class t {
						get openDialogs() {
							return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel
						}
						get afterOpened() {
							return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel
						}
						constructor(e, i, r, o, s, a) {
							;(this._overlay = e),
								(this._injector = i),
								(this._defaultOptions = r),
								(this._parentDialog = o),
								(this._overlayContainer = s),
								(this._openDialogsAtThisLevel = []),
								(this._afterAllClosedAtThisLevel = new vt()),
								(this._afterOpenedAtThisLevel = new vt()),
								(this._ariaHiddenElements = new Map()),
								(this.afterAllClosed = JD(() =>
									this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(hd(void 0))
								)),
								(this._scrollStrategy = a)
						}
						open(e, i) {
							;((i = { ...(this._defaultOptions || new zE()), ...i }).id = i.id || "cdk-dialog-" + QAe++),
								i.id && this.getDialogById(i.id)
							const o = this._getOverlayConfig(i),
								s = this._overlay.create(o),
								a = new eL(s, i),
								c = this._attachContainer(s, a, i)
							return (
								(a.containerInstance = c),
								this._attachDialogContent(e, a, c, i),
								this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(),
								this.openDialogs.push(a),
								a.closed.subscribe(() => this._removeOpenDialog(a, !0)),
								this.afterOpened.next(a),
								a
							)
						}
						closeAll() {
							tL(this.openDialogs, e => e.close())
						}
						getDialogById(e) {
							return this.openDialogs.find(i => i.id === e)
						}
						ngOnDestroy() {
							tL(this._openDialogsAtThisLevel, e => {
								!1 === e.config.closeOnDestroy && this._removeOpenDialog(e, !1)
							}),
								tL(this._openDialogsAtThisLevel, e => e.close()),
								this._afterAllClosedAtThisLevel.complete(),
								this._afterOpenedAtThisLevel.complete(),
								(this._openDialogsAtThisLevel = [])
						}
						_getOverlayConfig(e) {
							const i = new PE({
								positionStrategy:
									e.positionStrategy || this._overlay.position().global().centerHorizontally().centerVertically(),
								scrollStrategy: e.scrollStrategy || this._scrollStrategy(),
								panelClass: e.panelClass,
								hasBackdrop: e.hasBackdrop,
								direction: e.direction,
								minWidth: e.minWidth,
								minHeight: e.minHeight,
								maxWidth: e.maxWidth,
								maxHeight: e.maxHeight,
								width: e.width,
								height: e.height,
								disposeOnNavigation: e.closeOnNavigation
							})
							return e.backdropClass && (i.backdropClass = e.backdropClass), i
						}
						_attachContainer(e, i, r) {
							const o = r.injector || r.viewContainerRef?.injector,
								s = [
									{ provide: zE, useValue: r },
									{ provide: eL, useValue: i },
									{ provide: Cv, useValue: e }
								]
							let a
							r.container
								? "function" == typeof r.container
									? (a = r.container)
									: ((a = r.container.type), s.push(...r.container.providers(r)))
								: (a = zG)
							const c = new vv(
								a,
								r.viewContainerRef,
								ks.create({ parent: o || this._injector, providers: s }),
								r.componentFactoryResolver
							)
							return e.attach(c).instance
						}
						_attachDialogContent(e, i, r, o) {
							if (e instanceof Za) {
								const s = this._createInjector(o, i, r, void 0)
								let a = { $implicit: o.data, dialogRef: i }
								o.templateContext &&
									(a = { ...a, ...("function" == typeof o.templateContext ? o.templateContext() : o.templateContext) }),
									r.attachTemplatePortal(new yv(e, null, a, s))
							} else {
								const s = this._createInjector(o, i, r, this._injector),
									a = r.attachComponentPortal(new vv(e, o.viewContainerRef, s, o.componentFactoryResolver))
								;(i.componentRef = a), (i.componentInstance = a.instance)
							}
						}
						_createInjector(e, i, r, o) {
							const s = e.injector || e.viewContainerRef?.injector,
								a = [
									{ provide: NAe, useValue: e.data },
									{ provide: eL, useValue: i }
								]
							return (
								e.providers &&
									("function" == typeof e.providers ? a.push(...e.providers(i, e, r)) : a.push(...e.providers)),
								e.direction &&
									(!s || !s.get(wu, null, { optional: !0 })) &&
									a.push({ provide: wu, useValue: { value: e.direction, change: Wo() } }),
								ks.create({ parent: s || o, providers: a })
							)
						}
						_removeOpenDialog(e, i) {
							const r = this.openDialogs.indexOf(e)
							r > -1 &&
								(this.openDialogs.splice(r, 1),
								this.openDialogs.length ||
									(this._ariaHiddenElements.forEach((o, s) => {
										o ? s.setAttribute("aria-hidden", o) : s.removeAttribute("aria-hidden")
									}),
									this._ariaHiddenElements.clear(),
									i && this._getAfterAllClosed().next()))
						}
						_hideNonDialogContentFromAssistiveTechnology() {
							const e = this._overlayContainer.getContainerElement()
							if (e.parentElement) {
								const i = e.parentElement.children
								for (let r = i.length - 1; r > -1; r--) {
									const o = i[r]
									o !== e &&
										"SCRIPT" !== o.nodeName &&
										"STYLE" !== o.nodeName &&
										!o.hasAttribute("aria-live") &&
										(this._ariaHiddenElements.set(o, o.getAttribute("aria-hidden")),
										o.setAttribute("aria-hidden", "true"))
								}
							}
						}
						_getAfterAllClosed() {
							const e = this._parentDialog
							return e ? e._getAfterAllClosed() : this._afterAllClosedAtThisLevel
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(ec), re(ks), re(UAe, 8), re(t, 12), re(OE), re(GG))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})()
			function tL(t, n) {
				let e = t.length
				for (; e--; ) n(t[e])
			}
			let zAe = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({ providers: [$G, VAe], imports: [Ev, wv, ZD, wv] })
					}
				}
				return t
			})()
			const GAe = ["text"]
			function $Ae(t, n) {
				if ((1 & t && fe(0, "mat-pseudo-checkbox", 6), 2 & t)) {
					const e = Te()
					U("disabled", e.disabled)("state", e.selected ? "checked" : "unchecked")
				}
			}
			function WAe(t, n) {
				1 & t && fe(0, "mat-pseudo-checkbox", 7), 2 & t && U("disabled", Te().disabled)
			}
			function jAe(t, n) {
				if ((1 & t && (F(0, "span", 8), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1), Vt("(", e.group.label, ")")
				}
			}
			const KAe = [[["mat-icon"]], "*"],
				XAe = ["mat-icon", "*"],
				qAe = new He("mat-sanity-checks", {
					providedIn: "root",
					factory: function YAe() {
						return !0
					}
				})
			let Yi = (() => {
				class t {
					constructor(e, i, r) {
						;(this._sanityChecks = i),
							(this._document = r),
							(this._hasDoneGlobalChecks = !1),
							e._applyBodyHighContrastModeCssClasses(),
							this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0)
					}
					_checkIsEnabled(e) {
						return !PD() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[e])
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(QG), re(qAe, 8), re(wi))
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({ imports: [bv, bv] })
					}
				}
				return t
			})()
			function Sv(t) {
				return class extends t {
					get disabled() {
						return this._disabled
					}
					set disabled(n) {
						this._disabled = Mn(n)
					}
					constructor(...n) {
						super(...n), (this._disabled = !1)
					}
				}
			}
			function _g(t, n) {
				return class extends t {
					get color() {
						return this._color
					}
					set color(e) {
						const i = e || this.defaultColor
						i !== this._color &&
							(this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),
							i && this._elementRef.nativeElement.classList.add(`mat-${i}`),
							(this._color = i))
					}
					constructor(...e) {
						super(...e), (this.defaultColor = n), (this.color = n)
					}
				}
			}
			function Um(t) {
				return class extends t {
					get disableRipple() {
						return this._disableRipple
					}
					set disableRipple(n) {
						this._disableRipple = Mn(n)
					}
					constructor(...n) {
						super(...n), (this._disableRipple = !1)
					}
				}
			}
			function GE(t, n = 0) {
				return class extends t {
					get tabIndex() {
						return this.disabled ? -1 : this._tabIndex
					}
					set tabIndex(e) {
						this._tabIndex = null != e ? to(e) : this.defaultTabIndex
					}
					constructor(...e) {
						super(...e), (this._tabIndex = n), (this.defaultTabIndex = n)
					}
				}
			}
			function KG(t) {
				return class extends t {
					updateErrorState() {
						const n = this.errorState,
							o = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(
								this.ngControl ? this.ngControl.control : null,
								this._parentFormGroup || this._parentForm
							)
						o !== n && ((this.errorState = o), this.stateChanges.next())
					}
					constructor(...n) {
						super(...n), (this.errorState = !1)
					}
				}
			}
			let XG = (() => {
				class t {
					isErrorState(e, i) {
						return !!(e && e.invalid && (e.touched || (i && i.submitted)))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			class JAe {
				constructor(n, e, i, r = !1) {
					;(this._renderer = n),
						(this.element = e),
						(this.config = i),
						(this._animationForciblyDisabledThroughCss = r),
						(this.state = 3)
				}
				fadeOut() {
					this._renderer.fadeOutRipple(this)
				}
			}
			const YG = Rm({ passive: !0, capture: !0 })
			class ege {
				constructor() {
					;(this._events = new Map()),
						(this._delegateEventHandler = n => {
							const e = Hh(n)
							e &&
								this._events.get(n.type)?.forEach((i, r) => {
									;(r === e || r.contains(e)) && i.forEach(o => o.handleEvent(n))
								})
						})
				}
				addHandler(n, e, i, r) {
					const o = this._events.get(e)
					if (o) {
						const s = o.get(i)
						s ? s.add(r) : o.set(i, new Set([r]))
					} else
						this._events.set(e, new Map([[i, new Set([r])]])),
							n.runOutsideAngular(() => {
								document.addEventListener(e, this._delegateEventHandler, YG)
							})
				}
				removeHandler(n, e, i) {
					const r = this._events.get(n)
					if (!r) return
					const o = r.get(e)
					o &&
						(o.delete(i),
						0 === o.size && r.delete(e),
						0 === r.size && (this._events.delete(n), document.removeEventListener(n, this._delegateEventHandler, YG)))
				}
			}
			const qG = { enterDuration: 225, exitDuration: 150 },
				ZG = Rm({ passive: !0, capture: !0 }),
				JG = ["mousedown", "touchstart"],
				e9 = ["mouseup", "mouseleave", "touchend", "touchcancel"]
			class Tv {
				static {
					this._eventManager = new ege()
				}
				constructor(n, e, i, r) {
					;(this._target = n),
						(this._ngZone = e),
						(this._platform = r),
						(this._isPointerDown = !1),
						(this._activeRipples = new Map()),
						(this._pointerUpEventsRegistered = !1),
						r.isBrowser && (this._containerElement = yu(i))
				}
				fadeInRipple(n, e, i = {}) {
					const r = (this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect()),
						o = { ...qG, ...i.animation }
					i.centered && ((n = r.left + r.width / 2), (e = r.top + r.height / 2))
					const s =
							i.radius ||
							(function nge(t, n, e) {
								const i = Math.max(Math.abs(t - e.left), Math.abs(t - e.right)),
									r = Math.max(Math.abs(n - e.top), Math.abs(n - e.bottom))
								return Math.sqrt(i * i + r * r)
							})(n, e, r),
						a = n - r.left,
						c = e - r.top,
						l = o.enterDuration,
						d = document.createElement("div")
					d.classList.add("mat-ripple-element"),
						(d.style.left = a - s + "px"),
						(d.style.top = c - s + "px"),
						(d.style.height = 2 * s + "px"),
						(d.style.width = 2 * s + "px"),
						null != i.color && (d.style.backgroundColor = i.color),
						(d.style.transitionDuration = `${l}ms`),
						this._containerElement.appendChild(d)
					const u = window.getComputedStyle(d),
						f = u.transitionDuration,
						_ = "none" === u.transitionProperty || "0s" === f || "0s, 0s" === f || (0 === r.width && 0 === r.height),
						y = new JAe(this, d, i, _)
					;(d.style.transform = "scale3d(1, 1, 1)"), (y.state = 0), i.persistent || (this._mostRecentTransientRipple = y)
					let C = null
					return (
						!_ &&
							(l || o.exitDuration) &&
							this._ngZone.runOutsideAngular(() => {
								const x = () => this._finishRippleTransition(y),
									w = () => this._destroyRipple(y)
								d.addEventListener("transitionend", x),
									d.addEventListener("transitioncancel", w),
									(C = { onTransitionEnd: x, onTransitionCancel: w })
							}),
						this._activeRipples.set(y, C),
						(_ || !l) && this._finishRippleTransition(y),
						y
					)
				}
				fadeOutRipple(n) {
					if (2 === n.state || 3 === n.state) return
					const e = n.element,
						i = { ...qG, ...n.config.animation }
					;(e.style.transitionDuration = `${i.exitDuration}ms`),
						(e.style.opacity = "0"),
						(n.state = 2),
						(n._animationForciblyDisabledThroughCss || !i.exitDuration) && this._finishRippleTransition(n)
				}
				fadeOutAll() {
					this._getActiveRipples().forEach(n => n.fadeOut())
				}
				fadeOutAllNonPersistent() {
					this._getActiveRipples().forEach(n => {
						n.config.persistent || n.fadeOut()
					})
				}
				setupTriggerEvents(n) {
					const e = yu(n)
					!this._platform.isBrowser ||
						!e ||
						e === this._triggerElement ||
						(this._removeTriggerEvents(),
						(this._triggerElement = e),
						JG.forEach(i => {
							Tv._eventManager.addHandler(this._ngZone, i, e, this)
						}))
				}
				handleEvent(n) {
					"mousedown" === n.type ? this._onMousedown(n) : "touchstart" === n.type ? this._onTouchStart(n) : this._onPointerUp(),
						this._pointerUpEventsRegistered ||
							(this._ngZone.runOutsideAngular(() => {
								e9.forEach(e => {
									this._triggerElement.addEventListener(e, this, ZG)
								})
							}),
							(this._pointerUpEventsRegistered = !0))
				}
				_finishRippleTransition(n) {
					0 === n.state ? this._startFadeOutTransition(n) : 2 === n.state && this._destroyRipple(n)
				}
				_startFadeOutTransition(n) {
					const e = n === this._mostRecentTransientRipple,
						{ persistent: i } = n.config
					;(n.state = 1), !i && (!e || !this._isPointerDown) && n.fadeOut()
				}
				_destroyRipple(n) {
					const e = this._activeRipples.get(n) ?? null
					this._activeRipples.delete(n),
						this._activeRipples.size || (this._containerRect = null),
						n === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null),
						(n.state = 3),
						null !== e &&
							(n.element.removeEventListener("transitionend", e.onTransitionEnd),
							n.element.removeEventListener("transitioncancel", e.onTransitionCancel)),
						n.element.remove()
				}
				_onMousedown(n) {
					const e = XD(n),
						i = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800
					!this._target.rippleDisabled &&
						!e &&
						!i &&
						((this._isPointerDown = !0), this.fadeInRipple(n.clientX, n.clientY, this._target.rippleConfig))
				}
				_onTouchStart(n) {
					if (!this._target.rippleDisabled && !YD(n)) {
						;(this._lastTouchStartEvent = Date.now()), (this._isPointerDown = !0)
						const e = n.changedTouches
						if (e) for (let i = 0; i < e.length; i++) this.fadeInRipple(e[i].clientX, e[i].clientY, this._target.rippleConfig)
					}
				}
				_onPointerUp() {
					this._isPointerDown &&
						((this._isPointerDown = !1),
						this._getActiveRipples().forEach(n => {
							!n.config.persistent && (1 === n.state || (n.config.terminateOnPointerUp && 0 === n.state)) && n.fadeOut()
						}))
				}
				_getActiveRipples() {
					return Array.from(this._activeRipples.keys())
				}
				_removeTriggerEvents() {
					const n = this._triggerElement
					n &&
						(JG.forEach(e => Tv._eventManager.removeHandler(e, n, this)),
						this._pointerUpEventsRegistered && e9.forEach(e => n.removeEventListener(e, this, ZG)))
				}
			}
			const vg = new He("mat-ripple-global-options")
			let Cu = (() => {
					class t {
						get disabled() {
							return this._disabled
						}
						set disabled(e) {
							e && this.fadeOutAllNonPersistent(), (this._disabled = e), this._setupTriggerEventsIfEnabled()
						}
						get trigger() {
							return this._trigger || this._elementRef.nativeElement
						}
						set trigger(e) {
							;(this._trigger = e), this._setupTriggerEventsIfEnabled()
						}
						constructor(e, i, r, o, s) {
							;(this._elementRef = e),
								(this._animationMode = s),
								(this.radius = 0),
								(this._disabled = !1),
								(this._isInitialized = !1),
								(this._globalOptions = o || {}),
								(this._rippleRenderer = new Tv(this, i, e, r))
						}
						ngOnInit() {
							;(this._isInitialized = !0), this._setupTriggerEventsIfEnabled()
						}
						ngOnDestroy() {
							this._rippleRenderer._removeTriggerEvents()
						}
						fadeOutAll() {
							this._rippleRenderer.fadeOutAll()
						}
						fadeOutAllNonPersistent() {
							this._rippleRenderer.fadeOutAllNonPersistent()
						}
						get rippleConfig() {
							return {
								centered: this.centered,
								radius: this.radius,
								color: this.color,
								animation: {
									...this._globalOptions.animation,
									...("NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}),
									...this.animation
								},
								terminateOnPointerUp: this._globalOptions.terminateOnPointerUp
							}
						}
						get rippleDisabled() {
							return this.disabled || !!this._globalOptions.disabled
						}
						_setupTriggerEventsIfEnabled() {
							!this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger)
						}
						launch(e, i = 0, r) {
							return "number" == typeof e
								? this._rippleRenderer.fadeInRipple(e, i, { ...this.rippleConfig, ...r })
								: this._rippleRenderer.fadeInRipple(0, 0, { ...this.rippleConfig, ...e })
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(mn), P(Wr), P(vg, 8), P(Bo, 8))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [
									["", "mat-ripple", ""],
									["", "matRipple", ""]
								],
								hostAttrs: [1, "mat-ripple"],
								hostVars: 2,
								hostBindings: function (i, r) {
									2 & i && Zt("mat-ripple-unbounded", r.unbounded)
								},
								inputs: {
									color: ["matRippleColor", "color"],
									unbounded: ["matRippleUnbounded", "unbounded"],
									centered: ["matRippleCentered", "centered"],
									radius: ["matRippleRadius", "radius"],
									animation: ["matRippleAnimation", "animation"],
									disabled: ["matRippleDisabled", "disabled"],
									trigger: ["matRippleTrigger", "trigger"]
								},
								exportAs: ["matRipple"]
							})
						}
					}
					return t
				})(),
				Vh = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Yi] })
						}
					}
					return t
				})(),
				ige = (() => {
					class t {
						constructor(e) {
							;(this._animationMode = e), (this.state = "unchecked"), (this.disabled = !1), (this.appearance = "full")
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Bo, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-pseudo-checkbox"]],
								hostAttrs: [1, "mat-pseudo-checkbox"],
								hostVars: 12,
								hostBindings: function (i, r) {
									2 & i &&
										Zt("mat-pseudo-checkbox-indeterminate", "indeterminate" === r.state)(
											"mat-pseudo-checkbox-checked",
											"checked" === r.state
										)("mat-pseudo-checkbox-disabled", r.disabled)(
											"mat-pseudo-checkbox-minimal",
											"minimal" === r.appearance
										)("mat-pseudo-checkbox-full", "full" === r.appearance)(
											"_mat-animation-noopable",
											"NoopAnimations" === r._animationMode
										)
								},
								inputs: { state: "state", disabled: "disabled", appearance: "appearance" },
								decls: 0,
								vars: 0,
								template: function (i, r) {},
								styles: [
									'.mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-full{border:2px solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}'
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				t9 = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi] })
						}
					}
					return t
				})()
			const n9 = new He("MAT_OPTION_PARENT_COMPONENT"),
				i9 = new He("MatOptgroup")
			let rge = 0
			class oge {
				constructor(n, e = !1) {
					;(this.source = n), (this.isUserInput = e)
				}
			}
			let sge = (() => {
					class t {
						get multiple() {
							return this._parent && this._parent.multiple
						}
						get selected() {
							return this._selected
						}
						get disabled() {
							return (this.group && this.group.disabled) || this._disabled
						}
						set disabled(e) {
							this._disabled = Mn(e)
						}
						get disableRipple() {
							return !(!this._parent || !this._parent.disableRipple)
						}
						get hideSingleSelectionIndicator() {
							return !(!this._parent || !this._parent.hideSingleSelectionIndicator)
						}
						constructor(e, i, r, o) {
							;(this._element = e),
								(this._changeDetectorRef = i),
								(this._parent = r),
								(this.group = o),
								(this._selected = !1),
								(this._active = !1),
								(this._disabled = !1),
								(this._mostRecentViewValue = ""),
								(this.id = "mat-option-" + rge++),
								(this.onSelectionChange = new _n()),
								(this._stateChanges = new vt())
						}
						get active() {
							return this._active
						}
						get viewValue() {
							return (this._text?.nativeElement.textContent || "").trim()
						}
						select(e = !0) {
							this._selected ||
								((this._selected = !0), this._changeDetectorRef.markForCheck(), e && this._emitSelectionChangeEvent())
						}
						deselect(e = !0) {
							this._selected &&
								((this._selected = !1), this._changeDetectorRef.markForCheck(), e && this._emitSelectionChangeEvent())
						}
						focus(e, i) {
							const r = this._getHostElement()
							"function" == typeof r.focus && r.focus(i)
						}
						setActiveStyles() {
							this._active || ((this._active = !0), this._changeDetectorRef.markForCheck())
						}
						setInactiveStyles() {
							this._active && ((this._active = !1), this._changeDetectorRef.markForCheck())
						}
						getLabel() {
							return this.viewValue
						}
						_handleKeydown(e) {
							;(13 === e.keyCode || 32 === e.keyCode) && !fl(e) && (this._selectViaInteraction(), e.preventDefault())
						}
						_selectViaInteraction() {
							this.disabled ||
								((this._selected = !this.multiple || !this._selected),
								this._changeDetectorRef.markForCheck(),
								this._emitSelectionChangeEvent(!0))
						}
						_getTabIndex() {
							return this.disabled ? "-1" : "0"
						}
						_getHostElement() {
							return this._element.nativeElement
						}
						ngAfterViewChecked() {
							if (this._selected) {
								const e = this.viewValue
								e !== this._mostRecentViewValue &&
									(this._mostRecentViewValue && this._stateChanges.next(), (this._mostRecentViewValue = e))
							}
						}
						ngOnDestroy() {
							this._stateChanges.complete()
						}
						_emitSelectionChangeEvent(e = !1) {
							this.onSelectionChange.emit(new oge(this, e))
						}
						static {
							this.ɵfac = function (i) {
								Am()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								viewQuery: function (i, r) {
									if ((1 & i && _i(GAe, 7), 2 & i)) {
										let o
										sn((o = an())) && (r._text = o.first)
									}
								},
								inputs: { value: "value", id: "id", disabled: "disabled" },
								outputs: { onSelectionChange: "onSelectionChange" }
							})
						}
					}
					return t
				})(),
				Qh = (() => {
					class t extends sge {
						constructor(e, i, r, o) {
							super(e, i, r, o)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(Jr), P(n9, 8), P(i9, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-option"]],
								hostAttrs: ["role", "option", 1, "mat-mdc-option", "mdc-list-item"],
								hostVars: 11,
								hostBindings: function (i, r) {
									1 & i &&
										Le("click", function () {
											return r._selectViaInteraction()
										})("keydown", function (s) {
											return r._handleKeydown(s)
										}),
										2 & i &&
											(td("id", r.id),
											qn("aria-selected", r.selected)("aria-disabled", r.disabled.toString()),
											Zt("mdc-list-item--selected", r.selected)("mat-mdc-option-multiple", r.multiple)(
												"mat-mdc-option-active",
												r.active
											)("mdc-list-item--disabled", r.disabled))
								},
								exportAs: ["matOption"],
								features: [pn],
								ngContentSelectors: XAe,
								decls: 8,
								vars: 5,
								consts: [
									["class", "mat-mdc-option-pseudo-checkbox", "aria-hidden", "true", 3, "disabled", "state", 4, "ngIf"],
									[1, "mdc-list-item__primary-text"],
									["text", ""],
									[
										"class",
										"mat-mdc-option-pseudo-checkbox",
										"state",
										"checked",
										"aria-hidden",
										"true",
										"appearance",
										"minimal",
										3,
										"disabled",
										4,
										"ngIf"
									],
									["class", "cdk-visually-hidden", 4, "ngIf"],
									[
										"aria-hidden",
										"true",
										"mat-ripple",
										"",
										1,
										"mat-mdc-option-ripple",
										"mat-mdc-focus-indicator",
										3,
										"matRippleTrigger",
										"matRippleDisabled"
									],
									["aria-hidden", "true", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled", "state"],
									[
										"state",
										"checked",
										"aria-hidden",
										"true",
										"appearance",
										"minimal",
										1,
										"mat-mdc-option-pseudo-checkbox",
										3,
										"disabled"
									],
									[1, "cdk-visually-hidden"]
								],
								template: function (i, r) {
									1 & i &&
										(co(KAe),
										Ee(0, $Ae, 1, 2, "mat-pseudo-checkbox", 0),
										Ln(1),
										F(2, "span", 1, 2),
										Ln(4, 1),
										L(),
										Ee(5, WAe, 1, 1, "mat-pseudo-checkbox", 3),
										Ee(6, jAe, 2, 1, "span", 4),
										fe(7, "div", 5)),
										2 & i &&
											(U("ngIf", r.multiple),
											T(5),
											U("ngIf", !r.multiple && r.selected && !r.hideSingleSelectionIndicator),
											T(1),
											U("ngIf", r.group && r.group._inert),
											T(1),
											U("matRippleTrigger", r._getHostElement())("matRippleDisabled", r.disabled || r.disableRipple))
								},
								dependencies: [Cu, En, ige],
								styles: [
									'.mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);color:var(--mat-option-label-text-color);font-family:var(--mat-option-label-text-font);line-height:var(--mat-option-label-text-line-height);font-size:var(--mat-option-label-text-size);letter-spacing:var(--mat-option-label-text-tracking);font-weight:var(--mat-option-label-text-weight);min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option:hover:not(.mdc-list-item--disabled){background-color:var(--mat-option-hover-state-layer-color)}.mat-mdc-option:focus.mdc-list-item,.mat-mdc-option.mat-mdc-option-active.mdc-list-item{background-color:var(--mat-option-focus-state-layer-color)}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled) .mdc-list-item__primary-text{color:var(--mat-option-selected-state-label-text-color)}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple){background-color:var(--mat-option-selected-state-layer-color)}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active .mat-mdc-focus-indicator::before{content:""}'
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				r9 = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Vh, Ot, Yi, t9] })
						}
					}
					return t
				})()
			const o9 = { capture: !0 },
				s9 = ["focus", "click", "mouseenter", "touchstart"],
				nL = "mat-ripple-loader-uninitialized",
				iL = "mat-ripple-loader-class-name",
				a9 = "mat-ripple-loader-centered",
				$E = "mat-ripple-loader-disabled"
			let lge = (() => {
				class t {
					constructor() {
						;(this._document = Rt(wi, { optional: !0 })),
							(this._animationMode = Rt(Bo, { optional: !0 })),
							(this._globalRippleOptions = Rt(vg, { optional: !0 })),
							(this._platform = Rt(Wr)),
							(this._ngZone = Rt(mn)),
							(this._onInteraction = e => {
								if (!(e.target instanceof HTMLElement)) return
								const r = e.target.closest(`[${nL}]`)
								r && this.createRipple(r)
							}),
							this._ngZone.runOutsideAngular(() => {
								for (const e of s9) this._document?.addEventListener(e, this._onInteraction, o9)
							})
					}
					ngOnDestroy() {
						for (const e of s9) this._document?.removeEventListener(e, this._onInteraction, o9)
					}
					configureRipple(e, i) {
						e.setAttribute(nL, ""),
							(i.className || !e.hasAttribute(iL)) && e.setAttribute(iL, i.className || ""),
							i.centered && e.setAttribute(a9, ""),
							i.disabled && e.setAttribute($E, "")
					}
					getRipple(e) {
						return e.matRipple ? e.matRipple : this.createRipple(e)
					}
					setDisabled(e, i) {
						const r = e.matRipple
						r ? (r.disabled = i) : i ? e.setAttribute($E, "") : e.removeAttribute($E)
					}
					createRipple(e) {
						if (!this._document) return
						e.querySelector(".mat-ripple")?.remove()
						const i = this._document.createElement("span")
						i.classList.add("mat-ripple", e.getAttribute(iL)), e.append(i)
						const r = new Cu(
							new wn(i),
							this._ngZone,
							this._platform,
							this._globalRippleOptions ? this._globalRippleOptions : void 0,
							this._animationMode ? this._animationMode : void 0
						)
						return (
							(r._isInitialized = !0),
							(r.trigger = e),
							(r.centered = e.hasAttribute(a9)),
							(r.disabled = e.hasAttribute($E)),
							this.attachRipple(e, r),
							r
						)
					}
					attachRipple(e, i) {
						e.removeAttribute(nL), (e.matRipple = i)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			class c9 {}
			class dge {}
			const Eu = "*"
			function Mu(t, n) {
				return { type: 7, name: t, definitions: n, options: {} }
			}
			function Rc(t, n = null) {
				return { type: 4, styles: n, timings: t }
			}
			function d9(t, n = null) {
				return { type: 2, steps: t, options: n }
			}
			function wo(t) {
				return { type: 6, styles: t, offset: null }
			}
			function Pc(t, n, e) {
				return { type: 0, name: t, styles: n, options: e }
			}
			function tc(t, n, e = null) {
				return { type: 1, expr: t, animation: n, options: e }
			}
			function rL(t = null) {
				return { type: 9, options: t }
			}
			function oL(t, n, e = null) {
				return { type: 11, selector: t, animation: n, options: e }
			}
			class Fv {
				constructor(n = 0, e = 0) {
					;(this._onDoneFns = []),
						(this._onStartFns = []),
						(this._onDestroyFns = []),
						(this._originalOnDoneFns = []),
						(this._originalOnStartFns = []),
						(this._started = !1),
						(this._destroyed = !1),
						(this._finished = !1),
						(this._position = 0),
						(this.parentPlayer = null),
						(this.totalTime = n + e)
				}
				_onFinish() {
					this._finished || ((this._finished = !0), this._onDoneFns.forEach(n => n()), (this._onDoneFns = []))
				}
				onStart(n) {
					this._originalOnStartFns.push(n), this._onStartFns.push(n)
				}
				onDone(n) {
					this._originalOnDoneFns.push(n), this._onDoneFns.push(n)
				}
				onDestroy(n) {
					this._onDestroyFns.push(n)
				}
				hasStarted() {
					return this._started
				}
				init() {}
				play() {
					this.hasStarted() || (this._onStart(), this.triggerMicrotask()), (this._started = !0)
				}
				triggerMicrotask() {
					queueMicrotask(() => this._onFinish())
				}
				_onStart() {
					this._onStartFns.forEach(n => n()), (this._onStartFns = [])
				}
				pause() {}
				restart() {}
				finish() {
					this._onFinish()
				}
				destroy() {
					this._destroyed ||
						((this._destroyed = !0),
						this.hasStarted() || this._onStart(),
						this.finish(),
						this._onDestroyFns.forEach(n => n()),
						(this._onDestroyFns = []))
				}
				reset() {
					;(this._started = !1),
						(this._finished = !1),
						(this._onStartFns = this._originalOnStartFns),
						(this._onDoneFns = this._originalOnDoneFns)
				}
				setPosition(n) {
					this._position = this.totalTime ? n * this.totalTime : 1
				}
				getPosition() {
					return this.totalTime ? this._position / this.totalTime : 1
				}
				triggerCallback(n) {
					const e = "start" == n ? this._onStartFns : this._onDoneFns
					e.forEach(i => i()), (e.length = 0)
				}
			}
			class u9 {
				constructor(n) {
					;(this._onDoneFns = []),
						(this._onStartFns = []),
						(this._finished = !1),
						(this._started = !1),
						(this._destroyed = !1),
						(this._onDestroyFns = []),
						(this.parentPlayer = null),
						(this.totalTime = 0),
						(this.players = n)
					let e = 0,
						i = 0,
						r = 0
					const o = this.players.length
					0 == o
						? queueMicrotask(() => this._onFinish())
						: this.players.forEach(s => {
								s.onDone(() => {
									++e == o && this._onFinish()
								}),
									s.onDestroy(() => {
										++i == o && this._onDestroy()
									}),
									s.onStart(() => {
										++r == o && this._onStart()
									})
						  }),
						(this.totalTime = this.players.reduce((s, a) => Math.max(s, a.totalTime), 0))
				}
				_onFinish() {
					this._finished || ((this._finished = !0), this._onDoneFns.forEach(n => n()), (this._onDoneFns = []))
				}
				init() {
					this.players.forEach(n => n.init())
				}
				onStart(n) {
					this._onStartFns.push(n)
				}
				_onStart() {
					this.hasStarted() || ((this._started = !0), this._onStartFns.forEach(n => n()), (this._onStartFns = []))
				}
				onDone(n) {
					this._onDoneFns.push(n)
				}
				onDestroy(n) {
					this._onDestroyFns.push(n)
				}
				hasStarted() {
					return this._started
				}
				play() {
					this.parentPlayer || this.init(), this._onStart(), this.players.forEach(n => n.play())
				}
				pause() {
					this.players.forEach(n => n.pause())
				}
				restart() {
					this.players.forEach(n => n.restart())
				}
				finish() {
					this._onFinish(), this.players.forEach(n => n.finish())
				}
				destroy() {
					this._onDestroy()
				}
				_onDestroy() {
					this._destroyed ||
						((this._destroyed = !0),
						this._onFinish(),
						this.players.forEach(n => n.destroy()),
						this._onDestroyFns.forEach(n => n()),
						(this._onDestroyFns = []))
				}
				reset() {
					this.players.forEach(n => n.reset()), (this._destroyed = !1), (this._finished = !1), (this._started = !1)
				}
				setPosition(n) {
					const e = n * this.totalTime
					this.players.forEach(i => {
						const r = i.totalTime ? Math.min(1, e / i.totalTime) : 1
						i.setPosition(r)
					})
				}
				getPosition() {
					const n = this.players.reduce((e, i) => (null === e || i.totalTime > e.totalTime ? i : e), null)
					return null != n ? n.getPosition() : 0
				}
				beforeDestroy() {
					this.players.forEach(n => {
						n.beforeDestroy && n.beforeDestroy()
					})
				}
				triggerCallback(n) {
					const e = "start" == n ? this._onStartFns : this._onDoneFns
					e.forEach(i => i()), (e.length = 0)
				}
			}
			function uge(t, n) {}
			class WE {
				constructor() {
					;(this.role = "dialog"),
						(this.panelClass = ""),
						(this.hasBackdrop = !0),
						(this.backdropClass = ""),
						(this.disableClose = !1),
						(this.width = ""),
						(this.height = ""),
						(this.maxWidth = "80vw"),
						(this.data = null),
						(this.ariaDescribedBy = null),
						(this.ariaLabelledBy = null),
						(this.ariaLabel = null),
						(this.ariaModal = !0),
						(this.autoFocus = "first-tabbable"),
						(this.restoreFocus = !0),
						(this.delayFocusTrap = !0),
						(this.closeOnNavigation = !0)
				}
			}
			const aL = "mdc-dialog--open",
				h9 = "mdc-dialog--opening",
				f9 = "mdc-dialog--closing"
			let mge = (() => {
				class t extends zG {
					constructor(e, i, r, o, s, a, c, l) {
						super(e, i, r, o, s, a, c, l), (this._animationStateChanged = new _n())
					}
					_captureInitialFocus() {
						this._config.delayFocusTrap || this._trapFocus()
					}
					_openAnimationDone(e) {
						this._config.delayFocusTrap && this._trapFocus(),
							this._animationStateChanged.next({ state: "opened", totalTime: e })
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(wn), P(KD), P(wi, 8), P(WE), P(VE), P(mn), P(Cv), P(fd))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["ng-component"]],
							features: [pn],
							decls: 0,
							vars: 0,
							template: function (i, r) {},
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const m9 = "--mat-dialog-transition-duration"
			function p9(t) {
				return null == t
					? null
					: "number" == typeof t
					? t
					: t.endsWith("ms")
					? to(t.substring(0, t.length - 2))
					: t.endsWith("s")
					? 1e3 * to(t.substring(0, t.length - 1))
					: "0" === t
					? 0
					: null
			}
			let pge = (() => {
				class t extends mge {
					constructor(e, i, r, o, s, a, c, l, d) {
						super(e, i, r, o, s, a, c, d),
							(this._animationMode = l),
							(this._animationsEnabled = "NoopAnimations" !== this._animationMode),
							(this._hostElement = this._elementRef.nativeElement),
							(this._enterAnimationDuration = this._animationsEnabled ? p9(this._config.enterAnimationDuration) ?? 150 : 0),
							(this._exitAnimationDuration = this._animationsEnabled ? p9(this._config.exitAnimationDuration) ?? 75 : 0),
							(this._animationTimer = null),
							(this._finishDialogOpen = () => {
								this._clearAnimationClasses(), this._openAnimationDone(this._enterAnimationDuration)
							}),
							(this._finishDialogClose = () => {
								this._clearAnimationClasses(),
									this._animationStateChanged.emit({ state: "closed", totalTime: this._exitAnimationDuration })
							})
					}
					_contentAttached() {
						super._contentAttached(), this._startOpenAnimation()
					}
					ngOnDestroy() {
						super.ngOnDestroy(), null !== this._animationTimer && clearTimeout(this._animationTimer)
					}
					_startOpenAnimation() {
						this._animationStateChanged.emit({ state: "opening", totalTime: this._enterAnimationDuration }),
							this._animationsEnabled
								? (this._hostElement.style.setProperty(m9, `${this._enterAnimationDuration}ms`),
								  this._requestAnimationFrame(() => this._hostElement.classList.add(h9, aL)),
								  this._waitForAnimationToComplete(this._enterAnimationDuration, this._finishDialogOpen))
								: (this._hostElement.classList.add(aL), Promise.resolve().then(() => this._finishDialogOpen()))
					}
					_startExitAnimation() {
						this._animationStateChanged.emit({ state: "closing", totalTime: this._exitAnimationDuration }),
							this._hostElement.classList.remove(aL),
							this._animationsEnabled
								? (this._hostElement.style.setProperty(m9, `${this._exitAnimationDuration}ms`),
								  this._requestAnimationFrame(() => this._hostElement.classList.add(f9)),
								  this._waitForAnimationToComplete(this._exitAnimationDuration, this._finishDialogClose))
								: Promise.resolve().then(() => this._finishDialogClose())
					}
					_clearAnimationClasses() {
						this._hostElement.classList.remove(h9, f9)
					}
					_waitForAnimationToComplete(e, i) {
						null !== this._animationTimer && clearTimeout(this._animationTimer), (this._animationTimer = setTimeout(i, e))
					}
					_requestAnimationFrame(e) {
						this._ngZone.runOutsideAngular(() => {
							"function" == typeof requestAnimationFrame ? requestAnimationFrame(e) : e()
						})
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(wn), P(KD), P(wi, 8), P(WE), P(VE), P(mn), P(Cv), P(Bo, 8), P(fd))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["mat-dialog-container"]],
							hostAttrs: ["tabindex", "-1", 1, "mat-mdc-dialog-container", "mdc-dialog"],
							hostVars: 8,
							hostBindings: function (i, r) {
								2 & i &&
									(td("id", r._config.id),
									qn("aria-modal", r._config.ariaModal)("role", r._config.role)(
										"aria-labelledby",
										r._config.ariaLabel ? null : r._ariaLabelledByQueue[0]
									)("aria-label", r._config.ariaLabel)("aria-describedby", r._config.ariaDescribedBy || null),
									Zt("_mat-animation-noopable", !r._animationsEnabled))
							},
							features: [pn],
							decls: 3,
							vars: 0,
							consts: [
								[1, "mdc-dialog__container"],
								[1, "mat-mdc-dialog-surface", "mdc-dialog__surface"],
								["cdkPortalOutlet", ""]
							],
							template: function (i, r) {
								1 & i && (F(0, "div", 0)(1, "div", 1), Ee(2, uge, 0, 0, "ng-template", 2), L()())
							},
							dependencies: [BE],
							styles: [
								'.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto;outline:0}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:none;opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__container .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{display:block;width:100%;height:100%}.mat-mdc-dialog-container{--mdc-dialog-container-elevation-shadow:0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);--mdc-dialog-container-shadow-color:#000;--mdc-dialog-container-shape:4px;--mdc-dialog-container-elevation: var(--mdc-dialog-container-elevation-shadow);outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, 4px)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, Roboto, sans-serif);line-height:var(--mdc-dialog-subhead-line-height, 1.5rem);font-size:var(--mdc-dialog-subhead-size, 1rem);font-weight:var(--mdc-dialog-subhead-weight, 400);letter-spacing:var(--mdc-dialog-subhead-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, rgba(0, 0, 0, 0.87))}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, Roboto, sans-serif);line-height:var(--mdc-dialog-supporting-text-line-height, 1.5rem);font-size:var(--mdc-dialog-supporting-text-size, 1rem);font-weight:var(--mdc-dialog-supporting-text-weight, 400);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, rgba(0, 0, 0, 0.6))}.mat-mdc-dialog-container .mdc-dialog__container{transition-duration:var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container{transition:none}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-actions{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			class cL {
				constructor(n, e, i) {
					;(this._ref = n),
						(this._containerInstance = i),
						(this._afterOpened = new vt()),
						(this._beforeClosed = new vt()),
						(this._state = 0),
						(this.disableClose = e.disableClose),
						(this.id = n.id),
						i._animationStateChanged
							.pipe(
								xi(r => "opened" === r.state),
								Do(1)
							)
							.subscribe(() => {
								this._afterOpened.next(), this._afterOpened.complete()
							}),
						i._animationStateChanged
							.pipe(
								xi(r => "closed" === r.state),
								Do(1)
							)
							.subscribe(() => {
								clearTimeout(this._closeFallbackTimeout), this._finishDialogClose()
							}),
						n.overlayRef.detachments().subscribe(() => {
							this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._finishDialogClose()
						}),
						oo(
							this.backdropClick(),
							this.keydownEvents().pipe(xi(r => 27 === r.keyCode && !this.disableClose && !fl(r)))
						).subscribe(r => {
							this.disableClose || (r.preventDefault(), A9(this, "keydown" === r.type ? "keyboard" : "mouse"))
						})
				}
				close(n) {
					;(this._result = n),
						this._containerInstance._animationStateChanged
							.pipe(
								xi(e => "closing" === e.state),
								Do(1)
							)
							.subscribe(e => {
								this._beforeClosed.next(n),
									this._beforeClosed.complete(),
									this._ref.overlayRef.detachBackdrop(),
									(this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), e.totalTime + 100))
							}),
						(this._state = 1),
						this._containerInstance._startExitAnimation()
				}
				afterOpened() {
					return this._afterOpened
				}
				afterClosed() {
					return this._ref.closed
				}
				beforeClosed() {
					return this._beforeClosed
				}
				backdropClick() {
					return this._ref.backdropClick
				}
				keydownEvents() {
					return this._ref.keydownEvents
				}
				updatePosition(n) {
					let e = this._ref.config.positionStrategy
					return (
						n && (n.left || n.right) ? (n.left ? e.left(n.left) : e.right(n.right)) : e.centerHorizontally(),
						n && (n.top || n.bottom) ? (n.top ? e.top(n.top) : e.bottom(n.bottom)) : e.centerVertically(),
						this._ref.updatePosition(),
						this
					)
				}
				updateSize(n = "", e = "") {
					return this._ref.updateSize(n, e), this
				}
				addPanelClass(n) {
					return this._ref.addPanelClass(n), this
				}
				removePanelClass(n) {
					return this._ref.removePanelClass(n), this
				}
				getState() {
					return this._state
				}
				_finishDialogClose() {
					;(this._state = 2),
						this._ref.close(this._result, { focusOrigin: this._closeInteractionType }),
						(this.componentInstance = null)
				}
			}
			function A9(t, n, e) {
				return (t._closeInteractionType = n), t.close(e)
			}
			const Bv = new He("MatMdcDialogData"),
				Age = new He("mat-mdc-dialog-default-options"),
				g9 = new He("mat-mdc-dialog-scroll-strategy"),
				bge = {
					provide: g9,
					deps: [ec],
					useFactory: function gge(t) {
						return () => t.scrollStrategies.block()
					}
				}
			let _ge = 0,
				vge = (() => {
					class t {
						get openDialogs() {
							return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel
						}
						get afterOpened() {
							return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel
						}
						_getAfterAllClosed() {
							const e = this._parentDialog
							return e ? e._getAfterAllClosed() : this._afterAllClosedAtThisLevel
						}
						constructor(e, i, r, o, s, a, c, l, d, u) {
							;(this._overlay = e),
								(this._defaultOptions = r),
								(this._parentDialog = o),
								(this._dialogRefConstructor = c),
								(this._dialogContainerType = l),
								(this._dialogDataToken = d),
								(this._openDialogsAtThisLevel = []),
								(this._afterAllClosedAtThisLevel = new vt()),
								(this._afterOpenedAtThisLevel = new vt()),
								(this._idPrefix = "mat-dialog-"),
								(this.dialogConfigClass = WE),
								(this.afterAllClosed = JD(() =>
									this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(hd(void 0))
								)),
								(this._scrollStrategy = a),
								(this._dialog = i.get($G))
						}
						open(e, i) {
							let r
							;((i = { ...(this._defaultOptions || new WE()), ...i }).id = i.id || `${this._idPrefix}${_ge++}`),
								(i.scrollStrategy = i.scrollStrategy || this._scrollStrategy())
							const o = this._dialog.open(e, {
								...i,
								positionStrategy: this._overlay.position().global().centerHorizontally().centerVertically(),
								disableClose: !0,
								closeOnDestroy: !1,
								closeOnOverlayDetachments: !1,
								container: {
									type: this._dialogContainerType,
									providers: () => [
										{ provide: this.dialogConfigClass, useValue: i },
										{ provide: zE, useValue: i }
									]
								},
								templateContext: () => ({ dialogRef: r }),
								providers: (s, a, c) => (
									(r = new this._dialogRefConstructor(s, i, c)),
									r.updatePosition(i?.position),
									[
										{ provide: this._dialogContainerType, useValue: c },
										{ provide: this._dialogDataToken, useValue: a.data },
										{ provide: this._dialogRefConstructor, useValue: r }
									]
								)
							})
							return (
								(r.componentRef = o.componentRef),
								(r.componentInstance = o.componentInstance),
								this.openDialogs.push(r),
								this.afterOpened.next(r),
								r.afterClosed().subscribe(() => {
									const s = this.openDialogs.indexOf(r)
									s > -1 && (this.openDialogs.splice(s, 1), this.openDialogs.length || this._getAfterAllClosed().next())
								}),
								r
							)
						}
						closeAll() {
							this._closeDialogs(this.openDialogs)
						}
						getDialogById(e) {
							return this.openDialogs.find(i => i.id === e)
						}
						ngOnDestroy() {
							this._closeDialogs(this._openDialogsAtThisLevel),
								this._afterAllClosedAtThisLevel.complete(),
								this._afterOpenedAtThisLevel.complete()
						}
						_closeDialogs(e) {
							let i = e.length
							for (; i--; ) e[i].close()
						}
						static {
							this.ɵfac = function (i) {
								Am()
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				la = (() => {
					class t extends vge {
						constructor(e, i, r, o, s, a, c, l) {
							super(e, i, o, a, c, s, cL, pge, Bv, l), (this._idPrefix = "mat-mdc-dialog-")
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(ec), re(ks), re(x2, 8), re(Age, 8), re(g9), re(t, 12), re(OE), re(Bo, 8))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				yge = 0,
				md = (() => {
					class t {
						constructor(e, i, r) {
							;(this.dialogRef = e), (this._elementRef = i), (this._dialog = r), (this.type = "button")
						}
						ngOnInit() {
							this.dialogRef || (this.dialogRef = _9(this._elementRef, this._dialog.openDialogs))
						}
						ngOnChanges(e) {
							const i = e._matDialogClose || e._matDialogCloseResult
							i && (this.dialogResult = i.currentValue)
						}
						_onButtonClick(e) {
							A9(this.dialogRef, 0 === e.screenX && 0 === e.screenY ? "keyboard" : "mouse", this.dialogResult)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(cL, 8), P(wn), P(la))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [
									["", "mat-dialog-close", ""],
									["", "matDialogClose", ""]
								],
								hostVars: 2,
								hostBindings: function (i, r) {
									1 & i &&
										Le("click", function (s) {
											return r._onButtonClick(s)
										}),
										2 & i && qn("aria-label", r.ariaLabel || null)("type", r.type)
								},
								inputs: {
									ariaLabel: ["aria-label", "ariaLabel"],
									type: "type",
									dialogResult: ["mat-dialog-close", "dialogResult"],
									_matDialogClose: ["matDialogClose", "_matDialogClose"]
								},
								exportAs: ["matDialogClose"],
								features: [Ar]
							})
						}
					}
					return t
				})(),
				b9 = (() => {
					class t {
						constructor(e, i, r) {
							;(this._dialogRef = e), (this._elementRef = i), (this._dialog = r), (this.id = "mat-mdc-dialog-title-" + yge++)
						}
						ngOnInit() {
							this._dialogRef || (this._dialogRef = _9(this._elementRef, this._dialog.openDialogs)),
								this._dialogRef &&
									Promise.resolve().then(() => {
										this._dialogRef._containerInstance?._ariaLabelledByQueue?.push(this.id)
									})
						}
						ngOnDestroy() {
							const e = this._dialogRef?._containerInstance?._ariaLabelledByQueue
							e &&
								Promise.resolve().then(() => {
									const i = e.indexOf(this.id)
									i > -1 && e.splice(i, 1)
								})
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(cL, 8), P(wn), P(la))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [
									["", "mat-dialog-title", ""],
									["", "matDialogTitle", ""]
								],
								hostAttrs: [1, "mat-mdc-dialog-title", "mdc-dialog__title"],
								hostVars: 1,
								hostBindings: function (i, r) {
									2 & i && td("id", r.id)
								},
								inputs: { id: "id" },
								exportAs: ["matDialogTitle"]
							})
						}
					}
					return t
				})(),
				Hm = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "mat-dialog-content", ""], ["mat-dialog-content"], ["", "matDialogContent", ""]],
								hostAttrs: [1, "mat-mdc-dialog-content", "mdc-dialog__content"]
							})
						}
					}
					return t
				})(),
				Vm = (() => {
					class t {
						constructor() {
							this.align = "start"
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "mat-dialog-actions", ""], ["mat-dialog-actions"], ["", "matDialogActions", ""]],
								hostAttrs: [1, "mat-mdc-dialog-actions", "mdc-dialog__actions"],
								hostVars: 4,
								hostBindings: function (i, r) {
									2 & i &&
										Zt("mat-mdc-dialog-actions-align-center", "center" === r.align)(
											"mat-mdc-dialog-actions-align-end",
											"end" === r.align
										)
								},
								inputs: { align: "align" }
							})
						}
					}
					return t
				})()
			function _9(t, n) {
				let e = t.nativeElement.parentElement
				for (; e && !e.classList.contains("mat-mdc-dialog-container"); ) e = e.parentElement
				return e ? n.find(i => i.id === e.id) : null
			}
			let jE = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({ providers: [la, bge], imports: [zAe, Ev, wv, Yi, Yi] })
					}
				}
				return t
			})()
			const wge = ["mat-button", ""],
				xge = [
					[
						["", 8, "material-icons", 3, "iconPositionEnd", ""],
						["mat-icon", 3, "iconPositionEnd", ""],
						["", "matButtonIcon", "", 3, "iconPositionEnd", ""]
					],
					"*",
					[
						["", "iconPositionEnd", "", 8, "material-icons"],
						["mat-icon", "iconPositionEnd", ""],
						["", "matButtonIcon", "", "iconPositionEnd", ""]
					]
				],
				Cge = [
					".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])",
					"*",
					".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]"
				],
				Ege = [
					{ selector: "mat-button", mdcClasses: ["mdc-button", "mat-mdc-button"] },
					{ selector: "mat-flat-button", mdcClasses: ["mdc-button", "mdc-button--unelevated", "mat-mdc-unelevated-button"] },
					{ selector: "mat-raised-button", mdcClasses: ["mdc-button", "mdc-button--raised", "mat-mdc-raised-button"] },
					{ selector: "mat-stroked-button", mdcClasses: ["mdc-button", "mdc-button--outlined", "mat-mdc-outlined-button"] },
					{ selector: "mat-fab", mdcClasses: ["mdc-fab", "mat-mdc-fab"] },
					{ selector: "mat-mini-fab", mdcClasses: ["mdc-fab", "mdc-fab--mini", "mat-mdc-mini-fab"] },
					{ selector: "mat-icon-button", mdcClasses: ["mdc-icon-button", "mat-mdc-icon-button"] }
				],
				Mge = _g(
					Sv(
						Um(
							class {
								constructor(t) {
									this._elementRef = t
								}
							}
						)
					)
				)
			let Sge = (() => {
					class t extends Mge {
						get ripple() {
							return this._rippleLoader?.getRipple(this._elementRef.nativeElement)
						}
						set ripple(e) {
							this._rippleLoader?.attachRipple(this._elementRef.nativeElement, e)
						}
						get disableRipple() {
							return this._disableRipple
						}
						set disableRipple(e) {
							;(this._disableRipple = Mn(e)), this._updateRippleDisabled()
						}
						get disabled() {
							return this._disabled
						}
						set disabled(e) {
							;(this._disabled = Mn(e)), this._updateRippleDisabled()
						}
						constructor(e, i, r, o) {
							super(e),
								(this._platform = i),
								(this._ngZone = r),
								(this._animationMode = o),
								(this._focusMonitor = Rt(fd)),
								(this._rippleLoader = Rt(lge)),
								(this._isFab = !1),
								(this._disableRipple = !1),
								(this._disabled = !1),
								this._rippleLoader?.configureRipple(this._elementRef.nativeElement, { className: "mat-mdc-button-ripple" })
							const s = e.nativeElement.classList
							for (const a of Ege)
								this._hasHostAttributes(a.selector) &&
									a.mdcClasses.forEach(c => {
										s.add(c)
									})
						}
						ngAfterViewInit() {
							this._focusMonitor.monitor(this._elementRef, !0)
						}
						ngOnDestroy() {
							this._focusMonitor.stopMonitoring(this._elementRef)
						}
						focus(e = "program", i) {
							e ? this._focusMonitor.focusVia(this._elementRef.nativeElement, e, i) : this._elementRef.nativeElement.focus(i)
						}
						_hasHostAttributes(...e) {
							return e.some(i => this._elementRef.nativeElement.hasAttribute(i))
						}
						_updateRippleDisabled() {
							this._rippleLoader?.setDisabled(this._elementRef.nativeElement, this.disableRipple || this.disabled)
						}
						static {
							this.ɵfac = function (i) {
								Am()
							}
						}
						static {
							this.ɵdir = yt({ type: t, features: [pn] })
						}
					}
					return t
				})(),
				Qs = (() => {
					class t extends Sge {
						constructor(e, i, r, o) {
							super(e, i, r, o)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(Wr), P(mn), P(Bo, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [
									["button", "mat-button", ""],
									["button", "mat-raised-button", ""],
									["button", "mat-flat-button", ""],
									["button", "mat-stroked-button", ""]
								],
								hostVars: 7,
								hostBindings: function (i, r) {
									2 & i &&
										(qn("disabled", r.disabled || null),
										Zt("_mat-animation-noopable", "NoopAnimations" === r._animationMode)("mat-unthemed", !r.color)(
											"mat-mdc-button-base",
											!0
										))
								},
								inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" },
								exportAs: ["matButton"],
								features: [pn],
								attrs: wge,
								ngContentSelectors: Cge,
								decls: 7,
								vars: 4,
								consts: [
									[1, "mat-mdc-button-persistent-ripple"],
									[1, "mdc-button__label"],
									[1, "mat-mdc-focus-indicator"],
									[1, "mat-mdc-button-touch-target"]
								],
								template: function (i, r) {
									1 & i &&
										(co(xge),
										fe(0, "span", 0),
										Ln(1),
										F(2, "span", 1),
										Ln(3, 1),
										L(),
										Ln(4, 2),
										fe(5, "span", 2)(6, "span", 3)),
										2 & i && Zt("mdc-button__ripple", !r._isFab)("mdc-fab__ripple", r._isFab)
								},
								styles: [
									'.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%;line-height:initial}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}',
									".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				y9 = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Vh, Yi] })
						}
					}
					return t
				})(),
				yg = (() => {
					class t {
						constructor(e) {
							this.data = e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Bv))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["ng-component"]],
								decls: 6,
								vars: 2,
								consts: [
									["mat-dialog-title", ""],
									["mat-dialog-content", "", 3, "innerHTML"],
									["mat-dialog-actions", "", "align", "end"],
									["mat-button", "", "mat-dialog-close", ""]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "h1", 0), ge(1), L(), fe(2, "div", 1), F(3, "div", 2)(4, "button", 3), ge(5, "OK"), L()()),
										2 & i && (T(1), cr(r.data.title), T(1), U("innerHTML", r.data.message, $F))
								},
								dependencies: [Qs, md, b9, Hm, Vm],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function Fge(t) {
				return { title: "Something is wrong with the loaded file(s)", message: [...Bge(t), ...Ige(t)].join("") }
			}
			function Bge(t) {
				const n = t.filter(e => e.errors.length > 0)
				return n.length > 0
					? [
							"<h2>Errors</h2>",
							...n.map(e =>
								(function Dge(t) {
									return `<p><strong>${t.fileName}:</strong> ${lL(
										'<i class="fa fa-exclamation-circle"></i> ',
										t.errors
									)}</p>`
								})(e)
							)
					  ]
					: []
			}
			function Ige(t) {
				const n = t.filter(e => e.warnings.length > 0)
				return n.length > 0
					? [
							"<h2>Warnings</h2>",
							...n.map(e =>
								(function Lge(t) {
									return `<p><strong>${t.fileName}:</strong> ${lL(
										'<i class="fa fa-exclamation-triangle"></i> ',
										t.warnings
									)}</p>`
								})(e)
							)
					  ]
					: []
			}
			function lL(t, n) {
				return `<p>${n.map(e => t + e).join("<br>")}</p>`
			}
			var Rge = A(3233),
				w9 = A.n(Rge)
			const Iv = JSON.parse('{"i8":"1.124.2","sj":{"t":"1.3"}}'),
				Pge = JSON.parse(
					'{"$ref":"#/definitions/ExportCCFile","$schema":"http://json-schema.org/draft-07/schema#","definitions":{"AttributeTypes":{"properties":{"edges":{"additionalProperties":{"enum":["absolute","relative"],"type":"string"},"type":"object"},"nodes":{"additionalProperties":{"enum":["absolute","relative"],"type":"string"},"type":"object"}},"type":"object"},"CodeMapNode":{"properties":{"attributes":{"$ref":"#/definitions/KeyValuePair"},"children":{"items":{"$ref":"#/definitions/CodeMapNode"},"type":"array"},"deltas":{"additionalProperties":{"type":"number"},"type":"object"},"edgeAttributes":{"additionalProperties":{"$ref":"#/definitions/EdgeMetricCount"},"type":"object"},"fixedPosition":{"$ref":"#/definitions/FixedPosition"},"id":{"type":"number"},"isExcluded":{"type":"boolean"},"isFlattened":{"type":"boolean"},"link":{"type":"string"},"name":{"type":"string"},"path":{"type":"string"},"type":{"$ref":"#/definitions/NodeType"}},"required":["name","type"],"type":"object"},"Edge":{"properties":{"attributes":{"$ref":"#/definitions/KeyValuePair"},"fromNodeName":{"type":"string"},"toNodeName":{"type":"string"},"visible":{"$ref":"#/definitions/EdgeVisibility"}},"required":["attributes","fromNodeName","toNodeName"],"type":"object"},"EdgeMetricCount":{"properties":{"incoming":{"type":"number"},"outgoing":{"type":"number"}},"required":["incoming","outgoing"],"type":"object"},"EdgeVisibility":{"enum":["both","from","none","to"],"type":"string"},"ExportBlacklistItem":{"properties":{"path":{"type":"string"},"type":{"$ref":"#/definitions/ExportBlacklistType"}},"required":["path","type"],"type":"object"},"ExportBlacklistType":{"enum":["exclude","hide"],"type":"string"},"ExportCCFile":{"properties":{"apiVersion":{"type":"string"},"attributeTypes":{"anyOf":[{"$ref":"#/definitions/OldAttributeTypes"},{"$ref":"#/definitions/AttributeTypes"}]},"blacklist":{"items":{"$ref":"#/definitions/ExportBlacklistItem"},"type":"array"},"edges":{"items":{"$ref":"#/definitions/Edge"},"type":"array"},"markedPackages":{"items":{"$ref":"#/definitions/MarkedPackage"},"type":"array"},"nodes":{"items":{"$ref":"#/definitions/CodeMapNode"},"type":"array"},"projectName":{"type":"string"}},"required":["apiVersion","nodes","projectName"],"type":"object"},"FixedPosition":{"properties":{"height":{"type":"number"},"left":{"type":"number"},"top":{"type":"number"},"width":{"type":"number"}},"required":["height","left","top","width"],"type":"object"},"KeyValuePair":{"additionalProperties":{"type":"number"},"type":"object"},"MarkedPackage":{"properties":{"color":{"type":"string"},"path":{"type":"string"}},"required":["color","path"],"type":"object"},"NodeType":{"enum":["File","Folder"],"type":"string"},"OldAttributeTypes":{"properties":{"edges":{"additionalItems":{"anyOf":[{"additionalProperties":{"enum":["absolute","relative"],"type":"string"},"type":"object"}]},"items":[{"additionalProperties":{"enum":["absolute","relative"],"type":"string"},"type":"object"}],"minItems":0,"type":"array"},"nodes":{"additionalItems":{"anyOf":[{"additionalProperties":{"enum":["absolute","relative"],"type":"string"},"type":"object"}]},"items":[{"additionalProperties":{"enum":["absolute","relative"],"type":"string"},"type":"object"}],"minItems":0,"type":"array"}},"type":"object"}}}'
				),
				x9 = Iv.sj.t,
				pd = {
					fileIsInvalid: "File is empty or invalid.",
					apiVersionIsInvalid: "API Version is empty or invalid.",
					majorApiVersionIsOutdated: "API Version Outdated: Update CodeCharta API Version to match cc.json.",
					minorApiVersionOutdated: "Minor API Version Outdated.",
					nodesNotUnique: "Node names in combination with node types are not unique.",
					nodesEmpty: "The nodes array is empty. At least one node is required.",
					notAllFoldersAreFixed:
						"If at least one direct sub-folder of root is marked as fixed, all direct sub-folders of root must be fixed.",
					fixedFoldersOutOfBounds: "Coordinates of fixed folders must be within a range of 0 and 100.",
					fixedFoldersOverlapped: "Folders may not overlap.",
					fixedFoldersNotAllowed: "Fixated folders may not be defined in API-Version < 1.2.",
					fileAlreadyExists: "File already exists.",
					blacklistError: "Excluding all buildings is not possible."
				}
			function Oge(t) {
				const n = []
				return (
					t &&
						(function Qge(t) {
							return Dv(t.apiVersion).minor > Dv(x9).minor
						})(t) &&
						n.push(`${pd.minorApiVersionOutdated} Found: ${t.apiVersion}`),
					n
				)
			}
			function Nge(t) {
				const n = []
				switch (!0) {
					case !t:
						n.push(pd.fileIsInvalid)
						break
					case !(function Hge(t) {
						const { apiVersion: n } = t,
							e = void 0 !== n,
							r = /\d+\.\d+/.test(n)
						return e && r
					})(t):
						n.push(pd.apiVersionIsInvalid)
						break
					case (function Vge(t) {
						return Dv(t.apiVersion).major > Dv(x9).major
					})(t):
						n.push(pd.majorApiVersionIsOutdated)
				}
				return (
					0 === n.length &&
						n.push(
							...(function Uge(t) {
								const n = []
								if (0 === n.length) {
									const i = new (w9())({ allErrors: !0 }).compile(Pge)
									i(t)
										? 0 === t.nodes.length
											? n.push(pd.nodesEmpty)
											: n.push(
													...(function Gge(t) {
														const n = [],
															e = new Set()
														return e.add(`${t.name}|${t.type}`), C9(t, n, e, `/${t.name}`), n
													})(t.nodes[0]),
													...E9(t)
											  )
										: n.push(
												...i.errors.map(o =>
													(function zge(t) {
														return `${
															t.keyword.charAt(0).toUpperCase() + t.keyword.slice(1)
														} error: ${t.dataPath.slice(1)} ${t.message}`
													})(o)
												)
										  )
								}
								return n
							})(t)
						),
					n
				)
			}
			function Dv(t) {
				return { major: Number(t.split(".")[0]), minor: Number(t.split(".")[1]) }
			}
			function C9(t, n, e, i) {
				if (!uo(t))
					for (const r of t.children) {
						const o = `${i}/${r.name}`
						e.has(`${o}|${r.type}`)
							? n.push(`${pd.nodesNotUnique} Found duplicate of ${r.type} with path: ${o}`)
							: (e.add(`${o}|${r.type}`), C9(r, n, e, o))
					}
			}
			function E9(t, n = t.nodes[0].children) {
				const e = [],
					i = [],
					r = [],
					o = new Set()
				;(function $ge(t, n, e, i, r, o) {
					for (const s of t)
						if (void 0 === s.fixedPosition) n.push(`${s.name}`)
						else {
							const a = Dv(e.apiVersion)
							if (a.major < 1 || (1 === a.major && a.minor < 2))
								return void i.push(`${pd.fixedFoldersNotAllowed} Found: ${e.apiVersion}`)
							jge(s) && r.push(Lv(s))
							for (const c of t)
								void 0 !== c.fixedPosition &&
									s !== c &&
									Wge(s.fixedPosition, c.fixedPosition) &&
									!o.has(`${Lv(c)} and ${Lv(s)}`) &&
									o.add(`${Lv(s)} and ${Lv(c)}`)
						}
				})(n, i, t, e, r, o),
					i.length > 0 && i.length !== n.length && e.push(`${pd.notAllFoldersAreFixed} Found: ${i.join(", ")}`),
					r.length > 0 && e.push(`${pd.fixedFoldersOutOfBounds} Found: ${r.join(", ")}`),
					o.size > 0 && e.push(`${pd.fixedFoldersOverlapped} Found: ${[...o].join(", ")}`)
				for (const s of n) s.children && e.push(...E9(t, s.children))
				return e
			}
			function Lv(t) {
				return `${t.name} ${JSON.stringify(t.fixedPosition)}`
			}
			function Wge(t, n) {
				return (
					KE(t.left, t.top, n) ||
					KE(t.left, t.top + t.height, n) ||
					KE(t.left + t.width, t.top, n) ||
					KE(t.left + t.width, t.top + t.height, n)
				)
			}
			function KE(t, n, e) {
				return t >= e.left && t <= e.left + e.width && n >= e.top && n <= e.top + e.height
			}
			function jge({ fixedPosition: { left: t, top: n, width: e, height: i } }) {
				return t < 0 || n < 0 || t + e > 100 || n + i > 100 || e < 0 || i < 0
			}
			var Ad = (function (t) {
					return (t.SquarifiedTreeMap = "Squarified TreeMap"), (t.StreetMap = "StreetMap"), (t.TreeMapStreet = "TreeMapStreet"), t
				})(Ad || {}),
				Qm = (function (t) {
					return (t.Standard = "High"), (t.PixelRatioNoAA = "Low"), (t.PixelRatioFXAA = "Medium"), (t.PixelRatioAA = "Best"), t
				})(Qm || {}),
				Da = (function (t) {
					return (t.FILE = "File"), (t.FOLDER = "Folder"), t
				})(Da || {}),
				XE = (function (t) {
					return (t.NAME = "Name"), (t.NUMBER_OF_FILES = "Number of Files"), t
				})(XE || {}),
				zh = (function (t) {
					return (t.absolute = "absolute"), (t.relative = "relative"), t
				})(zh || {}),
				Rv = (function (t) {
					return (
						(t.trueGradient = "trueGradient"),
						(t.weightedGradient = "weightedGradient"),
						(t.focusedGradient = "focusedGradient"),
						(t.absolute = "absolute"),
						t
					)
				})(Rv || {}),
				gd = (function (t) {
					return (t.none = "none"), (t.from = "from"), (t.to = "to"), (t.both = "both"), t
				})(gd || {})
			function YE(t, n) {
				return n instanceof Map
					? { dataType: "Map", value: [...n.entries()] }
					: n instanceof Set
					? { dataType: "Set", value: [...n] }
					: n
			}
			function M9(t, n) {
				return "Map" === n?.dataType ? new Map(n.value) : "Set" === n?.dataType ? new Set(n.value) : n
			}
			const dL = {
				decorateMap(t, n, e) {
					for (const { data: i } of $r(t)) {
						;(i.isFlattened = !1), (i.isExcluded = !1)
						for (const r of e)
							"flatten" === r.type
								? (i.isFlattened = i.isFlattened || aG(i, r.path))
								: (i.isExcluded = i.isExcluded || (aG(i, r.path) && uo(i)))
					}
					;(t.isExcluded = !1), this.decorateMapWithMetricData(t, n)
				},
				decorateMapWithMetricData(t, n) {
					const { nodeMetricData: e, edgeMetricData: i } = n
					let r = 0
					for (const { data: o } of $r(t)) {
						;(o.id = r), r++, void 0 === o.attributes && (o.attributes = {}), uo(o) && (o.attributes[xE] = 1)
						for (const s of e)
							void 0 === o.attributes[s.name] && (o.attributes[s.name] = 0),
								void 0 !== o.deltas && void 0 === o.deltas[s.name] && (o.deltas[s.name] = 0)
						void 0 === o.edgeAttributes && (o.edgeAttributes = {})
						for (const s of i) void 0 === o.edgeAttributes[s.name] && (o.edgeAttributes[s.name] = { incoming: 0, outgoing: 0 })
						Kge(o)
					}
				},
				decorateMapWithPathAttribute(t) {
					for (const n of $r(t.map)) n.data.path = n.parent ? `${n.parent.data.path}/${n.data.name}` : `/${n.data.name}`
					return t
				},
				decorateParentNodesWithAggregatedAttributes(t, n, e) {
					const i = new Map(),
						r = Object.keys(t.attributes),
						o = Object.keys(t.edgeAttributes)
					$r(t).eachAfter(function ({ data: a, parent: c }) {
						if (!a.isExcluded && c) {
							for (const l of r) {
								const u = `${l}${c.data.path}`
								e.nodes[l] === zh.relative
									? (Yge(i, `${l}${a.path}`, u, a, l, n), Xge(i, u, a, l, n))
									: ((c.data.attributes[l] += a.attributes[l]),
									  n &&
											c.data.deltas &&
											((c.data.deltas[l] = c.data.deltas[l] ?? 0), (c.data.deltas[l] += a.deltas[l] ?? 0)))
							}
							n &&
								c.data.fileCount &&
								((c.data.fileCount.added += a.fileCount.added),
								(c.data.fileCount.changed += a.fileCount.changed),
								(c.data.fileCount.removed += a.fileCount.removed))
							for (const l of o) {
								const d = a.edgeAttributes[l]
								if (!d) continue
								const u = `${l}${a.path}`,
									h = `${l}${c.data.path}`
								e.edges[l] === zh.relative
									? (k9(i, `INCOMING${u}`, `INCOMING${h}`, a, l, "incoming"),
									  k9(i, `OUTGOING${u}`, `OUTGOING${h}`, a, l, "outgoing"),
									  S9(i, `INCOMING${h}`, a, l, "incoming"),
									  S9(i, `OUTGOING${h}`, a, l, "outgoing"))
									: ((c.data.edgeAttributes[l].incoming += d.incoming), (c.data.edgeAttributes[l].outgoing += d.outgoing))
							}
						}
					})
					for (const s of o)
						e.edges[s] === zh.relative &&
							((t.edgeAttributes[s].incoming = zm(i.get(`INCOMING${s}${t.path}`))),
							(t.edgeAttributes[s].outgoing = zm(i.get(`OUTGOING${s}${t.path}`))))
					for (const s of r)
						e.nodes[s] === zh.relative &&
							((t.attributes[s] = zm(i.get(`MEDIAN${s}${t.path}`))),
							n && t.deltas && (t.deltas[s] = zm(i.get(`DELTA${s}${t.path}`))))
				}
			}
			function Kge(t) {
				if (
					(1 !== t.children?.length || !t.children[0]?.fixedPosition) &&
					1 === t.children?.length &&
					t.children[0].children?.length > 0
				) {
					const [n] = t.children
					;(t.children = n.children), (t.name += `/${n.name}`), (t.path += `/${n.name}`), n.link && (t.link = n.link)
				}
			}
			function S9(t, n, e, i, r) {
				0 !== e.edgeAttributes[i][r] && hL(t, n, e, e.edgeAttributes[i][r])
			}
			function Xge(t, n, e, i, r) {
				0 !== e.attributes[i] && hL(t, `MEDIAN${n}`, e, e.attributes[i]),
					r && e.deltas && 0 !== e.deltas[i] && hL(t, `DELTA${n}`, e, e.deltas[i])
			}
			function Yge(t, n, e, i, r, o) {
				if (uo(i)) return
				const s = t.get(`MEDIAN${n}`)
				if ((void 0 !== s && ((i.attributes[r] = zm(s)), uL(t, `MEDIAN${e}`, s)), o && i.deltas)) {
					const a = t.get(`DELTA${n}`)
					void 0 !== a && ((i.deltas[r] = zm(a)), uL(t, `DELTA${e}`, a))
				}
			}
			function k9(t, n, e, i, r, o) {
				if (uo(i)) return
				const s = t.get(n)
				void 0 !== s && ((i.edgeAttributes[r][o] = zm(s)), uL(t, e, s))
			}
			function uL(t, n, e) {
				const i = t.get(n)
				void 0 === i
					? t.set(n, e)
					: (function Zge(t, n) {
							let e = 0
							for (let i = 0; i < t.length; i++) {
								let r = 0
								for (; t[i] > n[e] && (r++, e++, e !== n.length); );
								if (r > 0 && (t.splice(i, 0, ...n.slice(e - r, e)), e === n.length)) return
							}
							t.push(...n.slice(e))
					  })(i, e)
			}
			function hL(t, n, e, i) {
				const r = t.get(n)
				void 0 === r
					? t.set(n, [i])
					: uo(e) &&
					  (function qge(t, n) {
							let e = 0,
								i = t.length - 1,
								r = 0
							if (i < 0 || t[i] <= n) t.push(n)
							else if (t[0] >= n) t.unshift(n)
							else
								for (; e <= i; )
									if (((r = Math.floor((e + i) / 2)), t[r] < n)) e = r + 1
									else if (((i = r - 1), t[i] <= n)) return void t.splice(r, 0, n)
					  })(r, i)
			}
			function zm(t) {
				if (void 0 === t || 0 === t.length) return 0
				const n = (t.length - 1) / 2
				return (t[Math.floor(n)] + t[Math.ceil(n)]) / 2
			}
			function T9(t) {
				return { fileName: t.fileMeta.fileName, fileSize: t.fileMeta.exportedFileSize, content: Jge(t) }
			}
			function Jge(t) {
				return {
					projectName: t.fileMeta.projectName,
					apiVersion: t.fileMeta.apiVersion,
					fileChecksum: t.fileMeta.fileChecksum,
					nodes: [t.map],
					attributeTypes: t.settings.fileSettings.attributeTypes,
					attributeDescriptors: t.settings.fileSettings.attributeDescriptors,
					edges: t.settings.fileSettings.edges,
					markedPackages: t.settings.fileSettings.markedPackages,
					blacklist: t.settings.fileSettings.blacklist.map(n => {
						switch (n.type) {
							case "flatten":
								return { path: n.path, type: "hide" }
							case "exclude":
								return { path: n.path, type: n.type }
						}
					})
				}
			}
			function tbe(t, n, e) {
				const i = (function Qme(t) {
					const n = t.content
					return {
						fileMeta: {
							fileName: t.fileName,
							fileChecksum: n.fileChecksum,
							projectName: n.projectName,
							apiVersion: n.apiVersion,
							exportedFileSize: t.fileSize,
							repoCreationDate: n.repoCreationDate || ""
						},
						settings: {
							fileSettings: {
								edges: n.edges || [],
								attributeTypes: zme(n.attributeTypes),
								attributeDescriptors: Gme(n.attributeDescriptors),
								blacklist: $me(n.blacklist || []),
								markedPackages: n.markedPackages || []
							}
						},
						map: dd(n.nodes[0])
					}
				})(e)
				dL.decorateMapWithPathAttribute(i)
				const r = i.fileMeta.fileChecksum
				let o = i.fileMeta.fileName
				const s = new Map(t.map(l => [l.file.fileMeta.fileName, l.file.fileMeta.fileChecksum])),
					a = new Map(t.map((l, d) => [l.file.fileMeta.fileChecksum, d])),
					c = a.has(r)
				if (
					(s.has(o) &&
						((o = (function nbe(t, n, e) {
							if (n.get(t) === e) return t
							let i = !1,
								r = 1,
								o = t
							for (; !i; ) {
								const s = t.indexOf(".")
								;(o = s >= 0 ? [t.slice(0, s), "_", r, t.slice(s)].join("") : `${t}_${r}`),
									(n.get(o) === e || !n.has(o)) && (i = !0),
									r++
							}
							return o
						})(o, s, r)),
						(i.fileMeta.fileName = o)),
					c)
				)
					return (t[a.get(r)].file.fileMeta.fileName = o), (n[0] = o), void n.push(o)
				t.push({ file: i, selectedAs: Fi.None }), n.push(o)
			}
			const F9 = Mt(_u, t => t.find(n => n.selectedAs === Fi.Reference)?.file),
				bd = {
					rootName: "root",
					rootPath: "/root",
					updateRoot(t) {
						;(this.rootName = t), (this.rootPath = `/${t}`)
					}
				},
				fL = "File(s) could not be loaded"
			let wg = (() => {
				class t {
					static {
						this.CC_FILE_EXTENSION = ".cc.json"
					}
					constructor(e, i, r) {
						;(this.store = e),
							(this.state = i),
							(this.dialog = r),
							(this.referenceFileSubscription = this.store
								.select(F9)
								.pipe(
									eo(o => {
										o && bd.updateRoot(o.map.name)
									})
								)
								.subscribe())
					}
					ngOnDestroy() {
						this.referenceFileSubscription.unsubscribe()
					}
					loadFiles(e) {
						const i = dd(this.state.getValue().files),
							r = [],
							o = []
						if (
							((function ebe(t, n, e, i) {
								for (const r of e) {
									const o = { fileName: r?.fileName, errors: [], warnings: [] }
									o.errors.push(...Nge(r?.content)),
										0 === o.errors.length && (o.warnings.push(...Oge(r?.content)), tbe(t, n, r)),
										(o.errors.length > 0 || o.warnings.length > 0) && i.push(o)
								}
							})(i, r, e, o),
							o.length > 0 && this.dialog.open(yg, { data: Fge(o) }),
							0 === r.length)
						)
							throw new Error(fL)
						this.store.dispatch(mv({ value: i }))
						const s = r[0],
							a = this.state.getValue().files.find(c => c.file.fileMeta.fileName === s).file.map.name
						this.store.dispatch(CD({ fileNames: r })), bd.updateRoot(a)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Ct), re(Sr), re(la))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			const mL = m(
				t =>
					function () {
						t(this), (this.name = "EmptyError"), (this.message = "no elements in sequence")
					}
			)
			function B9(t, n) {
				const e = "object" == typeof n
				return new Promise((i, r) => {
					const o = new st({
						next: s => {
							i(s), o.unsubscribe()
						},
						error: r,
						complete: () => {
							e ? i(n.defaultValue) : r(new mL())
						}
					})
					t.subscribe(o)
				})
			}
			function xg(t) {
				let n = t.length
				for (; --n >= 0; ) t[n] = 0
			}
			const _L = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
				qE = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
				dbe = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
				U9 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
				Su = new Array(576)
			xg(Su)
			const Nv = new Array(60)
			xg(Nv)
			const Uv = new Array(512)
			xg(Uv)
			const Hv = new Array(256)
			xg(Hv)
			const vL = new Array(29)
			xg(vL)
			const ZE = new Array(30)
			function yL(t, n, e, i, r) {
				;(this.static_tree = t),
					(this.extra_bits = n),
					(this.extra_base = e),
					(this.elems = i),
					(this.max_length = r),
					(this.has_stree = t && t.length)
			}
			let H9, V9, Q9
			function wL(t, n) {
				;(this.dyn_tree = t), (this.max_code = 0), (this.stat_desc = n)
			}
			xg(ZE)
			const z9 = t => (t < 256 ? Uv[t] : Uv[256 + (t >>> 7)]),
				Vv = (t, n) => {
					;(t.pending_buf[t.pending++] = 255 & n), (t.pending_buf[t.pending++] = (n >>> 8) & 255)
				},
				La = (t, n, e) => {
					t.bi_valid > 16 - e
						? ((t.bi_buf |= (n << t.bi_valid) & 65535),
						  Vv(t, t.bi_buf),
						  (t.bi_buf = n >> (16 - t.bi_valid)),
						  (t.bi_valid += e - 16))
						: ((t.bi_buf |= (n << t.bi_valid) & 65535), (t.bi_valid += e))
				},
				_d = (t, n, e) => {
					La(t, e[2 * n], e[2 * n + 1])
				},
				G9 = (t, n) => {
					let e = 0
					do {
						;(e |= 1 & t), (t >>>= 1), (e <<= 1)
					} while (--n > 0)
					return e >>> 1
				},
				$9 = (t, n, e) => {
					const i = new Array(16)
					let o,
						s,
						r = 0
					for (o = 1; o <= 15; o++) (r = (r + e[o - 1]) << 1), (i[o] = r)
					for (s = 0; s <= n; s++) {
						let a = t[2 * s + 1]
						0 !== a && (t[2 * s] = G9(i[a]++, a))
					}
				},
				W9 = t => {
					let n
					for (n = 0; n < 286; n++) t.dyn_ltree[2 * n] = 0
					for (n = 0; n < 30; n++) t.dyn_dtree[2 * n] = 0
					for (n = 0; n < 19; n++) t.bl_tree[2 * n] = 0
					;(t.dyn_ltree[512] = 1), (t.opt_len = t.static_len = 0), (t.sym_next = t.matches = 0)
				},
				j9 = t => {
					t.bi_valid > 8 ? Vv(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf),
						(t.bi_buf = 0),
						(t.bi_valid = 0)
				},
				K9 = (t, n, e, i) => {
					const r = 2 * n,
						o = 2 * e
					return t[r] < t[o] || (t[r] === t[o] && i[n] <= i[e])
				},
				xL = (t, n, e) => {
					const i = t.heap[e]
					let r = e << 1
					for (
						;
						r <= t.heap_len &&
						(r < t.heap_len && K9(n, t.heap[r + 1], t.heap[r], t.depth) && r++, !K9(n, i, t.heap[r], t.depth));

					)
						(t.heap[e] = t.heap[r]), (e = r), (r <<= 1)
					t.heap[e] = i
				},
				X9 = (t, n, e) => {
					let i,
						r,
						s,
						a,
						o = 0
					if (0 !== t.sym_next)
						do {
							;(i = 255 & t.pending_buf[t.sym_buf + o++]),
								(i += (255 & t.pending_buf[t.sym_buf + o++]) << 8),
								(r = t.pending_buf[t.sym_buf + o++]),
								0 === i
									? _d(t, r, n)
									: ((s = Hv[r]),
									  _d(t, s + 256 + 1, n),
									  (a = _L[s]),
									  0 !== a && ((r -= vL[s]), La(t, r, a)),
									  i--,
									  (s = z9(i)),
									  _d(t, s, e),
									  (a = qE[s]),
									  0 !== a && ((i -= ZE[s]), La(t, i, a)))
						} while (o < t.sym_next)
					_d(t, 256, n)
				},
				CL = (t, n) => {
					const e = n.dyn_tree,
						i = n.stat_desc.static_tree,
						r = n.stat_desc.has_stree,
						o = n.stat_desc.elems
					let s,
						a,
						l,
						c = -1
					for (t.heap_len = 0, t.heap_max = 573, s = 0; s < o; s++)
						0 !== e[2 * s] ? ((t.heap[++t.heap_len] = c = s), (t.depth[s] = 0)) : (e[2 * s + 1] = 0)
					for (; t.heap_len < 2; )
						(l = t.heap[++t.heap_len] = c < 2 ? ++c : 0),
							(e[2 * l] = 1),
							(t.depth[l] = 0),
							t.opt_len--,
							r && (t.static_len -= i[2 * l + 1])
					for (n.max_code = c, s = t.heap_len >> 1; s >= 1; s--) xL(t, e, s)
					l = o
					do {
						;(s = t.heap[1]),
							(t.heap[1] = t.heap[t.heap_len--]),
							xL(t, e, 1),
							(a = t.heap[1]),
							(t.heap[--t.heap_max] = s),
							(t.heap[--t.heap_max] = a),
							(e[2 * l] = e[2 * s] + e[2 * a]),
							(t.depth[l] = (t.depth[s] >= t.depth[a] ? t.depth[s] : t.depth[a]) + 1),
							(e[2 * s + 1] = e[2 * a + 1] = l),
							(t.heap[1] = l++),
							xL(t, e, 1)
					} while (t.heap_len >= 2)
					;(t.heap[--t.heap_max] = t.heap[1]),
						((t, n) => {
							const e = n.dyn_tree,
								i = n.max_code,
								r = n.stat_desc.static_tree,
								o = n.stat_desc.has_stree,
								s = n.stat_desc.extra_bits,
								a = n.stat_desc.extra_base,
								c = n.stat_desc.max_length
							let l,
								d,
								u,
								h,
								f,
								_,
								y = 0
							for (h = 0; h <= 15; h++) t.bl_count[h] = 0
							for (e[2 * t.heap[t.heap_max] + 1] = 0, l = t.heap_max + 1; l < 573; l++)
								(d = t.heap[l]),
									(h = e[2 * e[2 * d + 1] + 1] + 1),
									h > c && ((h = c), y++),
									(e[2 * d + 1] = h),
									!(d > i) &&
										(t.bl_count[h]++,
										(f = 0),
										d >= a && (f = s[d - a]),
										(_ = e[2 * d]),
										(t.opt_len += _ * (h + f)),
										o && (t.static_len += _ * (r[2 * d + 1] + f)))
							if (0 !== y) {
								do {
									for (h = c - 1; 0 === t.bl_count[h]; ) h--
									t.bl_count[h]--, (t.bl_count[h + 1] += 2), t.bl_count[c]--, (y -= 2)
								} while (y > 0)
								for (h = c; 0 !== h; h--)
									for (d = t.bl_count[h]; 0 !== d; )
										(u = t.heap[--l]),
											!(u > i) &&
												(e[2 * u + 1] !== h && ((t.opt_len += (h - e[2 * u + 1]) * e[2 * u]), (e[2 * u + 1] = h)),
												d--)
							}
						})(t, n),
						$9(e, c, t.bl_count)
				},
				Y9 = (t, n, e) => {
					let i,
						o,
						r = -1,
						s = n[1],
						a = 0,
						c = 7,
						l = 4
					for (0 === s && ((c = 138), (l = 3)), n[2 * (e + 1) + 1] = 65535, i = 0; i <= e; i++)
						(o = s),
							(s = n[2 * (i + 1) + 1]),
							!(++a < c && o === s) &&
								(a < l
									? (t.bl_tree[2 * o] += a)
									: 0 !== o
									? (o !== r && t.bl_tree[2 * o]++, t.bl_tree[32]++)
									: a <= 10
									? t.bl_tree[34]++
									: t.bl_tree[36]++,
								(a = 0),
								(r = o),
								0 === s ? ((c = 138), (l = 3)) : o === s ? ((c = 6), (l = 3)) : ((c = 7), (l = 4)))
				},
				q9 = (t, n, e) => {
					let i,
						o,
						r = -1,
						s = n[1],
						a = 0,
						c = 7,
						l = 4
					for (0 === s && ((c = 138), (l = 3)), i = 0; i <= e; i++)
						if (((o = s), (s = n[2 * (i + 1) + 1]), !(++a < c && o === s))) {
							if (a < l)
								do {
									_d(t, o, t.bl_tree)
								} while (0 != --a)
							else
								0 !== o
									? (o !== r && (_d(t, o, t.bl_tree), a--), _d(t, 16, t.bl_tree), La(t, a - 3, 2))
									: a <= 10
									? (_d(t, 17, t.bl_tree), La(t, a - 3, 3))
									: (_d(t, 18, t.bl_tree), La(t, a - 11, 7))
							;(a = 0), (r = o), 0 === s ? ((c = 138), (l = 3)) : o === s ? ((c = 6), (l = 3)) : ((c = 7), (l = 4))
						}
				}
			let Z9 = !1
			const J9 = (t, n, e, i) => {
				La(t, 0 + (i ? 1 : 0), 3),
					j9(t),
					Vv(t, e),
					Vv(t, ~e),
					e && t.pending_buf.set(t.window.subarray(n, n + e), t.pending),
					(t.pending += e)
			}
			var Sbe = {
					_tr_init: t => {
						Z9 ||
							((() => {
								let t, n, e, i, r
								const o = new Array(16)
								for (e = 0, i = 0; i < 28; i++) for (vL[i] = e, t = 0; t < 1 << _L[i]; t++) Hv[e++] = i
								for (Hv[e - 1] = i, r = 0, i = 0; i < 16; i++) for (ZE[i] = r, t = 0; t < 1 << qE[i]; t++) Uv[r++] = i
								for (r >>= 7; i < 30; i++) for (ZE[i] = r << 7, t = 0; t < 1 << (qE[i] - 7); t++) Uv[256 + r++] = i
								for (n = 0; n <= 15; n++) o[n] = 0
								for (t = 0; t <= 143; ) (Su[2 * t + 1] = 8), t++, o[8]++
								for (; t <= 255; ) (Su[2 * t + 1] = 9), t++, o[9]++
								for (; t <= 279; ) (Su[2 * t + 1] = 7), t++, o[7]++
								for (; t <= 287; ) (Su[2 * t + 1] = 8), t++, o[8]++
								for ($9(Su, 287, o), t = 0; t < 30; t++) (Nv[2 * t + 1] = 5), (Nv[2 * t] = G9(t, 5))
								;(H9 = new yL(Su, _L, 257, 286, 15)),
									(V9 = new yL(Nv, qE, 0, 30, 15)),
									(Q9 = new yL(new Array(0), dbe, 0, 19, 7))
							})(),
							(Z9 = !0)),
							(t.l_desc = new wL(t.dyn_ltree, H9)),
							(t.d_desc = new wL(t.dyn_dtree, V9)),
							(t.bl_desc = new wL(t.bl_tree, Q9)),
							(t.bi_buf = 0),
							(t.bi_valid = 0),
							W9(t)
					},
					_tr_stored_block: J9,
					_tr_flush_block: (t, n, e, i) => {
						let r,
							o,
							s = 0
						t.level > 0
							? (2 === t.strm.data_type &&
									(t.strm.data_type = (t => {
										let e,
											n = 4093624447
										for (e = 0; e <= 31; e++, n >>>= 1) if (1 & n && 0 !== t.dyn_ltree[2 * e]) return 0
										if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1
										for (e = 32; e < 256; e++) if (0 !== t.dyn_ltree[2 * e]) return 1
										return 0
									})(t)),
							  CL(t, t.l_desc),
							  CL(t, t.d_desc),
							  (s = (t => {
									let n
									for (
										Y9(t, t.dyn_ltree, t.l_desc.max_code),
											Y9(t, t.dyn_dtree, t.d_desc.max_code),
											CL(t, t.bl_desc),
											n = 18;
										n >= 3 && 0 === t.bl_tree[2 * U9[n] + 1];
										n--
									);
									return (t.opt_len += 3 * (n + 1) + 5 + 5 + 4), n
							  })(t)),
							  (r = (t.opt_len + 3 + 7) >>> 3),
							  (o = (t.static_len + 3 + 7) >>> 3),
							  o <= r && (r = o))
							: (r = o = e + 5),
							e + 4 <= r && -1 !== n
								? J9(t, n, e, i)
								: 4 === t.strategy || o === r
								? (La(t, 2 + (i ? 1 : 0), 3), X9(t, Su, Nv))
								: (La(t, 4 + (i ? 1 : 0), 3),
								  ((t, n, e, i) => {
										let r
										for (La(t, n - 257, 5), La(t, e - 1, 5), La(t, i - 4, 4), r = 0; r < i; r++)
											La(t, t.bl_tree[2 * U9[r] + 1], 3)
										q9(t, t.dyn_ltree, n - 1), q9(t, t.dyn_dtree, e - 1)
								  })(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1),
								  X9(t, t.dyn_ltree, t.dyn_dtree)),
							W9(t),
							i && j9(t)
					},
					_tr_tally: (t, n, e) => (
						(t.pending_buf[t.sym_buf + t.sym_next++] = n),
						(t.pending_buf[t.sym_buf + t.sym_next++] = n >> 8),
						(t.pending_buf[t.sym_buf + t.sym_next++] = e),
						0 === n ? t.dyn_ltree[2 * e]++ : (t.matches++, n--, t.dyn_ltree[2 * (Hv[e] + 256 + 1)]++, t.dyn_dtree[2 * z9(n)]++),
						t.sym_next === t.sym_end
					),
					_tr_align: t => {
						La(t, 2, 3),
							_d(t, 256, Su),
							(t => {
								16 === t.bi_valid
									? (Vv(t, t.bi_buf), (t.bi_buf = 0), (t.bi_valid = 0))
									: t.bi_valid >= 8 &&
									  ((t.pending_buf[t.pending++] = 255 & t.bi_buf), (t.bi_buf >>= 8), (t.bi_valid -= 8))
							})(t)
					}
				},
				Qv = (t, n, e, i) => {
					let r = (65535 & t) | 0,
						o = ((t >>> 16) & 65535) | 0,
						s = 0
					for (; 0 !== e; ) {
						;(s = e > 2e3 ? 2e3 : e), (e -= s)
						do {
							;(r = (r + n[i++]) | 0), (o = (o + r) | 0)
						} while (--s)
						;(r %= 65521), (o %= 65521)
					}
					return r | (o << 16) | 0
				}
			const Tbe = new Uint32Array(
				(() => {
					let t,
						n = []
					for (var e = 0; e < 256; e++) {
						t = e
						for (var i = 0; i < 8; i++) t = 1 & t ? 3988292384 ^ (t >>> 1) : t >>> 1
						n[e] = t
					}
					return n
				})()
			)
			var hs = (t, n, e, i) => {
					const r = Tbe,
						o = i + e
					t ^= -1
					for (let s = i; s < o; s++) t = (t >>> 8) ^ r[255 & (t ^ n[s])]
					return -1 ^ t
				},
				$m = {
					2: "need dictionary",
					1: "stream end",
					0: "",
					"-1": "file error",
					"-2": "stream error",
					"-3": "data error",
					"-4": "insufficient memory",
					"-5": "buffer error",
					"-6": "incompatible version"
				},
				Wm = {
					Z_NO_FLUSH: 0,
					Z_PARTIAL_FLUSH: 1,
					Z_SYNC_FLUSH: 2,
					Z_FULL_FLUSH: 3,
					Z_FINISH: 4,
					Z_BLOCK: 5,
					Z_TREES: 6,
					Z_OK: 0,
					Z_STREAM_END: 1,
					Z_NEED_DICT: 2,
					Z_ERRNO: -1,
					Z_STREAM_ERROR: -2,
					Z_DATA_ERROR: -3,
					Z_MEM_ERROR: -4,
					Z_BUF_ERROR: -5,
					Z_NO_COMPRESSION: 0,
					Z_BEST_SPEED: 1,
					Z_BEST_COMPRESSION: 9,
					Z_DEFAULT_COMPRESSION: -1,
					Z_FILTERED: 1,
					Z_HUFFMAN_ONLY: 2,
					Z_RLE: 3,
					Z_FIXED: 4,
					Z_DEFAULT_STRATEGY: 0,
					Z_BINARY: 0,
					Z_TEXT: 1,
					Z_UNKNOWN: 2,
					Z_DEFLATED: 8
				}
			const { _tr_init: Fbe, _tr_stored_block: EL, _tr_flush_block: Bbe, _tr_tally: Gh, _tr_align: Ibe } = Sbe,
				{
					Z_NO_FLUSH: $h,
					Z_PARTIAL_FLUSH: Dbe,
					Z_FULL_FLUSH: Lbe,
					Z_FINISH: Oc,
					Z_BLOCK: e$,
					Z_OK: Bs,
					Z_STREAM_END: t$,
					Z_STREAM_ERROR: vd,
					Z_DATA_ERROR: Rbe,
					Z_BUF_ERROR: ML,
					Z_DEFAULT_COMPRESSION: Pbe,
					Z_FILTERED: Obe,
					Z_HUFFMAN_ONLY: JE,
					Z_RLE: Nbe,
					Z_FIXED: Ube,
					Z_DEFAULT_STRATEGY: Hbe,
					Z_UNKNOWN: Vbe,
					Z_DEFLATED: eM
				} = Wm,
				yd = 262,
				Xm = (t, n) => ((t.msg = $m[n]), n),
				n$ = t => 2 * t - (t > 4 ? 9 : 0),
				jh = t => {
					let n = t.length
					for (; --n >= 0; ) t[n] = 0
				},
				Zbe = t => {
					let n,
						e,
						i,
						r = t.w_size
					;(n = t.hash_size), (i = n)
					do {
						;(e = t.head[--i]), (t.head[i] = e >= r ? e - r : 0)
					} while (--n)
					;(n = r), (i = n)
					do {
						;(e = t.prev[--i]), (t.prev[i] = e >= r ? e - r : 0)
					} while (--n)
				}
			let Kh = (t, n, e) => ((n << t.hash_shift) ^ e) & t.hash_mask
			const nc = t => {
					const n = t.state
					let e = n.pending
					e > t.avail_out && (e = t.avail_out),
						0 !== e &&
							(t.output.set(n.pending_buf.subarray(n.pending_out, n.pending_out + e), t.next_out),
							(t.next_out += e),
							(n.pending_out += e),
							(t.total_out += e),
							(t.avail_out -= e),
							(n.pending -= e),
							0 === n.pending && (n.pending_out = 0))
				},
				ic = (t, n) => {
					Bbe(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, n), (t.block_start = t.strstart), nc(t.strm)
				},
				sr = (t, n) => {
					t.pending_buf[t.pending++] = n
				},
				Gv = (t, n) => {
					;(t.pending_buf[t.pending++] = (n >>> 8) & 255), (t.pending_buf[t.pending++] = 255 & n)
				},
				DL = (t, n, e, i) => {
					let r = t.avail_in
					return (
						r > i && (r = i),
						0 === r
							? 0
							: ((t.avail_in -= r),
							  n.set(t.input.subarray(t.next_in, t.next_in + r), e),
							  1 === t.state.wrap
									? (t.adler = Qv(t.adler, n, r, e))
									: 2 === t.state.wrap && (t.adler = hs(t.adler, n, r, e)),
							  (t.next_in += r),
							  (t.total_in += r),
							  r)
					)
				},
				i$ = (t, n) => {
					let r,
						o,
						e = t.max_chain_length,
						i = t.strstart,
						s = t.prev_length,
						a = t.nice_match
					const c = t.strstart > t.w_size - yd ? t.strstart - (t.w_size - yd) : 0,
						l = t.window,
						d = t.w_mask,
						u = t.prev,
						h = t.strstart + 258
					let f = l[i + s - 1],
						_ = l[i + s]
					t.prev_length >= t.good_match && (e >>= 2), a > t.lookahead && (a = t.lookahead)
					do {
						if (((r = n), l[r + s] === _ && l[r + s - 1] === f && l[r] === l[i] && l[++r] === l[i + 1])) {
							;(i += 2), r++
							do {} while (
								l[++i] === l[++r] &&
								l[++i] === l[++r] &&
								l[++i] === l[++r] &&
								l[++i] === l[++r] &&
								l[++i] === l[++r] &&
								l[++i] === l[++r] &&
								l[++i] === l[++r] &&
								l[++i] === l[++r] &&
								i < h
							)
							if (((o = 258 - (h - i)), (i = h - 258), o > s)) {
								if (((t.match_start = n), (s = o), o >= a)) break
								;(f = l[i + s - 1]), (_ = l[i + s])
							}
						}
					} while ((n = u[n & d]) > c && 0 != --e)
					return s <= t.lookahead ? s : t.lookahead
				},
				kg = t => {
					const n = t.w_size
					let e, i, r
					do {
						if (
							((i = t.window_size - t.lookahead - t.strstart),
							t.strstart >= n + (n - yd) &&
								(t.window.set(t.window.subarray(n, n + n - i), 0),
								(t.match_start -= n),
								(t.strstart -= n),
								(t.block_start -= n),
								t.insert > t.strstart && (t.insert = t.strstart),
								Zbe(t),
								(i += n)),
							0 === t.strm.avail_in)
						)
							break
						if (((e = DL(t.strm, t.window, t.strstart + t.lookahead, i)), (t.lookahead += e), t.lookahead + t.insert >= 3))
							for (
								r = t.strstart - t.insert, t.ins_h = t.window[r], t.ins_h = Kh(t, t.ins_h, t.window[r + 1]);
								t.insert &&
								((t.ins_h = Kh(t, t.ins_h, t.window[r + 3 - 1])),
								(t.prev[r & t.w_mask] = t.head[t.ins_h]),
								(t.head[t.ins_h] = r),
								r++,
								t.insert--,
								!(t.lookahead + t.insert < 3));

							);
					} while (t.lookahead < yd && 0 !== t.strm.avail_in)
				},
				r$ = (t, n) => {
					let i,
						r,
						o,
						e = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5,
						s = 0,
						a = t.strm.avail_in
					do {
						if (
							((i = 65535),
							(o = (t.bi_valid + 42) >> 3),
							t.strm.avail_out < o ||
								((o = t.strm.avail_out - o),
								(r = t.strstart - t.block_start),
								i > r + t.strm.avail_in && (i = r + t.strm.avail_in),
								i > o && (i = o),
								i < e && ((0 === i && n !== Oc) || n === $h || i !== r + t.strm.avail_in)))
						)
							break
						;(s = n === Oc && i === r + t.strm.avail_in ? 1 : 0),
							EL(t, 0, 0, s),
							(t.pending_buf[t.pending - 4] = i),
							(t.pending_buf[t.pending - 3] = i >> 8),
							(t.pending_buf[t.pending - 2] = ~i),
							(t.pending_buf[t.pending - 1] = ~i >> 8),
							nc(t.strm),
							r &&
								(r > i && (r = i),
								t.strm.output.set(t.window.subarray(t.block_start, t.block_start + r), t.strm.next_out),
								(t.strm.next_out += r),
								(t.strm.avail_out -= r),
								(t.strm.total_out += r),
								(t.block_start += r),
								(i -= r)),
							i &&
								(DL(t.strm, t.strm.output, t.strm.next_out, i),
								(t.strm.next_out += i),
								(t.strm.avail_out -= i),
								(t.strm.total_out += i))
					} while (0 === s)
					return (
						(a -= t.strm.avail_in),
						a &&
							(a >= t.w_size
								? ((t.matches = 2),
								  t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0),
								  (t.strstart = t.w_size),
								  (t.insert = t.strstart))
								: (t.window_size - t.strstart <= a &&
										((t.strstart -= t.w_size),
										t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0),
										t.matches < 2 && t.matches++,
										t.insert > t.strstart && (t.insert = t.strstart)),
								  t.window.set(t.strm.input.subarray(t.strm.next_in - a, t.strm.next_in), t.strstart),
								  (t.strstart += a),
								  (t.insert += a > t.w_size - t.insert ? t.w_size - t.insert : a)),
							(t.block_start = t.strstart)),
						t.high_water < t.strstart && (t.high_water = t.strstart),
						s
							? 4
							: n !== $h && n !== Oc && 0 === t.strm.avail_in && t.strstart === t.block_start
							? 2
							: ((o = t.window_size - t.strstart),
							  t.strm.avail_in > o &&
									t.block_start >= t.w_size &&
									((t.block_start -= t.w_size),
									(t.strstart -= t.w_size),
									t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0),
									t.matches < 2 && t.matches++,
									(o += t.w_size),
									t.insert > t.strstart && (t.insert = t.strstart)),
							  o > t.strm.avail_in && (o = t.strm.avail_in),
							  o &&
									(DL(t.strm, t.window, t.strstart, o),
									(t.strstart += o),
									(t.insert += o > t.w_size - t.insert ? t.w_size - t.insert : o)),
							  t.high_water < t.strstart && (t.high_water = t.strstart),
							  (o = (t.bi_valid + 42) >> 3),
							  (o = t.pending_buf_size - o > 65535 ? 65535 : t.pending_buf_size - o),
							  (e = o > t.w_size ? t.w_size : o),
							  (r = t.strstart - t.block_start),
							  (r >= e || ((r || n === Oc) && n !== $h && 0 === t.strm.avail_in && r <= o)) &&
									((i = r > o ? o : r),
									(s = n === Oc && 0 === t.strm.avail_in && i === r ? 1 : 0),
									EL(t, t.block_start, i, s),
									(t.block_start += i),
									nc(t.strm)),
							  s ? 3 : 1)
					)
				},
				LL = (t, n) => {
					let e, i
					for (;;) {
						if (t.lookahead < yd) {
							if ((kg(t), t.lookahead < yd && n === $h)) return 1
							if (0 === t.lookahead) break
						}
						if (
							((e = 0),
							t.lookahead >= 3 &&
								((t.ins_h = Kh(t, t.ins_h, t.window[t.strstart + 3 - 1])),
								(e = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
								(t.head[t.ins_h] = t.strstart)),
							0 !== e && t.strstart - e <= t.w_size - yd && (t.match_length = i$(t, e)),
							t.match_length >= 3)
						)
							if (
								((i = Gh(t, t.strstart - t.match_start, t.match_length - 3)),
								(t.lookahead -= t.match_length),
								t.match_length <= t.max_lazy_match && t.lookahead >= 3)
							) {
								t.match_length--
								do {
									t.strstart++,
										(t.ins_h = Kh(t, t.ins_h, t.window[t.strstart + 3 - 1])),
										(e = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
										(t.head[t.ins_h] = t.strstart)
								} while (0 != --t.match_length)
								t.strstart++
							} else
								(t.strstart += t.match_length),
									(t.match_length = 0),
									(t.ins_h = t.window[t.strstart]),
									(t.ins_h = Kh(t, t.ins_h, t.window[t.strstart + 1]))
						else (i = Gh(t, 0, t.window[t.strstart])), t.lookahead--, t.strstart++
						if (i && (ic(t, !1), 0 === t.strm.avail_out)) return 1
					}
					return (
						(t.insert = t.strstart < 2 ? t.strstart : 2),
						n === Oc ? (ic(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (ic(t, !1), 0 === t.strm.avail_out) ? 1 : 2
					)
				},
				Tg = (t, n) => {
					let e, i, r
					for (;;) {
						if (t.lookahead < yd) {
							if ((kg(t), t.lookahead < yd && n === $h)) return 1
							if (0 === t.lookahead) break
						}
						if (
							((e = 0),
							t.lookahead >= 3 &&
								((t.ins_h = Kh(t, t.ins_h, t.window[t.strstart + 3 - 1])),
								(e = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
								(t.head[t.ins_h] = t.strstart)),
							(t.prev_length = t.match_length),
							(t.prev_match = t.match_start),
							(t.match_length = 2),
							0 !== e &&
								t.prev_length < t.max_lazy_match &&
								t.strstart - e <= t.w_size - yd &&
								((t.match_length = i$(t, e)),
								t.match_length <= 5 &&
									(t.strategy === Obe || (3 === t.match_length && t.strstart - t.match_start > 4096)) &&
									(t.match_length = 2)),
							t.prev_length >= 3 && t.match_length <= t.prev_length)
						) {
							;(r = t.strstart + t.lookahead - 3),
								(i = Gh(t, t.strstart - 1 - t.prev_match, t.prev_length - 3)),
								(t.lookahead -= t.prev_length - 1),
								(t.prev_length -= 2)
							do {
								++t.strstart <= r &&
									((t.ins_h = Kh(t, t.ins_h, t.window[t.strstart + 3 - 1])),
									(e = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
									(t.head[t.ins_h] = t.strstart))
							} while (0 != --t.prev_length)
							if (((t.match_available = 0), (t.match_length = 2), t.strstart++, i && (ic(t, !1), 0 === t.strm.avail_out)))
								return 1
						} else if (t.match_available) {
							if (
								((i = Gh(t, 0, t.window[t.strstart - 1])),
								i && ic(t, !1),
								t.strstart++,
								t.lookahead--,
								0 === t.strm.avail_out)
							)
								return 1
						} else (t.match_available = 1), t.strstart++, t.lookahead--
					}
					return (
						t.match_available && ((i = Gh(t, 0, t.window[t.strstart - 1])), (t.match_available = 0)),
						(t.insert = t.strstart < 2 ? t.strstart : 2),
						n === Oc ? (ic(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (ic(t, !1), 0 === t.strm.avail_out) ? 1 : 2
					)
				}
			function wd(t, n, e, i, r) {
				;(this.good_length = t), (this.max_lazy = n), (this.nice_length = e), (this.max_chain = i), (this.func = r)
			}
			const $v = [
				new wd(0, 0, 0, 0, r$),
				new wd(4, 4, 8, 4, LL),
				new wd(4, 5, 16, 8, LL),
				new wd(4, 6, 32, 32, LL),
				new wd(4, 4, 16, 16, Tg),
				new wd(8, 16, 32, 32, Tg),
				new wd(8, 16, 128, 128, Tg),
				new wd(8, 32, 128, 256, Tg),
				new wd(32, 128, 258, 1024, Tg),
				new wd(32, 258, 258, 4096, Tg)
			]
			function n_e() {
				;(this.strm = null),
					(this.status = 0),
					(this.pending_buf = null),
					(this.pending_buf_size = 0),
					(this.pending_out = 0),
					(this.pending = 0),
					(this.wrap = 0),
					(this.gzhead = null),
					(this.gzindex = 0),
					(this.method = eM),
					(this.last_flush = -1),
					(this.w_size = 0),
					(this.w_bits = 0),
					(this.w_mask = 0),
					(this.window = null),
					(this.window_size = 0),
					(this.prev = null),
					(this.head = null),
					(this.ins_h = 0),
					(this.hash_size = 0),
					(this.hash_bits = 0),
					(this.hash_mask = 0),
					(this.hash_shift = 0),
					(this.block_start = 0),
					(this.match_length = 0),
					(this.prev_match = 0),
					(this.match_available = 0),
					(this.strstart = 0),
					(this.match_start = 0),
					(this.lookahead = 0),
					(this.prev_length = 0),
					(this.max_chain_length = 0),
					(this.max_lazy_match = 0),
					(this.level = 0),
					(this.strategy = 0),
					(this.good_match = 0),
					(this.nice_match = 0),
					(this.dyn_ltree = new Uint16Array(1146)),
					(this.dyn_dtree = new Uint16Array(122)),
					(this.bl_tree = new Uint16Array(78)),
					jh(this.dyn_ltree),
					jh(this.dyn_dtree),
					jh(this.bl_tree),
					(this.l_desc = null),
					(this.d_desc = null),
					(this.bl_desc = null),
					(this.bl_count = new Uint16Array(16)),
					(this.heap = new Uint16Array(573)),
					jh(this.heap),
					(this.heap_len = 0),
					(this.heap_max = 0),
					(this.depth = new Uint16Array(573)),
					jh(this.depth),
					(this.sym_buf = 0),
					(this.lit_bufsize = 0),
					(this.sym_next = 0),
					(this.sym_end = 0),
					(this.opt_len = 0),
					(this.static_len = 0),
					(this.matches = 0),
					(this.insert = 0),
					(this.bi_buf = 0),
					(this.bi_valid = 0)
			}
			const Wv = t => {
					if (!t) return 1
					const n = t.state
					return !n ||
						n.strm !== t ||
						(42 !== n.status &&
							57 !== n.status &&
							69 !== n.status &&
							73 !== n.status &&
							91 !== n.status &&
							103 !== n.status &&
							113 !== n.status &&
							666 !== n.status)
						? 1
						: 0
				},
				o$ = t => {
					if (Wv(t)) return Xm(t, vd)
					;(t.total_in = t.total_out = 0), (t.data_type = Vbe)
					const n = t.state
					return (
						(n.pending = 0),
						(n.pending_out = 0),
						n.wrap < 0 && (n.wrap = -n.wrap),
						(n.status = 2 === n.wrap ? 57 : n.wrap ? 42 : 113),
						(t.adler = 2 === n.wrap ? 0 : 1),
						(n.last_flush = -2),
						Fbe(n),
						Bs
					)
				},
				s$ = t => {
					const n = o$(t)
					return (
						n === Bs &&
							(t => {
								;(t.window_size = 2 * t.w_size),
									jh(t.head),
									(t.max_lazy_match = $v[t.level].max_lazy),
									(t.good_match = $v[t.level].good_length),
									(t.nice_match = $v[t.level].nice_length),
									(t.max_chain_length = $v[t.level].max_chain),
									(t.strstart = 0),
									(t.block_start = 0),
									(t.lookahead = 0),
									(t.insert = 0),
									(t.match_length = t.prev_length = 2),
									(t.match_available = 0),
									(t.ins_h = 0)
							})(t.state),
						n
					)
				},
				a$ = (t, n, e, i, r, o) => {
					if (!t) return vd
					let s = 1
					if (
						(n === Pbe && (n = 6),
						i < 0 ? ((s = 0), (i = -i)) : i > 15 && ((s = 2), (i -= 16)),
						r < 1 || r > 9 || e !== eM || i < 8 || i > 15 || n < 0 || n > 9 || o < 0 || o > Ube || (8 === i && 1 !== s))
					)
						return Xm(t, vd)
					8 === i && (i = 9)
					const a = new n_e()
					return (
						(t.state = a),
						(a.strm = t),
						(a.status = 42),
						(a.wrap = s),
						(a.gzhead = null),
						(a.w_bits = i),
						(a.w_size = 1 << a.w_bits),
						(a.w_mask = a.w_size - 1),
						(a.hash_bits = r + 7),
						(a.hash_size = 1 << a.hash_bits),
						(a.hash_mask = a.hash_size - 1),
						(a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3)),
						(a.window = new Uint8Array(2 * a.w_size)),
						(a.head = new Uint16Array(a.hash_size)),
						(a.prev = new Uint16Array(a.w_size)),
						(a.lit_bufsize = 1 << (r + 6)),
						(a.pending_buf_size = 4 * a.lit_bufsize),
						(a.pending_buf = new Uint8Array(a.pending_buf_size)),
						(a.sym_buf = a.lit_bufsize),
						(a.sym_end = 3 * (a.lit_bufsize - 1)),
						(a.level = n),
						(a.strategy = o),
						(a.method = e),
						s$(t)
					)
				}
			var jv = {
				deflateInit: (t, n) => a$(t, n, eM, 15, 8, Hbe),
				deflateInit2: a$,
				deflateReset: s$,
				deflateResetKeep: o$,
				deflateSetHeader: (t, n) => (Wv(t) || 2 !== t.state.wrap ? vd : ((t.state.gzhead = n), Bs)),
				deflate: (t, n) => {
					if (Wv(t) || n > e$ || n < 0) return t ? Xm(t, vd) : vd
					const e = t.state
					if (!t.output || (0 !== t.avail_in && !t.input) || (666 === e.status && n !== Oc))
						return Xm(t, 0 === t.avail_out ? ML : vd)
					const i = e.last_flush
					if (((e.last_flush = n), 0 !== e.pending)) {
						if ((nc(t), 0 === t.avail_out)) return (e.last_flush = -1), Bs
					} else if (0 === t.avail_in && n$(n) <= n$(i) && n !== Oc) return Xm(t, ML)
					if (666 === e.status && 0 !== t.avail_in) return Xm(t, ML)
					if ((42 === e.status && 0 === e.wrap && (e.status = 113), 42 === e.status)) {
						let r = (eM + ((e.w_bits - 8) << 4)) << 8,
							o = -1
						if (
							((o = e.strategy >= JE || e.level < 2 ? 0 : e.level < 6 ? 1 : 6 === e.level ? 2 : 3),
							(r |= o << 6),
							0 !== e.strstart && (r |= 32),
							(r += 31 - (r % 31)),
							Gv(e, r),
							0 !== e.strstart && (Gv(e, t.adler >>> 16), Gv(e, 65535 & t.adler)),
							(t.adler = 1),
							(e.status = 113),
							nc(t),
							0 !== e.pending)
						)
							return (e.last_flush = -1), Bs
					}
					if (57 === e.status)
						if (((t.adler = 0), sr(e, 31), sr(e, 139), sr(e, 8), e.gzhead))
							sr(
								e,
								(e.gzhead.text ? 1 : 0) +
									(e.gzhead.hcrc ? 2 : 0) +
									(e.gzhead.extra ? 4 : 0) +
									(e.gzhead.name ? 8 : 0) +
									(e.gzhead.comment ? 16 : 0)
							),
								sr(e, 255 & e.gzhead.time),
								sr(e, (e.gzhead.time >> 8) & 255),
								sr(e, (e.gzhead.time >> 16) & 255),
								sr(e, (e.gzhead.time >> 24) & 255),
								sr(e, 9 === e.level ? 2 : e.strategy >= JE || e.level < 2 ? 4 : 0),
								sr(e, 255 & e.gzhead.os),
								e.gzhead.extra &&
									e.gzhead.extra.length &&
									(sr(e, 255 & e.gzhead.extra.length), sr(e, (e.gzhead.extra.length >> 8) & 255)),
								e.gzhead.hcrc && (t.adler = hs(t.adler, e.pending_buf, e.pending, 0)),
								(e.gzindex = 0),
								(e.status = 69)
						else if (
							(sr(e, 0),
							sr(e, 0),
							sr(e, 0),
							sr(e, 0),
							sr(e, 0),
							sr(e, 9 === e.level ? 2 : e.strategy >= JE || e.level < 2 ? 4 : 0),
							sr(e, 3),
							(e.status = 113),
							nc(t),
							0 !== e.pending)
						)
							return (e.last_flush = -1), Bs
					if (69 === e.status) {
						if (e.gzhead.extra) {
							let r = e.pending,
								o = (65535 & e.gzhead.extra.length) - e.gzindex
							for (; e.pending + o > e.pending_buf_size; ) {
								let a = e.pending_buf_size - e.pending
								if (
									(e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex, e.gzindex + a), e.pending),
									(e.pending = e.pending_buf_size),
									e.gzhead.hcrc && e.pending > r && (t.adler = hs(t.adler, e.pending_buf, e.pending - r, r)),
									(e.gzindex += a),
									nc(t),
									0 !== e.pending)
								)
									return (e.last_flush = -1), Bs
								;(r = 0), (o -= a)
							}
							let s = new Uint8Array(e.gzhead.extra)
							e.pending_buf.set(s.subarray(e.gzindex, e.gzindex + o), e.pending),
								(e.pending += o),
								e.gzhead.hcrc && e.pending > r && (t.adler = hs(t.adler, e.pending_buf, e.pending - r, r)),
								(e.gzindex = 0)
						}
						e.status = 73
					}
					if (73 === e.status) {
						if (e.gzhead.name) {
							let o,
								r = e.pending
							do {
								if (e.pending === e.pending_buf_size) {
									if (
										(e.gzhead.hcrc && e.pending > r && (t.adler = hs(t.adler, e.pending_buf, e.pending - r, r)),
										nc(t),
										0 !== e.pending)
									)
										return (e.last_flush = -1), Bs
									r = 0
								}
								;(o = e.gzindex < e.gzhead.name.length ? 255 & e.gzhead.name.charCodeAt(e.gzindex++) : 0), sr(e, o)
							} while (0 !== o)
							e.gzhead.hcrc && e.pending > r && (t.adler = hs(t.adler, e.pending_buf, e.pending - r, r)), (e.gzindex = 0)
						}
						e.status = 91
					}
					if (91 === e.status) {
						if (e.gzhead.comment) {
							let o,
								r = e.pending
							do {
								if (e.pending === e.pending_buf_size) {
									if (
										(e.gzhead.hcrc && e.pending > r && (t.adler = hs(t.adler, e.pending_buf, e.pending - r, r)),
										nc(t),
										0 !== e.pending)
									)
										return (e.last_flush = -1), Bs
									r = 0
								}
								;(o = e.gzindex < e.gzhead.comment.length ? 255 & e.gzhead.comment.charCodeAt(e.gzindex++) : 0), sr(e, o)
							} while (0 !== o)
							e.gzhead.hcrc && e.pending > r && (t.adler = hs(t.adler, e.pending_buf, e.pending - r, r))
						}
						e.status = 103
					}
					if (103 === e.status) {
						if (e.gzhead.hcrc) {
							if (e.pending + 2 > e.pending_buf_size && (nc(t), 0 !== e.pending)) return (e.last_flush = -1), Bs
							sr(e, 255 & t.adler), sr(e, (t.adler >> 8) & 255), (t.adler = 0)
						}
						if (((e.status = 113), nc(t), 0 !== e.pending)) return (e.last_flush = -1), Bs
					}
					if (0 !== t.avail_in || 0 !== e.lookahead || (n !== $h && 666 !== e.status)) {
						let r =
							0 === e.level
								? r$(e, n)
								: e.strategy === JE
								? ((t, n) => {
										let e
										for (;;) {
											if (0 === t.lookahead && (kg(t), 0 === t.lookahead)) {
												if (n === $h) return 1
												break
											}
											if (
												((t.match_length = 0),
												(e = Gh(t, 0, t.window[t.strstart])),
												t.lookahead--,
												t.strstart++,
												e && (ic(t, !1), 0 === t.strm.avail_out))
											)
												return 1
										}
										return (
											(t.insert = 0),
											n === Oc
												? (ic(t, !0), 0 === t.strm.avail_out ? 3 : 4)
												: t.sym_next && (ic(t, !1), 0 === t.strm.avail_out)
												? 1
												: 2
										)
								  })(e, n)
								: e.strategy === Nbe
								? ((t, n) => {
										let e, i, r, o
										const s = t.window
										for (;;) {
											if (t.lookahead <= 258) {
												if ((kg(t), t.lookahead <= 258 && n === $h)) return 1
												if (0 === t.lookahead) break
											}
											if (
												((t.match_length = 0),
												t.lookahead >= 3 &&
													t.strstart > 0 &&
													((r = t.strstart - 1), (i = s[r]), i === s[++r] && i === s[++r] && i === s[++r]))
											) {
												o = t.strstart + 258
												do {} while (
													i === s[++r] &&
													i === s[++r] &&
													i === s[++r] &&
													i === s[++r] &&
													i === s[++r] &&
													i === s[++r] &&
													i === s[++r] &&
													i === s[++r] &&
													r < o
												)
												;(t.match_length = 258 - (o - r)),
													t.match_length > t.lookahead && (t.match_length = t.lookahead)
											}
											if (
												(t.match_length >= 3
													? ((e = Gh(t, 1, t.match_length - 3)),
													  (t.lookahead -= t.match_length),
													  (t.strstart += t.match_length),
													  (t.match_length = 0))
													: ((e = Gh(t, 0, t.window[t.strstart])), t.lookahead--, t.strstart++),
												e && (ic(t, !1), 0 === t.strm.avail_out))
											)
												return 1
										}
										return (
											(t.insert = 0),
											n === Oc
												? (ic(t, !0), 0 === t.strm.avail_out ? 3 : 4)
												: t.sym_next && (ic(t, !1), 0 === t.strm.avail_out)
												? 1
												: 2
										)
								  })(e, n)
								: $v[e.level].func(e, n)
						if (((3 === r || 4 === r) && (e.status = 666), 1 === r || 3 === r))
							return 0 === t.avail_out && (e.last_flush = -1), Bs
						if (
							2 === r &&
							(n === Dbe
								? Ibe(e)
								: n !== e$ &&
								  (EL(e, 0, 0, !1),
								  n === Lbe && (jh(e.head), 0 === e.lookahead && ((e.strstart = 0), (e.block_start = 0), (e.insert = 0)))),
							nc(t),
							0 === t.avail_out)
						)
							return (e.last_flush = -1), Bs
					}
					return n !== Oc
						? Bs
						: e.wrap <= 0
						? t$
						: (2 === e.wrap
								? (sr(e, 255 & t.adler),
								  sr(e, (t.adler >> 8) & 255),
								  sr(e, (t.adler >> 16) & 255),
								  sr(e, (t.adler >> 24) & 255),
								  sr(e, 255 & t.total_in),
								  sr(e, (t.total_in >> 8) & 255),
								  sr(e, (t.total_in >> 16) & 255),
								  sr(e, (t.total_in >> 24) & 255))
								: (Gv(e, t.adler >>> 16), Gv(e, 65535 & t.adler)),
						  nc(t),
						  e.wrap > 0 && (e.wrap = -e.wrap),
						  0 !== e.pending ? Bs : t$)
				},
				deflateEnd: t => {
					if (Wv(t)) return vd
					const n = t.state.status
					return (t.state = null), 113 === n ? Xm(t, Rbe) : Bs
				},
				deflateSetDictionary: (t, n) => {
					let e = n.length
					if (Wv(t)) return vd
					const i = t.state,
						r = i.wrap
					if (2 === r || (1 === r && 42 !== i.status) || i.lookahead) return vd
					if ((1 === r && (t.adler = Qv(t.adler, n, e, 0)), (i.wrap = 0), e >= i.w_size)) {
						0 === r && (jh(i.head), (i.strstart = 0), (i.block_start = 0), (i.insert = 0))
						let c = new Uint8Array(i.w_size)
						c.set(n.subarray(e - i.w_size, e), 0), (n = c), (e = i.w_size)
					}
					const o = t.avail_in,
						s = t.next_in,
						a = t.input
					for (t.avail_in = e, t.next_in = 0, t.input = n, kg(i); i.lookahead >= 3; ) {
						let c = i.strstart,
							l = i.lookahead - 2
						do {
							;(i.ins_h = Kh(i, i.ins_h, i.window[c + 3 - 1])),
								(i.prev[c & i.w_mask] = i.head[i.ins_h]),
								(i.head[i.ins_h] = c),
								c++
						} while (--l)
						;(i.strstart = c), (i.lookahead = 2), kg(i)
					}
					return (
						(i.strstart += i.lookahead),
						(i.block_start = i.strstart),
						(i.insert = i.lookahead),
						(i.lookahead = 0),
						(i.match_length = i.prev_length = 2),
						(i.match_available = 0),
						(t.next_in = s),
						(t.input = a),
						(t.avail_in = o),
						(i.wrap = r),
						Bs
					)
				},
				deflateInfo: "pako deflate (from Nodeca project)"
			}
			const g_e = (t, n) => Object.prototype.hasOwnProperty.call(t, n)
			var tM = {
				assign: function (t) {
					const n = Array.prototype.slice.call(arguments, 1)
					for (; n.length; ) {
						const e = n.shift()
						if (e) {
							if ("object" != typeof e) throw new TypeError(e + "must be non-object")
							for (const i in e) g_e(e, i) && (t[i] = e[i])
						}
					}
					return t
				},
				flattenChunks: t => {
					let n = 0
					for (let i = 0, r = t.length; i < r; i++) n += t[i].length
					const e = new Uint8Array(n)
					for (let i = 0, r = 0, o = t.length; i < o; i++) {
						let s = t[i]
						e.set(s, r), (r += s.length)
					}
					return e
				}
			}
			let c$ = !0
			try {
				String.fromCharCode.apply(null, new Uint8Array(1))
			} catch {
				c$ = !1
			}
			const Kv = new Uint8Array(256)
			for (let t = 0; t < 256; t++) Kv[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1
			Kv[254] = Kv[254] = 1
			var Xv = {
					string2buf: t => {
						if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(t)
						let n,
							e,
							i,
							r,
							o,
							s = t.length,
							a = 0
						for (r = 0; r < s; r++)
							(e = t.charCodeAt(r)),
								55296 == (64512 & e) &&
									r + 1 < s &&
									((i = t.charCodeAt(r + 1)),
									56320 == (64512 & i) && ((e = 65536 + ((e - 55296) << 10) + (i - 56320)), r++)),
								(a += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4)
						for (n = new Uint8Array(a), o = 0, r = 0; o < a; r++)
							(e = t.charCodeAt(r)),
								55296 == (64512 & e) &&
									r + 1 < s &&
									((i = t.charCodeAt(r + 1)),
									56320 == (64512 & i) && ((e = 65536 + ((e - 55296) << 10) + (i - 56320)), r++)),
								e < 128
									? (n[o++] = e)
									: e < 2048
									? ((n[o++] = 192 | (e >>> 6)), (n[o++] = 128 | (63 & e)))
									: e < 65536
									? ((n[o++] = 224 | (e >>> 12)), (n[o++] = 128 | ((e >>> 6) & 63)), (n[o++] = 128 | (63 & e)))
									: ((n[o++] = 240 | (e >>> 18)),
									  (n[o++] = 128 | ((e >>> 12) & 63)),
									  (n[o++] = 128 | ((e >>> 6) & 63)),
									  (n[o++] = 128 | (63 & e)))
						return n
					},
					buf2string: (t, n) => {
						const e = n || t.length
						if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
							return new TextDecoder().decode(t.subarray(0, n))
						let i, r
						const o = new Array(2 * e)
						for (r = 0, i = 0; i < e; ) {
							let s = t[i++]
							if (s < 128) {
								o[r++] = s
								continue
							}
							let a = Kv[s]
							if (a > 4) (o[r++] = 65533), (i += a - 1)
							else {
								for (s &= 2 === a ? 31 : 3 === a ? 15 : 7; a > 1 && i < e; ) (s = (s << 6) | (63 & t[i++])), a--
								a > 1
									? (o[r++] = 65533)
									: s < 65536
									? (o[r++] = s)
									: ((s -= 65536), (o[r++] = 55296 | ((s >> 10) & 1023)), (o[r++] = 56320 | (1023 & s)))
							}
						}
						return ((t, n) => {
							if (n < 65534 && t.subarray && c$) return String.fromCharCode.apply(null, t.length === n ? t : t.subarray(0, n))
							let e = ""
							for (let i = 0; i < n; i++) e += String.fromCharCode(t[i])
							return e
						})(o, r)
					},
					utf8border: (t, n) => {
						;(n = n || t.length) > t.length && (n = t.length)
						let e = n - 1
						for (; e >= 0 && 128 == (192 & t[e]); ) e--
						return e < 0 || 0 === e ? n : e + Kv[t[e]] > n ? e : n
					}
				},
				l$ = function C_e() {
					;(this.input = null),
						(this.next_in = 0),
						(this.avail_in = 0),
						(this.total_in = 0),
						(this.output = null),
						(this.next_out = 0),
						(this.avail_out = 0),
						(this.total_out = 0),
						(this.msg = ""),
						(this.state = null),
						(this.data_type = 2),
						(this.adler = 0)
				}
			const d$ = Object.prototype.toString,
				{
					Z_NO_FLUSH: E_e,
					Z_SYNC_FLUSH: M_e,
					Z_FULL_FLUSH: S_e,
					Z_FINISH: k_e,
					Z_OK: nM,
					Z_STREAM_END: T_e,
					Z_DEFAULT_COMPRESSION: F_e,
					Z_DEFAULT_STRATEGY: B_e,
					Z_DEFLATED: I_e
				} = Wm
			function Yv(t) {
				this.options = tM.assign({ level: F_e, method: I_e, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: B_e }, t || {})
				let n = this.options
				n.raw && n.windowBits > 0
					? (n.windowBits = -n.windowBits)
					: n.gzip && n.windowBits > 0 && n.windowBits < 16 && (n.windowBits += 16),
					(this.err = 0),
					(this.msg = ""),
					(this.ended = !1),
					(this.chunks = []),
					(this.strm = new l$()),
					(this.strm.avail_out = 0)
				let e = jv.deflateInit2(this.strm, n.level, n.method, n.windowBits, n.memLevel, n.strategy)
				if (e !== nM) throw new Error($m[e])
				if ((n.header && jv.deflateSetHeader(this.strm, n.header), n.dictionary)) {
					let i
					if (
						((i =
							"string" == typeof n.dictionary
								? Xv.string2buf(n.dictionary)
								: "[object ArrayBuffer]" === d$.call(n.dictionary)
								? new Uint8Array(n.dictionary)
								: n.dictionary),
						(e = jv.deflateSetDictionary(this.strm, i)),
						e !== nM)
					)
						throw new Error($m[e])
					this._dict_set = !0
				}
			}
			function RL(t, n) {
				const e = new Yv(n)
				if ((e.push(t, !0), e.err)) throw e.msg || $m[e.err]
				return e.result
			}
			;(Yv.prototype.push = function (t, n) {
				const e = this.strm,
					i = this.options.chunkSize
				let r, o
				if (this.ended) return !1
				for (
					o = n === ~~n ? n : !0 === n ? k_e : E_e,
						e.input = "string" == typeof t ? Xv.string2buf(t) : "[object ArrayBuffer]" === d$.call(t) ? new Uint8Array(t) : t,
						e.next_in = 0,
						e.avail_in = e.input.length;
					;

				)
					if (
						(0 === e.avail_out && ((e.output = new Uint8Array(i)), (e.next_out = 0), (e.avail_out = i)),
						(o === M_e || o === S_e) && e.avail_out <= 6)
					)
						this.onData(e.output.subarray(0, e.next_out)), (e.avail_out = 0)
					else {
						if (((r = jv.deflate(e, o)), r === T_e))
							return (
								e.next_out > 0 && this.onData(e.output.subarray(0, e.next_out)),
								(r = jv.deflateEnd(this.strm)),
								this.onEnd(r),
								(this.ended = !0),
								r === nM
							)
						if (0 !== e.avail_out) {
							if (o > 0 && e.next_out > 0) this.onData(e.output.subarray(0, e.next_out)), (e.avail_out = 0)
							else if (0 === e.avail_in) break
						} else this.onData(e.output)
					}
				return !0
			}),
				(Yv.prototype.onData = function (t) {
					this.chunks.push(t)
				}),
				(Yv.prototype.onEnd = function (t) {
					t === nM && (this.result = tM.flattenChunks(this.chunks)),
						(this.chunks = []),
						(this.err = t),
						(this.msg = this.strm.msg)
				})
			var H_e = {
				Deflate: Yv,
				deflate: RL,
				deflateRaw: function D_e(t, n) {
					return ((n = n || {}).raw = !0), RL(t, n)
				},
				gzip: function L_e(t, n) {
					return ((n = n || {}).gzip = !0), RL(t, n)
				},
				constants: Wm
			}
			const iM = 16209
			var Q_e = function (n, e) {
				let i, r, o, s, a, c, l, d, u, h, f, _, y, C, x, w, S, M, O, N, j, le, ae, ce
				const ue = n.state
				;(i = n.next_in),
					(ae = n.input),
					(r = i + (n.avail_in - 5)),
					(o = n.next_out),
					(ce = n.output),
					(s = o - (e - n.avail_out)),
					(a = o + (n.avail_out - 257)),
					(c = ue.dmax),
					(l = ue.wsize),
					(d = ue.whave),
					(u = ue.wnext),
					(h = ue.window),
					(f = ue.hold),
					(_ = ue.bits),
					(y = ue.lencode),
					(C = ue.distcode),
					(x = (1 << ue.lenbits) - 1),
					(w = (1 << ue.distbits) - 1)
				e: do {
					_ < 15 && ((f += ae[i++] << _), (_ += 8), (f += ae[i++] << _), (_ += 8)), (S = y[f & x])
					t: for (;;) {
						if (((M = S >>> 24), (f >>>= M), (_ -= M), (M = (S >>> 16) & 255), 0 === M)) ce[o++] = 65535 & S
						else {
							if (!(16 & M)) {
								if (64 & M) {
									if (32 & M) {
										ue.mode = 16191
										break e
									}
									;(n.msg = "invalid literal/length code"), (ue.mode = iM)
									break e
								}
								S = y[(65535 & S) + (f & ((1 << M) - 1))]
								continue t
							}
							for (
								O = 65535 & S,
									M &= 15,
									M && (_ < M && ((f += ae[i++] << _), (_ += 8)), (O += f & ((1 << M) - 1)), (f >>>= M), (_ -= M)),
									_ < 15 && ((f += ae[i++] << _), (_ += 8), (f += ae[i++] << _), (_ += 8)),
									S = C[f & w];
								;

							) {
								if (((M = S >>> 24), (f >>>= M), (_ -= M), (M = (S >>> 16) & 255), 16 & M)) {
									if (
										((N = 65535 & S),
										(M &= 15),
										_ < M && ((f += ae[i++] << _), (_ += 8), _ < M && ((f += ae[i++] << _), (_ += 8))),
										(N += f & ((1 << M) - 1)),
										N > c)
									) {
										;(n.msg = "invalid distance too far back"), (ue.mode = iM)
										break e
									}
									if (((f >>>= M), (_ -= M), (M = o - s), N > M)) {
										if (((M = N - M), M > d && ue.sane)) {
											;(n.msg = "invalid distance too far back"), (ue.mode = iM)
											break e
										}
										if (((j = 0), (le = h), 0 === u)) {
											if (((j += l - M), M < O)) {
												O -= M
												do {
													ce[o++] = h[j++]
												} while (--M)
												;(j = o - N), (le = ce)
											}
										} else if (u < M) {
											if (((j += l + u - M), (M -= u), M < O)) {
												O -= M
												do {
													ce[o++] = h[j++]
												} while (--M)
												if (((j = 0), u < O)) {
													;(M = u), (O -= M)
													do {
														ce[o++] = h[j++]
													} while (--M)
													;(j = o - N), (le = ce)
												}
											}
										} else if (((j += u - M), M < O)) {
											O -= M
											do {
												ce[o++] = h[j++]
											} while (--M)
											;(j = o - N), (le = ce)
										}
										for (; O > 2; ) (ce[o++] = le[j++]), (ce[o++] = le[j++]), (ce[o++] = le[j++]), (O -= 3)
										O && ((ce[o++] = le[j++]), O > 1 && (ce[o++] = le[j++]))
									} else {
										j = o - N
										do {
											;(ce[o++] = ce[j++]), (ce[o++] = ce[j++]), (ce[o++] = ce[j++]), (O -= 3)
										} while (O > 2)
										O && ((ce[o++] = ce[j++]), O > 1 && (ce[o++] = ce[j++]))
									}
									break
								}
								if (64 & M) {
									;(n.msg = "invalid distance code"), (ue.mode = iM)
									break e
								}
								S = C[(65535 & S) + (f & ((1 << M) - 1))]
							}
						}
						break
					}
				} while (i < r && o < a)
				;(O = _ >> 3),
					(i -= O),
					(_ -= O << 3),
					(f &= (1 << _) - 1),
					(n.next_in = i),
					(n.next_out = o),
					(n.avail_in = i < r ? r - i + 5 : 5 - (i - r)),
					(n.avail_out = o < a ? a - o + 257 : 257 - (o - a)),
					(ue.hold = f),
					(ue.bits = _)
			}
			const z_e = new Uint16Array([
					3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
				]),
				G_e = new Uint8Array([
					16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72,
					78
				]),
				$_e = new Uint16Array([
					1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193,
					12289, 16385, 24577, 0, 0
				]),
				W_e = new Uint8Array([
					16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29,
					64, 64
				])
			var qv = (t, n, e, i, r, o, s, a) => {
				const c = a.bits
				let S,
					M,
					O,
					N,
					j,
					ae,
					l = 0,
					d = 0,
					u = 0,
					h = 0,
					f = 0,
					_ = 0,
					y = 0,
					C = 0,
					x = 0,
					w = 0,
					le = null
				const ce = new Uint16Array(16),
					ue = new Uint16Array(16)
				let ve,
					W,
					me,
					Se = null
				for (l = 0; l <= 15; l++) ce[l] = 0
				for (d = 0; d < i; d++) ce[n[e + d]]++
				for (f = c, h = 15; h >= 1 && 0 === ce[h]; h--);
				if ((f > h && (f = h), 0 === h)) return (r[o++] = 20971520), (r[o++] = 20971520), (a.bits = 1), 0
				for (u = 1; u < h && 0 === ce[u]; u++);
				for (f < u && (f = u), C = 1, l = 1; l <= 15; l++) if (((C <<= 1), (C -= ce[l]), C < 0)) return -1
				if (C > 0 && (0 === t || 1 !== h)) return -1
				for (ue[1] = 0, l = 1; l < 15; l++) ue[l + 1] = ue[l] + ce[l]
				for (d = 0; d < i; d++) 0 !== n[e + d] && (s[ue[n[e + d]]++] = d)
				if (
					(0 === t
						? ((le = Se = s), (ae = 20))
						: 1 === t
						? ((le = z_e), (Se = G_e), (ae = 257))
						: ((le = $_e), (Se = W_e), (ae = 0)),
					(w = 0),
					(d = 0),
					(l = u),
					(j = o),
					(_ = f),
					(y = 0),
					(O = -1),
					(x = 1 << f),
					(N = x - 1),
					(1 === t && x > 852) || (2 === t && x > 592))
				)
					return 1
				for (;;) {
					;(ve = l - y),
						s[d] + 1 < ae
							? ((W = 0), (me = s[d]))
							: s[d] >= ae
							? ((W = Se[s[d] - ae]), (me = le[s[d] - ae]))
							: ((W = 96), (me = 0)),
						(S = 1 << (l - y)),
						(M = 1 << _),
						(u = M)
					do {
						;(M -= S), (r[j + (w >> y) + M] = (ve << 24) | (W << 16) | me | 0)
					} while (0 !== M)
					for (S = 1 << (l - 1); w & S; ) S >>= 1
					if ((0 !== S ? ((w &= S - 1), (w += S)) : (w = 0), d++, 0 == --ce[l])) {
						if (l === h) break
						l = n[e + s[d]]
					}
					if (l > f && (w & N) !== O) {
						for (0 === y && (y = f), j += u, _ = l - y, C = 1 << _; _ + y < h && ((C -= ce[_ + y]), !(C <= 0)); ) _++, (C <<= 1)
						if (((x += 1 << _), (1 === t && x > 852) || (2 === t && x > 592))) return 1
						;(O = w & N), (r[O] = (f << 24) | (_ << 16) | (j - o) | 0)
					}
				}
				return 0 !== w && (r[j + w] = ((l - y) << 24) | (64 << 16) | 0), (a.bits = f), 0
			}
			const {
					Z_FINISH: g$,
					Z_BLOCK: K_e,
					Z_TREES: rM,
					Z_OK: Ym,
					Z_STREAM_END: X_e,
					Z_NEED_DICT: Y_e,
					Z_STREAM_ERROR: Nc,
					Z_DATA_ERROR: b$,
					Z_MEM_ERROR: _$,
					Z_BUF_ERROR: q_e,
					Z_DEFLATED: v$
				} = Wm,
				oM = 16180,
				sM = 16190,
				ku = 16191,
				aM = 16199,
				cM = 16200,
				no = 16209,
				G$ = t => ((t >>> 24) & 255) + ((t >>> 8) & 65280) + ((65280 & t) << 8) + ((255 & t) << 24)
			function t0e() {
				;(this.strm = null),
					(this.mode = 0),
					(this.last = !1),
					(this.wrap = 0),
					(this.havedict = !1),
					(this.flags = 0),
					(this.dmax = 0),
					(this.check = 0),
					(this.total = 0),
					(this.head = null),
					(this.wbits = 0),
					(this.wsize = 0),
					(this.whave = 0),
					(this.wnext = 0),
					(this.window = null),
					(this.hold = 0),
					(this.bits = 0),
					(this.length = 0),
					(this.offset = 0),
					(this.extra = 0),
					(this.lencode = null),
					(this.distcode = null),
					(this.lenbits = 0),
					(this.distbits = 0),
					(this.ncode = 0),
					(this.nlen = 0),
					(this.ndist = 0),
					(this.have = 0),
					(this.next = null),
					(this.lens = new Uint16Array(320)),
					(this.work = new Uint16Array(288)),
					(this.lendyn = null),
					(this.distdyn = null),
					(this.sane = 0),
					(this.back = 0),
					(this.was = 0)
			}
			const qm = t => {
					if (!t) return 1
					const n = t.state
					return !n || n.strm !== t || n.mode < oM || n.mode > 16211 ? 1 : 0
				},
				$$ = t => {
					if (qm(t)) return Nc
					const n = t.state
					return (
						(t.total_in = t.total_out = n.total = 0),
						(t.msg = ""),
						n.wrap && (t.adler = 1 & n.wrap),
						(n.mode = oM),
						(n.last = 0),
						(n.havedict = 0),
						(n.flags = -1),
						(n.dmax = 32768),
						(n.head = null),
						(n.hold = 0),
						(n.bits = 0),
						(n.lencode = n.lendyn = new Int32Array(852)),
						(n.distcode = n.distdyn = new Int32Array(592)),
						(n.sane = 1),
						(n.back = -1),
						Ym
					)
				},
				W$ = t => {
					if (qm(t)) return Nc
					const n = t.state
					return (n.wsize = 0), (n.whave = 0), (n.wnext = 0), $$(t)
				},
				j$ = (t, n) => {
					let e
					if (qm(t)) return Nc
					const i = t.state
					return (
						n < 0 ? ((e = 0), (n = -n)) : ((e = 5 + (n >> 4)), n < 48 && (n &= 15)),
						n && (n < 8 || n > 15)
							? Nc
							: (null !== i.window && i.wbits !== n && (i.window = null), (i.wrap = e), (i.wbits = n), W$(t))
					)
				},
				K$ = (t, n) => {
					if (!t) return Nc
					const e = new t0e()
					;(t.state = e), (e.strm = t), (e.window = null), (e.mode = oM)
					const i = j$(t, n)
					return i !== Ym && (t.state = null), i
				}
			let HL,
				VL,
				X$ = !0
			const i0e = t => {
					if (X$) {
						;(HL = new Int32Array(512)), (VL = new Int32Array(32))
						let n = 0
						for (; n < 144; ) t.lens[n++] = 8
						for (; n < 256; ) t.lens[n++] = 9
						for (; n < 280; ) t.lens[n++] = 7
						for (; n < 288; ) t.lens[n++] = 8
						for (qv(1, t.lens, 0, 288, HL, 0, t.work, { bits: 9 }), n = 0; n < 32; ) t.lens[n++] = 5
						qv(2, t.lens, 0, 32, VL, 0, t.work, { bits: 5 }), (X$ = !1)
					}
					;(t.lencode = HL), (t.lenbits = 9), (t.distcode = VL), (t.distbits = 5)
				},
				Y$ = (t, n, e, i) => {
					let r
					const o = t.state
					return (
						null === o.window && ((o.wsize = 1 << o.wbits), (o.wnext = 0), (o.whave = 0), (o.window = new Uint8Array(o.wsize))),
						i >= o.wsize
							? (o.window.set(n.subarray(e - o.wsize, e), 0), (o.wnext = 0), (o.whave = o.wsize))
							: ((r = o.wsize - o.wnext),
							  r > i && (r = i),
							  o.window.set(n.subarray(e - i, e - i + r), o.wnext),
							  (i -= r)
									? (o.window.set(n.subarray(e - i, e), 0), (o.wnext = i), (o.whave = o.wsize))
									: ((o.wnext += r), o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += r))),
						0
					)
				}
			var Tu = {
					inflateReset: W$,
					inflateReset2: j$,
					inflateResetKeep: $$,
					inflateInit: t => K$(t, 15),
					inflateInit2: K$,
					inflate: (t, n) => {
						let e,
							i,
							r,
							o,
							s,
							a,
							c,
							l,
							d,
							u,
							h,
							f,
							_,
							y,
							x,
							w,
							S,
							M,
							O,
							N,
							j,
							le,
							C = 0
						const ae = new Uint8Array(4)
						let ce, ue
						const Se = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
						if (qm(t) || !t.output || (!t.input && 0 !== t.avail_in)) return Nc
						;(e = t.state),
							e.mode === ku && (e.mode = 16192),
							(s = t.next_out),
							(r = t.output),
							(c = t.avail_out),
							(o = t.next_in),
							(i = t.input),
							(a = t.avail_in),
							(l = e.hold),
							(d = e.bits),
							(u = a),
							(h = c),
							(le = Ym)
						e: for (;;)
							switch (e.mode) {
								case oM:
									if (0 === e.wrap) {
										e.mode = 16192
										break
									}
									for (; d < 16; ) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									if (2 & e.wrap && 35615 === l) {
										0 === e.wbits && (e.wbits = 15),
											(e.check = 0),
											(ae[0] = 255 & l),
											(ae[1] = (l >>> 8) & 255),
											(e.check = hs(e.check, ae, 2, 0)),
											(l = 0),
											(d = 0),
											(e.mode = 16181)
										break
									}
									if ((e.head && (e.head.done = !1), !(1 & e.wrap) || (((255 & l) << 8) + (l >> 8)) % 31)) {
										;(t.msg = "incorrect header check"), (e.mode = no)
										break
									}
									if ((15 & l) !== v$) {
										;(t.msg = "unknown compression method"), (e.mode = no)
										break
									}
									if (((l >>>= 4), (d -= 4), (j = 8 + (15 & l)), 0 === e.wbits && (e.wbits = j), j > 15 || j > e.wbits)) {
										;(t.msg = "invalid window size"), (e.mode = no)
										break
									}
									;(e.dmax = 1 << e.wbits),
										(e.flags = 0),
										(t.adler = e.check = 1),
										(e.mode = 512 & l ? 16189 : ku),
										(l = 0),
										(d = 0)
									break
								case 16181:
									for (; d < 16; ) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									if (((e.flags = l), (255 & e.flags) !== v$)) {
										;(t.msg = "unknown compression method"), (e.mode = no)
										break
									}
									if (57344 & e.flags) {
										;(t.msg = "unknown header flags set"), (e.mode = no)
										break
									}
									e.head && (e.head.text = (l >> 8) & 1),
										512 & e.flags &&
											4 & e.wrap &&
											((ae[0] = 255 & l), (ae[1] = (l >>> 8) & 255), (e.check = hs(e.check, ae, 2, 0))),
										(l = 0),
										(d = 0),
										(e.mode = 16182)
								case 16182:
									for (; d < 32; ) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									e.head && (e.head.time = l),
										512 & e.flags &&
											4 & e.wrap &&
											((ae[0] = 255 & l),
											(ae[1] = (l >>> 8) & 255),
											(ae[2] = (l >>> 16) & 255),
											(ae[3] = (l >>> 24) & 255),
											(e.check = hs(e.check, ae, 4, 0))),
										(l = 0),
										(d = 0),
										(e.mode = 16183)
								case 16183:
									for (; d < 16; ) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									e.head && ((e.head.xflags = 255 & l), (e.head.os = l >> 8)),
										512 & e.flags &&
											4 & e.wrap &&
											((ae[0] = 255 & l), (ae[1] = (l >>> 8) & 255), (e.check = hs(e.check, ae, 2, 0))),
										(l = 0),
										(d = 0),
										(e.mode = 16184)
								case 16184:
									if (1024 & e.flags) {
										for (; d < 16; ) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										;(e.length = l),
											e.head && (e.head.extra_len = l),
											512 & e.flags &&
												4 & e.wrap &&
												((ae[0] = 255 & l), (ae[1] = (l >>> 8) & 255), (e.check = hs(e.check, ae, 2, 0))),
											(l = 0),
											(d = 0)
									} else e.head && (e.head.extra = null)
									e.mode = 16185
								case 16185:
									if (
										1024 & e.flags &&
										((f = e.length),
										f > a && (f = a),
										f &&
											(e.head &&
												((j = e.head.extra_len - e.length),
												e.head.extra || (e.head.extra = new Uint8Array(e.head.extra_len)),
												e.head.extra.set(i.subarray(o, o + f), j)),
											512 & e.flags && 4 & e.wrap && (e.check = hs(e.check, i, f, o)),
											(a -= f),
											(o += f),
											(e.length -= f)),
										e.length)
									)
										break e
									;(e.length = 0), (e.mode = 16186)
								case 16186:
									if (2048 & e.flags) {
										if (0 === a) break e
										f = 0
										do {
											;(j = i[o + f++]), e.head && j && e.length < 65536 && (e.head.name += String.fromCharCode(j))
										} while (j && f < a)
										if ((512 & e.flags && 4 & e.wrap && (e.check = hs(e.check, i, f, o)), (a -= f), (o += f), j))
											break e
									} else e.head && (e.head.name = null)
									;(e.length = 0), (e.mode = 16187)
								case 16187:
									if (4096 & e.flags) {
										if (0 === a) break e
										f = 0
										do {
											;(j = i[o + f++]), e.head && j && e.length < 65536 && (e.head.comment += String.fromCharCode(j))
										} while (j && f < a)
										if ((512 & e.flags && 4 & e.wrap && (e.check = hs(e.check, i, f, o)), (a -= f), (o += f), j))
											break e
									} else e.head && (e.head.comment = null)
									e.mode = 16188
								case 16188:
									if (512 & e.flags) {
										for (; d < 16; ) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										if (4 & e.wrap && l !== (65535 & e.check)) {
											;(t.msg = "header crc mismatch"), (e.mode = no)
											break
										}
										;(l = 0), (d = 0)
									}
									e.head && ((e.head.hcrc = (e.flags >> 9) & 1), (e.head.done = !0)),
										(t.adler = e.check = 0),
										(e.mode = ku)
									break
								case 16189:
									for (; d < 32; ) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									;(t.adler = e.check = G$(l)), (l = 0), (d = 0), (e.mode = sM)
								case sM:
									if (0 === e.havedict)
										return (
											(t.next_out = s),
											(t.avail_out = c),
											(t.next_in = o),
											(t.avail_in = a),
											(e.hold = l),
											(e.bits = d),
											Y_e
										)
									;(t.adler = e.check = 1), (e.mode = ku)
								case ku:
									if (n === K_e || n === rM) break e
								case 16192:
									if (e.last) {
										;(l >>>= 7 & d), (d -= 7 & d), (e.mode = 16206)
										break
									}
									for (; d < 3; ) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									switch (((e.last = 1 & l), (l >>>= 1), (d -= 1), 3 & l)) {
										case 0:
											e.mode = 16193
											break
										case 1:
											if ((i0e(e), (e.mode = aM), n === rM)) {
												;(l >>>= 2), (d -= 2)
												break e
											}
											break
										case 2:
											e.mode = 16196
											break
										case 3:
											;(t.msg = "invalid block type"), (e.mode = no)
									}
									;(l >>>= 2), (d -= 2)
									break
								case 16193:
									for (l >>>= 7 & d, d -= 7 & d; d < 32; ) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									if ((65535 & l) != ((l >>> 16) ^ 65535)) {
										;(t.msg = "invalid stored block lengths"), (e.mode = no)
										break
									}
									if (((e.length = 65535 & l), (l = 0), (d = 0), (e.mode = 16194), n === rM)) break e
								case 16194:
									e.mode = 16195
								case 16195:
									if (((f = e.length), f)) {
										if ((f > a && (f = a), f > c && (f = c), 0 === f)) break e
										r.set(i.subarray(o, o + f), s), (a -= f), (o += f), (c -= f), (s += f), (e.length -= f)
										break
									}
									e.mode = ku
									break
								case 16196:
									for (; d < 14; ) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									if (
										((e.nlen = 257 + (31 & l)),
										(l >>>= 5),
										(d -= 5),
										(e.ndist = 1 + (31 & l)),
										(l >>>= 5),
										(d -= 5),
										(e.ncode = 4 + (15 & l)),
										(l >>>= 4),
										(d -= 4),
										e.nlen > 286 || e.ndist > 30)
									) {
										;(t.msg = "too many length or distance symbols"), (e.mode = no)
										break
									}
									;(e.have = 0), (e.mode = 16197)
								case 16197:
									for (; e.have < e.ncode; ) {
										for (; d < 3; ) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										;(e.lens[Se[e.have++]] = 7 & l), (l >>>= 3), (d -= 3)
									}
									for (; e.have < 19; ) e.lens[Se[e.have++]] = 0
									if (
										((e.lencode = e.lendyn),
										(e.lenbits = 7),
										(ce = { bits: e.lenbits }),
										(le = qv(0, e.lens, 0, 19, e.lencode, 0, e.work, ce)),
										(e.lenbits = ce.bits),
										le)
									) {
										;(t.msg = "invalid code lengths set"), (e.mode = no)
										break
									}
									;(e.have = 0), (e.mode = 16198)
								case 16198:
									for (; e.have < e.nlen + e.ndist; ) {
										for (
											;
											(C = e.lencode[l & ((1 << e.lenbits) - 1)]),
												(x = C >>> 24),
												(w = (C >>> 16) & 255),
												(S = 65535 & C),
												!(x <= d);

										) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										if (S < 16) (l >>>= x), (d -= x), (e.lens[e.have++] = S)
										else {
											if (16 === S) {
												for (ue = x + 2; d < ue; ) {
													if (0 === a) break e
													a--, (l += i[o++] << d), (d += 8)
												}
												if (((l >>>= x), (d -= x), 0 === e.have)) {
													;(t.msg = "invalid bit length repeat"), (e.mode = no)
													break
												}
												;(j = e.lens[e.have - 1]), (f = 3 + (3 & l)), (l >>>= 2), (d -= 2)
											} else if (17 === S) {
												for (ue = x + 3; d < ue; ) {
													if (0 === a) break e
													a--, (l += i[o++] << d), (d += 8)
												}
												;(l >>>= x), (d -= x), (j = 0), (f = 3 + (7 & l)), (l >>>= 3), (d -= 3)
											} else {
												for (ue = x + 7; d < ue; ) {
													if (0 === a) break e
													a--, (l += i[o++] << d), (d += 8)
												}
												;(l >>>= x), (d -= x), (j = 0), (f = 11 + (127 & l)), (l >>>= 7), (d -= 7)
											}
											if (e.have + f > e.nlen + e.ndist) {
												;(t.msg = "invalid bit length repeat"), (e.mode = no)
												break
											}
											for (; f--; ) e.lens[e.have++] = j
										}
									}
									if (e.mode === no) break
									if (0 === e.lens[256]) {
										;(t.msg = "invalid code -- missing end-of-block"), (e.mode = no)
										break
									}
									if (
										((e.lenbits = 9),
										(ce = { bits: e.lenbits }),
										(le = qv(1, e.lens, 0, e.nlen, e.lencode, 0, e.work, ce)),
										(e.lenbits = ce.bits),
										le)
									) {
										;(t.msg = "invalid literal/lengths set"), (e.mode = no)
										break
									}
									if (
										((e.distbits = 6),
										(e.distcode = e.distdyn),
										(ce = { bits: e.distbits }),
										(le = qv(2, e.lens, e.nlen, e.ndist, e.distcode, 0, e.work, ce)),
										(e.distbits = ce.bits),
										le)
									) {
										;(t.msg = "invalid distances set"), (e.mode = no)
										break
									}
									if (((e.mode = aM), n === rM)) break e
								case aM:
									e.mode = cM
								case cM:
									if (a >= 6 && c >= 258) {
										;(t.next_out = s),
											(t.avail_out = c),
											(t.next_in = o),
											(t.avail_in = a),
											(e.hold = l),
											(e.bits = d),
											Q_e(t, h),
											(s = t.next_out),
											(r = t.output),
											(c = t.avail_out),
											(o = t.next_in),
											(i = t.input),
											(a = t.avail_in),
											(l = e.hold),
											(d = e.bits),
											e.mode === ku && (e.back = -1)
										break
									}
									for (
										e.back = 0;
										(C = e.lencode[l & ((1 << e.lenbits) - 1)]),
											(x = C >>> 24),
											(w = (C >>> 16) & 255),
											(S = 65535 & C),
											!(x <= d);

									) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									if (w && !(240 & w)) {
										for (
											M = x, O = w, N = S;
											(C = e.lencode[N + ((l & ((1 << (M + O)) - 1)) >> M)]),
												(x = C >>> 24),
												(w = (C >>> 16) & 255),
												(S = 65535 & C),
												!(M + x <= d);

										) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										;(l >>>= M), (d -= M), (e.back += M)
									}
									if (((l >>>= x), (d -= x), (e.back += x), (e.length = S), 0 === w)) {
										e.mode = 16205
										break
									}
									if (32 & w) {
										;(e.back = -1), (e.mode = ku)
										break
									}
									if (64 & w) {
										;(t.msg = "invalid literal/length code"), (e.mode = no)
										break
									}
									;(e.extra = 15 & w), (e.mode = 16201)
								case 16201:
									if (e.extra) {
										for (ue = e.extra; d < ue; ) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										;(e.length += l & ((1 << e.extra) - 1)), (l >>>= e.extra), (d -= e.extra), (e.back += e.extra)
									}
									;(e.was = e.length), (e.mode = 16202)
								case 16202:
									for (
										;
										(C = e.distcode[l & ((1 << e.distbits) - 1)]),
											(x = C >>> 24),
											(w = (C >>> 16) & 255),
											(S = 65535 & C),
											!(x <= d);

									) {
										if (0 === a) break e
										a--, (l += i[o++] << d), (d += 8)
									}
									if (!(240 & w)) {
										for (
											M = x, O = w, N = S;
											(C = e.distcode[N + ((l & ((1 << (M + O)) - 1)) >> M)]),
												(x = C >>> 24),
												(w = (C >>> 16) & 255),
												(S = 65535 & C),
												!(M + x <= d);

										) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										;(l >>>= M), (d -= M), (e.back += M)
									}
									if (((l >>>= x), (d -= x), (e.back += x), 64 & w)) {
										;(t.msg = "invalid distance code"), (e.mode = no)
										break
									}
									;(e.offset = S), (e.extra = 15 & w), (e.mode = 16203)
								case 16203:
									if (e.extra) {
										for (ue = e.extra; d < ue; ) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										;(e.offset += l & ((1 << e.extra) - 1)), (l >>>= e.extra), (d -= e.extra), (e.back += e.extra)
									}
									if (e.offset > e.dmax) {
										;(t.msg = "invalid distance too far back"), (e.mode = no)
										break
									}
									e.mode = 16204
								case 16204:
									if (0 === c) break e
									if (((f = h - c), e.offset > f)) {
										if (((f = e.offset - f), f > e.whave && e.sane)) {
											;(t.msg = "invalid distance too far back"), (e.mode = no)
											break
										}
										f > e.wnext ? ((f -= e.wnext), (_ = e.wsize - f)) : (_ = e.wnext - f),
											f > e.length && (f = e.length),
											(y = e.window)
									} else (y = r), (_ = s - e.offset), (f = e.length)
									f > c && (f = c), (c -= f), (e.length -= f)
									do {
										r[s++] = y[_++]
									} while (--f)
									0 === e.length && (e.mode = cM)
									break
								case 16205:
									if (0 === c) break e
									;(r[s++] = e.length), c--, (e.mode = cM)
									break
								case 16206:
									if (e.wrap) {
										for (; d < 32; ) {
											if (0 === a) break e
											a--, (l |= i[o++] << d), (d += 8)
										}
										if (
											((h -= c),
											(t.total_out += h),
											(e.total += h),
											4 & e.wrap &&
												h &&
												(t.adler = e.check = e.flags ? hs(e.check, r, h, s - h) : Qv(e.check, r, h, s - h)),
											(h = c),
											4 & e.wrap && (e.flags ? l : G$(l)) !== e.check)
										) {
											;(t.msg = "incorrect data check"), (e.mode = no)
											break
										}
										;(l = 0), (d = 0)
									}
									e.mode = 16207
								case 16207:
									if (e.wrap && e.flags) {
										for (; d < 32; ) {
											if (0 === a) break e
											a--, (l += i[o++] << d), (d += 8)
										}
										if (4 & e.wrap && l !== (4294967295 & e.total)) {
											;(t.msg = "incorrect length check"), (e.mode = no)
											break
										}
										;(l = 0), (d = 0)
									}
									e.mode = 16208
								case 16208:
									le = X_e
									break e
								case no:
									le = b$
									break e
								case 16210:
									return _$
								default:
									return Nc
							}
						return (
							(t.next_out = s),
							(t.avail_out = c),
							(t.next_in = o),
							(t.avail_in = a),
							(e.hold = l),
							(e.bits = d),
							(e.wsize || (h !== t.avail_out && e.mode < no && (e.mode < 16206 || n !== g$))) &&
								Y$(t, t.output, t.next_out, h - t.avail_out),
							(u -= t.avail_in),
							(h -= t.avail_out),
							(t.total_in += u),
							(t.total_out += h),
							(e.total += h),
							4 & e.wrap &&
								h &&
								(t.adler = e.check = e.flags ? hs(e.check, r, h, t.next_out - h) : Qv(e.check, r, h, t.next_out - h)),
							(t.data_type =
								e.bits + (e.last ? 64 : 0) + (e.mode === ku ? 128 : 0) + (e.mode === aM || 16194 === e.mode ? 256 : 0)),
							((0 === u && 0 === h) || n === g$) && le === Ym && (le = q_e),
							le
						)
					},
					inflateEnd: t => {
						if (qm(t)) return Nc
						let n = t.state
						return n.window && (n.window = null), (t.state = null), Ym
					},
					inflateGetHeader: (t, n) => {
						if (qm(t)) return Nc
						const e = t.state
						return 2 & e.wrap ? ((e.head = n), (n.done = !1), Ym) : Nc
					},
					inflateSetDictionary: (t, n) => {
						const e = n.length
						let i, r, o
						return qm(t) || ((i = t.state), 0 !== i.wrap && i.mode !== sM)
							? Nc
							: i.mode === sM && ((r = 1), (r = Qv(r, n, e, 0)), r !== i.check)
							? b$
							: ((o = Y$(t, n, e, e)), o ? ((i.mode = 16210), _$) : ((i.havedict = 1), Ym))
					},
					inflateInfo: "pako inflate (from Nodeca project)"
				},
				_0e = function b0e() {
					;(this.text = 0),
						(this.time = 0),
						(this.xflags = 0),
						(this.os = 0),
						(this.extra = null),
						(this.extra_len = 0),
						(this.name = ""),
						(this.comment = ""),
						(this.hcrc = 0),
						(this.done = !1)
				}
			const q$ = Object.prototype.toString,
				{
					Z_NO_FLUSH: v0e,
					Z_FINISH: y0e,
					Z_OK: Zv,
					Z_STREAM_END: QL,
					Z_NEED_DICT: zL,
					Z_STREAM_ERROR: w0e,
					Z_DATA_ERROR: Z$,
					Z_MEM_ERROR: x0e
				} = Wm
			function Jv(t) {
				this.options = tM.assign({ chunkSize: 65536, windowBits: 15, to: "" }, t || {})
				const n = this.options
				n.raw &&
					n.windowBits >= 0 &&
					n.windowBits < 16 &&
					((n.windowBits = -n.windowBits), 0 === n.windowBits && (n.windowBits = -15)),
					n.windowBits >= 0 && n.windowBits < 16 && !(t && t.windowBits) && (n.windowBits += 32),
					n.windowBits > 15 && n.windowBits < 48 && (15 & n.windowBits || (n.windowBits |= 15)),
					(this.err = 0),
					(this.msg = ""),
					(this.ended = !1),
					(this.chunks = []),
					(this.strm = new l$()),
					(this.strm.avail_out = 0)
				let e = Tu.inflateInit2(this.strm, n.windowBits)
				if (e !== Zv) throw new Error($m[e])
				if (
					((this.header = new _0e()),
					Tu.inflateGetHeader(this.strm, this.header),
					n.dictionary &&
						("string" == typeof n.dictionary
							? (n.dictionary = Xv.string2buf(n.dictionary))
							: "[object ArrayBuffer]" === q$.call(n.dictionary) && (n.dictionary = new Uint8Array(n.dictionary)),
						n.raw && ((e = Tu.inflateSetDictionary(this.strm, n.dictionary)), e !== Zv)))
				)
					throw new Error($m[e])
			}
			function GL(t, n) {
				const e = new Jv(n)
				if ((e.push(t), e.err)) throw e.msg || $m[e.err]
				return e.result
			}
			;(Jv.prototype.push = function (t, n) {
				const e = this.strm,
					i = this.options.chunkSize,
					r = this.options.dictionary
				let o, s, a
				if (this.ended) return !1
				for (
					s = n === ~~n ? n : !0 === n ? y0e : v0e,
						e.input = "[object ArrayBuffer]" === q$.call(t) ? new Uint8Array(t) : t,
						e.next_in = 0,
						e.avail_in = e.input.length;
					;

				) {
					for (
						0 === e.avail_out && ((e.output = new Uint8Array(i)), (e.next_out = 0), (e.avail_out = i)),
							o = Tu.inflate(e, s),
							o === zL &&
								r &&
								((o = Tu.inflateSetDictionary(e, r)), o === Zv ? (o = Tu.inflate(e, s)) : o === Z$ && (o = zL));
						e.avail_in > 0 && o === QL && e.state.wrap > 0 && 0 !== t[e.next_in];

					)
						Tu.inflateReset(e), (o = Tu.inflate(e, s))
					switch (o) {
						case w0e:
						case Z$:
						case zL:
						case x0e:
							return this.onEnd(o), (this.ended = !0), !1
					}
					if (((a = e.avail_out), e.next_out && (0 === e.avail_out || o === QL)))
						if ("string" === this.options.to) {
							let c = Xv.utf8border(e.output, e.next_out),
								l = e.next_out - c,
								d = Xv.buf2string(e.output, c)
							;(e.next_out = l), (e.avail_out = i - l), l && e.output.set(e.output.subarray(c, c + l), 0), this.onData(d)
						} else this.onData(e.output.length === e.next_out ? e.output : e.output.subarray(0, e.next_out))
					if (o !== Zv || 0 !== a) {
						if (o === QL) return (o = Tu.inflateEnd(this.strm)), this.onEnd(o), (this.ended = !0), !0
						if (0 === e.avail_in) break
					}
				}
				return !0
			}),
				(Jv.prototype.onData = function (t) {
					this.chunks.push(t)
				}),
				(Jv.prototype.onEnd = function (t) {
					t === Zv && (this.result = "string" === this.options.to ? this.chunks.join("") : tM.flattenChunks(this.chunks)),
						(this.chunks = []),
						(this.err = t),
						(this.msg = this.strm.msg)
				})
			var F0e = {
				Inflate: Jv,
				inflate: GL,
				inflateRaw: function C0e(t, n) {
					return ((n = n || {}).raw = !0), GL(t, n)
				},
				ungzip: GL,
				constants: Wm
			}
			const { ungzip: N0e } = F0e
			var $L = N0e
			class J$ {
				constructor(n) {
					this.httpClient = n
				}
				getParameterByName(n) {
					const e = n.replaceAll(/[[\]]/g, "\\$&"),
						r = new RegExp(`[?&]${e}(=([^&#]*)|&|#|$)`).exec(window.location.href)
					return r ? (r[2] ? decodeURIComponent(r[2].replaceAll("+", " ")) : "") : null
				}
				getFileDataFromQueryParam() {
					var n = this
					return _r(function* () {
						const i = new URLSearchParams(window.location.search).getAll("file")
						if (0 === i.length) throw new Error("Filename is missing")
						return Promise.all(
							i.map(
								(function () {
									var r = _r(function* (o) {
										return n.getFileDataFromFile(o)
									})
									return function (o) {
										return r.apply(this, arguments)
									}
								})()
							)
						)
					})()
				}
				getFileDataFromFile(n) {
					var e = this
					return _r(function* () {
						if (!n) throw new Error("Filename is missing")
						return n.endsWith(".gz") ? e.getUnzippedFile(n) : e.getFile(n)
					})()
				}
				getUnzippedFile(n) {
					var e = this
					return _r(function* () {
						const i = yield B9(e.httpClient.get(n, { responseType: "arraybuffer", observe: "response" }))
						if (i.status >= 200 && i.status < 300) {
							const s = wD($L(i.body, { to: "string" }))
							return { fileName: e.getFileName(n, s.projectName), fileSize: 13, content: s }
						}
						throw new Error(`Could not load file "${n}"`)
					})()
				}
				getFile(n) {
					var e = this
					return _r(function* () {
						const i = yield B9(e.httpClient.get(n, { observe: "response" }))
						if (i.status >= 200 && i.status < 300) {
							const o = wD(i.body)
							return { fileName: (n = e.getFileName(n, o.projectName)), fileSize: 15, content: o }
						}
						throw new Error(`Could not load file "${n}"`)
					})()
				}
				getFileName(n, e) {
					return e?.trim() || n.split("/").pop()
				}
			}
			const lM = { fileName: "sample1.cc.json", fileSize: 3072, content: lme },
				dM = { fileName: "sample2.cc.json", fileSize: 2048, content: dme }
			let WL = (() => {
					class t {
						constructor(e, i, r, o, s) {
							;(this.store = e),
								(this.state = i),
								(this.dialog = r),
								(this.loadFileService = o),
								(this.httpClient = s),
								(this.urlUtils = new J$(this.httpClient))
						}
						loadFilesOrSampleFiles() {
							var e = this
							return _r(function* () {
								yield e.checkFileQueryParameterPresent() ? e.loadFilesFromQueryParams() : e.loadFilesFromIndexedDB()
							})()
						}
						checkFileQueryParameterPresent() {
							return !!this.urlUtils.getParameterByName("file")
						}
						loadFilesFromQueryParams() {
							var e = this
							return _r(function* () {
								try {
									const i = yield e.urlUtils.getFileDataFromQueryParam(),
										r = yield pD()
									if (!r) return e.loadFileService.loadFiles(i), void e.setRenderStateFromUrl()
									const o = r.files,
										s = o.map(l => T9(l.file)),
										a = i.map(l => l.content.fileChecksum),
										c = s.map(l => l.content.fileChecksum)
									ul(a) === ul(c) ? e.applySettingsAndFilesFromSavedState(o, r, s) : e.applySettingsFromSavedState(r, i),
										e.setRenderStateFromUrl()
								} catch (i) {
									yield e.handleErrorLoadFilesFromQueryParams(i)
								} finally {
									e.setMetricsFromUrl()
								}
							})()
						}
						applySettingsAndFilesFromSavedState(e, i, r) {
							const o = [],
								s = this.applyAppSettings(i.appSettings)
							o.push(...s), this.loadFileService.loadFiles(r), this.store.dispatch(mv({ value: e }))
							const a = this.applyFileSettings(i.fileSettings)
							o.push(...a)
							const c = this.applyDynamicSettings(i.dynamicSettings)
							o.push(...c), o.length > 0 && this.showErrorDialogForMissingProperties(o)
						}
						applySettingsFromSavedState(e, i) {
							this.applyAllSettings(e), this.loadFileService.loadFiles(i)
						}
						showErrorDialogForMissingProperties(e) {
							const r = this.buildMissingPropertiesMessage(e)
							this.showErrorDialog(
								"The previous state could not be fully restored after loading the page. The following properties were not restored.",
								r
							)
						}
						handleErrorLoadFilesFromQueryParams(e) {
							var i = this
							return _r(function* () {
								if (e.message !== fL) {
									const r = "File(s) could not be loaded from the given file URL parameter. Loaded sample files instead.",
										o = i.createTitleUrlErrorDialog(e)
									i.showErrorDialog(r, o)
								}
								yield i.loadSampleFiles()
							})()
						}
						loadFilesFromIndexedDB() {
							var e = this
							return _r(function* () {
								try {
									const i = yield pD()
									if (!i) return void (yield e.loadSampleFiles())
									const r = i.files,
										o = r.map(s => T9(s.file))
									e.applySettingsAndFilesFromSavedState(r, i, o)
								} catch (i) {
									yield e.handleErrorLoadFilesFromIndexedDB(i)
								}
							})()
						}
						handleErrorLoadFilesFromIndexedDB(e) {
							var i = this
							return _r(function* () {
								e.message !== fL &&
									i.showErrorDialog(
										"Previously loaded files and settings could not be restored. Loaded sample files instead.",
										e.message
									),
									yield i.loadSampleFiles()
							})()
						}
						applyAllSettings(e) {
							var i = this
							return _r(function* () {
								const r = e.fileSettings,
									o = e.dynamicSettings,
									s = e.appSettings,
									a = []
								if (r) {
									const c = i.applyFileSettings(r)
									a.push(...c)
								}
								if (o) {
									const c = i.applyDynamicSettings(o)
									a.push(...c)
								}
								if (s) {
									const c = i.applyAppSettings(s)
									a.push(...c)
								}
								a.length > 0 && i.showErrorDialogForMissingProperties(a)
							})()
						}
						applyFileSettings(e) {
							const i = this.state.getValue().fileSettings,
								r = []
							for (const [o, s] of Object.entries(i))
								o in e ? ul(s) !== ul(e[o]) && this.mapFileSettingToAction(o, e[o]) : r.push(o)
							return r
						}
						applyDynamicSettings(e) {
							const i = this.state.getValue().dynamicSettings,
								r = []
							for (const [o, s] of Object.entries(i))
								o in e ? ul(s) !== ul(e[o]) && this.mapDynamicSettingToAction(o, e[o]) : r.push(o)
							return r
						}
						applyAppSettings(e) {
							const i = this.state.getValue().appSettings,
								r = []
							for (const [o, s] of Object.entries(i))
								o in e ? ul(s) !== ul(e[o]) && this.mapAppSettingToAction(o, e[o]) : r.push(o)
							return r
						}
						mapFileSettingToAction(e, i) {
							switch (e) {
								case "attributeTypes":
									this.store.dispatch(JI({ value: i }))
									break
								case "attributeDescriptors":
									this.store.dispatch(ZI({ value: i }))
									break
								case "blacklist":
									this.store.dispatch(tD({ value: i }))
									break
								case "edges":
									this.store.dispatch(rD({ value: i }))
									break
								case "markedPackages":
									this.store.dispatch(hE({ value: i }))
									break
								default:
									throw new Error(`Unhandled key: ${e}`)
							}
						}
						mapDynamicSettingToAction(e, i) {
							switch (e) {
								case "areaMetric":
									this.store.dispatch(gu({ value: i }))
									break
								case "heightMetric":
									this.store.dispatch(bu({ value: i }))
									break
								case "edgeMetric":
									this.store.dispatch(Oh({ value: i }))
									break
								case "colorMetric":
									this.store.dispatch(hl({ value: i }))
									break
								case "colorMode":
									this.store.dispatch(sv({ value: i }))
									break
								case "sortingOption":
									this.store.dispatch(lE({ value: i }))
									break
								case "colorRange":
									this.store.dispatch(sd({ value: i }))
									break
								case "distributionMetric":
									this.store.dispatch(av({ value: i }))
									break
								case "focusedNodePath":
									this.store.dispatch(sE({ value: i }))
									break
								case "searchPattern":
									this.store.dispatch(Nh({ value: i }))
									break
								case "margin":
									this.store.dispatch(lv({ value: i }))
									break
								default:
									throw new Error(`Unhandled key: ${e}`)
							}
						}
						mapAppSettingToAction(e, i) {
							switch (e) {
								case "amountOfTopLabels":
								case "amountOfEdgePreviews":
									this.store.dispatch(Lm({ value: i }))
									break
								case "edgeHeight":
									this.store.dispatch(j0({ value: i }))
									break
								case "scaling":
									this.store.dispatch(tv({ value: i }))
									break
								case "hideFlatBuildings":
									this.store.dispatch(X0({ value: i }))
									break
								case "invertHeight":
									this.store.dispatch(q0({ value: i }))
									break
								case "invertArea":
									this.store.dispatch(Y0({ value: i }))
									break
								case "isWhiteBackground":
									this.store.dispatch(Z0({ value: i }))
									break
								case "mapColors":
									this.store.dispatch(Au({ value: i }))
									break
								case "isPresentationMode":
									this.store.dispatch(nE({ value: i }))
									break
								case "showOnlyBuildingsWithEdges":
									this.store.dispatch(ov({ value: i }))
									break
								case "isEdgeMetricVisible":
									this.store.dispatch(XI({ value: i }))
									break
								case "resetCameraIfNewFileIsLoaded":
									this.store.dispatch(oE({ value: i }))
									break
								case "isLoadingMap":
									this.store.dispatch(fg({ value: i }))
									break
								case "isLoadingFile":
									this.store.dispatch(Dm({ value: i }))
									break
								case "sortingOrderAscending":
								case "isSearchPanelPinned":
									break
								case "showMetricLabelNameValue":
									this.store.dispatch(iv({ value: i }))
									break
								case "showMetricLabelNodeName":
									this.store.dispatch(rv({ value: i }))
									break
								case "layoutAlgorithm":
									this.store.dispatch(J0({ value: i }))
									break
								case "maxTreeMapFiles":
									this.store.dispatch(ev({ value: i }))
									break
								case "sharpnessMode":
									this.store.dispatch(nv({ value: i }))
									break
								case "experimentalFeaturesEnabled":
									this.store.dispatch(eE({ value: i }))
									break
								case "screenshotToClipboardEnabled":
									this.store.dispatch(JC({ value: i }))
									break
								case "colorLabels":
									this.store.dispatch(W0({ value: i }))
									break
								case "isColorMetricLinkedToHeightMetric":
									this.store.dispatch(YI({ value: i }))
									break
								case "enableFloorLabels":
									this.store.dispatch(K0({ value: i }))
									break
								default:
									throw new Error(`Unhandled key: ${e}`)
							}
						}
						buildMissingPropertiesMessage(e) {
							return `${lL('<i class="fa fa-exclamation-triangle"></i> ', e)}`
						}
						loadSampleFiles() {
							var e = this
							return _r(function* () {
								try {
									const i = yield pD()
									i && e.applyAllSettings(i), e.loadFileService.loadFiles([lM, dM])
								} catch {
									e.loadFileService.loadFiles([lM, dM])
								}
							})()
						}
						showErrorDialog(e, i) {
							this.dialog.open(yg, { data: { title: e, message: i } })
						}
						createTitleUrlErrorDialog(e) {
							let i = "Error"
							return (
								e.message ? (i += ` (${e.message})`) : e.statusText && e.status && (i += ` (${e.status}: ${e.statusText})`),
								i
							)
						}
						setMetricsFromUrl() {
							const e = this.urlUtils.getParameterByName(ud.areaMetric),
								i = this.urlUtils.getParameterByName(ud.heightMetric),
								r = this.urlUtils.getParameterByName(ud.colorMetric),
								o = this.urlUtils.getParameterByName(ud.edgeMetric),
								s = this.state.getValue(),
								a = Fs(s).nodeMetricData,
								c = Fs(s).edgeMetricData
							if (!a) return
							const l = new Set(a.map(u => u.name)),
								d = c.map(u => u.name)
							e && l.has(e) && this.store.dispatch(gu({ value: e })),
								i && l.has(i) && this.store.dispatch(bu({ value: i })),
								r && l.has(r) && this.store.dispatch(hl({ value: r })),
								o && d.includes(o) && this.store.dispatch(Oh({ value: o }))
						}
						setRenderStateFromUrl() {
							const e = this.urlUtils.getParameterByName("mode"),
								i = (function hme(t) {
									return t.map(n => n.file)
								})(this.state.getValue().files)
							"Delta" === e && i.length >= 2 && this.store.dispatch(CE({ referenceFile: i[0], comparisonFile: i[1] }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(Sr), re(la), re(wg), re(J2))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				j0e = (() => {
					class t {
						constructor() {
							this.version = Iv.i8
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-logo"]],
								decls: 5,
								vars: 1,
								consts: [
									["id", "logo"],
									[
										"href",
										"https://github.com/MaibornWolff/codecharta",
										"target",
										"_blank",
										"rel",
										"noopener noreferrer"
									],
									["src", "codeCharta/assets/codecharta_logo.svg", "alt", "CodeCharta", "rel", "noopener noreferrer"]
								],
								template: function (i, r) {
									1 & i && (F(0, "div", 0)(1, "a", 1), fe(2, "img", 2), L(), F(3, "h2"), ge(4), L()()),
										2 & i && (T(4), Vt("Version ", r.version, ""))
								},
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const Tr = t => t.appSettings,
				jL = Mt(Tr, t => t.isLoadingFile),
				eW = Mt(Tr, t => t.sharpnessMode),
				KL = "126",
				K0e = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
				X0e = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
				tW = 0,
				XL = 1,
				nW = 2,
				Y0e = 3,
				q0e = 0,
				YL = 1,
				iW = 2,
				Bg = 3,
				Ig = 0,
				Lo = 1,
				ey = 2,
				qL = 1,
				Z0e = 2,
				Fu = 0,
				Dg = 1,
				ZL = 2,
				JL = 3,
				eR = 4,
				rW = 5,
				Zm = 100,
				oW = 101,
				sW = 102,
				tR = 103,
				nR = 104,
				aW = 200,
				cW = 201,
				lW = 202,
				dW = 203,
				iR = 204,
				rR = 205,
				uW = 206,
				hW = 207,
				fW = 208,
				mW = 209,
				pW = 210,
				AW = 0,
				gW = 1,
				bW = 2,
				uM = 3,
				_W = 4,
				vW = 5,
				yW = 6,
				wW = 7,
				ty = 0,
				xW = 1,
				CW = 2,
				Jm = 0,
				EW = 1,
				MW = 2,
				SW = 3,
				kW = 4,
				TW = 5,
				hM = 300,
				ny = 301,
				iy = 302,
				fM = 303,
				mM = 304,
				Lg = 306,
				ry = 307,
				ep = 1e3,
				ua = 1001,
				oy = 1002,
				ts = 1003,
				pM = 1004,
				J0e = 1004,
				AM = 1005,
				eve = 1005,
				xo = 1006,
				oR = 1007,
				tve = 1007,
				Rg = 1008,
				nve = 1008,
				Pg = 1009,
				FW = 1010,
				BW = 1011,
				sy = 1012,
				IW = 1013,
				ay = 1014,
				Bu = 1015,
				cy = 1016,
				DW = 1017,
				LW = 1018,
				RW = 1019,
				Og = 1020,
				PW = 1021,
				Xh = 1022,
				ha = 1023,
				OW = 1024,
				NW = 1025,
				UW = ha,
				tp = 1026,
				Ng = 1027,
				HW = 1028,
				VW = 1029,
				QW = 1030,
				zW = 1031,
				GW = 1032,
				$W = 1033,
				sR = 33776,
				aR = 33777,
				cR = 33778,
				lR = 33779,
				dR = 35840,
				uR = 35841,
				hR = 35842,
				fR = 35843,
				WW = 36196,
				mR = 37492,
				pR = 37496,
				jW = 37808,
				KW = 37809,
				XW = 37810,
				YW = 37811,
				qW = 37812,
				ZW = 37813,
				JW = 37814,
				ej = 37815,
				tj = 37816,
				nj = 37817,
				ij = 37818,
				rj = 37819,
				oj = 37820,
				sj = 37821,
				aj = 36492,
				cj = 37840,
				lj = 37841,
				dj = 37842,
				uj = 37843,
				hj = 37844,
				fj = 37845,
				mj = 37846,
				pj = 37847,
				Aj = 37848,
				gj = 37849,
				bj = 37850,
				_j = 37851,
				vj = 37852,
				yj = 37853,
				wj = 2200,
				xj = 2201,
				Cj = 2202,
				ly = 2300,
				dy = 2301,
				gM = 2302,
				np = 2400,
				ip = 2401,
				uy = 2402,
				bM = 2500,
				AR = 2501,
				Ej = 0,
				ive = 1,
				rve = 2,
				fa = 3e3,
				hy = 3001,
				_M = 3007,
				vM = 3002,
				Mj = 3003,
				gR = 3004,
				bR = 3005,
				_R = 3006,
				Sj = 3200,
				kj = 3201,
				rp = 0,
				Tj = 1,
				ove = 0,
				yM = 7680,
				sve = 7681,
				ave = 7682,
				cve = 7683,
				lve = 34055,
				dve = 34056,
				uve = 5386,
				hve = 512,
				fve = 513,
				mve = 514,
				pve = 515,
				Ave = 516,
				gve = 517,
				bve = 518,
				Fj = 519,
				fy = 35044,
				op = 35048,
				_ve = 35040,
				vve = 35045,
				yve = 35049,
				wve = 35041,
				xve = 35046,
				Cve = 35050,
				Eve = 35042,
				Mve = "100",
				vR = "300 es"
			function Iu() {}
			Object.assign(Iu.prototype, {
				addEventListener: function (t, n) {
					void 0 === this._listeners && (this._listeners = {})
					const e = this._listeners
					void 0 === e[t] && (e[t] = []), -1 === e[t].indexOf(n) && e[t].push(n)
				},
				hasEventListener: function (t, n) {
					if (void 0 === this._listeners) return !1
					const e = this._listeners
					return void 0 !== e[t] && -1 !== e[t].indexOf(n)
				},
				removeEventListener: function (t, n) {
					if (void 0 === this._listeners) return
					const i = this._listeners[t]
					if (void 0 !== i) {
						const r = i.indexOf(n)
						;-1 !== r && i.splice(r, 1)
					}
				},
				dispatchEvent: function (t) {
					if (void 0 === this._listeners) return
					const e = this._listeners[t.type]
					if (void 0 !== e) {
						t.target = this
						const i = e.slice(0)
						for (let r = 0, o = i.length; r < o; r++) i[r].call(this, t)
					}
				}
			})
			const Is = []
			for (let t = 0; t < 256; t++) Is[t] = (t < 16 ? "0" : "") + t.toString(16)
			let wM = 1234567
			const jn = {
				DEG2RAD: Math.PI / 180,
				RAD2DEG: 180 / Math.PI,
				generateUUID: function () {
					const t = (4294967295 * Math.random()) | 0,
						n = (4294967295 * Math.random()) | 0,
						e = (4294967295 * Math.random()) | 0,
						i = (4294967295 * Math.random()) | 0
					return (
						Is[255 & t] +
						Is[(t >> 8) & 255] +
						Is[(t >> 16) & 255] +
						Is[(t >> 24) & 255] +
						"-" +
						Is[255 & n] +
						Is[(n >> 8) & 255] +
						"-" +
						Is[((n >> 16) & 15) | 64] +
						Is[(n >> 24) & 255] +
						"-" +
						Is[(63 & e) | 128] +
						Is[(e >> 8) & 255] +
						"-" +
						Is[(e >> 16) & 255] +
						Is[(e >> 24) & 255] +
						Is[255 & i] +
						Is[(i >> 8) & 255] +
						Is[(i >> 16) & 255] +
						Is[(i >> 24) & 255]
					).toUpperCase()
				},
				clamp: function (t, n, e) {
					return Math.max(n, Math.min(e, t))
				},
				euclideanModulo: function (t, n) {
					return ((t % n) + n) % n
				},
				mapLinear: function (t, n, e, i, r) {
					return i + ((t - n) * (r - i)) / (e - n)
				},
				lerp: function (t, n, e) {
					return (1 - e) * t + e * n
				},
				damp: function (t, n, e, i) {
					return jn.lerp(t, n, 1 - Math.exp(-e * i))
				},
				pingpong: function (t, n = 1) {
					return n - Math.abs(jn.euclideanModulo(t, 2 * n) - n)
				},
				smoothstep: function (t, n, e) {
					return t <= n ? 0 : t >= e ? 1 : (t = (t - n) / (e - n)) * t * (3 - 2 * t)
				},
				smootherstep: function (t, n, e) {
					return t <= n ? 0 : t >= e ? 1 : (t = (t - n) / (e - n)) * t * t * (t * (6 * t - 15) + 10)
				},
				randInt: function (t, n) {
					return t + Math.floor(Math.random() * (n - t + 1))
				},
				randFloat: function (t, n) {
					return t + Math.random() * (n - t)
				},
				randFloatSpread: function (t) {
					return t * (0.5 - Math.random())
				},
				seededRandom: function (t) {
					return void 0 !== t && (wM = t % 2147483647), (wM = (16807 * wM) % 2147483647), (wM - 1) / 2147483646
				},
				degToRad: function (t) {
					return t * jn.DEG2RAD
				},
				radToDeg: function (t) {
					return t * jn.RAD2DEG
				},
				isPowerOfTwo: function (t) {
					return 0 == (t & (t - 1)) && 0 !== t
				},
				ceilPowerOfTwo: function (t) {
					return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
				},
				floorPowerOfTwo: function (t) {
					return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
				},
				setQuaternionFromProperEuler: function (t, n, e, i, r) {
					const o = Math.cos,
						s = Math.sin,
						a = o(e / 2),
						c = s(e / 2),
						l = o((n + i) / 2),
						d = s((n + i) / 2),
						u = o((n - i) / 2),
						h = s((n - i) / 2),
						f = o((i - n) / 2),
						_ = s((i - n) / 2)
					switch (r) {
						case "XYX":
							t.set(a * d, c * u, c * h, a * l)
							break
						case "YZY":
							t.set(c * h, a * d, c * u, a * l)
							break
						case "ZXZ":
							t.set(c * u, c * h, a * d, a * l)
							break
						case "XZX":
							t.set(a * d, c * _, c * f, a * l)
							break
						case "YXY":
							t.set(c * f, a * d, c * _, a * l)
							break
						case "ZYZ":
							t.set(c * _, c * f, a * d, a * l)
							break
						default:
							console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
					}
				}
			}
			class lt {
				constructor(n = 0, e = 0) {
					;(this.x = n), (this.y = e)
				}
				get width() {
					return this.x
				}
				set width(n) {
					this.x = n
				}
				get height() {
					return this.y
				}
				set height(n) {
					this.y = n
				}
				set(n, e) {
					return (this.x = n), (this.y = e), this
				}
				setScalar(n) {
					return (this.x = n), (this.y = n), this
				}
				setX(n) {
					return (this.x = n), this
				}
				setY(n) {
					return (this.y = n), this
				}
				setComponent(n, e) {
					switch (n) {
						case 0:
							this.x = e
							break
						case 1:
							this.y = e
							break
						default:
							throw new Error("index is out of range: " + n)
					}
					return this
				}
				getComponent(n) {
					switch (n) {
						case 0:
							return this.x
						case 1:
							return this.y
						default:
							throw new Error("index is out of range: " + n)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y)
				}
				copy(n) {
					return (this.x = n.x), (this.y = n.y), this
				}
				add(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
						  this.addVectors(n, e))
						: ((this.x += n.x), (this.y += n.y), this)
				}
				addScalar(n) {
					return (this.x += n), (this.y += n), this
				}
				addVectors(n, e) {
					return (this.x = n.x + e.x), (this.y = n.y + e.y), this
				}
				addScaledVector(n, e) {
					return (this.x += n.x * e), (this.y += n.y * e), this
				}
				sub(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
						  this.subVectors(n, e))
						: ((this.x -= n.x), (this.y -= n.y), this)
				}
				subScalar(n) {
					return (this.x -= n), (this.y -= n), this
				}
				subVectors(n, e) {
					return (this.x = n.x - e.x), (this.y = n.y - e.y), this
				}
				multiply(n) {
					return (this.x *= n.x), (this.y *= n.y), this
				}
				multiplyScalar(n) {
					return (this.x *= n), (this.y *= n), this
				}
				divide(n) {
					return (this.x /= n.x), (this.y /= n.y), this
				}
				divideScalar(n) {
					return this.multiplyScalar(1 / n)
				}
				applyMatrix3(n) {
					const e = this.x,
						i = this.y,
						r = n.elements
					return (this.x = r[0] * e + r[3] * i + r[6]), (this.y = r[1] * e + r[4] * i + r[7]), this
				}
				min(n) {
					return (this.x = Math.min(this.x, n.x)), (this.y = Math.min(this.y, n.y)), this
				}
				max(n) {
					return (this.x = Math.max(this.x, n.x)), (this.y = Math.max(this.y, n.y)), this
				}
				clamp(n, e) {
					return (this.x = Math.max(n.x, Math.min(e.x, this.x))), (this.y = Math.max(n.y, Math.min(e.y, this.y))), this
				}
				clampScalar(n, e) {
					return (this.x = Math.max(n, Math.min(e, this.x))), (this.y = Math.max(n, Math.min(e, this.y))), this
				}
				clampLength(n, e) {
					const i = this.length()
					return this.divideScalar(i || 1).multiplyScalar(Math.max(n, Math.min(e, i)))
				}
				floor() {
					return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
				}
				ceil() {
					return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
				}
				round() {
					return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
				}
				roundToZero() {
					return (
						(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
						(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
						this
					)
				}
				negate() {
					return (this.x = -this.x), (this.y = -this.y), this
				}
				dot(n) {
					return this.x * n.x + this.y * n.y
				}
				cross(n) {
					return this.x * n.y - this.y * n.x
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				angle() {
					return Math.atan2(-this.y, -this.x) + Math.PI
				}
				distanceTo(n) {
					return Math.sqrt(this.distanceToSquared(n))
				}
				distanceToSquared(n) {
					const e = this.x - n.x,
						i = this.y - n.y
					return e * e + i * i
				}
				manhattanDistanceTo(n) {
					return Math.abs(this.x - n.x) + Math.abs(this.y - n.y)
				}
				setLength(n) {
					return this.normalize().multiplyScalar(n)
				}
				lerp(n, e) {
					return (this.x += (n.x - this.x) * e), (this.y += (n.y - this.y) * e), this
				}
				lerpVectors(n, e, i) {
					return (this.x = n.x + (e.x - n.x) * i), (this.y = n.y + (e.y - n.y) * i), this
				}
				equals(n) {
					return n.x === this.x && n.y === this.y
				}
				fromArray(n, e = 0) {
					return (this.x = n[e]), (this.y = n[e + 1]), this
				}
				toArray(n = [], e = 0) {
					return (n[e] = this.x), (n[e + 1] = this.y), n
				}
				fromBufferAttribute(n, e, i) {
					return (
						void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
						(this.x = n.getX(e)),
						(this.y = n.getY(e)),
						this
					)
				}
				rotateAround(n, e) {
					const i = Math.cos(e),
						r = Math.sin(e),
						o = this.x - n.x,
						s = this.y - n.y
					return (this.x = o * i - s * r + n.x), (this.y = o * r + s * i + n.y), this
				}
				random() {
					return (this.x = Math.random()), (this.y = Math.random()), this
				}
			}
			lt.prototype.isVector2 = !0
			class ns {
				constructor() {
					;(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
						arguments.length > 0 &&
							console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
				}
				set(n, e, i, r, o, s, a, c, l) {
					const d = this.elements
					return (d[0] = n), (d[1] = r), (d[2] = a), (d[3] = e), (d[4] = o), (d[5] = c), (d[6] = i), (d[7] = s), (d[8] = l), this
				}
				identity() {
					return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
				}
				copy(n) {
					const e = this.elements,
						i = n.elements
					return (
						(e[0] = i[0]),
						(e[1] = i[1]),
						(e[2] = i[2]),
						(e[3] = i[3]),
						(e[4] = i[4]),
						(e[5] = i[5]),
						(e[6] = i[6]),
						(e[7] = i[7]),
						(e[8] = i[8]),
						this
					)
				}
				extractBasis(n, e, i) {
					return n.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
				}
				setFromMatrix4(n) {
					const e = n.elements
					return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
				}
				multiply(n) {
					return this.multiplyMatrices(this, n)
				}
				premultiply(n) {
					return this.multiplyMatrices(n, this)
				}
				multiplyMatrices(n, e) {
					const i = n.elements,
						r = e.elements,
						o = this.elements,
						s = i[0],
						a = i[3],
						c = i[6],
						l = i[1],
						d = i[4],
						u = i[7],
						h = i[2],
						f = i[5],
						_ = i[8],
						y = r[0],
						C = r[3],
						x = r[6],
						w = r[1],
						S = r[4],
						M = r[7],
						O = r[2],
						N = r[5],
						j = r[8]
					return (
						(o[0] = s * y + a * w + c * O),
						(o[3] = s * C + a * S + c * N),
						(o[6] = s * x + a * M + c * j),
						(o[1] = l * y + d * w + u * O),
						(o[4] = l * C + d * S + u * N),
						(o[7] = l * x + d * M + u * j),
						(o[2] = h * y + f * w + _ * O),
						(o[5] = h * C + f * S + _ * N),
						(o[8] = h * x + f * M + _ * j),
						this
					)
				}
				multiplyScalar(n) {
					const e = this.elements
					return (
						(e[0] *= n),
						(e[3] *= n),
						(e[6] *= n),
						(e[1] *= n),
						(e[4] *= n),
						(e[7] *= n),
						(e[2] *= n),
						(e[5] *= n),
						(e[8] *= n),
						this
					)
				}
				determinant() {
					const n = this.elements,
						e = n[0],
						i = n[1],
						r = n[2],
						o = n[3],
						s = n[4],
						a = n[5],
						c = n[6],
						l = n[7],
						d = n[8]
					return e * s * d - e * a * l - i * o * d + i * a * c + r * o * l - r * s * c
				}
				invert() {
					const n = this.elements,
						e = n[0],
						i = n[1],
						r = n[2],
						o = n[3],
						s = n[4],
						a = n[5],
						c = n[6],
						l = n[7],
						d = n[8],
						u = d * s - a * l,
						h = a * c - d * o,
						f = l * o - s * c,
						_ = e * u + i * h + r * f
					if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
					const y = 1 / _
					return (
						(n[0] = u * y),
						(n[1] = (r * l - d * i) * y),
						(n[2] = (a * i - r * s) * y),
						(n[3] = h * y),
						(n[4] = (d * e - r * c) * y),
						(n[5] = (r * o - a * e) * y),
						(n[6] = f * y),
						(n[7] = (i * c - l * e) * y),
						(n[8] = (s * e - i * o) * y),
						this
					)
				}
				transpose() {
					let n
					const e = this.elements
					return (
						(n = e[1]),
						(e[1] = e[3]),
						(e[3] = n),
						(n = e[2]),
						(e[2] = e[6]),
						(e[6] = n),
						(n = e[5]),
						(e[5] = e[7]),
						(e[7] = n),
						this
					)
				}
				getNormalMatrix(n) {
					return this.setFromMatrix4(n).invert().transpose()
				}
				transposeIntoArray(n) {
					const e = this.elements
					return (
						(n[0] = e[0]),
						(n[1] = e[3]),
						(n[2] = e[6]),
						(n[3] = e[1]),
						(n[4] = e[4]),
						(n[5] = e[7]),
						(n[6] = e[2]),
						(n[7] = e[5]),
						(n[8] = e[8]),
						this
					)
				}
				setUvTransform(n, e, i, r, o, s, a) {
					const c = Math.cos(o),
						l = Math.sin(o)
					return this.set(i * c, i * l, -i * (c * s + l * a) + s + n, -r * l, r * c, -r * (-l * s + c * a) + a + e, 0, 0, 1), this
				}
				scale(n, e) {
					const i = this.elements
					return (i[0] *= n), (i[3] *= n), (i[6] *= n), (i[1] *= e), (i[4] *= e), (i[7] *= e), this
				}
				rotate(n) {
					const e = Math.cos(n),
						i = Math.sin(n),
						r = this.elements,
						o = r[0],
						s = r[3],
						a = r[6],
						c = r[1],
						l = r[4],
						d = r[7]
					return (
						(r[0] = e * o + i * c),
						(r[3] = e * s + i * l),
						(r[6] = e * a + i * d),
						(r[1] = -i * o + e * c),
						(r[4] = -i * s + e * l),
						(r[7] = -i * a + e * d),
						this
					)
				}
				translate(n, e) {
					const i = this.elements
					return (
						(i[0] += n * i[2]),
						(i[3] += n * i[5]),
						(i[6] += n * i[8]),
						(i[1] += e * i[2]),
						(i[4] += e * i[5]),
						(i[7] += e * i[8]),
						this
					)
				}
				equals(n) {
					const e = this.elements,
						i = n.elements
					for (let r = 0; r < 9; r++) if (e[r] !== i[r]) return !1
					return !0
				}
				fromArray(n, e = 0) {
					for (let i = 0; i < 9; i++) this.elements[i] = n[i + e]
					return this
				}
				toArray(n = [], e = 0) {
					const i = this.elements
					return (
						(n[e] = i[0]),
						(n[e + 1] = i[1]),
						(n[e + 2] = i[2]),
						(n[e + 3] = i[3]),
						(n[e + 4] = i[4]),
						(n[e + 5] = i[5]),
						(n[e + 6] = i[6]),
						(n[e + 7] = i[7]),
						(n[e + 8] = i[8]),
						n
					)
				}
				clone() {
					return new this.constructor().fromArray(this.elements)
				}
			}
			let Ug
			ns.prototype.isMatrix3 = !0
			const sp = {
				getDataURL: function (t) {
					if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src
					let n
					if (t instanceof HTMLCanvasElement) n = t
					else {
						void 0 === Ug && (Ug = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
							(Ug.width = t.width),
							(Ug.height = t.height)
						const e = Ug.getContext("2d")
						t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), (n = Ug)
					}
					return n.width > 2048 || n.height > 2048 ? n.toDataURL("image/jpeg", 0.6) : n.toDataURL("image/png")
				}
			}
			let Sve = 0
			class zo extends Iu {
				constructor(n = zo.DEFAULT_IMAGE, e = zo.DEFAULT_MAPPING, i = ua, r = ua, o = xo, s = Rg, a = ha, c = Pg, l = 1, d = fa) {
					super(),
						Object.defineProperty(this, "id", { value: Sve++ }),
						(this.uuid = jn.generateUUID()),
						(this.name = ""),
						(this.image = n),
						(this.mipmaps = []),
						(this.mapping = e),
						(this.wrapS = i),
						(this.wrapT = r),
						(this.magFilter = o),
						(this.minFilter = s),
						(this.anisotropy = l),
						(this.format = a),
						(this.internalFormat = null),
						(this.type = c),
						(this.offset = new lt(0, 0)),
						(this.repeat = new lt(1, 1)),
						(this.center = new lt(0, 0)),
						(this.rotation = 0),
						(this.matrixAutoUpdate = !0),
						(this.matrix = new ns()),
						(this.generateMipmaps = !0),
						(this.premultiplyAlpha = !1),
						(this.flipY = !0),
						(this.unpackAlignment = 4),
						(this.encoding = d),
						(this.version = 0),
						(this.onUpdate = null)
				}
				updateMatrix() {
					this.matrix.setUvTransform(
						this.offset.x,
						this.offset.y,
						this.repeat.x,
						this.repeat.y,
						this.rotation,
						this.center.x,
						this.center.y
					)
				}
				clone() {
					return new this.constructor().copy(this)
				}
				copy(n) {
					return (
						(this.name = n.name),
						(this.image = n.image),
						(this.mipmaps = n.mipmaps.slice(0)),
						(this.mapping = n.mapping),
						(this.wrapS = n.wrapS),
						(this.wrapT = n.wrapT),
						(this.magFilter = n.magFilter),
						(this.minFilter = n.minFilter),
						(this.anisotropy = n.anisotropy),
						(this.format = n.format),
						(this.internalFormat = n.internalFormat),
						(this.type = n.type),
						this.offset.copy(n.offset),
						this.repeat.copy(n.repeat),
						this.center.copy(n.center),
						(this.rotation = n.rotation),
						(this.matrixAutoUpdate = n.matrixAutoUpdate),
						this.matrix.copy(n.matrix),
						(this.generateMipmaps = n.generateMipmaps),
						(this.premultiplyAlpha = n.premultiplyAlpha),
						(this.flipY = n.flipY),
						(this.unpackAlignment = n.unpackAlignment),
						(this.encoding = n.encoding),
						this
					)
				}
				toJSON(n) {
					const e = void 0 === n || "string" == typeof n
					if (!e && void 0 !== n.textures[this.uuid]) return n.textures[this.uuid]
					const i = {
						metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
						uuid: this.uuid,
						name: this.name,
						mapping: this.mapping,
						repeat: [this.repeat.x, this.repeat.y],
						offset: [this.offset.x, this.offset.y],
						center: [this.center.x, this.center.y],
						rotation: this.rotation,
						wrap: [this.wrapS, this.wrapT],
						format: this.format,
						type: this.type,
						encoding: this.encoding,
						minFilter: this.minFilter,
						magFilter: this.magFilter,
						anisotropy: this.anisotropy,
						flipY: this.flipY,
						premultiplyAlpha: this.premultiplyAlpha,
						unpackAlignment: this.unpackAlignment
					}
					if (void 0 !== this.image) {
						const r = this.image
						if ((void 0 === r.uuid && (r.uuid = jn.generateUUID()), !e && void 0 === n.images[r.uuid])) {
							let o
							if (Array.isArray(r)) {
								o = []
								for (let s = 0, a = r.length; s < a; s++) o.push(yR(r[s].isDataTexture ? r[s].image : r[s]))
							} else o = yR(r)
							n.images[r.uuid] = { uuid: r.uuid, url: o }
						}
						i.image = r.uuid
					}
					return e || (n.textures[this.uuid] = i), i
				}
				dispose() {
					this.dispatchEvent({ type: "dispose" })
				}
				transformUv(n) {
					if (this.mapping !== hM) return n
					if ((n.applyMatrix3(this.matrix), n.x < 0 || n.x > 1))
						switch (this.wrapS) {
							case ep:
								n.x = n.x - Math.floor(n.x)
								break
							case ua:
								n.x = n.x < 0 ? 0 : 1
								break
							case oy:
								n.x = 1 === Math.abs(Math.floor(n.x) % 2) ? Math.ceil(n.x) - n.x : n.x - Math.floor(n.x)
						}
					if (n.y < 0 || n.y > 1)
						switch (this.wrapT) {
							case ep:
								n.y = n.y - Math.floor(n.y)
								break
							case ua:
								n.y = n.y < 0 ? 0 : 1
								break
							case oy:
								n.y = 1 === Math.abs(Math.floor(n.y) % 2) ? Math.ceil(n.y) - n.y : n.y - Math.floor(n.y)
						}
					return this.flipY && (n.y = 1 - n.y), n
				}
				set needsUpdate(n) {
					!0 === n && this.version++
				}
			}
			function yR(t) {
				return (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
					(typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
					(typeof ImageBitmap < "u" && t instanceof ImageBitmap)
					? sp.getDataURL(t)
					: t.data
					? { data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name }
					: (console.warn("THREE.Texture: Unable to serialize Texture."), {})
			}
			;(zo.DEFAULT_IMAGE = void 0), (zo.DEFAULT_MAPPING = hM), (zo.prototype.isTexture = !0)
			class lr {
				constructor(n = 0, e = 0, i = 0, r = 1) {
					;(this.x = n), (this.y = e), (this.z = i), (this.w = r)
				}
				get width() {
					return this.z
				}
				set width(n) {
					this.z = n
				}
				get height() {
					return this.w
				}
				set height(n) {
					this.w = n
				}
				set(n, e, i, r) {
					return (this.x = n), (this.y = e), (this.z = i), (this.w = r), this
				}
				setScalar(n) {
					return (this.x = n), (this.y = n), (this.z = n), (this.w = n), this
				}
				setX(n) {
					return (this.x = n), this
				}
				setY(n) {
					return (this.y = n), this
				}
				setZ(n) {
					return (this.z = n), this
				}
				setW(n) {
					return (this.w = n), this
				}
				setComponent(n, e) {
					switch (n) {
						case 0:
							this.x = e
							break
						case 1:
							this.y = e
							break
						case 2:
							this.z = e
							break
						case 3:
							this.w = e
							break
						default:
							throw new Error("index is out of range: " + n)
					}
					return this
				}
				getComponent(n) {
					switch (n) {
						case 0:
							return this.x
						case 1:
							return this.y
						case 2:
							return this.z
						case 3:
							return this.w
						default:
							throw new Error("index is out of range: " + n)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y, this.z, this.w)
				}
				copy(n) {
					return (this.x = n.x), (this.y = n.y), (this.z = n.z), (this.w = void 0 !== n.w ? n.w : 1), this
				}
				add(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
						  this.addVectors(n, e))
						: ((this.x += n.x), (this.y += n.y), (this.z += n.z), (this.w += n.w), this)
				}
				addScalar(n) {
					return (this.x += n), (this.y += n), (this.z += n), (this.w += n), this
				}
				addVectors(n, e) {
					return (this.x = n.x + e.x), (this.y = n.y + e.y), (this.z = n.z + e.z), (this.w = n.w + e.w), this
				}
				addScaledVector(n, e) {
					return (this.x += n.x * e), (this.y += n.y * e), (this.z += n.z * e), (this.w += n.w * e), this
				}
				sub(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
						  this.subVectors(n, e))
						: ((this.x -= n.x), (this.y -= n.y), (this.z -= n.z), (this.w -= n.w), this)
				}
				subScalar(n) {
					return (this.x -= n), (this.y -= n), (this.z -= n), (this.w -= n), this
				}
				subVectors(n, e) {
					return (this.x = n.x - e.x), (this.y = n.y - e.y), (this.z = n.z - e.z), (this.w = n.w - e.w), this
				}
				multiply(n) {
					return (this.x *= n.x), (this.y *= n.y), (this.z *= n.z), (this.w *= n.w), this
				}
				multiplyScalar(n) {
					return (this.x *= n), (this.y *= n), (this.z *= n), (this.w *= n), this
				}
				applyMatrix4(n) {
					const e = this.x,
						i = this.y,
						r = this.z,
						o = this.w,
						s = n.elements
					return (
						(this.x = s[0] * e + s[4] * i + s[8] * r + s[12] * o),
						(this.y = s[1] * e + s[5] * i + s[9] * r + s[13] * o),
						(this.z = s[2] * e + s[6] * i + s[10] * r + s[14] * o),
						(this.w = s[3] * e + s[7] * i + s[11] * r + s[15] * o),
						this
					)
				}
				divideScalar(n) {
					return this.multiplyScalar(1 / n)
				}
				setAxisAngleFromQuaternion(n) {
					this.w = 2 * Math.acos(n.w)
					const e = Math.sqrt(1 - n.w * n.w)
					return (
						e < 1e-4
							? ((this.x = 1), (this.y = 0), (this.z = 0))
							: ((this.x = n.x / e), (this.y = n.y / e), (this.z = n.z / e)),
						this
					)
				}
				setAxisAngleFromRotationMatrix(n) {
					let e, i, r, o
					const c = n.elements,
						l = c[0],
						d = c[4],
						u = c[8],
						h = c[1],
						f = c[5],
						_ = c[9],
						y = c[2],
						C = c[6],
						x = c[10]
					if (Math.abs(d - h) < 0.01 && Math.abs(u - y) < 0.01 && Math.abs(_ - C) < 0.01) {
						if (Math.abs(d + h) < 0.1 && Math.abs(u + y) < 0.1 && Math.abs(_ + C) < 0.1 && Math.abs(l + f + x - 3) < 0.1)
							return this.set(1, 0, 0, 0), this
						e = Math.PI
						const S = (l + 1) / 2,
							M = (f + 1) / 2,
							O = (x + 1) / 2,
							N = (d + h) / 4,
							j = (u + y) / 4,
							le = (_ + C) / 4
						return (
							S > M && S > O
								? S < 0.01
									? ((i = 0), (r = 0.707106781), (o = 0.707106781))
									: ((i = Math.sqrt(S)), (r = N / i), (o = j / i))
								: M > O
								? M < 0.01
									? ((i = 0.707106781), (r = 0), (o = 0.707106781))
									: ((r = Math.sqrt(M)), (i = N / r), (o = le / r))
								: O < 0.01
								? ((i = 0.707106781), (r = 0.707106781), (o = 0))
								: ((o = Math.sqrt(O)), (i = j / o), (r = le / o)),
							this.set(i, r, o, e),
							this
						)
					}
					let w = Math.sqrt((C - _) * (C - _) + (u - y) * (u - y) + (h - d) * (h - d))
					return (
						Math.abs(w) < 0.001 && (w = 1),
						(this.x = (C - _) / w),
						(this.y = (u - y) / w),
						(this.z = (h - d) / w),
						(this.w = Math.acos((l + f + x - 1) / 2)),
						this
					)
				}
				min(n) {
					return (
						(this.x = Math.min(this.x, n.x)),
						(this.y = Math.min(this.y, n.y)),
						(this.z = Math.min(this.z, n.z)),
						(this.w = Math.min(this.w, n.w)),
						this
					)
				}
				max(n) {
					return (
						(this.x = Math.max(this.x, n.x)),
						(this.y = Math.max(this.y, n.y)),
						(this.z = Math.max(this.z, n.z)),
						(this.w = Math.max(this.w, n.w)),
						this
					)
				}
				clamp(n, e) {
					return (
						(this.x = Math.max(n.x, Math.min(e.x, this.x))),
						(this.y = Math.max(n.y, Math.min(e.y, this.y))),
						(this.z = Math.max(n.z, Math.min(e.z, this.z))),
						(this.w = Math.max(n.w, Math.min(e.w, this.w))),
						this
					)
				}
				clampScalar(n, e) {
					return (
						(this.x = Math.max(n, Math.min(e, this.x))),
						(this.y = Math.max(n, Math.min(e, this.y))),
						(this.z = Math.max(n, Math.min(e, this.z))),
						(this.w = Math.max(n, Math.min(e, this.w))),
						this
					)
				}
				clampLength(n, e) {
					const i = this.length()
					return this.divideScalar(i || 1).multiplyScalar(Math.max(n, Math.min(e, i)))
				}
				floor() {
					return (
						(this.x = Math.floor(this.x)),
						(this.y = Math.floor(this.y)),
						(this.z = Math.floor(this.z)),
						(this.w = Math.floor(this.w)),
						this
					)
				}
				ceil() {
					return (
						(this.x = Math.ceil(this.x)),
						(this.y = Math.ceil(this.y)),
						(this.z = Math.ceil(this.z)),
						(this.w = Math.ceil(this.w)),
						this
					)
				}
				round() {
					return (
						(this.x = Math.round(this.x)),
						(this.y = Math.round(this.y)),
						(this.z = Math.round(this.z)),
						(this.w = Math.round(this.w)),
						this
					)
				}
				roundToZero() {
					return (
						(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
						(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
						(this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
						(this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
						this
					)
				}
				negate() {
					return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this
				}
				dot(n) {
					return this.x * n.x + this.y * n.y + this.z * n.z + this.w * n.w
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				setLength(n) {
					return this.normalize().multiplyScalar(n)
				}
				lerp(n, e) {
					return (
						(this.x += (n.x - this.x) * e),
						(this.y += (n.y - this.y) * e),
						(this.z += (n.z - this.z) * e),
						(this.w += (n.w - this.w) * e),
						this
					)
				}
				lerpVectors(n, e, i) {
					return (
						(this.x = n.x + (e.x - n.x) * i),
						(this.y = n.y + (e.y - n.y) * i),
						(this.z = n.z + (e.z - n.z) * i),
						(this.w = n.w + (e.w - n.w) * i),
						this
					)
				}
				equals(n) {
					return n.x === this.x && n.y === this.y && n.z === this.z && n.w === this.w
				}
				fromArray(n, e = 0) {
					return (this.x = n[e]), (this.y = n[e + 1]), (this.z = n[e + 2]), (this.w = n[e + 3]), this
				}
				toArray(n = [], e = 0) {
					return (n[e] = this.x), (n[e + 1] = this.y), (n[e + 2] = this.z), (n[e + 3] = this.w), n
				}
				fromBufferAttribute(n, e, i) {
					return (
						void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
						(this.x = n.getX(e)),
						(this.y = n.getY(e)),
						(this.z = n.getZ(e)),
						(this.w = n.getW(e)),
						this
					)
				}
				random() {
					return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), (this.w = Math.random()), this
				}
			}
			lr.prototype.isVector4 = !0
			class ml extends Iu {
				constructor(n, e, i) {
					super(),
						(this.width = n),
						(this.height = e),
						(this.depth = 1),
						(this.scissor = new lr(0, 0, n, e)),
						(this.scissorTest = !1),
						(this.viewport = new lr(0, 0, n, e)),
						(this.texture = new zo(
							void 0,
							(i = i || {}).mapping,
							i.wrapS,
							i.wrapT,
							i.magFilter,
							i.minFilter,
							i.format,
							i.type,
							i.anisotropy,
							i.encoding
						)),
						(this.texture.image = {}),
						(this.texture.image.width = n),
						(this.texture.image.height = e),
						(this.texture.image.depth = 1),
						(this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps),
						(this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : xo),
						(this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
						(this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer),
						(this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null)
				}
				setTexture(n) {
					;(n.image = { width: this.width, height: this.height, depth: this.depth }), (this.texture = n)
				}
				setSize(n, e, i = 1) {
					;(this.width !== n || this.height !== e || this.depth !== i) &&
						((this.width = n),
						(this.height = e),
						(this.depth = i),
						(this.texture.image.width = n),
						(this.texture.image.height = e),
						(this.texture.image.depth = i),
						this.dispose()),
						this.viewport.set(0, 0, n, e),
						this.scissor.set(0, 0, n, e)
				}
				clone() {
					return new this.constructor().copy(this)
				}
				copy(n) {
					return (
						(this.width = n.width),
						(this.height = n.height),
						(this.depth = n.depth),
						this.viewport.copy(n.viewport),
						(this.texture = n.texture.clone()),
						(this.depthBuffer = n.depthBuffer),
						(this.stencilBuffer = n.stencilBuffer),
						(this.depthTexture = n.depthTexture),
						this
					)
				}
				dispose() {
					this.dispatchEvent({ type: "dispose" })
				}
			}
			ml.prototype.isWebGLRenderTarget = !0
			class Bj extends ml {
				constructor(n, e, i) {
					super(n, e, i), (this.samples = 4)
				}
				copy(n) {
					return super.copy.call(this, n), (this.samples = n.samples), this
				}
			}
			Bj.prototype.isWebGLMultisampleRenderTarget = !0
			class fs {
				constructor(n = 0, e = 0, i = 0, r = 1) {
					;(this._x = n), (this._y = e), (this._z = i), (this._w = r)
				}
				static slerp(n, e, i, r) {
					return i.copy(n).slerp(e, r)
				}
				static slerpFlat(n, e, i, r, o, s, a) {
					let c = i[r + 0],
						l = i[r + 1],
						d = i[r + 2],
						u = i[r + 3]
					const h = o[s + 0],
						f = o[s + 1],
						_ = o[s + 2],
						y = o[s + 3]
					if (0 === a) return (n[e + 0] = c), (n[e + 1] = l), (n[e + 2] = d), void (n[e + 3] = u)
					if (1 === a) return (n[e + 0] = h), (n[e + 1] = f), (n[e + 2] = _), void (n[e + 3] = y)
					if (u !== y || c !== h || l !== f || d !== _) {
						let C = 1 - a
						const x = c * h + l * f + d * _ + u * y,
							w = x >= 0 ? 1 : -1,
							S = 1 - x * x
						if (S > Number.EPSILON) {
							const O = Math.sqrt(S),
								N = Math.atan2(O, x * w)
							;(C = Math.sin(C * N) / O), (a = Math.sin(a * N) / O)
						}
						const M = a * w
						if (((c = c * C + h * M), (l = l * C + f * M), (d = d * C + _ * M), (u = u * C + y * M), C === 1 - a)) {
							const O = 1 / Math.sqrt(c * c + l * l + d * d + u * u)
							;(c *= O), (l *= O), (d *= O), (u *= O)
						}
					}
					;(n[e] = c), (n[e + 1] = l), (n[e + 2] = d), (n[e + 3] = u)
				}
				static multiplyQuaternionsFlat(n, e, i, r, o, s) {
					const a = i[r],
						c = i[r + 1],
						l = i[r + 2],
						d = i[r + 3],
						u = o[s],
						h = o[s + 1],
						f = o[s + 2],
						_ = o[s + 3]
					return (
						(n[e] = a * _ + d * u + c * f - l * h),
						(n[e + 1] = c * _ + d * h + l * u - a * f),
						(n[e + 2] = l * _ + d * f + a * h - c * u),
						(n[e + 3] = d * _ - a * u - c * h - l * f),
						n
					)
				}
				get x() {
					return this._x
				}
				set x(n) {
					;(this._x = n), this._onChangeCallback()
				}
				get y() {
					return this._y
				}
				set y(n) {
					;(this._y = n), this._onChangeCallback()
				}
				get z() {
					return this._z
				}
				set z(n) {
					;(this._z = n), this._onChangeCallback()
				}
				get w() {
					return this._w
				}
				set w(n) {
					;(this._w = n), this._onChangeCallback()
				}
				set(n, e, i, r) {
					return (this._x = n), (this._y = e), (this._z = i), (this._w = r), this._onChangeCallback(), this
				}
				clone() {
					return new this.constructor(this._x, this._y, this._z, this._w)
				}
				copy(n) {
					return (this._x = n.x), (this._y = n.y), (this._z = n.z), (this._w = n.w), this._onChangeCallback(), this
				}
				setFromEuler(n, e) {
					if (!n || !n.isEuler)
						throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.")
					const i = n._x,
						r = n._y,
						o = n._z,
						s = n._order,
						a = Math.cos,
						c = Math.sin,
						l = a(i / 2),
						d = a(r / 2),
						u = a(o / 2),
						h = c(i / 2),
						f = c(r / 2),
						_ = c(o / 2)
					switch (s) {
						case "XYZ":
							;(this._x = h * d * u + l * f * _),
								(this._y = l * f * u - h * d * _),
								(this._z = l * d * _ + h * f * u),
								(this._w = l * d * u - h * f * _)
							break
						case "YXZ":
							;(this._x = h * d * u + l * f * _),
								(this._y = l * f * u - h * d * _),
								(this._z = l * d * _ - h * f * u),
								(this._w = l * d * u + h * f * _)
							break
						case "ZXY":
							;(this._x = h * d * u - l * f * _),
								(this._y = l * f * u + h * d * _),
								(this._z = l * d * _ + h * f * u),
								(this._w = l * d * u - h * f * _)
							break
						case "ZYX":
							;(this._x = h * d * u - l * f * _),
								(this._y = l * f * u + h * d * _),
								(this._z = l * d * _ - h * f * u),
								(this._w = l * d * u + h * f * _)
							break
						case "YZX":
							;(this._x = h * d * u + l * f * _),
								(this._y = l * f * u + h * d * _),
								(this._z = l * d * _ - h * f * u),
								(this._w = l * d * u - h * f * _)
							break
						case "XZY":
							;(this._x = h * d * u - l * f * _),
								(this._y = l * f * u - h * d * _),
								(this._z = l * d * _ + h * f * u),
								(this._w = l * d * u + h * f * _)
							break
						default:
							console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
					}
					return !1 !== e && this._onChangeCallback(), this
				}
				setFromAxisAngle(n, e) {
					const i = e / 2,
						r = Math.sin(i)
					return (
						(this._x = n.x * r),
						(this._y = n.y * r),
						(this._z = n.z * r),
						(this._w = Math.cos(i)),
						this._onChangeCallback(),
						this
					)
				}
				setFromRotationMatrix(n) {
					const e = n.elements,
						i = e[0],
						r = e[4],
						o = e[8],
						s = e[1],
						a = e[5],
						c = e[9],
						l = e[2],
						d = e[6],
						u = e[10],
						h = i + a + u
					if (h > 0) {
						const f = 0.5 / Math.sqrt(h + 1)
						;(this._w = 0.25 / f), (this._x = (d - c) * f), (this._y = (o - l) * f), (this._z = (s - r) * f)
					} else if (i > a && i > u) {
						const f = 2 * Math.sqrt(1 + i - a - u)
						;(this._w = (d - c) / f), (this._x = 0.25 * f), (this._y = (r + s) / f), (this._z = (o + l) / f)
					} else if (a > u) {
						const f = 2 * Math.sqrt(1 + a - i - u)
						;(this._w = (o - l) / f), (this._x = (r + s) / f), (this._y = 0.25 * f), (this._z = (c + d) / f)
					} else {
						const f = 2 * Math.sqrt(1 + u - i - a)
						;(this._w = (s - r) / f), (this._x = (o + l) / f), (this._y = (c + d) / f), (this._z = 0.25 * f)
					}
					return this._onChangeCallback(), this
				}
				setFromUnitVectors(n, e) {
					let r = n.dot(e) + 1
					return (
						r < 1e-6
							? ((r = 0),
							  Math.abs(n.x) > Math.abs(n.z)
									? ((this._x = -n.y), (this._y = n.x), (this._z = 0), (this._w = r))
									: ((this._x = 0), (this._y = -n.z), (this._z = n.y), (this._w = r)))
							: ((this._x = n.y * e.z - n.z * e.y),
							  (this._y = n.z * e.x - n.x * e.z),
							  (this._z = n.x * e.y - n.y * e.x),
							  (this._w = r)),
						this.normalize()
					)
				}
				angleTo(n) {
					return 2 * Math.acos(Math.abs(jn.clamp(this.dot(n), -1, 1)))
				}
				rotateTowards(n, e) {
					const i = this.angleTo(n)
					if (0 === i) return this
					const r = Math.min(1, e / i)
					return this.slerp(n, r), this
				}
				identity() {
					return this.set(0, 0, 0, 1)
				}
				invert() {
					return this.conjugate()
				}
				conjugate() {
					return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this
				}
				dot(n) {
					return this._x * n._x + this._y * n._y + this._z * n._z + this._w * n._w
				}
				lengthSq() {
					return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
				}
				length() {
					return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
				}
				normalize() {
					let n = this.length()
					return (
						0 === n
							? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
							: ((n = 1 / n),
							  (this._x = this._x * n),
							  (this._y = this._y * n),
							  (this._z = this._z * n),
							  (this._w = this._w * n)),
						this._onChangeCallback(),
						this
					)
				}
				multiply(n, e) {
					return void 0 !== e
						? (console.warn(
								"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
						  ),
						  this.multiplyQuaternions(n, e))
						: this.multiplyQuaternions(this, n)
				}
				premultiply(n) {
					return this.multiplyQuaternions(n, this)
				}
				multiplyQuaternions(n, e) {
					const i = n._x,
						r = n._y,
						o = n._z,
						s = n._w,
						a = e._x,
						c = e._y,
						l = e._z,
						d = e._w
					return (
						(this._x = i * d + s * a + r * l - o * c),
						(this._y = r * d + s * c + o * a - i * l),
						(this._z = o * d + s * l + i * c - r * a),
						(this._w = s * d - i * a - r * c - o * l),
						this._onChangeCallback(),
						this
					)
				}
				slerp(n, e) {
					if (0 === e) return this
					if (1 === e) return this.copy(n)
					const i = this._x,
						r = this._y,
						o = this._z,
						s = this._w
					let a = s * n._w + i * n._x + r * n._y + o * n._z
					if (
						(a < 0 ? ((this._w = -n._w), (this._x = -n._x), (this._y = -n._y), (this._z = -n._z), (a = -a)) : this.copy(n),
						a >= 1)
					)
						return (this._w = s), (this._x = i), (this._y = r), (this._z = o), this
					const c = 1 - a * a
					if (c <= Number.EPSILON) {
						const f = 1 - e
						return (
							(this._w = f * s + e * this._w),
							(this._x = f * i + e * this._x),
							(this._y = f * r + e * this._y),
							(this._z = f * o + e * this._z),
							this.normalize(),
							this._onChangeCallback(),
							this
						)
					}
					const l = Math.sqrt(c),
						d = Math.atan2(l, a),
						u = Math.sin((1 - e) * d) / l,
						h = Math.sin(e * d) / l
					return (
						(this._w = s * u + this._w * h),
						(this._x = i * u + this._x * h),
						(this._y = r * u + this._y * h),
						(this._z = o * u + this._z * h),
						this._onChangeCallback(),
						this
					)
				}
				equals(n) {
					return n._x === this._x && n._y === this._y && n._z === this._z && n._w === this._w
				}
				fromArray(n, e = 0) {
					return (
						(this._x = n[e]), (this._y = n[e + 1]), (this._z = n[e + 2]), (this._w = n[e + 3]), this._onChangeCallback(), this
					)
				}
				toArray(n = [], e = 0) {
					return (n[e] = this._x), (n[e + 1] = this._y), (n[e + 2] = this._z), (n[e + 3] = this._w), n
				}
				fromBufferAttribute(n, e) {
					return (this._x = n.getX(e)), (this._y = n.getY(e)), (this._z = n.getZ(e)), (this._w = n.getW(e)), this
				}
				_onChange(n) {
					return (this._onChangeCallback = n), this
				}
				_onChangeCallback() {}
			}
			fs.prototype.isQuaternion = !0
			class K {
				constructor(n = 0, e = 0, i = 0) {
					;(this.x = n), (this.y = e), (this.z = i)
				}
				set(n, e, i) {
					return void 0 === i && (i = this.z), (this.x = n), (this.y = e), (this.z = i), this
				}
				setScalar(n) {
					return (this.x = n), (this.y = n), (this.z = n), this
				}
				setX(n) {
					return (this.x = n), this
				}
				setY(n) {
					return (this.y = n), this
				}
				setZ(n) {
					return (this.z = n), this
				}
				setComponent(n, e) {
					switch (n) {
						case 0:
							this.x = e
							break
						case 1:
							this.y = e
							break
						case 2:
							this.z = e
							break
						default:
							throw new Error("index is out of range: " + n)
					}
					return this
				}
				getComponent(n) {
					switch (n) {
						case 0:
							return this.x
						case 1:
							return this.y
						case 2:
							return this.z
						default:
							throw new Error("index is out of range: " + n)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y, this.z)
				}
				copy(n) {
					return (this.x = n.x), (this.y = n.y), (this.z = n.z), this
				}
				add(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
						  this.addVectors(n, e))
						: ((this.x += n.x), (this.y += n.y), (this.z += n.z), this)
				}
				addScalar(n) {
					return (this.x += n), (this.y += n), (this.z += n), this
				}
				addVectors(n, e) {
					return (this.x = n.x + e.x), (this.y = n.y + e.y), (this.z = n.z + e.z), this
				}
				addScaledVector(n, e) {
					return (this.x += n.x * e), (this.y += n.y * e), (this.z += n.z * e), this
				}
				sub(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
						  this.subVectors(n, e))
						: ((this.x -= n.x), (this.y -= n.y), (this.z -= n.z), this)
				}
				subScalar(n) {
					return (this.x -= n), (this.y -= n), (this.z -= n), this
				}
				subVectors(n, e) {
					return (this.x = n.x - e.x), (this.y = n.y - e.y), (this.z = n.z - e.z), this
				}
				multiply(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
						  this.multiplyVectors(n, e))
						: ((this.x *= n.x), (this.y *= n.y), (this.z *= n.z), this)
				}
				multiplyScalar(n) {
					return (this.x *= n), (this.y *= n), (this.z *= n), this
				}
				multiplyVectors(n, e) {
					return (this.x = n.x * e.x), (this.y = n.y * e.y), (this.z = n.z * e.z), this
				}
				applyEuler(n) {
					return (
						(n && n.isEuler) ||
							console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
						this.applyQuaternion(Ij.setFromEuler(n))
					)
				}
				applyAxisAngle(n, e) {
					return this.applyQuaternion(Ij.setFromAxisAngle(n, e))
				}
				applyMatrix3(n) {
					const e = this.x,
						i = this.y,
						r = this.z,
						o = n.elements
					return (
						(this.x = o[0] * e + o[3] * i + o[6] * r),
						(this.y = o[1] * e + o[4] * i + o[7] * r),
						(this.z = o[2] * e + o[5] * i + o[8] * r),
						this
					)
				}
				applyNormalMatrix(n) {
					return this.applyMatrix3(n).normalize()
				}
				applyMatrix4(n) {
					const e = this.x,
						i = this.y,
						r = this.z,
						o = n.elements,
						s = 1 / (o[3] * e + o[7] * i + o[11] * r + o[15])
					return (
						(this.x = (o[0] * e + o[4] * i + o[8] * r + o[12]) * s),
						(this.y = (o[1] * e + o[5] * i + o[9] * r + o[13]) * s),
						(this.z = (o[2] * e + o[6] * i + o[10] * r + o[14]) * s),
						this
					)
				}
				applyQuaternion(n) {
					const e = this.x,
						i = this.y,
						r = this.z,
						o = n.x,
						s = n.y,
						a = n.z,
						c = n.w,
						l = c * e + s * r - a * i,
						d = c * i + a * e - o * r,
						u = c * r + o * i - s * e,
						h = -o * e - s * i - a * r
					return (
						(this.x = l * c + h * -o + d * -a - u * -s),
						(this.y = d * c + h * -s + u * -o - l * -a),
						(this.z = u * c + h * -a + l * -s - d * -o),
						this
					)
				}
				project(n) {
					return this.applyMatrix4(n.matrixWorldInverse).applyMatrix4(n.projectionMatrix)
				}
				unproject(n) {
					return this.applyMatrix4(n.projectionMatrixInverse).applyMatrix4(n.matrixWorld)
				}
				transformDirection(n) {
					const e = this.x,
						i = this.y,
						r = this.z,
						o = n.elements
					return (
						(this.x = o[0] * e + o[4] * i + o[8] * r),
						(this.y = o[1] * e + o[5] * i + o[9] * r),
						(this.z = o[2] * e + o[6] * i + o[10] * r),
						this.normalize()
					)
				}
				divide(n) {
					return (this.x /= n.x), (this.y /= n.y), (this.z /= n.z), this
				}
				divideScalar(n) {
					return this.multiplyScalar(1 / n)
				}
				min(n) {
					return (this.x = Math.min(this.x, n.x)), (this.y = Math.min(this.y, n.y)), (this.z = Math.min(this.z, n.z)), this
				}
				max(n) {
					return (this.x = Math.max(this.x, n.x)), (this.y = Math.max(this.y, n.y)), (this.z = Math.max(this.z, n.z)), this
				}
				clamp(n, e) {
					return (
						(this.x = Math.max(n.x, Math.min(e.x, this.x))),
						(this.y = Math.max(n.y, Math.min(e.y, this.y))),
						(this.z = Math.max(n.z, Math.min(e.z, this.z))),
						this
					)
				}
				clampScalar(n, e) {
					return (
						(this.x = Math.max(n, Math.min(e, this.x))),
						(this.y = Math.max(n, Math.min(e, this.y))),
						(this.z = Math.max(n, Math.min(e, this.z))),
						this
					)
				}
				clampLength(n, e) {
					const i = this.length()
					return this.divideScalar(i || 1).multiplyScalar(Math.max(n, Math.min(e, i)))
				}
				floor() {
					return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this
				}
				ceil() {
					return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this
				}
				round() {
					return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this
				}
				roundToZero() {
					return (
						(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
						(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
						(this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
						this
					)
				}
				negate() {
					return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
				}
				dot(n) {
					return this.x * n.x + this.y * n.y + this.z * n.z
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y + this.z * this.z
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				setLength(n) {
					return this.normalize().multiplyScalar(n)
				}
				lerp(n, e) {
					return (this.x += (n.x - this.x) * e), (this.y += (n.y - this.y) * e), (this.z += (n.z - this.z) * e), this
				}
				lerpVectors(n, e, i) {
					return (this.x = n.x + (e.x - n.x) * i), (this.y = n.y + (e.y - n.y) * i), (this.z = n.z + (e.z - n.z) * i), this
				}
				cross(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
						  this.crossVectors(n, e))
						: this.crossVectors(this, n)
				}
				crossVectors(n, e) {
					const i = n.x,
						r = n.y,
						o = n.z,
						s = e.x,
						a = e.y,
						c = e.z
					return (this.x = r * c - o * a), (this.y = o * s - i * c), (this.z = i * a - r * s), this
				}
				projectOnVector(n) {
					const e = n.lengthSq()
					if (0 === e) return this.set(0, 0, 0)
					const i = n.dot(this) / e
					return this.copy(n).multiplyScalar(i)
				}
				projectOnPlane(n) {
					return wR.copy(this).projectOnVector(n), this.sub(wR)
				}
				reflect(n) {
					return this.sub(wR.copy(n).multiplyScalar(2 * this.dot(n)))
				}
				angleTo(n) {
					const e = Math.sqrt(this.lengthSq() * n.lengthSq())
					if (0 === e) return Math.PI / 2
					const i = this.dot(n) / e
					return Math.acos(jn.clamp(i, -1, 1))
				}
				distanceTo(n) {
					return Math.sqrt(this.distanceToSquared(n))
				}
				distanceToSquared(n) {
					const e = this.x - n.x,
						i = this.y - n.y,
						r = this.z - n.z
					return e * e + i * i + r * r
				}
				manhattanDistanceTo(n) {
					return Math.abs(this.x - n.x) + Math.abs(this.y - n.y) + Math.abs(this.z - n.z)
				}
				setFromSpherical(n) {
					return this.setFromSphericalCoords(n.radius, n.phi, n.theta)
				}
				setFromSphericalCoords(n, e, i) {
					const r = Math.sin(e) * n
					return (this.x = r * Math.sin(i)), (this.y = Math.cos(e) * n), (this.z = r * Math.cos(i)), this
				}
				setFromCylindrical(n) {
					return this.setFromCylindricalCoords(n.radius, n.theta, n.y)
				}
				setFromCylindricalCoords(n, e, i) {
					return (this.x = n * Math.sin(e)), (this.y = i), (this.z = n * Math.cos(e)), this
				}
				setFromMatrixPosition(n) {
					const e = n.elements
					return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
				}
				setFromMatrixScale(n) {
					const e = this.setFromMatrixColumn(n, 0).length(),
						i = this.setFromMatrixColumn(n, 1).length(),
						r = this.setFromMatrixColumn(n, 2).length()
					return (this.x = e), (this.y = i), (this.z = r), this
				}
				setFromMatrixColumn(n, e) {
					return this.fromArray(n.elements, 4 * e)
				}
				setFromMatrix3Column(n, e) {
					return this.fromArray(n.elements, 3 * e)
				}
				equals(n) {
					return n.x === this.x && n.y === this.y && n.z === this.z
				}
				fromArray(n, e = 0) {
					return (this.x = n[e]), (this.y = n[e + 1]), (this.z = n[e + 2]), this
				}
				toArray(n = [], e = 0) {
					return (n[e] = this.x), (n[e + 1] = this.y), (n[e + 2] = this.z), n
				}
				fromBufferAttribute(n, e, i) {
					return (
						void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
						(this.x = n.getX(e)),
						(this.y = n.getY(e)),
						(this.z = n.getZ(e)),
						this
					)
				}
				random() {
					return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this
				}
			}
			K.prototype.isVector3 = !0
			const wR = new K(),
				Ij = new fs()
			class is {
				constructor(n = new K(1 / 0, 1 / 0, 1 / 0), e = new K(-1 / 0, -1 / 0, -1 / 0)) {
					;(this.min = n), (this.max = e)
				}
				set(n, e) {
					return this.min.copy(n), this.max.copy(e), this
				}
				setFromArray(n) {
					let e = 1 / 0,
						i = 1 / 0,
						r = 1 / 0,
						o = -1 / 0,
						s = -1 / 0,
						a = -1 / 0
					for (let c = 0, l = n.length; c < l; c += 3) {
						const d = n[c],
							u = n[c + 1],
							h = n[c + 2]
						d < e && (e = d), u < i && (i = u), h < r && (r = h), d > o && (o = d), u > s && (s = u), h > a && (a = h)
					}
					return this.min.set(e, i, r), this.max.set(o, s, a), this
				}
				setFromBufferAttribute(n) {
					let e = 1 / 0,
						i = 1 / 0,
						r = 1 / 0,
						o = -1 / 0,
						s = -1 / 0,
						a = -1 / 0
					for (let c = 0, l = n.count; c < l; c++) {
						const d = n.getX(c),
							u = n.getY(c),
							h = n.getZ(c)
						d < e && (e = d), u < i && (i = u), h < r && (r = h), d > o && (o = d), u > s && (s = u), h > a && (a = h)
					}
					return this.min.set(e, i, r), this.max.set(o, s, a), this
				}
				setFromPoints(n) {
					this.makeEmpty()
					for (let e = 0, i = n.length; e < i; e++) this.expandByPoint(n[e])
					return this
				}
				setFromCenterAndSize(n, e) {
					const i = my.copy(e).multiplyScalar(0.5)
					return this.min.copy(n).sub(i), this.max.copy(n).add(i), this
				}
				setFromObject(n) {
					return this.makeEmpty(), this.expandByObject(n)
				}
				clone() {
					return new this.constructor().copy(this)
				}
				copy(n) {
					return this.min.copy(n.min), this.max.copy(n.max), this
				}
				makeEmpty() {
					return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this
				}
				isEmpty() {
					return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
				}
				getCenter(n) {
					return (
						void 0 === n && (console.warn("THREE.Box3: .getCenter() target is now required"), (n = new K())),
						this.isEmpty() ? n.set(0, 0, 0) : n.addVectors(this.min, this.max).multiplyScalar(0.5)
					)
				}
				getSize(n) {
					return (
						void 0 === n && (console.warn("THREE.Box3: .getSize() target is now required"), (n = new K())),
						this.isEmpty() ? n.set(0, 0, 0) : n.subVectors(this.max, this.min)
					)
				}
				expandByPoint(n) {
					return this.min.min(n), this.max.max(n), this
				}
				expandByVector(n) {
					return this.min.sub(n), this.max.add(n), this
				}
				expandByScalar(n) {
					return this.min.addScalar(-n), this.max.addScalar(n), this
				}
				expandByObject(n) {
					n.updateWorldMatrix(!1, !1)
					const e = n.geometry
					void 0 !== e &&
						(null === e.boundingBox && e.computeBoundingBox(),
						xR.copy(e.boundingBox),
						xR.applyMatrix4(n.matrixWorld),
						this.union(xR))
					const i = n.children
					for (let r = 0, o = i.length; r < o; r++) this.expandByObject(i[r])
					return this
				}
				containsPoint(n) {
					return !(
						n.x < this.min.x ||
						n.x > this.max.x ||
						n.y < this.min.y ||
						n.y > this.max.y ||
						n.z < this.min.z ||
						n.z > this.max.z
					)
				}
				containsBox(n) {
					return (
						this.min.x <= n.min.x &&
						n.max.x <= this.max.x &&
						this.min.y <= n.min.y &&
						n.max.y <= this.max.y &&
						this.min.z <= n.min.z &&
						n.max.z <= this.max.z
					)
				}
				getParameter(n, e) {
					return (
						void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), (e = new K())),
						e.set(
							(n.x - this.min.x) / (this.max.x - this.min.x),
							(n.y - this.min.y) / (this.max.y - this.min.y),
							(n.z - this.min.z) / (this.max.z - this.min.z)
						)
					)
				}
				intersectsBox(n) {
					return !(
						n.max.x < this.min.x ||
						n.min.x > this.max.x ||
						n.max.y < this.min.y ||
						n.min.y > this.max.y ||
						n.max.z < this.min.z ||
						n.min.z > this.max.z
					)
				}
				intersectsSphere(n) {
					return this.clampPoint(n.center, my), my.distanceToSquared(n.center) <= n.radius * n.radius
				}
				intersectsPlane(n) {
					let e, i
					return (
						n.normal.x > 0
							? ((e = n.normal.x * this.min.x), (i = n.normal.x * this.max.x))
							: ((e = n.normal.x * this.max.x), (i = n.normal.x * this.min.x)),
						n.normal.y > 0
							? ((e += n.normal.y * this.min.y), (i += n.normal.y * this.max.y))
							: ((e += n.normal.y * this.max.y), (i += n.normal.y * this.min.y)),
						n.normal.z > 0
							? ((e += n.normal.z * this.min.z), (i += n.normal.z * this.max.z))
							: ((e += n.normal.z * this.max.z), (i += n.normal.z * this.min.z)),
						e <= -n.constant && i >= -n.constant
					)
				}
				intersectsTriangle(n) {
					if (this.isEmpty()) return !1
					this.getCenter(py),
						xM.subVectors(this.max, py),
						Hg.subVectors(n.a, py),
						Vg.subVectors(n.b, py),
						Qg.subVectors(n.c, py),
						Yh.subVectors(Vg, Hg),
						qh.subVectors(Qg, Vg),
						ap.subVectors(Hg, Qg)
					let e = [
						0,
						-Yh.z,
						Yh.y,
						0,
						-qh.z,
						qh.y,
						0,
						-ap.z,
						ap.y,
						Yh.z,
						0,
						-Yh.x,
						qh.z,
						0,
						-qh.x,
						ap.z,
						0,
						-ap.x,
						-Yh.y,
						Yh.x,
						0,
						-qh.y,
						qh.x,
						0,
						-ap.y,
						ap.x,
						0
					]
					return (
						!(!CR(e, Hg, Vg, Qg, xM) || ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !CR(e, Hg, Vg, Qg, xM))) &&
						(CM.crossVectors(Yh, qh), (e = [CM.x, CM.y, CM.z]), CR(e, Hg, Vg, Qg, xM))
					)
				}
				clampPoint(n, e) {
					return (
						void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), (e = new K())),
						e.copy(n).clamp(this.min, this.max)
					)
				}
				distanceToPoint(n) {
					return my.copy(n).clamp(this.min, this.max).sub(n).length()
				}
				getBoundingSphere(n) {
					return (
						void 0 === n && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
						this.getCenter(n.center),
						(n.radius = 0.5 * this.getSize(my).length()),
						n
					)
				}
				intersect(n) {
					return this.min.max(n.min), this.max.min(n.max), this.isEmpty() && this.makeEmpty(), this
				}
				union(n) {
					return this.min.min(n.min), this.max.max(n.max), this
				}
				applyMatrix4(n) {
					return (
						this.isEmpty() ||
							(Du[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(n),
							Du[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(n),
							Du[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(n),
							Du[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(n),
							Du[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(n),
							Du[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(n),
							Du[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(n),
							Du[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(n),
							this.setFromPoints(Du)),
						this
					)
				}
				translate(n) {
					return this.min.add(n), this.max.add(n), this
				}
				equals(n) {
					return n.min.equals(this.min) && n.max.equals(this.max)
				}
			}
			is.prototype.isBox3 = !0
			const Du = [new K(), new K(), new K(), new K(), new K(), new K(), new K(), new K()],
				my = new K(),
				xR = new is(),
				Hg = new K(),
				Vg = new K(),
				Qg = new K(),
				Yh = new K(),
				qh = new K(),
				ap = new K(),
				py = new K(),
				xM = new K(),
				CM = new K(),
				cp = new K()
			function CR(t, n, e, i, r) {
				for (let o = 0, s = t.length - 3; o <= s; o += 3) {
					cp.fromArray(t, o)
					const a = r.x * Math.abs(cp.x) + r.y * Math.abs(cp.y) + r.z * Math.abs(cp.z),
						c = n.dot(cp),
						l = e.dot(cp),
						d = i.dot(cp)
					if (Math.max(-Math.max(c, l, d), Math.min(c, l, d)) > a) return !1
				}
				return !0
			}
			const kve = new is()
			class xd {
				constructor(n = new K(), e = -1) {
					;(this.center = n), (this.radius = e)
				}
				set(n, e) {
					return this.center.copy(n), (this.radius = e), this
				}
				setFromPoints(n, e) {
					const i = this.center
					void 0 !== e ? i.copy(e) : kve.setFromPoints(n).getCenter(i)
					let r = 0
					for (let o = 0, s = n.length; o < s; o++) r = Math.max(r, i.distanceToSquared(n[o]))
					return (this.radius = Math.sqrt(r)), this
				}
				copy(n) {
					return this.center.copy(n.center), (this.radius = n.radius), this
				}
				isEmpty() {
					return this.radius < 0
				}
				makeEmpty() {
					return this.center.set(0, 0, 0), (this.radius = -1), this
				}
				containsPoint(n) {
					return n.distanceToSquared(this.center) <= this.radius * this.radius
				}
				distanceToPoint(n) {
					return n.distanceTo(this.center) - this.radius
				}
				intersectsSphere(n) {
					const e = this.radius + n.radius
					return n.center.distanceToSquared(this.center) <= e * e
				}
				intersectsBox(n) {
					return n.intersectsSphere(this)
				}
				intersectsPlane(n) {
					return Math.abs(n.distanceToPoint(this.center)) <= this.radius
				}
				clampPoint(n, e) {
					const i = this.center.distanceToSquared(n)
					return (
						void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), (e = new K())),
						e.copy(n),
						i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)),
						e
					)
				}
				getBoundingBox(n) {
					return (
						void 0 === n && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), (n = new is())),
						this.isEmpty() ? (n.makeEmpty(), n) : (n.set(this.center, this.center), n.expandByScalar(this.radius), n)
					)
				}
				applyMatrix4(n) {
					return this.center.applyMatrix4(n), (this.radius = this.radius * n.getMaxScaleOnAxis()), this
				}
				translate(n) {
					return this.center.add(n), this
				}
				equals(n) {
					return n.center.equals(this.center) && n.radius === this.radius
				}
				clone() {
					return new this.constructor().copy(this)
				}
			}
			const Lu = new K(),
				ER = new K(),
				EM = new K(),
				Zh = new K(),
				MR = new K(),
				MM = new K(),
				SR = new K()
			class Ru {
				constructor(n = new K(), e = new K(0, 0, -1)) {
					;(this.origin = n), (this.direction = e)
				}
				set(n, e) {
					return this.origin.copy(n), this.direction.copy(e), this
				}
				copy(n) {
					return this.origin.copy(n.origin), this.direction.copy(n.direction), this
				}
				at(n, e) {
					return (
						void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), (e = new K())),
						e.copy(this.direction).multiplyScalar(n).add(this.origin)
					)
				}
				lookAt(n) {
					return this.direction.copy(n).sub(this.origin).normalize(), this
				}
				recast(n) {
					return this.origin.copy(this.at(n, Lu)), this
				}
				closestPointToPoint(n, e) {
					void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), (e = new K())),
						e.subVectors(n, this.origin)
					const i = e.dot(this.direction)
					return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
				}
				distanceToPoint(n) {
					return Math.sqrt(this.distanceSqToPoint(n))
				}
				distanceSqToPoint(n) {
					const e = Lu.subVectors(n, this.origin).dot(this.direction)
					return e < 0
						? this.origin.distanceToSquared(n)
						: (Lu.copy(this.direction).multiplyScalar(e).add(this.origin), Lu.distanceToSquared(n))
				}
				distanceSqToSegment(n, e, i, r) {
					ER.copy(n).add(e).multiplyScalar(0.5), EM.copy(e).sub(n).normalize(), Zh.copy(this.origin).sub(ER)
					const o = 0.5 * n.distanceTo(e),
						s = -this.direction.dot(EM),
						a = Zh.dot(this.direction),
						c = -Zh.dot(EM),
						l = Zh.lengthSq(),
						d = Math.abs(1 - s * s)
					let u, h, f, _
					if (d > 0)
						if (((u = s * c - a), (h = s * a - c), (_ = o * d), u >= 0))
							if (h >= -_)
								if (h <= _) {
									const y = 1 / d
									;(u *= y), (h *= y), (f = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * c) + l)
								} else (h = o), (u = Math.max(0, -(s * h + a))), (f = -u * u + h * (h + 2 * c) + l)
							else (h = -o), (u = Math.max(0, -(s * h + a))), (f = -u * u + h * (h + 2 * c) + l)
						else
							h <= -_
								? ((u = Math.max(0, -(-s * o + a))),
								  (h = u > 0 ? -o : Math.min(Math.max(-o, -c), o)),
								  (f = -u * u + h * (h + 2 * c) + l))
								: h <= _
								? ((u = 0), (h = Math.min(Math.max(-o, -c), o)), (f = h * (h + 2 * c) + l))
								: ((u = Math.max(0, -(s * o + a))),
								  (h = u > 0 ? o : Math.min(Math.max(-o, -c), o)),
								  (f = -u * u + h * (h + 2 * c) + l))
					else (h = s > 0 ? -o : o), (u = Math.max(0, -(s * h + a))), (f = -u * u + h * (h + 2 * c) + l)
					return i && i.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(EM).multiplyScalar(h).add(ER), f
				}
				intersectSphere(n, e) {
					Lu.subVectors(n.center, this.origin)
					const i = Lu.dot(this.direction),
						r = Lu.dot(Lu) - i * i,
						o = n.radius * n.radius
					if (r > o) return null
					const s = Math.sqrt(o - r),
						a = i - s,
						c = i + s
					return a < 0 && c < 0 ? null : this.at(a < 0 ? c : a, e)
				}
				intersectsSphere(n) {
					return this.distanceSqToPoint(n.center) <= n.radius * n.radius
				}
				distanceToPlane(n) {
					const e = n.normal.dot(this.direction)
					if (0 === e) return 0 === n.distanceToPoint(this.origin) ? 0 : null
					const i = -(this.origin.dot(n.normal) + n.constant) / e
					return i >= 0 ? i : null
				}
				intersectPlane(n, e) {
					const i = this.distanceToPlane(n)
					return null === i ? null : this.at(i, e)
				}
				intersectsPlane(n) {
					const e = n.distanceToPoint(this.origin)
					return 0 === e || n.normal.dot(this.direction) * e < 0
				}
				intersectBox(n, e) {
					let i, r, o, s, a, c
					const l = 1 / this.direction.x,
						d = 1 / this.direction.y,
						u = 1 / this.direction.z,
						h = this.origin
					return (
						l >= 0
							? ((i = (n.min.x - h.x) * l), (r = (n.max.x - h.x) * l))
							: ((i = (n.max.x - h.x) * l), (r = (n.min.x - h.x) * l)),
						d >= 0
							? ((o = (n.min.y - h.y) * d), (s = (n.max.y - h.y) * d))
							: ((o = (n.max.y - h.y) * d), (s = (n.min.y - h.y) * d)),
						i > s ||
						o > r ||
						((o > i || i != i) && (i = o),
						(s < r || r != r) && (r = s),
						u >= 0
							? ((a = (n.min.z - h.z) * u), (c = (n.max.z - h.z) * u))
							: ((a = (n.max.z - h.z) * u), (c = (n.min.z - h.z) * u)),
						i > c || a > r) ||
						((a > i || i != i) && (i = a), (c < r || r != r) && (r = c), r < 0)
							? null
							: this.at(i >= 0 ? i : r, e)
					)
				}
				intersectsBox(n) {
					return null !== this.intersectBox(n, Lu)
				}
				intersectTriangle(n, e, i, r, o) {
					MR.subVectors(e, n), MM.subVectors(i, n), SR.crossVectors(MR, MM)
					let a,
						s = this.direction.dot(SR)
					if (s > 0) {
						if (r) return null
						a = 1
					} else {
						if (!(s < 0)) return null
						;(a = -1), (s = -s)
					}
					Zh.subVectors(this.origin, n)
					const c = a * this.direction.dot(MM.crossVectors(Zh, MM))
					if (c < 0) return null
					const l = a * this.direction.dot(MR.cross(Zh))
					if (l < 0 || c + l > s) return null
					const d = -a * Zh.dot(SR)
					return d < 0 ? null : this.at(d / s, o)
				}
				applyMatrix4(n) {
					return this.origin.applyMatrix4(n), this.direction.transformDirection(n), this
				}
				equals(n) {
					return n.origin.equals(this.origin) && n.direction.equals(this.direction)
				}
				clone() {
					return new this.constructor().copy(this)
				}
			}
			class Cn {
				constructor() {
					;(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
						arguments.length > 0 &&
							console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
				}
				set(n, e, i, r, o, s, a, c, l, d, u, h, f, _, y, C) {
					const x = this.elements
					return (
						(x[0] = n),
						(x[4] = e),
						(x[8] = i),
						(x[12] = r),
						(x[1] = o),
						(x[5] = s),
						(x[9] = a),
						(x[13] = c),
						(x[2] = l),
						(x[6] = d),
						(x[10] = u),
						(x[14] = h),
						(x[3] = f),
						(x[7] = _),
						(x[11] = y),
						(x[15] = C),
						this
					)
				}
				identity() {
					return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
				}
				clone() {
					return new Cn().fromArray(this.elements)
				}
				copy(n) {
					const e = this.elements,
						i = n.elements
					return (
						(e[0] = i[0]),
						(e[1] = i[1]),
						(e[2] = i[2]),
						(e[3] = i[3]),
						(e[4] = i[4]),
						(e[5] = i[5]),
						(e[6] = i[6]),
						(e[7] = i[7]),
						(e[8] = i[8]),
						(e[9] = i[9]),
						(e[10] = i[10]),
						(e[11] = i[11]),
						(e[12] = i[12]),
						(e[13] = i[13]),
						(e[14] = i[14]),
						(e[15] = i[15]),
						this
					)
				}
				copyPosition(n) {
					const e = this.elements,
						i = n.elements
					return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this
				}
				setFromMatrix3(n) {
					const e = n.elements
					return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
				}
				extractBasis(n, e, i) {
					return n.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
				}
				makeBasis(n, e, i) {
					return this.set(n.x, e.x, i.x, 0, n.y, e.y, i.y, 0, n.z, e.z, i.z, 0, 0, 0, 0, 1), this
				}
				extractRotation(n) {
					const e = this.elements,
						i = n.elements,
						r = 1 / zg.setFromMatrixColumn(n, 0).length(),
						o = 1 / zg.setFromMatrixColumn(n, 1).length(),
						s = 1 / zg.setFromMatrixColumn(n, 2).length()
					return (
						(e[0] = i[0] * r),
						(e[1] = i[1] * r),
						(e[2] = i[2] * r),
						(e[3] = 0),
						(e[4] = i[4] * o),
						(e[5] = i[5] * o),
						(e[6] = i[6] * o),
						(e[7] = 0),
						(e[8] = i[8] * s),
						(e[9] = i[9] * s),
						(e[10] = i[10] * s),
						(e[11] = 0),
						(e[12] = 0),
						(e[13] = 0),
						(e[14] = 0),
						(e[15] = 1),
						this
					)
				}
				makeRotationFromEuler(n) {
					;(n && n.isEuler) ||
						console.error(
							"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
						)
					const e = this.elements,
						i = n.x,
						r = n.y,
						o = n.z,
						s = Math.cos(i),
						a = Math.sin(i),
						c = Math.cos(r),
						l = Math.sin(r),
						d = Math.cos(o),
						u = Math.sin(o)
					if ("XYZ" === n.order) {
						const h = s * d,
							f = s * u,
							_ = a * d,
							y = a * u
						;(e[0] = c * d),
							(e[4] = -c * u),
							(e[8] = l),
							(e[1] = f + _ * l),
							(e[5] = h - y * l),
							(e[9] = -a * c),
							(e[2] = y - h * l),
							(e[6] = _ + f * l),
							(e[10] = s * c)
					} else if ("YXZ" === n.order) {
						const h = c * d,
							f = c * u,
							_ = l * d,
							y = l * u
						;(e[0] = h + y * a),
							(e[4] = _ * a - f),
							(e[8] = s * l),
							(e[1] = s * u),
							(e[5] = s * d),
							(e[9] = -a),
							(e[2] = f * a - _),
							(e[6] = y + h * a),
							(e[10] = s * c)
					} else if ("ZXY" === n.order) {
						const h = c * d,
							f = c * u,
							_ = l * d,
							y = l * u
						;(e[0] = h - y * a),
							(e[4] = -s * u),
							(e[8] = _ + f * a),
							(e[1] = f + _ * a),
							(e[5] = s * d),
							(e[9] = y - h * a),
							(e[2] = -s * l),
							(e[6] = a),
							(e[10] = s * c)
					} else if ("ZYX" === n.order) {
						const h = s * d,
							f = s * u,
							_ = a * d,
							y = a * u
						;(e[0] = c * d),
							(e[4] = _ * l - f),
							(e[8] = h * l + y),
							(e[1] = c * u),
							(e[5] = y * l + h),
							(e[9] = f * l - _),
							(e[2] = -l),
							(e[6] = a * c),
							(e[10] = s * c)
					} else if ("YZX" === n.order) {
						const h = s * c,
							f = s * l,
							_ = a * c,
							y = a * l
						;(e[0] = c * d),
							(e[4] = y - h * u),
							(e[8] = _ * u + f),
							(e[1] = u),
							(e[5] = s * d),
							(e[9] = -a * d),
							(e[2] = -l * d),
							(e[6] = f * u + _),
							(e[10] = h - y * u)
					} else if ("XZY" === n.order) {
						const h = s * c,
							f = s * l,
							_ = a * c,
							y = a * l
						;(e[0] = c * d),
							(e[4] = -u),
							(e[8] = l * d),
							(e[1] = h * u + y),
							(e[5] = s * d),
							(e[9] = f * u - _),
							(e[2] = _ * u - f),
							(e[6] = a * d),
							(e[10] = y * u + h)
					}
					return (e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this
				}
				makeRotationFromQuaternion(n) {
					return this.compose(Tve, n, Fve)
				}
				lookAt(n, e, i) {
					const r = this.elements
					return (
						rc.subVectors(n, e),
						0 === rc.lengthSq() && (rc.z = 1),
						rc.normalize(),
						Jh.crossVectors(i, rc),
						0 === Jh.lengthSq() &&
							(1 === Math.abs(i.z) ? (rc.x += 1e-4) : (rc.z += 1e-4), rc.normalize(), Jh.crossVectors(i, rc)),
						Jh.normalize(),
						SM.crossVectors(rc, Jh),
						(r[0] = Jh.x),
						(r[4] = SM.x),
						(r[8] = rc.x),
						(r[1] = Jh.y),
						(r[5] = SM.y),
						(r[9] = rc.y),
						(r[2] = Jh.z),
						(r[6] = SM.z),
						(r[10] = rc.z),
						this
					)
				}
				multiply(n, e) {
					return void 0 !== e
						? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
						  this.multiplyMatrices(n, e))
						: this.multiplyMatrices(this, n)
				}
				premultiply(n) {
					return this.multiplyMatrices(n, this)
				}
				multiplyMatrices(n, e) {
					const i = n.elements,
						r = e.elements,
						o = this.elements,
						s = i[0],
						a = i[4],
						c = i[8],
						l = i[12],
						d = i[1],
						u = i[5],
						h = i[9],
						f = i[13],
						_ = i[2],
						y = i[6],
						C = i[10],
						x = i[14],
						w = i[3],
						S = i[7],
						M = i[11],
						O = i[15],
						N = r[0],
						j = r[4],
						le = r[8],
						ae = r[12],
						ce = r[1],
						ue = r[5],
						Se = r[9],
						ve = r[13],
						W = r[2],
						me = r[6],
						Z = r[10],
						Ae = r[14],
						Ie = r[3],
						Pe = r[7],
						nt = r[11],
						pt = r[15]
					return (
						(o[0] = s * N + a * ce + c * W + l * Ie),
						(o[4] = s * j + a * ue + c * me + l * Pe),
						(o[8] = s * le + a * Se + c * Z + l * nt),
						(o[12] = s * ae + a * ve + c * Ae + l * pt),
						(o[1] = d * N + u * ce + h * W + f * Ie),
						(o[5] = d * j + u * ue + h * me + f * Pe),
						(o[9] = d * le + u * Se + h * Z + f * nt),
						(o[13] = d * ae + u * ve + h * Ae + f * pt),
						(o[2] = _ * N + y * ce + C * W + x * Ie),
						(o[6] = _ * j + y * ue + C * me + x * Pe),
						(o[10] = _ * le + y * Se + C * Z + x * nt),
						(o[14] = _ * ae + y * ve + C * Ae + x * pt),
						(o[3] = w * N + S * ce + M * W + O * Ie),
						(o[7] = w * j + S * ue + M * me + O * Pe),
						(o[11] = w * le + S * Se + M * Z + O * nt),
						(o[15] = w * ae + S * ve + M * Ae + O * pt),
						this
					)
				}
				multiplyScalar(n) {
					const e = this.elements
					return (
						(e[0] *= n),
						(e[4] *= n),
						(e[8] *= n),
						(e[12] *= n),
						(e[1] *= n),
						(e[5] *= n),
						(e[9] *= n),
						(e[13] *= n),
						(e[2] *= n),
						(e[6] *= n),
						(e[10] *= n),
						(e[14] *= n),
						(e[3] *= n),
						(e[7] *= n),
						(e[11] *= n),
						(e[15] *= n),
						this
					)
				}
				determinant() {
					const n = this.elements,
						e = n[0],
						i = n[4],
						r = n[8],
						o = n[12],
						s = n[1],
						a = n[5],
						c = n[9],
						l = n[13],
						d = n[2],
						u = n[6],
						h = n[10],
						f = n[14]
					return (
						n[3] * (+o * c * u - r * l * u - o * a * h + i * l * h + r * a * f - i * c * f) +
						n[7] * (+e * c * f - e * l * h + o * s * h - r * s * f + r * l * d - o * c * d) +
						n[11] * (+e * l * u - e * a * f - o * s * u + i * s * f + o * a * d - i * l * d) +
						n[15] * (-r * a * d - e * c * u + e * a * h + r * s * u - i * s * h + i * c * d)
					)
				}
				transpose() {
					const n = this.elements
					let e
					return (
						(e = n[1]),
						(n[1] = n[4]),
						(n[4] = e),
						(e = n[2]),
						(n[2] = n[8]),
						(n[8] = e),
						(e = n[6]),
						(n[6] = n[9]),
						(n[9] = e),
						(e = n[3]),
						(n[3] = n[12]),
						(n[12] = e),
						(e = n[7]),
						(n[7] = n[13]),
						(n[13] = e),
						(e = n[11]),
						(n[11] = n[14]),
						(n[14] = e),
						this
					)
				}
				setPosition(n, e, i) {
					const r = this.elements
					return n.isVector3 ? ((r[12] = n.x), (r[13] = n.y), (r[14] = n.z)) : ((r[12] = n), (r[13] = e), (r[14] = i)), this
				}
				invert() {
					const n = this.elements,
						e = n[0],
						i = n[1],
						r = n[2],
						o = n[3],
						s = n[4],
						a = n[5],
						c = n[6],
						l = n[7],
						d = n[8],
						u = n[9],
						h = n[10],
						f = n[11],
						_ = n[12],
						y = n[13],
						C = n[14],
						x = n[15],
						w = u * C * l - y * h * l + y * c * f - a * C * f - u * c * x + a * h * x,
						S = _ * h * l - d * C * l - _ * c * f + s * C * f + d * c * x - s * h * x,
						M = d * y * l - _ * u * l + _ * a * f - s * y * f - d * a * x + s * u * x,
						O = _ * u * c - d * y * c - _ * a * h + s * y * h + d * a * C - s * u * C,
						N = e * w + i * S + r * M + o * O
					if (0 === N) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
					const j = 1 / N
					return (
						(n[0] = w * j),
						(n[1] = (y * h * o - u * C * o - y * r * f + i * C * f + u * r * x - i * h * x) * j),
						(n[2] = (a * C * o - y * c * o + y * r * l - i * C * l - a * r * x + i * c * x) * j),
						(n[3] = (u * c * o - a * h * o - u * r * l + i * h * l + a * r * f - i * c * f) * j),
						(n[4] = S * j),
						(n[5] = (d * C * o - _ * h * o + _ * r * f - e * C * f - d * r * x + e * h * x) * j),
						(n[6] = (_ * c * o - s * C * o - _ * r * l + e * C * l + s * r * x - e * c * x) * j),
						(n[7] = (s * h * o - d * c * o + d * r * l - e * h * l - s * r * f + e * c * f) * j),
						(n[8] = M * j),
						(n[9] = (_ * u * o - d * y * o - _ * i * f + e * y * f + d * i * x - e * u * x) * j),
						(n[10] = (s * y * o - _ * a * o + _ * i * l - e * y * l - s * i * x + e * a * x) * j),
						(n[11] = (d * a * o - s * u * o - d * i * l + e * u * l + s * i * f - e * a * f) * j),
						(n[12] = O * j),
						(n[13] = (d * y * r - _ * u * r + _ * i * h - e * y * h - d * i * C + e * u * C) * j),
						(n[14] = (_ * a * r - s * y * r - _ * i * c + e * y * c + s * i * C - e * a * C) * j),
						(n[15] = (s * u * r - d * a * r + d * i * c - e * u * c - s * i * h + e * a * h) * j),
						this
					)
				}
				scale(n) {
					const e = this.elements,
						i = n.x,
						r = n.y,
						o = n.z
					return (
						(e[0] *= i),
						(e[4] *= r),
						(e[8] *= o),
						(e[1] *= i),
						(e[5] *= r),
						(e[9] *= o),
						(e[2] *= i),
						(e[6] *= r),
						(e[10] *= o),
						(e[3] *= i),
						(e[7] *= r),
						(e[11] *= o),
						this
					)
				}
				getMaxScaleOnAxis() {
					const n = this.elements
					return Math.sqrt(
						Math.max(
							n[0] * n[0] + n[1] * n[1] + n[2] * n[2],
							n[4] * n[4] + n[5] * n[5] + n[6] * n[6],
							n[8] * n[8] + n[9] * n[9] + n[10] * n[10]
						)
					)
				}
				makeTranslation(n, e, i) {
					return this.set(1, 0, 0, n, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
				}
				makeRotationX(n) {
					const e = Math.cos(n),
						i = Math.sin(n)
					return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
				}
				makeRotationY(n) {
					const e = Math.cos(n),
						i = Math.sin(n)
					return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
				}
				makeRotationZ(n) {
					const e = Math.cos(n),
						i = Math.sin(n)
					return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
				}
				makeRotationAxis(n, e) {
					const i = Math.cos(e),
						r = Math.sin(e),
						o = 1 - i,
						s = n.x,
						a = n.y,
						c = n.z,
						l = o * s,
						d = o * a
					return (
						this.set(
							l * s + i,
							l * a - r * c,
							l * c + r * a,
							0,
							l * a + r * c,
							d * a + i,
							d * c - r * s,
							0,
							l * c - r * a,
							d * c + r * s,
							o * c * c + i,
							0,
							0,
							0,
							0,
							1
						),
						this
					)
				}
				makeScale(n, e, i) {
					return this.set(n, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
				}
				makeShear(n, e, i) {
					return this.set(1, e, i, 0, n, 1, i, 0, n, e, 1, 0, 0, 0, 0, 1), this
				}
				compose(n, e, i) {
					const r = this.elements,
						o = e._x,
						s = e._y,
						a = e._z,
						c = e._w,
						l = o + o,
						d = s + s,
						u = a + a,
						h = o * l,
						f = o * d,
						_ = o * u,
						y = s * d,
						C = s * u,
						x = a * u,
						w = c * l,
						S = c * d,
						M = c * u,
						O = i.x,
						N = i.y,
						j = i.z
					return (
						(r[0] = (1 - (y + x)) * O),
						(r[1] = (f + M) * O),
						(r[2] = (_ - S) * O),
						(r[3] = 0),
						(r[4] = (f - M) * N),
						(r[5] = (1 - (h + x)) * N),
						(r[6] = (C + w) * N),
						(r[7] = 0),
						(r[8] = (_ + S) * j),
						(r[9] = (C - w) * j),
						(r[10] = (1 - (h + y)) * j),
						(r[11] = 0),
						(r[12] = n.x),
						(r[13] = n.y),
						(r[14] = n.z),
						(r[15] = 1),
						this
					)
				}
				decompose(n, e, i) {
					const r = this.elements
					let o = zg.set(r[0], r[1], r[2]).length()
					const s = zg.set(r[4], r[5], r[6]).length(),
						a = zg.set(r[8], r[9], r[10]).length()
					this.determinant() < 0 && (o = -o), (n.x = r[12]), (n.y = r[13]), (n.z = r[14]), pl.copy(this)
					const l = 1 / o,
						d = 1 / s,
						u = 1 / a
					return (
						(pl.elements[0] *= l),
						(pl.elements[1] *= l),
						(pl.elements[2] *= l),
						(pl.elements[4] *= d),
						(pl.elements[5] *= d),
						(pl.elements[6] *= d),
						(pl.elements[8] *= u),
						(pl.elements[9] *= u),
						(pl.elements[10] *= u),
						e.setFromRotationMatrix(pl),
						(i.x = o),
						(i.y = s),
						(i.z = a),
						this
					)
				}
				makePerspective(n, e, i, r, o, s) {
					void 0 === s &&
						console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.")
					const a = this.elements,
						l = (2 * o) / (i - r),
						d = (e + n) / (e - n),
						u = (i + r) / (i - r),
						h = -(s + o) / (s - o),
						f = (-2 * s * o) / (s - o)
					return (
						(a[0] = (2 * o) / (e - n)),
						(a[4] = 0),
						(a[8] = d),
						(a[12] = 0),
						(a[1] = 0),
						(a[5] = l),
						(a[9] = u),
						(a[13] = 0),
						(a[2] = 0),
						(a[6] = 0),
						(a[10] = h),
						(a[14] = f),
						(a[3] = 0),
						(a[7] = 0),
						(a[11] = -1),
						(a[15] = 0),
						this
					)
				}
				makeOrthographic(n, e, i, r, o, s) {
					const a = this.elements,
						c = 1 / (e - n),
						l = 1 / (i - r),
						d = 1 / (s - o),
						u = (e + n) * c,
						h = (i + r) * l,
						f = (s + o) * d
					return (
						(a[0] = 2 * c),
						(a[4] = 0),
						(a[8] = 0),
						(a[12] = -u),
						(a[1] = 0),
						(a[5] = 2 * l),
						(a[9] = 0),
						(a[13] = -h),
						(a[2] = 0),
						(a[6] = 0),
						(a[10] = -2 * d),
						(a[14] = -f),
						(a[3] = 0),
						(a[7] = 0),
						(a[11] = 0),
						(a[15] = 1),
						this
					)
				}
				equals(n) {
					const e = this.elements,
						i = n.elements
					for (let r = 0; r < 16; r++) if (e[r] !== i[r]) return !1
					return !0
				}
				fromArray(n, e = 0) {
					for (let i = 0; i < 16; i++) this.elements[i] = n[i + e]
					return this
				}
				toArray(n = [], e = 0) {
					const i = this.elements
					return (
						(n[e] = i[0]),
						(n[e + 1] = i[1]),
						(n[e + 2] = i[2]),
						(n[e + 3] = i[3]),
						(n[e + 4] = i[4]),
						(n[e + 5] = i[5]),
						(n[e + 6] = i[6]),
						(n[e + 7] = i[7]),
						(n[e + 8] = i[8]),
						(n[e + 9] = i[9]),
						(n[e + 10] = i[10]),
						(n[e + 11] = i[11]),
						(n[e + 12] = i[12]),
						(n[e + 13] = i[13]),
						(n[e + 14] = i[14]),
						(n[e + 15] = i[15]),
						n
					)
				}
			}
			Cn.prototype.isMatrix4 = !0
			const zg = new K(),
				pl = new Cn(),
				Tve = new K(0, 0, 0),
				Fve = new K(1, 1, 1),
				Jh = new K(),
				SM = new K(),
				rc = new K(),
				Dj = new Cn(),
				Lj = new fs()
			class lp {
				constructor(n = 0, e = 0, i = 0, r = lp.DefaultOrder) {
					;(this._x = n), (this._y = e), (this._z = i), (this._order = r)
				}
				get x() {
					return this._x
				}
				set x(n) {
					;(this._x = n), this._onChangeCallback()
				}
				get y() {
					return this._y
				}
				set y(n) {
					;(this._y = n), this._onChangeCallback()
				}
				get z() {
					return this._z
				}
				set z(n) {
					;(this._z = n), this._onChangeCallback()
				}
				get order() {
					return this._order
				}
				set order(n) {
					;(this._order = n), this._onChangeCallback()
				}
				set(n, e, i, r) {
					return (this._x = n), (this._y = e), (this._z = i), (this._order = r || this._order), this._onChangeCallback(), this
				}
				clone() {
					return new this.constructor(this._x, this._y, this._z, this._order)
				}
				copy(n) {
					return (this._x = n._x), (this._y = n._y), (this._z = n._z), (this._order = n._order), this._onChangeCallback(), this
				}
				setFromRotationMatrix(n, e, i) {
					const r = jn.clamp,
						o = n.elements,
						s = o[0],
						a = o[4],
						c = o[8],
						l = o[1],
						d = o[5],
						u = o[9],
						h = o[2],
						f = o[6],
						_ = o[10]
					switch ((e = e || this._order)) {
						case "XYZ":
							;(this._y = Math.asin(r(c, -1, 1))),
								Math.abs(c) < 0.9999999
									? ((this._x = Math.atan2(-u, _)), (this._z = Math.atan2(-a, s)))
									: ((this._x = Math.atan2(f, d)), (this._z = 0))
							break
						case "YXZ":
							;(this._x = Math.asin(-r(u, -1, 1))),
								Math.abs(u) < 0.9999999
									? ((this._y = Math.atan2(c, _)), (this._z = Math.atan2(l, d)))
									: ((this._y = Math.atan2(-h, s)), (this._z = 0))
							break
						case "ZXY":
							;(this._x = Math.asin(r(f, -1, 1))),
								Math.abs(f) < 0.9999999
									? ((this._y = Math.atan2(-h, _)), (this._z = Math.atan2(-a, d)))
									: ((this._y = 0), (this._z = Math.atan2(l, s)))
							break
						case "ZYX":
							;(this._y = Math.asin(-r(h, -1, 1))),
								Math.abs(h) < 0.9999999
									? ((this._x = Math.atan2(f, _)), (this._z = Math.atan2(l, s)))
									: ((this._x = 0), (this._z = Math.atan2(-a, d)))
							break
						case "YZX":
							;(this._z = Math.asin(r(l, -1, 1))),
								Math.abs(l) < 0.9999999
									? ((this._x = Math.atan2(-u, d)), (this._y = Math.atan2(-h, s)))
									: ((this._x = 0), (this._y = Math.atan2(c, _)))
							break
						case "XZY":
							;(this._z = Math.asin(-r(a, -1, 1))),
								Math.abs(a) < 0.9999999
									? ((this._x = Math.atan2(f, d)), (this._y = Math.atan2(c, s)))
									: ((this._x = Math.atan2(-u, _)), (this._y = 0))
							break
						default:
							console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
					}
					return (this._order = e), !1 !== i && this._onChangeCallback(), this
				}
				setFromQuaternion(n, e, i) {
					return Dj.makeRotationFromQuaternion(n), this.setFromRotationMatrix(Dj, e, i)
				}
				setFromVector3(n, e) {
					return this.set(n.x, n.y, n.z, e || this._order)
				}
				reorder(n) {
					return Lj.setFromEuler(this), this.setFromQuaternion(Lj, n)
				}
				equals(n) {
					return n._x === this._x && n._y === this._y && n._z === this._z && n._order === this._order
				}
				fromArray(n) {
					return (
						(this._x = n[0]),
						(this._y = n[1]),
						(this._z = n[2]),
						void 0 !== n[3] && (this._order = n[3]),
						this._onChangeCallback(),
						this
					)
				}
				toArray(n = [], e = 0) {
					return (n[e] = this._x), (n[e + 1] = this._y), (n[e + 2] = this._z), (n[e + 3] = this._order), n
				}
				toVector3(n) {
					return n ? n.set(this._x, this._y, this._z) : new K(this._x, this._y, this._z)
				}
				_onChange(n) {
					return (this._onChangeCallback = n), this
				}
				_onChangeCallback() {}
			}
			;(lp.prototype.isEuler = !0), (lp.DefaultOrder = "XYZ"), (lp.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"])
			class kR {
				constructor() {
					this.mask = 1
				}
				set(n) {
					this.mask = (1 << n) | 0
				}
				enable(n) {
					this.mask |= (1 << n) | 0
				}
				enableAll() {
					this.mask = -1
				}
				toggle(n) {
					this.mask ^= (1 << n) | 0
				}
				disable(n) {
					this.mask &= ~((1 << n) | 0)
				}
				disableAll() {
					this.mask = 0
				}
				test(n) {
					return 0 != (this.mask & n.mask)
				}
			}
			let Bve = 0
			const Rj = new K(),
				Gg = new fs(),
				Pu = new Cn(),
				kM = new K(),
				Ay = new K(),
				Ive = new K(),
				Dve = new fs(),
				Pj = new K(1, 0, 0),
				Oj = new K(0, 1, 0),
				Nj = new K(0, 0, 1),
				Lve = { type: "added" },
				Uj = { type: "removed" }
			function On() {
				Object.defineProperty(this, "id", { value: Bve++ }),
					(this.uuid = jn.generateUUID()),
					(this.name = ""),
					(this.type = "Object3D"),
					(this.parent = null),
					(this.children = []),
					(this.up = On.DefaultUp.clone())
				const t = new K(),
					n = new lp(),
					e = new fs(),
					i = new K(1, 1, 1)
				n._onChange(function r() {
					e.setFromEuler(n, !1)
				}),
					e._onChange(function o() {
						n.setFromQuaternion(e, void 0, !1)
					}),
					Object.defineProperties(this, {
						position: { configurable: !0, enumerable: !0, value: t },
						rotation: { configurable: !0, enumerable: !0, value: n },
						quaternion: { configurable: !0, enumerable: !0, value: e },
						scale: { configurable: !0, enumerable: !0, value: i },
						modelViewMatrix: { value: new Cn() },
						normalMatrix: { value: new ns() }
					}),
					(this.matrix = new Cn()),
					(this.matrixWorld = new Cn()),
					(this.matrixAutoUpdate = On.DefaultMatrixAutoUpdate),
					(this.matrixWorldNeedsUpdate = !1),
					(this.layers = new kR()),
					(this.visible = !0),
					(this.castShadow = !1),
					(this.receiveShadow = !1),
					(this.frustumCulled = !0),
					(this.renderOrder = 0),
					(this.animations = []),
					(this.userData = {})
			}
			;(On.DefaultUp = new K(0, 1, 0)),
				(On.DefaultMatrixAutoUpdate = !0),
				(On.prototype = Object.assign(Object.create(Iu.prototype), {
					constructor: On,
					isObject3D: !0,
					onBeforeRender: function () {},
					onAfterRender: function () {},
					applyMatrix4: function (t) {
						this.matrixAutoUpdate && this.updateMatrix(),
							this.matrix.premultiply(t),
							this.matrix.decompose(this.position, this.quaternion, this.scale)
					},
					applyQuaternion: function (t) {
						return this.quaternion.premultiply(t), this
					},
					setRotationFromAxisAngle: function (t, n) {
						this.quaternion.setFromAxisAngle(t, n)
					},
					setRotationFromEuler: function (t) {
						this.quaternion.setFromEuler(t, !0)
					},
					setRotationFromMatrix: function (t) {
						this.quaternion.setFromRotationMatrix(t)
					},
					setRotationFromQuaternion: function (t) {
						this.quaternion.copy(t)
					},
					rotateOnAxis: function (t, n) {
						return Gg.setFromAxisAngle(t, n), this.quaternion.multiply(Gg), this
					},
					rotateOnWorldAxis: function (t, n) {
						return Gg.setFromAxisAngle(t, n), this.quaternion.premultiply(Gg), this
					},
					rotateX: function (t) {
						return this.rotateOnAxis(Pj, t)
					},
					rotateY: function (t) {
						return this.rotateOnAxis(Oj, t)
					},
					rotateZ: function (t) {
						return this.rotateOnAxis(Nj, t)
					},
					translateOnAxis: function (t, n) {
						return Rj.copy(t).applyQuaternion(this.quaternion), this.position.add(Rj.multiplyScalar(n)), this
					},
					translateX: function (t) {
						return this.translateOnAxis(Pj, t)
					},
					translateY: function (t) {
						return this.translateOnAxis(Oj, t)
					},
					translateZ: function (t) {
						return this.translateOnAxis(Nj, t)
					},
					localToWorld: function (t) {
						return t.applyMatrix4(this.matrixWorld)
					},
					worldToLocal: function (t) {
						return t.applyMatrix4(Pu.copy(this.matrixWorld).invert())
					},
					lookAt: function (t, n, e) {
						t.isVector3 ? kM.copy(t) : kM.set(t, n, e)
						const i = this.parent
						this.updateWorldMatrix(!0, !1),
							Ay.setFromMatrixPosition(this.matrixWorld),
							this.isCamera || this.isLight ? Pu.lookAt(Ay, kM, this.up) : Pu.lookAt(kM, Ay, this.up),
							this.quaternion.setFromRotationMatrix(Pu),
							i && (Pu.extractRotation(i.matrixWorld), Gg.setFromRotationMatrix(Pu), this.quaternion.premultiply(Gg.invert()))
					},
					add: function (t) {
						if (arguments.length > 1) {
							for (let n = 0; n < arguments.length; n++) this.add(arguments[n])
							return this
						}
						return t === this
							? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this)
							: (t && t.isObject3D
									? (null !== t.parent && t.parent.remove(t),
									  (t.parent = this),
									  this.children.push(t),
									  t.dispatchEvent(Lve))
									: console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
							  this)
					},
					remove: function (t) {
						if (arguments.length > 1) {
							for (let e = 0; e < arguments.length; e++) this.remove(arguments[e])
							return this
						}
						const n = this.children.indexOf(t)
						return -1 !== n && ((t.parent = null), this.children.splice(n, 1), t.dispatchEvent(Uj)), this
					},
					clear: function () {
						for (let t = 0; t < this.children.length; t++) {
							const n = this.children[t]
							;(n.parent = null), n.dispatchEvent(Uj)
						}
						return (this.children.length = 0), this
					},
					attach: function (t) {
						return (
							this.updateWorldMatrix(!0, !1),
							Pu.copy(this.matrixWorld).invert(),
							null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Pu.multiply(t.parent.matrixWorld)),
							t.applyMatrix4(Pu),
							this.add(t),
							t.updateWorldMatrix(!1, !0),
							this
						)
					},
					getObjectById: function (t) {
						return this.getObjectByProperty("id", t)
					},
					getObjectByName: function (t) {
						return this.getObjectByProperty("name", t)
					},
					getObjectByProperty: function (t, n) {
						if (this[t] === n) return this
						for (let e = 0, i = this.children.length; e < i; e++) {
							const o = this.children[e].getObjectByProperty(t, n)
							if (void 0 !== o) return o
						}
					},
					getWorldPosition: function (t) {
						return (
							void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), (t = new K())),
							this.updateWorldMatrix(!0, !1),
							t.setFromMatrixPosition(this.matrixWorld)
						)
					},
					getWorldQuaternion: function (t) {
						return (
							void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), (t = new fs())),
							this.updateWorldMatrix(!0, !1),
							this.matrixWorld.decompose(Ay, t, Ive),
							t
						)
					},
					getWorldScale: function (t) {
						return (
							void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), (t = new K())),
							this.updateWorldMatrix(!0, !1),
							this.matrixWorld.decompose(Ay, Dve, t),
							t
						)
					},
					getWorldDirection: function (t) {
						void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), (t = new K())),
							this.updateWorldMatrix(!0, !1)
						const n = this.matrixWorld.elements
						return t.set(n[8], n[9], n[10]).normalize()
					},
					raycast: function () {},
					traverse: function (t) {
						t(this)
						const n = this.children
						for (let e = 0, i = n.length; e < i; e++) n[e].traverse(t)
					},
					traverseVisible: function (t) {
						if (!1 === this.visible) return
						t(this)
						const n = this.children
						for (let e = 0, i = n.length; e < i; e++) n[e].traverseVisible(t)
					},
					traverseAncestors: function (t) {
						const n = this.parent
						null !== n && (t(n), n.traverseAncestors(t))
					},
					updateMatrix: function () {
						this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0)
					},
					updateMatrixWorld: function (t) {
						this.matrixAutoUpdate && this.updateMatrix(),
							(this.matrixWorldNeedsUpdate || t) &&
								(null === this.parent
									? this.matrixWorld.copy(this.matrix)
									: this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
								(this.matrixWorldNeedsUpdate = !1),
								(t = !0))
						const n = this.children
						for (let e = 0, i = n.length; e < i; e++) n[e].updateMatrixWorld(t)
					},
					updateWorldMatrix: function (t, n) {
						const e = this.parent
						if (
							(!0 === t && null !== e && e.updateWorldMatrix(!0, !1),
							this.matrixAutoUpdate && this.updateMatrix(),
							null === this.parent
								? this.matrixWorld.copy(this.matrix)
								: this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
							!0 === n)
						) {
							const i = this.children
							for (let r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0)
						}
					},
					toJSON: function (t) {
						const n = void 0 === t || "string" == typeof t,
							e = {}
						n &&
							((t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }),
							(e.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }))
						const i = {}
						function r(s, a) {
							return void 0 === s[a.uuid] && (s[a.uuid] = a.toJSON(t)), a.uuid
						}
						if (
							((i.uuid = this.uuid),
							(i.type = this.type),
							"" !== this.name && (i.name = this.name),
							!0 === this.castShadow && (i.castShadow = !0),
							!0 === this.receiveShadow && (i.receiveShadow = !0),
							!1 === this.visible && (i.visible = !1),
							!1 === this.frustumCulled && (i.frustumCulled = !1),
							0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
							"{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
							(i.layers = this.layers.mask),
							(i.matrix = this.matrix.toArray()),
							!1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
							this.isInstancedMesh &&
								((i.type = "InstancedMesh"), (i.count = this.count), (i.instanceMatrix = this.instanceMatrix.toJSON())),
							this.isMesh || this.isLine || this.isPoints)
						) {
							i.geometry = r(t.geometries, this.geometry)
							const s = this.geometry.parameters
							if (void 0 !== s && void 0 !== s.shapes) {
								const a = s.shapes
								if (Array.isArray(a)) for (let c = 0, l = a.length; c < l; c++) r(t.shapes, a[c])
								else r(t.shapes, a)
							}
						}
						if (
							(this.isSkinnedMesh &&
								((i.bindMode = this.bindMode),
								(i.bindMatrix = this.bindMatrix.toArray()),
								void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
							void 0 !== this.material)
						)
							if (Array.isArray(this.material)) {
								const s = []
								for (let a = 0, c = this.material.length; a < c; a++) s.push(r(t.materials, this.material[a]))
								i.material = s
							} else i.material = r(t.materials, this.material)
						if (this.children.length > 0) {
							i.children = []
							for (let s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(t).object)
						}
						if (this.animations.length > 0) {
							i.animations = []
							for (let s = 0; s < this.animations.length; s++) i.animations.push(r(t.animations, this.animations[s]))
						}
						if (n) {
							const s = o(t.geometries),
								a = o(t.materials),
								c = o(t.textures),
								l = o(t.images),
								d = o(t.shapes),
								u = o(t.skeletons),
								h = o(t.animations)
							s.length > 0 && (e.geometries = s),
								a.length > 0 && (e.materials = a),
								c.length > 0 && (e.textures = c),
								l.length > 0 && (e.images = l),
								d.length > 0 && (e.shapes = d),
								u.length > 0 && (e.skeletons = u),
								h.length > 0 && (e.animations = h)
						}
						return (e.object = i), e
						function o(s) {
							const a = []
							for (const c in s) {
								const l = s[c]
								delete l.metadata, a.push(l)
							}
							return a
						}
					},
					clone: function (t) {
						return new this.constructor().copy(this, t)
					},
					copy: function (t, n = !0) {
						if (
							((this.name = t.name),
							this.up.copy(t.up),
							this.position.copy(t.position),
							(this.rotation.order = t.rotation.order),
							this.quaternion.copy(t.quaternion),
							this.scale.copy(t.scale),
							this.matrix.copy(t.matrix),
							this.matrixWorld.copy(t.matrixWorld),
							(this.matrixAutoUpdate = t.matrixAutoUpdate),
							(this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
							(this.layers.mask = t.layers.mask),
							(this.visible = t.visible),
							(this.castShadow = t.castShadow),
							(this.receiveShadow = t.receiveShadow),
							(this.frustumCulled = t.frustumCulled),
							(this.renderOrder = t.renderOrder),
							(this.userData = JSON.parse(JSON.stringify(t.userData))),
							!0 === n)
						)
							for (let e = 0; e < t.children.length; e++) this.add(t.children[e].clone())
						return this
					}
				}))
			const TR = new K(),
				Rve = new K(),
				Pve = new ns()
			class Al {
				constructor(n = new K(1, 0, 0), e = 0) {
					;(this.normal = n), (this.constant = e)
				}
				set(n, e) {
					return this.normal.copy(n), (this.constant = e), this
				}
				setComponents(n, e, i, r) {
					return this.normal.set(n, e, i), (this.constant = r), this
				}
				setFromNormalAndCoplanarPoint(n, e) {
					return this.normal.copy(n), (this.constant = -e.dot(this.normal)), this
				}
				setFromCoplanarPoints(n, e, i) {
					const r = TR.subVectors(i, e).cross(Rve.subVectors(n, e)).normalize()
					return this.setFromNormalAndCoplanarPoint(r, n), this
				}
				copy(n) {
					return this.normal.copy(n.normal), (this.constant = n.constant), this
				}
				normalize() {
					const n = 1 / this.normal.length()
					return this.normal.multiplyScalar(n), (this.constant *= n), this
				}
				negate() {
					return (this.constant *= -1), this.normal.negate(), this
				}
				distanceToPoint(n) {
					return this.normal.dot(n) + this.constant
				}
				distanceToSphere(n) {
					return this.distanceToPoint(n.center) - n.radius
				}
				projectPoint(n, e) {
					return (
						void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), (e = new K())),
						e.copy(this.normal).multiplyScalar(-this.distanceToPoint(n)).add(n)
					)
				}
				intersectLine(n, e) {
					void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), (e = new K()))
					const i = n.delta(TR),
						r = this.normal.dot(i)
					if (0 === r) return 0 === this.distanceToPoint(n.start) ? e.copy(n.start) : void 0
					const o = -(n.start.dot(this.normal) + this.constant) / r
					return o < 0 || o > 1 ? void 0 : e.copy(i).multiplyScalar(o).add(n.start)
				}
				intersectsLine(n) {
					const e = this.distanceToPoint(n.start),
						i = this.distanceToPoint(n.end)
					return (e < 0 && i > 0) || (i < 0 && e > 0)
				}
				intersectsBox(n) {
					return n.intersectsPlane(this)
				}
				intersectsSphere(n) {
					return n.intersectsPlane(this)
				}
				coplanarPoint(n) {
					return (
						void 0 === n && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), (n = new K())),
						n.copy(this.normal).multiplyScalar(-this.constant)
					)
				}
				applyMatrix4(n, e) {
					const i = e || Pve.getNormalMatrix(n),
						r = this.coplanarPoint(TR).applyMatrix4(n),
						o = this.normal.applyMatrix3(i).normalize()
					return (this.constant = -r.dot(o)), this
				}
				translate(n) {
					return (this.constant -= n.dot(this.normal)), this
				}
				equals(n) {
					return n.normal.equals(this.normal) && n.constant === this.constant
				}
				clone() {
					return new this.constructor().copy(this)
				}
			}
			Al.prototype.isPlane = !0
			const gl = new K(),
				Ou = new K(),
				FR = new K(),
				Nu = new K(),
				$g = new K(),
				Wg = new K(),
				Hj = new K(),
				BR = new K(),
				IR = new K(),
				DR = new K()
			class Ro {
				constructor(n = new K(), e = new K(), i = new K()) {
					;(this.a = n), (this.b = e), (this.c = i)
				}
				static getNormal(n, e, i, r) {
					void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), (r = new K())),
						r.subVectors(i, e),
						gl.subVectors(n, e),
						r.cross(gl)
					const o = r.lengthSq()
					return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0)
				}
				static getBarycoord(n, e, i, r, o) {
					gl.subVectors(r, e), Ou.subVectors(i, e), FR.subVectors(n, e)
					const s = gl.dot(gl),
						a = gl.dot(Ou),
						c = gl.dot(FR),
						l = Ou.dot(Ou),
						d = Ou.dot(FR),
						u = s * l - a * a
					if ((void 0 === o && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), (o = new K())), 0 === u))
						return o.set(-2, -1, -1)
					const h = 1 / u,
						f = (l * c - a * d) * h,
						_ = (s * d - a * c) * h
					return o.set(1 - f - _, _, f)
				}
				static containsPoint(n, e, i, r) {
					return this.getBarycoord(n, e, i, r, Nu), Nu.x >= 0 && Nu.y >= 0 && Nu.x + Nu.y <= 1
				}
				static getUV(n, e, i, r, o, s, a, c) {
					return (
						this.getBarycoord(n, e, i, r, Nu),
						c.set(0, 0),
						c.addScaledVector(o, Nu.x),
						c.addScaledVector(s, Nu.y),
						c.addScaledVector(a, Nu.z),
						c
					)
				}
				static isFrontFacing(n, e, i, r) {
					return gl.subVectors(i, e), Ou.subVectors(n, e), gl.cross(Ou).dot(r) < 0
				}
				set(n, e, i) {
					return this.a.copy(n), this.b.copy(e), this.c.copy(i), this
				}
				setFromPointsAndIndices(n, e, i, r) {
					return this.a.copy(n[e]), this.b.copy(n[i]), this.c.copy(n[r]), this
				}
				clone() {
					return new this.constructor().copy(this)
				}
				copy(n) {
					return this.a.copy(n.a), this.b.copy(n.b), this.c.copy(n.c), this
				}
				getArea() {
					return gl.subVectors(this.c, this.b), Ou.subVectors(this.a, this.b), 0.5 * gl.cross(Ou).length()
				}
				getMidpoint(n) {
					return (
						void 0 === n && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), (n = new K())),
						n
							.addVectors(this.a, this.b)
							.add(this.c)
							.multiplyScalar(1 / 3)
					)
				}
				getNormal(n) {
					return Ro.getNormal(this.a, this.b, this.c, n)
				}
				getPlane(n) {
					return (
						void 0 === n && (console.warn("THREE.Triangle: .getPlane() target is now required"), (n = new Al())),
						n.setFromCoplanarPoints(this.a, this.b, this.c)
					)
				}
				getBarycoord(n, e) {
					return Ro.getBarycoord(n, this.a, this.b, this.c, e)
				}
				getUV(n, e, i, r, o) {
					return Ro.getUV(n, this.a, this.b, this.c, e, i, r, o)
				}
				containsPoint(n) {
					return Ro.containsPoint(n, this.a, this.b, this.c)
				}
				isFrontFacing(n) {
					return Ro.isFrontFacing(this.a, this.b, this.c, n)
				}
				intersectsBox(n) {
					return n.intersectsTriangle(this)
				}
				closestPointToPoint(n, e) {
					void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), (e = new K()))
					const i = this.a,
						r = this.b,
						o = this.c
					let s, a
					$g.subVectors(r, i), Wg.subVectors(o, i), BR.subVectors(n, i)
					const c = $g.dot(BR),
						l = Wg.dot(BR)
					if (c <= 0 && l <= 0) return e.copy(i)
					IR.subVectors(n, r)
					const d = $g.dot(IR),
						u = Wg.dot(IR)
					if (d >= 0 && u <= d) return e.copy(r)
					const h = c * u - d * l
					if (h <= 0 && c >= 0 && d <= 0) return (s = c / (c - d)), e.copy(i).addScaledVector($g, s)
					DR.subVectors(n, o)
					const f = $g.dot(DR),
						_ = Wg.dot(DR)
					if (_ >= 0 && f <= _) return e.copy(o)
					const y = f * l - c * _
					if (y <= 0 && l >= 0 && _ <= 0) return (a = l / (l - _)), e.copy(i).addScaledVector(Wg, a)
					const C = d * _ - f * u
					if (C <= 0 && u - d >= 0 && f - _ >= 0)
						return Hj.subVectors(o, r), (a = (u - d) / (u - d + (f - _))), e.copy(r).addScaledVector(Hj, a)
					const x = 1 / (C + y + h)
					return (s = y * x), (a = h * x), e.copy(i).addScaledVector($g, s).addScaledVector(Wg, a)
				}
				equals(n) {
					return n.a.equals(this.a) && n.b.equals(this.b) && n.c.equals(this.c)
				}
			}
			let Ove = 0
			function jr() {
				Object.defineProperty(this, "id", { value: Ove++ }),
					(this.uuid = jn.generateUUID()),
					(this.name = ""),
					(this.type = "Material"),
					(this.fog = !0),
					(this.blending = Dg),
					(this.side = Ig),
					(this.vertexColors = !1),
					(this.opacity = 1),
					(this.transparent = !1),
					(this.blendSrc = iR),
					(this.blendDst = rR),
					(this.blendEquation = Zm),
					(this.blendSrcAlpha = null),
					(this.blendDstAlpha = null),
					(this.blendEquationAlpha = null),
					(this.depthFunc = uM),
					(this.depthTest = !0),
					(this.depthWrite = !0),
					(this.stencilWriteMask = 255),
					(this.stencilFunc = Fj),
					(this.stencilRef = 0),
					(this.stencilFuncMask = 255),
					(this.stencilFail = yM),
					(this.stencilZFail = yM),
					(this.stencilZPass = yM),
					(this.stencilWrite = !1),
					(this.clippingPlanes = null),
					(this.clipIntersection = !1),
					(this.clipShadows = !1),
					(this.shadowSide = null),
					(this.colorWrite = !0),
					(this.precision = null),
					(this.polygonOffset = !1),
					(this.polygonOffsetFactor = 0),
					(this.polygonOffsetUnits = 0),
					(this.dithering = !1),
					(this.alphaTest = 0),
					(this.premultipliedAlpha = !1),
					(this.visible = !0),
					(this.toneMapped = !0),
					(this.userData = {}),
					(this.version = 0)
			}
			;(jr.prototype = Object.assign(Object.create(Iu.prototype), {
				constructor: jr,
				isMaterial: !0,
				onBeforeCompile: function () {},
				customProgramCacheKey: function () {
					return this.onBeforeCompile.toString()
				},
				setValues: function (t) {
					if (void 0 !== t)
						for (const n in t) {
							const e = t[n]
							if (void 0 === e) {
								console.warn("THREE.Material: '" + n + "' parameter is undefined.")
								continue
							}
							if ("shading" === n) {
								console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
									(this.flatShading = e === qL)
								continue
							}
							const i = this[n]
							void 0 !== i
								? i && i.isColor
									? i.set(e)
									: i && i.isVector3 && e && e.isVector3
									? i.copy(e)
									: (this[n] = e)
								: console.warn("THREE." + this.type + ": '" + n + "' is not a property of this material.")
						}
				},
				toJSON: function (t) {
					const n = void 0 === t || "string" == typeof t
					n && (t = { textures: {}, images: {} })
					const e = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }
					function i(r) {
						const o = []
						for (const s in r) {
							const a = r[s]
							delete a.metadata, o.push(a)
						}
						return o
					}
					if (
						((e.uuid = this.uuid),
						(e.type = this.type),
						"" !== this.name && (e.name = this.name),
						this.color && this.color.isColor && (e.color = this.color.getHex()),
						void 0 !== this.roughness && (e.roughness = this.roughness),
						void 0 !== this.metalness && (e.metalness = this.metalness),
						this.sheen && this.sheen.isColor && (e.sheen = this.sheen.getHex()),
						this.emissive && this.emissive.isColor && (e.emissive = this.emissive.getHex()),
						this.emissiveIntensity && 1 !== this.emissiveIntensity && (e.emissiveIntensity = this.emissiveIntensity),
						this.specular && this.specular.isColor && (e.specular = this.specular.getHex()),
						void 0 !== this.shininess && (e.shininess = this.shininess),
						void 0 !== this.clearcoat && (e.clearcoat = this.clearcoat),
						void 0 !== this.clearcoatRoughness && (e.clearcoatRoughness = this.clearcoatRoughness),
						this.clearcoatMap && this.clearcoatMap.isTexture && (e.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
						this.clearcoatRoughnessMap &&
							this.clearcoatRoughnessMap.isTexture &&
							(e.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
						this.clearcoatNormalMap &&
							this.clearcoatNormalMap.isTexture &&
							((e.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
							(e.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
						this.map && this.map.isTexture && (e.map = this.map.toJSON(t).uuid),
						this.matcap && this.matcap.isTexture && (e.matcap = this.matcap.toJSON(t).uuid),
						this.alphaMap && this.alphaMap.isTexture && (e.alphaMap = this.alphaMap.toJSON(t).uuid),
						this.lightMap &&
							this.lightMap.isTexture &&
							((e.lightMap = this.lightMap.toJSON(t).uuid), (e.lightMapIntensity = this.lightMapIntensity)),
						this.aoMap &&
							this.aoMap.isTexture &&
							((e.aoMap = this.aoMap.toJSON(t).uuid), (e.aoMapIntensity = this.aoMapIntensity)),
						this.bumpMap &&
							this.bumpMap.isTexture &&
							((e.bumpMap = this.bumpMap.toJSON(t).uuid), (e.bumpScale = this.bumpScale)),
						this.normalMap &&
							this.normalMap.isTexture &&
							((e.normalMap = this.normalMap.toJSON(t).uuid),
							(e.normalMapType = this.normalMapType),
							(e.normalScale = this.normalScale.toArray())),
						this.displacementMap &&
							this.displacementMap.isTexture &&
							((e.displacementMap = this.displacementMap.toJSON(t).uuid),
							(e.displacementScale = this.displacementScale),
							(e.displacementBias = this.displacementBias)),
						this.roughnessMap && this.roughnessMap.isTexture && (e.roughnessMap = this.roughnessMap.toJSON(t).uuid),
						this.metalnessMap && this.metalnessMap.isTexture && (e.metalnessMap = this.metalnessMap.toJSON(t).uuid),
						this.emissiveMap && this.emissiveMap.isTexture && (e.emissiveMap = this.emissiveMap.toJSON(t).uuid),
						this.specularMap && this.specularMap.isTexture && (e.specularMap = this.specularMap.toJSON(t).uuid),
						this.envMap &&
							this.envMap.isTexture &&
							((e.envMap = this.envMap.toJSON(t).uuid),
							(e.reflectivity = this.reflectivity),
							(e.refractionRatio = this.refractionRatio),
							void 0 !== this.combine && (e.combine = this.combine),
							void 0 !== this.envMapIntensity && (e.envMapIntensity = this.envMapIntensity)),
						this.gradientMap && this.gradientMap.isTexture && (e.gradientMap = this.gradientMap.toJSON(t).uuid),
						void 0 !== this.size && (e.size = this.size),
						void 0 !== this.sizeAttenuation && (e.sizeAttenuation = this.sizeAttenuation),
						this.blending !== Dg && (e.blending = this.blending),
						this.side !== Ig && (e.side = this.side),
						this.vertexColors && (e.vertexColors = !0),
						this.opacity < 1 && (e.opacity = this.opacity),
						!0 === this.transparent && (e.transparent = this.transparent),
						(e.depthFunc = this.depthFunc),
						(e.depthTest = this.depthTest),
						(e.depthWrite = this.depthWrite),
						(e.stencilWrite = this.stencilWrite),
						(e.stencilWriteMask = this.stencilWriteMask),
						(e.stencilFunc = this.stencilFunc),
						(e.stencilRef = this.stencilRef),
						(e.stencilFuncMask = this.stencilFuncMask),
						(e.stencilFail = this.stencilFail),
						(e.stencilZFail = this.stencilZFail),
						(e.stencilZPass = this.stencilZPass),
						this.rotation && 0 !== this.rotation && (e.rotation = this.rotation),
						!0 === this.polygonOffset && (e.polygonOffset = !0),
						0 !== this.polygonOffsetFactor && (e.polygonOffsetFactor = this.polygonOffsetFactor),
						0 !== this.polygonOffsetUnits && (e.polygonOffsetUnits = this.polygonOffsetUnits),
						this.linewidth && 1 !== this.linewidth && (e.linewidth = this.linewidth),
						void 0 !== this.dashSize && (e.dashSize = this.dashSize),
						void 0 !== this.gapSize && (e.gapSize = this.gapSize),
						void 0 !== this.scale && (e.scale = this.scale),
						!0 === this.dithering && (e.dithering = !0),
						this.alphaTest > 0 && (e.alphaTest = this.alphaTest),
						!0 === this.premultipliedAlpha && (e.premultipliedAlpha = this.premultipliedAlpha),
						!0 === this.wireframe && (e.wireframe = this.wireframe),
						this.wireframeLinewidth > 1 && (e.wireframeLinewidth = this.wireframeLinewidth),
						"round" !== this.wireframeLinecap && (e.wireframeLinecap = this.wireframeLinecap),
						"round" !== this.wireframeLinejoin && (e.wireframeLinejoin = this.wireframeLinejoin),
						!0 === this.morphTargets && (e.morphTargets = !0),
						!0 === this.morphNormals && (e.morphNormals = !0),
						!0 === this.skinning && (e.skinning = !0),
						!0 === this.flatShading && (e.flatShading = this.flatShading),
						!1 === this.visible && (e.visible = !1),
						!1 === this.toneMapped && (e.toneMapped = !1),
						"{}" !== JSON.stringify(this.userData) && (e.userData = this.userData),
						n)
					) {
						const r = i(t.textures),
							o = i(t.images)
						r.length > 0 && (e.textures = r), o.length > 0 && (e.images = o)
					}
					return e
				},
				clone: function () {
					return new this.constructor().copy(this)
				},
				copy: function (t) {
					;(this.name = t.name),
						(this.fog = t.fog),
						(this.blending = t.blending),
						(this.side = t.side),
						(this.vertexColors = t.vertexColors),
						(this.opacity = t.opacity),
						(this.transparent = t.transparent),
						(this.blendSrc = t.blendSrc),
						(this.blendDst = t.blendDst),
						(this.blendEquation = t.blendEquation),
						(this.blendSrcAlpha = t.blendSrcAlpha),
						(this.blendDstAlpha = t.blendDstAlpha),
						(this.blendEquationAlpha = t.blendEquationAlpha),
						(this.depthFunc = t.depthFunc),
						(this.depthTest = t.depthTest),
						(this.depthWrite = t.depthWrite),
						(this.stencilWriteMask = t.stencilWriteMask),
						(this.stencilFunc = t.stencilFunc),
						(this.stencilRef = t.stencilRef),
						(this.stencilFuncMask = t.stencilFuncMask),
						(this.stencilFail = t.stencilFail),
						(this.stencilZFail = t.stencilZFail),
						(this.stencilZPass = t.stencilZPass),
						(this.stencilWrite = t.stencilWrite)
					const n = t.clippingPlanes
					let e = null
					if (null !== n) {
						const i = n.length
						e = new Array(i)
						for (let r = 0; r !== i; ++r) e[r] = n[r].clone()
					}
					return (
						(this.clippingPlanes = e),
						(this.clipIntersection = t.clipIntersection),
						(this.clipShadows = t.clipShadows),
						(this.shadowSide = t.shadowSide),
						(this.colorWrite = t.colorWrite),
						(this.precision = t.precision),
						(this.polygonOffset = t.polygonOffset),
						(this.polygonOffsetFactor = t.polygonOffsetFactor),
						(this.polygonOffsetUnits = t.polygonOffsetUnits),
						(this.dithering = t.dithering),
						(this.alphaTest = t.alphaTest),
						(this.premultipliedAlpha = t.premultipliedAlpha),
						(this.visible = t.visible),
						(this.toneMapped = t.toneMapped),
						(this.userData = JSON.parse(JSON.stringify(t.userData))),
						this
					)
				},
				dispose: function () {
					this.dispatchEvent({ type: "dispose" })
				}
			})),
				Object.defineProperty(jr.prototype, "needsUpdate", {
					set: function (t) {
						!0 === t && this.version++
					}
				})
			const Vj = {
					aliceblue: 15792383,
					antiquewhite: 16444375,
					aqua: 65535,
					aquamarine: 8388564,
					azure: 15794175,
					beige: 16119260,
					bisque: 16770244,
					black: 0,
					blanchedalmond: 16772045,
					blue: 255,
					blueviolet: 9055202,
					brown: 10824234,
					burlywood: 14596231,
					cadetblue: 6266528,
					chartreuse: 8388352,
					chocolate: 13789470,
					coral: 16744272,
					cornflowerblue: 6591981,
					cornsilk: 16775388,
					crimson: 14423100,
					cyan: 65535,
					darkblue: 139,
					darkcyan: 35723,
					darkgoldenrod: 12092939,
					darkgray: 11119017,
					darkgreen: 25600,
					darkgrey: 11119017,
					darkkhaki: 12433259,
					darkmagenta: 9109643,
					darkolivegreen: 5597999,
					darkorange: 16747520,
					darkorchid: 10040012,
					darkred: 9109504,
					darksalmon: 15308410,
					darkseagreen: 9419919,
					darkslateblue: 4734347,
					darkslategray: 3100495,
					darkslategrey: 3100495,
					darkturquoise: 52945,
					darkviolet: 9699539,
					deeppink: 16716947,
					deepskyblue: 49151,
					dimgray: 6908265,
					dimgrey: 6908265,
					dodgerblue: 2003199,
					firebrick: 11674146,
					floralwhite: 16775920,
					forestgreen: 2263842,
					fuchsia: 16711935,
					gainsboro: 14474460,
					ghostwhite: 16316671,
					gold: 16766720,
					goldenrod: 14329120,
					gray: 8421504,
					green: 32768,
					greenyellow: 11403055,
					grey: 8421504,
					honeydew: 15794160,
					hotpink: 16738740,
					indianred: 13458524,
					indigo: 4915330,
					ivory: 16777200,
					khaki: 15787660,
					lavender: 15132410,
					lavenderblush: 16773365,
					lawngreen: 8190976,
					lemonchiffon: 16775885,
					lightblue: 11393254,
					lightcoral: 15761536,
					lightcyan: 14745599,
					lightgoldenrodyellow: 16448210,
					lightgray: 13882323,
					lightgreen: 9498256,
					lightgrey: 13882323,
					lightpink: 16758465,
					lightsalmon: 16752762,
					lightseagreen: 2142890,
					lightskyblue: 8900346,
					lightslategray: 7833753,
					lightslategrey: 7833753,
					lightsteelblue: 11584734,
					lightyellow: 16777184,
					lime: 65280,
					limegreen: 3329330,
					linen: 16445670,
					magenta: 16711935,
					maroon: 8388608,
					mediumaquamarine: 6737322,
					mediumblue: 205,
					mediumorchid: 12211667,
					mediumpurple: 9662683,
					mediumseagreen: 3978097,
					mediumslateblue: 8087790,
					mediumspringgreen: 64154,
					mediumturquoise: 4772300,
					mediumvioletred: 13047173,
					midnightblue: 1644912,
					mintcream: 16121850,
					mistyrose: 16770273,
					moccasin: 16770229,
					navajowhite: 16768685,
					navy: 128,
					oldlace: 16643558,
					olive: 8421376,
					olivedrab: 7048739,
					orange: 16753920,
					orangered: 16729344,
					orchid: 14315734,
					palegoldenrod: 15657130,
					palegreen: 10025880,
					paleturquoise: 11529966,
					palevioletred: 14381203,
					papayawhip: 16773077,
					peachpuff: 16767673,
					peru: 13468991,
					pink: 16761035,
					plum: 14524637,
					powderblue: 11591910,
					purple: 8388736,
					rebeccapurple: 6697881,
					red: 16711680,
					rosybrown: 12357519,
					royalblue: 4286945,
					saddlebrown: 9127187,
					salmon: 16416882,
					sandybrown: 16032864,
					seagreen: 3050327,
					seashell: 16774638,
					sienna: 10506797,
					silver: 12632256,
					skyblue: 8900331,
					slateblue: 6970061,
					slategray: 7372944,
					slategrey: 7372944,
					snow: 16775930,
					springgreen: 65407,
					steelblue: 4620980,
					tan: 13808780,
					teal: 32896,
					thistle: 14204888,
					tomato: 16737095,
					turquoise: 4251856,
					violet: 15631086,
					wheat: 16113331,
					white: 16777215,
					whitesmoke: 16119285,
					yellow: 16776960,
					yellowgreen: 10145074
				},
				bl = { h: 0, s: 0, l: 0 },
				TM = { h: 0, s: 0, l: 0 }
			function LR(t, n, e) {
				return (
					e < 0 && (e += 1),
					e > 1 && (e -= 1),
					e < 1 / 6 ? t + 6 * (n - t) * e : e < 0.5 ? n : e < 2 / 3 ? t + 6 * (n - t) * (2 / 3 - e) : t
				)
			}
			function RR(t) {
				return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4)
			}
			function PR(t) {
				return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055
			}
			let Lt = (() => {
				class t {
					constructor(e, i, r) {
						return void 0 === i && void 0 === r ? this.set(e) : this.setRGB(e, i, r)
					}
					set(e) {
						return (
							e && e.isColor
								? this.copy(e)
								: "number" == typeof e
								? this.setHex(e)
								: "string" == typeof e && this.setStyle(e),
							this
						)
					}
					setScalar(e) {
						return (this.r = e), (this.g = e), (this.b = e), this
					}
					setHex(e) {
						return (
							(e = Math.floor(e)),
							(this.r = ((e >> 16) & 255) / 255),
							(this.g = ((e >> 8) & 255) / 255),
							(this.b = (255 & e) / 255),
							this
						)
					}
					setRGB(e, i, r) {
						return (this.r = e), (this.g = i), (this.b = r), this
					}
					setHSL(e, i, r) {
						if (((e = jn.euclideanModulo(e, 1)), (i = jn.clamp(i, 0, 1)), (r = jn.clamp(r, 0, 1)), 0 === i))
							this.r = this.g = this.b = r
						else {
							const o = r <= 0.5 ? r * (1 + i) : r + i - r * i,
								s = 2 * r - o
							;(this.r = LR(s, o, e + 1 / 3)), (this.g = LR(s, o, e)), (this.b = LR(s, o, e - 1 / 3))
						}
						return this
					}
					setStyle(e) {
						function i(o) {
							void 0 !== o && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
						}
						let r
						if ((r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
							let o
							const a = r[2]
							switch (r[1]) {
								case "rgb":
								case "rgba":
									if ((o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
										return (
											(this.r = Math.min(255, parseInt(o[1], 10)) / 255),
											(this.g = Math.min(255, parseInt(o[2], 10)) / 255),
											(this.b = Math.min(255, parseInt(o[3], 10)) / 255),
											i(o[4]),
											this
										)
									if ((o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
										return (
											(this.r = Math.min(100, parseInt(o[1], 10)) / 100),
											(this.g = Math.min(100, parseInt(o[2], 10)) / 100),
											(this.b = Math.min(100, parseInt(o[3], 10)) / 100),
											i(o[4]),
											this
										)
									break
								case "hsl":
								case "hsla":
									if ((o = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))) {
										const c = parseFloat(o[1]) / 360,
											l = parseInt(o[2], 10) / 100,
											d = parseInt(o[3], 10) / 100
										return i(o[4]), this.setHSL(c, l, d)
									}
							}
						} else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
							const o = r[1],
								s = o.length
							if (3 === s)
								return (
									(this.r = parseInt(o.charAt(0) + o.charAt(0), 16) / 255),
									(this.g = parseInt(o.charAt(1) + o.charAt(1), 16) / 255),
									(this.b = parseInt(o.charAt(2) + o.charAt(2), 16) / 255),
									this
								)
							if (6 === s)
								return (
									(this.r = parseInt(o.charAt(0) + o.charAt(1), 16) / 255),
									(this.g = parseInt(o.charAt(2) + o.charAt(3), 16) / 255),
									(this.b = parseInt(o.charAt(4) + o.charAt(5), 16) / 255),
									this
								)
						}
						return e && e.length > 0 ? this.setColorName(e) : this
					}
					setColorName(e) {
						const i = Vj[e]
						return void 0 !== i ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + e), this
					}
					clone() {
						return new this.constructor(this.r, this.g, this.b)
					}
					copy(e) {
						return (this.r = e.r), (this.g = e.g), (this.b = e.b), this
					}
					copyGammaToLinear(e, i = 2) {
						return (this.r = Math.pow(e.r, i)), (this.g = Math.pow(e.g, i)), (this.b = Math.pow(e.b, i)), this
					}
					copyLinearToGamma(e, i = 2) {
						const r = i > 0 ? 1 / i : 1
						return (this.r = Math.pow(e.r, r)), (this.g = Math.pow(e.g, r)), (this.b = Math.pow(e.b, r)), this
					}
					convertGammaToLinear(e) {
						return this.copyGammaToLinear(this, e), this
					}
					convertLinearToGamma(e) {
						return this.copyLinearToGamma(this, e), this
					}
					copySRGBToLinear(e) {
						return (this.r = RR(e.r)), (this.g = RR(e.g)), (this.b = RR(e.b)), this
					}
					copyLinearToSRGB(e) {
						return (this.r = PR(e.r)), (this.g = PR(e.g)), (this.b = PR(e.b)), this
					}
					convertSRGBToLinear() {
						return this.copySRGBToLinear(this), this
					}
					convertLinearToSRGB() {
						return this.copyLinearToSRGB(this), this
					}
					getHex() {
						return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
					}
					getHexString() {
						return ("000000" + this.getHex().toString(16)).slice(-6)
					}
					getHSL(e) {
						void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), (e = { h: 0, s: 0, l: 0 }))
						const i = this.r,
							r = this.g,
							o = this.b,
							s = Math.max(i, r, o),
							a = Math.min(i, r, o)
						let c, l
						const d = (a + s) / 2
						if (a === s) (c = 0), (l = 0)
						else {
							const u = s - a
							switch (((l = d <= 0.5 ? u / (s + a) : u / (2 - s - a)), s)) {
								case i:
									c = (r - o) / u + (r < o ? 6 : 0)
									break
								case r:
									c = (o - i) / u + 2
									break
								case o:
									c = (i - r) / u + 4
							}
							c /= 6
						}
						return (e.h = c), (e.s = l), (e.l = d), e
					}
					getStyle() {
						return "rgb(" + ((255 * this.r) | 0) + "," + ((255 * this.g) | 0) + "," + ((255 * this.b) | 0) + ")"
					}
					offsetHSL(e, i, r) {
						return this.getHSL(bl), (bl.h += e), (bl.s += i), (bl.l += r), this.setHSL(bl.h, bl.s, bl.l), this
					}
					add(e) {
						return (this.r += e.r), (this.g += e.g), (this.b += e.b), this
					}
					addColors(e, i) {
						return (this.r = e.r + i.r), (this.g = e.g + i.g), (this.b = e.b + i.b), this
					}
					addScalar(e) {
						return (this.r += e), (this.g += e), (this.b += e), this
					}
					sub(e) {
						return (
							(this.r = Math.max(0, this.r - e.r)),
							(this.g = Math.max(0, this.g - e.g)),
							(this.b = Math.max(0, this.b - e.b)),
							this
						)
					}
					multiply(e) {
						return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this
					}
					multiplyScalar(e) {
						return (this.r *= e), (this.g *= e), (this.b *= e), this
					}
					lerp(e, i) {
						return (this.r += (e.r - this.r) * i), (this.g += (e.g - this.g) * i), (this.b += (e.b - this.b) * i), this
					}
					lerpColors(e, i, r) {
						return (this.r = e.r + (i.r - e.r) * r), (this.g = e.g + (i.g - e.g) * r), (this.b = e.b + (i.b - e.b) * r), this
					}
					lerpHSL(e, i) {
						this.getHSL(bl), e.getHSL(TM)
						const r = jn.lerp(bl.h, TM.h, i),
							o = jn.lerp(bl.s, TM.s, i),
							s = jn.lerp(bl.l, TM.l, i)
						return this.setHSL(r, o, s), this
					}
					equals(e) {
						return e.r === this.r && e.g === this.g && e.b === this.b
					}
					fromArray(e, i = 0) {
						return (this.r = e[i]), (this.g = e[i + 1]), (this.b = e[i + 2]), this
					}
					toArray(e = [], i = 0) {
						return (e[i] = this.r), (e[i + 1] = this.g), (e[i + 2] = this.b), e
					}
					fromBufferAttribute(e, i) {
						return (
							(this.r = e.getX(i)),
							(this.g = e.getY(i)),
							(this.b = e.getZ(i)),
							!0 === e.normalized && ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
							this
						)
					}
					toJSON() {
						return this.getHex()
					}
				}
				return (t.NAMES = Vj), t
			})()
			;(Lt.prototype.isColor = !0), (Lt.prototype.r = 1), (Lt.prototype.g = 1), (Lt.prototype.b = 1)
			class Cd extends jr {
				constructor(n) {
					super(),
						(this.type = "MeshBasicMaterial"),
						(this.color = new Lt(16777215)),
						(this.map = null),
						(this.lightMap = null),
						(this.lightMapIntensity = 1),
						(this.aoMap = null),
						(this.aoMapIntensity = 1),
						(this.specularMap = null),
						(this.alphaMap = null),
						(this.envMap = null),
						(this.combine = ty),
						(this.reflectivity = 1),
						(this.refractionRatio = 0.98),
						(this.wireframe = !1),
						(this.wireframeLinewidth = 1),
						(this.wireframeLinecap = "round"),
						(this.wireframeLinejoin = "round"),
						(this.skinning = !1),
						(this.morphTargets = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						this.color.copy(n.color),
						(this.map = n.map),
						(this.lightMap = n.lightMap),
						(this.lightMapIntensity = n.lightMapIntensity),
						(this.aoMap = n.aoMap),
						(this.aoMapIntensity = n.aoMapIntensity),
						(this.specularMap = n.specularMap),
						(this.alphaMap = n.alphaMap),
						(this.envMap = n.envMap),
						(this.combine = n.combine),
						(this.reflectivity = n.reflectivity),
						(this.refractionRatio = n.refractionRatio),
						(this.wireframe = n.wireframe),
						(this.wireframeLinewidth = n.wireframeLinewidth),
						(this.wireframeLinecap = n.wireframeLinecap),
						(this.wireframeLinejoin = n.wireframeLinejoin),
						(this.skinning = n.skinning),
						(this.morphTargets = n.morphTargets),
						this
					)
				}
			}
			Cd.prototype.isMeshBasicMaterial = !0
			const Nr = new K(),
				FM = new lt()
			function xn(t, n, e) {
				if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.")
				;(this.name = ""),
					(this.array = t),
					(this.itemSize = n),
					(this.count = void 0 !== t ? t.length / n : 0),
					(this.normalized = !0 === e),
					(this.usage = fy),
					(this.updateRange = { offset: 0, count: -1 }),
					(this.version = 0)
			}
			function gy(t, n, e) {
				xn.call(this, new Int8Array(t), n, e)
			}
			function by(t, n, e) {
				xn.call(this, new Uint8Array(t), n, e)
			}
			function _y(t, n, e) {
				xn.call(this, new Uint8ClampedArray(t), n, e)
			}
			function vy(t, n, e) {
				xn.call(this, new Int16Array(t), n, e)
			}
			function dp(t, n, e) {
				xn.call(this, new Uint16Array(t), n, e)
			}
			function yy(t, n, e) {
				xn.call(this, new Int32Array(t), n, e)
			}
			function up(t, n, e) {
				xn.call(this, new Uint32Array(t), n, e)
			}
			function wy(t, n, e) {
				xn.call(this, new Uint16Array(t), n, e)
			}
			function cn(t, n, e) {
				xn.call(this, new Float32Array(t), n, e)
			}
			function xy(t, n, e) {
				xn.call(this, new Float64Array(t), n, e)
			}
			function Qj(t) {
				if (0 === t.length) return -1 / 0
				let n = t[0]
				for (let e = 1, i = t.length; e < i; ++e) t[e] > n && (n = t[e])
				return n
			}
			Object.defineProperty(xn.prototype, "needsUpdate", {
				set: function (t) {
					!0 === t && this.version++
				}
			}),
				Object.assign(xn.prototype, {
					isBufferAttribute: !0,
					onUploadCallback: function () {},
					setUsage: function (t) {
						return (this.usage = t), this
					},
					copy: function (t) {
						return (
							(this.name = t.name),
							(this.array = new t.array.constructor(t.array)),
							(this.itemSize = t.itemSize),
							(this.count = t.count),
							(this.normalized = t.normalized),
							(this.usage = t.usage),
							this
						)
					},
					copyAt: function (t, n, e) {
						;(t *= this.itemSize), (e *= n.itemSize)
						for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = n.array[e + i]
						return this
					},
					copyArray: function (t) {
						return this.array.set(t), this
					},
					copyColorsArray: function (t) {
						const n = this.array
						let e = 0
						for (let i = 0, r = t.length; i < r; i++) {
							let o = t[i]
							void 0 === o &&
								(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), (o = new Lt())),
								(n[e++] = o.r),
								(n[e++] = o.g),
								(n[e++] = o.b)
						}
						return this
					},
					copyVector2sArray: function (t) {
						const n = this.array
						let e = 0
						for (let i = 0, r = t.length; i < r; i++) {
							let o = t[i]
							void 0 === o &&
								(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), (o = new lt())),
								(n[e++] = o.x),
								(n[e++] = o.y)
						}
						return this
					},
					copyVector3sArray: function (t) {
						const n = this.array
						let e = 0
						for (let i = 0, r = t.length; i < r; i++) {
							let o = t[i]
							void 0 === o &&
								(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), (o = new K())),
								(n[e++] = o.x),
								(n[e++] = o.y),
								(n[e++] = o.z)
						}
						return this
					},
					copyVector4sArray: function (t) {
						const n = this.array
						let e = 0
						for (let i = 0, r = t.length; i < r; i++) {
							let o = t[i]
							void 0 === o &&
								(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), (o = new lr())),
								(n[e++] = o.x),
								(n[e++] = o.y),
								(n[e++] = o.z),
								(n[e++] = o.w)
						}
						return this
					},
					applyMatrix3: function (t) {
						if (2 === this.itemSize)
							for (let n = 0, e = this.count; n < e; n++)
								FM.fromBufferAttribute(this, n), FM.applyMatrix3(t), this.setXY(n, FM.x, FM.y)
						else if (3 === this.itemSize)
							for (let n = 0, e = this.count; n < e; n++)
								Nr.fromBufferAttribute(this, n), Nr.applyMatrix3(t), this.setXYZ(n, Nr.x, Nr.y, Nr.z)
						return this
					},
					applyMatrix4: function (t) {
						for (let n = 0, e = this.count; n < e; n++)
							(Nr.x = this.getX(n)),
								(Nr.y = this.getY(n)),
								(Nr.z = this.getZ(n)),
								Nr.applyMatrix4(t),
								this.setXYZ(n, Nr.x, Nr.y, Nr.z)
						return this
					},
					applyNormalMatrix: function (t) {
						for (let n = 0, e = this.count; n < e; n++)
							(Nr.x = this.getX(n)),
								(Nr.y = this.getY(n)),
								(Nr.z = this.getZ(n)),
								Nr.applyNormalMatrix(t),
								this.setXYZ(n, Nr.x, Nr.y, Nr.z)
						return this
					},
					transformDirection: function (t) {
						for (let n = 0, e = this.count; n < e; n++)
							(Nr.x = this.getX(n)),
								(Nr.y = this.getY(n)),
								(Nr.z = this.getZ(n)),
								Nr.transformDirection(t),
								this.setXYZ(n, Nr.x, Nr.y, Nr.z)
						return this
					},
					set: function (t, n = 0) {
						return this.array.set(t, n), this
					},
					getX: function (t) {
						return this.array[t * this.itemSize]
					},
					setX: function (t, n) {
						return (this.array[t * this.itemSize] = n), this
					},
					getY: function (t) {
						return this.array[t * this.itemSize + 1]
					},
					setY: function (t, n) {
						return (this.array[t * this.itemSize + 1] = n), this
					},
					getZ: function (t) {
						return this.array[t * this.itemSize + 2]
					},
					setZ: function (t, n) {
						return (this.array[t * this.itemSize + 2] = n), this
					},
					getW: function (t) {
						return this.array[t * this.itemSize + 3]
					},
					setW: function (t, n) {
						return (this.array[t * this.itemSize + 3] = n), this
					},
					setXY: function (t, n, e) {
						return (this.array[0 + (t *= this.itemSize)] = n), (this.array[t + 1] = e), this
					},
					setXYZ: function (t, n, e, i) {
						return (this.array[0 + (t *= this.itemSize)] = n), (this.array[t + 1] = e), (this.array[t + 2] = i), this
					},
					setXYZW: function (t, n, e, i, r) {
						return (
							(this.array[0 + (t *= this.itemSize)] = n),
							(this.array[t + 1] = e),
							(this.array[t + 2] = i),
							(this.array[t + 3] = r),
							this
						)
					},
					onUpload: function (t) {
						return (this.onUploadCallback = t), this
					},
					clone: function () {
						return new this.constructor(this.array, this.itemSize).copy(this)
					},
					toJSON: function () {
						return {
							itemSize: this.itemSize,
							type: this.array.constructor.name,
							array: Array.prototype.slice.call(this.array),
							normalized: this.normalized
						}
					}
				}),
				((gy.prototype = Object.create(xn.prototype)).constructor = gy),
				((by.prototype = Object.create(xn.prototype)).constructor = by),
				((_y.prototype = Object.create(xn.prototype)).constructor = _y),
				((vy.prototype = Object.create(xn.prototype)).constructor = vy),
				((dp.prototype = Object.create(xn.prototype)).constructor = dp),
				((yy.prototype = Object.create(xn.prototype)).constructor = yy),
				((up.prototype = Object.create(xn.prototype)).constructor = up),
				((wy.prototype = Object.create(xn.prototype)).constructor = wy),
				(wy.prototype.isFloat16BufferAttribute = !0),
				((cn.prototype = Object.create(xn.prototype)).constructor = cn),
				((xy.prototype = Object.create(xn.prototype)).constructor = xy)
			const Nve = {
				Int8Array,
				Uint8Array,
				Uint8ClampedArray,
				Int16Array,
				Uint16Array,
				Int32Array,
				Uint32Array,
				Float32Array,
				Float64Array
			}
			function Cy(t, n) {
				return new Nve[t](n)
			}
			let Uve = 0
			const Ed = new Cn(),
				OR = new On(),
				jg = new K(),
				oc = new is(),
				Ey = new is(),
				ms = new K()
			function vn() {
				Object.defineProperty(this, "id", { value: Uve++ }),
					(this.uuid = jn.generateUUID()),
					(this.name = ""),
					(this.type = "BufferGeometry"),
					(this.index = null),
					(this.attributes = {}),
					(this.morphAttributes = {}),
					(this.morphTargetsRelative = !1),
					(this.groups = []),
					(this.boundingBox = null),
					(this.boundingSphere = null),
					(this.drawRange = { start: 0, count: 1 / 0 }),
					(this.userData = {})
			}
			vn.prototype = Object.assign(Object.create(Iu.prototype), {
				constructor: vn,
				isBufferGeometry: !0,
				getIndex: function () {
					return this.index
				},
				setIndex: function (t) {
					return (this.index = Array.isArray(t) ? new (Qj(t) > 65535 ? up : dp)(t, 1) : t), this
				},
				getAttribute: function (t) {
					return this.attributes[t]
				},
				setAttribute: function (t, n) {
					return (this.attributes[t] = n), this
				},
				deleteAttribute: function (t) {
					return delete this.attributes[t], this
				},
				hasAttribute: function (t) {
					return void 0 !== this.attributes[t]
				},
				addGroup: function (t, n, e = 0) {
					this.groups.push({ start: t, count: n, materialIndex: e })
				},
				clearGroups: function () {
					this.groups = []
				},
				setDrawRange: function (t, n) {
					;(this.drawRange.start = t), (this.drawRange.count = n)
				},
				applyMatrix4: function (t) {
					const n = this.attributes.position
					void 0 !== n && (n.applyMatrix4(t), (n.needsUpdate = !0))
					const e = this.attributes.normal
					if (void 0 !== e) {
						const r = new ns().getNormalMatrix(t)
						e.applyNormalMatrix(r), (e.needsUpdate = !0)
					}
					const i = this.attributes.tangent
					return (
						void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
						null !== this.boundingBox && this.computeBoundingBox(),
						null !== this.boundingSphere && this.computeBoundingSphere(),
						this
					)
				},
				rotateX: function (t) {
					return Ed.makeRotationX(t), this.applyMatrix4(Ed), this
				},
				rotateY: function (t) {
					return Ed.makeRotationY(t), this.applyMatrix4(Ed), this
				},
				rotateZ: function (t) {
					return Ed.makeRotationZ(t), this.applyMatrix4(Ed), this
				},
				translate: function (t, n, e) {
					return Ed.makeTranslation(t, n, e), this.applyMatrix4(Ed), this
				},
				scale: function (t, n, e) {
					return Ed.makeScale(t, n, e), this.applyMatrix4(Ed), this
				},
				lookAt: function (t) {
					return OR.lookAt(t), OR.updateMatrix(), this.applyMatrix4(OR.matrix), this
				},
				center: function () {
					return this.computeBoundingBox(), this.boundingBox.getCenter(jg).negate(), this.translate(jg.x, jg.y, jg.z), this
				},
				setFromPoints: function (t) {
					const n = []
					for (let e = 0, i = t.length; e < i; e++) {
						const r = t[e]
						n.push(r.x, r.y, r.z || 0)
					}
					return this.setAttribute("position", new cn(n, 3)), this
				},
				computeBoundingBox: function () {
					null === this.boundingBox && (this.boundingBox = new is())
					const t = this.attributes.position,
						n = this.morphAttributes.position
					if (t && t.isGLBufferAttribute)
						return (
							console.error(
								'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
								this
							),
							void this.boundingBox.set(new K(-1 / 0, -1 / 0, -1 / 0), new K(1 / 0, 1 / 0, 1 / 0))
						)
					if (void 0 !== t) {
						if ((this.boundingBox.setFromBufferAttribute(t), n))
							for (let e = 0, i = n.length; e < i; e++)
								oc.setFromBufferAttribute(n[e]),
									this.morphTargetsRelative
										? (ms.addVectors(this.boundingBox.min, oc.min),
										  this.boundingBox.expandByPoint(ms),
										  ms.addVectors(this.boundingBox.max, oc.max),
										  this.boundingBox.expandByPoint(ms))
										: (this.boundingBox.expandByPoint(oc.min), this.boundingBox.expandByPoint(oc.max))
					} else this.boundingBox.makeEmpty()
					;(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
						console.error(
							'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
							this
						)
				},
				computeBoundingSphere: function () {
					null === this.boundingSphere && (this.boundingSphere = new xd())
					const t = this.attributes.position,
						n = this.morphAttributes.position
					if (t && t.isGLBufferAttribute)
						return (
							console.error(
								'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
								this
							),
							void this.boundingSphere.set(new K(), 1 / 0)
						)
					if (t) {
						const e = this.boundingSphere.center
						if ((oc.setFromBufferAttribute(t), n))
							for (let r = 0, o = n.length; r < o; r++)
								Ey.setFromBufferAttribute(n[r]),
									this.morphTargetsRelative
										? (ms.addVectors(oc.min, Ey.min),
										  oc.expandByPoint(ms),
										  ms.addVectors(oc.max, Ey.max),
										  oc.expandByPoint(ms))
										: (oc.expandByPoint(Ey.min), oc.expandByPoint(Ey.max))
						oc.getCenter(e)
						let i = 0
						for (let r = 0, o = t.count; r < o; r++) ms.fromBufferAttribute(t, r), (i = Math.max(i, e.distanceToSquared(ms)))
						if (n)
							for (let r = 0, o = n.length; r < o; r++) {
								const s = n[r],
									a = this.morphTargetsRelative
								for (let c = 0, l = s.count; c < l; c++)
									ms.fromBufferAttribute(s, c),
										a && (jg.fromBufferAttribute(t, c), ms.add(jg)),
										(i = Math.max(i, e.distanceToSquared(ms)))
							}
						;(this.boundingSphere.radius = Math.sqrt(i)),
							isNaN(this.boundingSphere.radius) &&
								console.error(
									'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
									this
								)
					}
				},
				computeFaceNormals: function () {},
				computeTangents: function () {
					const t = this.index,
						n = this.attributes
					if (null === t || void 0 === n.position || void 0 === n.normal || void 0 === n.uv)
						return void console.error(
							"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
						)
					const e = t.array,
						i = n.position.array,
						r = n.normal.array,
						o = n.uv.array,
						s = i.length / 3
					void 0 === n.tangent && this.setAttribute("tangent", new xn(new Float32Array(4 * s), 4))
					const a = n.tangent.array,
						c = [],
						l = []
					for (let ae = 0; ae < s; ae++) (c[ae] = new K()), (l[ae] = new K())
					const d = new K(),
						u = new K(),
						h = new K(),
						f = new lt(),
						_ = new lt(),
						y = new lt(),
						C = new K(),
						x = new K()
					function w(ae, ce, ue) {
						d.fromArray(i, 3 * ae),
							u.fromArray(i, 3 * ce),
							h.fromArray(i, 3 * ue),
							f.fromArray(o, 2 * ae),
							_.fromArray(o, 2 * ce),
							y.fromArray(o, 2 * ue),
							u.sub(d),
							h.sub(d),
							_.sub(f),
							y.sub(f)
						const Se = 1 / (_.x * y.y - y.x * _.y)
						isFinite(Se) &&
							(C.copy(u).multiplyScalar(y.y).addScaledVector(h, -_.y).multiplyScalar(Se),
							x.copy(h).multiplyScalar(_.x).addScaledVector(u, -y.x).multiplyScalar(Se),
							c[ae].add(C),
							c[ce].add(C),
							c[ue].add(C),
							l[ae].add(x),
							l[ce].add(x),
							l[ue].add(x))
					}
					let S = this.groups
					0 === S.length && (S = [{ start: 0, count: e.length }])
					for (let ae = 0, ce = S.length; ae < ce; ++ae) {
						const ue = S[ae],
							Se = ue.start
						for (let W = Se, me = Se + ue.count; W < me; W += 3) w(e[W + 0], e[W + 1], e[W + 2])
					}
					const M = new K(),
						O = new K(),
						N = new K(),
						j = new K()
					function le(ae) {
						N.fromArray(r, 3 * ae), j.copy(N)
						const ce = c[ae]
						M.copy(ce), M.sub(N.multiplyScalar(N.dot(ce))).normalize(), O.crossVectors(j, ce)
						const Se = O.dot(l[ae]) < 0 ? -1 : 1
						;(a[4 * ae] = M.x), (a[4 * ae + 1] = M.y), (a[4 * ae + 2] = M.z), (a[4 * ae + 3] = Se)
					}
					for (let ae = 0, ce = S.length; ae < ce; ++ae) {
						const ue = S[ae],
							Se = ue.start
						for (let W = Se, me = Se + ue.count; W < me; W += 3) le(e[W + 0]), le(e[W + 1]), le(e[W + 2])
					}
				},
				computeVertexNormals: function () {
					const t = this.index,
						n = this.getAttribute("position")
					if (void 0 !== n) {
						let e = this.getAttribute("normal")
						if (void 0 === e) (e = new xn(new Float32Array(3 * n.count), 3)), this.setAttribute("normal", e)
						else for (let u = 0, h = e.count; u < h; u++) e.setXYZ(u, 0, 0, 0)
						const i = new K(),
							r = new K(),
							o = new K(),
							s = new K(),
							a = new K(),
							c = new K(),
							l = new K(),
							d = new K()
						if (t)
							for (let u = 0, h = t.count; u < h; u += 3) {
								const f = t.getX(u + 0),
									_ = t.getX(u + 1),
									y = t.getX(u + 2)
								i.fromBufferAttribute(n, f),
									r.fromBufferAttribute(n, _),
									o.fromBufferAttribute(n, y),
									l.subVectors(o, r),
									d.subVectors(i, r),
									l.cross(d),
									s.fromBufferAttribute(e, f),
									a.fromBufferAttribute(e, _),
									c.fromBufferAttribute(e, y),
									s.add(l),
									a.add(l),
									c.add(l),
									e.setXYZ(f, s.x, s.y, s.z),
									e.setXYZ(_, a.x, a.y, a.z),
									e.setXYZ(y, c.x, c.y, c.z)
							}
						else
							for (let u = 0, h = n.count; u < h; u += 3)
								i.fromBufferAttribute(n, u + 0),
									r.fromBufferAttribute(n, u + 1),
									o.fromBufferAttribute(n, u + 2),
									l.subVectors(o, r),
									d.subVectors(i, r),
									l.cross(d),
									e.setXYZ(u + 0, l.x, l.y, l.z),
									e.setXYZ(u + 1, l.x, l.y, l.z),
									e.setXYZ(u + 2, l.x, l.y, l.z)
						this.normalizeNormals(), (e.needsUpdate = !0)
					}
				},
				merge: function (t, n) {
					if (!t || !t.isBufferGeometry)
						return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
					void 0 === n &&
						((n = 0),
						console.warn(
							"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
						))
					const e = this.attributes
					for (const i in e) {
						if (void 0 === t.attributes[i]) continue
						const o = e[i].array,
							s = t.attributes[i],
							a = s.array,
							c = s.itemSize * n,
							l = Math.min(a.length, o.length - c)
						for (let d = 0, u = c; d < l; d++, u++) o[u] = a[d]
					}
					return this
				},
				normalizeNormals: function () {
					const t = this.attributes.normal
					for (let n = 0, e = t.count; n < e; n++) ms.fromBufferAttribute(t, n), ms.normalize(), t.setXYZ(n, ms.x, ms.y, ms.z)
				},
				toNonIndexed: function () {
					function t(s, a) {
						const c = s.array,
							l = s.itemSize,
							d = s.normalized,
							u = new c.constructor(a.length * l)
						let h = 0,
							f = 0
						for (let _ = 0, y = a.length; _ < y; _++) {
							h = a[_] * l
							for (let C = 0; C < l; C++) u[f++] = c[h++]
						}
						return new xn(u, l, d)
					}
					if (null === this.index)
						return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this
					const n = new vn(),
						e = this.index.array,
						i = this.attributes
					for (const s in i) {
						const c = t(i[s], e)
						n.setAttribute(s, c)
					}
					const r = this.morphAttributes
					for (const s in r) {
						const a = [],
							c = r[s]
						for (let l = 0, d = c.length; l < d; l++) {
							const h = t(c[l], e)
							a.push(h)
						}
						n.morphAttributes[s] = a
					}
					n.morphTargetsRelative = this.morphTargetsRelative
					const o = this.groups
					for (let s = 0, a = o.length; s < a; s++) {
						const c = o[s]
						n.addGroup(c.start, c.count, c.materialIndex)
					}
					return n
				},
				toJSON: function () {
					const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }
					if (
						((t.uuid = this.uuid),
						(t.type = this.type),
						"" !== this.name && (t.name = this.name),
						Object.keys(this.userData).length > 0 && (t.userData = this.userData),
						void 0 !== this.parameters)
					) {
						const a = this.parameters
						for (const c in a) void 0 !== a[c] && (t[c] = a[c])
						return t
					}
					t.data = { attributes: {} }
					const n = this.index
					null !== n && (t.data.index = { type: n.array.constructor.name, array: Array.prototype.slice.call(n.array) })
					const e = this.attributes
					for (const a in e) {
						const c = e[a],
							l = c.toJSON(t.data)
						"" !== c.name && (l.name = c.name), (t.data.attributes[a] = l)
					}
					const i = {}
					let r = !1
					for (const a in this.morphAttributes) {
						const c = this.morphAttributes[a],
							l = []
						for (let d = 0, u = c.length; d < u; d++) {
							const h = c[d],
								f = h.toJSON(t.data)
							"" !== h.name && (f.name = h.name), l.push(f)
						}
						l.length > 0 && ((i[a] = l), (r = !0))
					}
					r && ((t.data.morphAttributes = i), (t.data.morphTargetsRelative = this.morphTargetsRelative))
					const o = this.groups
					o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)))
					const s = this.boundingSphere
					return null !== s && (t.data.boundingSphere = { center: s.center.toArray(), radius: s.radius }), t
				},
				clone: function () {
					return new vn().copy(this)
				},
				copy: function (t) {
					;(this.index = null),
						(this.attributes = {}),
						(this.morphAttributes = {}),
						(this.groups = []),
						(this.boundingBox = null),
						(this.boundingSphere = null)
					const n = {}
					this.name = t.name
					const e = t.index
					null !== e && this.setIndex(e.clone(n))
					const i = t.attributes
					for (const c in i) this.setAttribute(c, i[c].clone(n))
					const r = t.morphAttributes
					for (const c in r) {
						const l = [],
							d = r[c]
						for (let u = 0, h = d.length; u < h; u++) l.push(d[u].clone(n))
						this.morphAttributes[c] = l
					}
					this.morphTargetsRelative = t.morphTargetsRelative
					const o = t.groups
					for (let c = 0, l = o.length; c < l; c++) {
						const d = o[c]
						this.addGroup(d.start, d.count, d.materialIndex)
					}
					const s = t.boundingBox
					null !== s && (this.boundingBox = s.clone())
					const a = t.boundingSphere
					return (
						null !== a && (this.boundingSphere = a.clone()),
						(this.drawRange.start = t.drawRange.start),
						(this.drawRange.count = t.drawRange.count),
						(this.userData = t.userData),
						this
					)
				},
				dispose: function () {
					this.dispatchEvent({ type: "dispose" })
				}
			})
			const zj = new Cn(),
				Kg = new Ru(),
				NR = new xd(),
				ef = new K(),
				tf = new K(),
				nf = new K(),
				UR = new K(),
				HR = new K(),
				VR = new K(),
				BM = new K(),
				IM = new K(),
				DM = new K(),
				LM = new lt(),
				RM = new lt(),
				PM = new lt(),
				QR = new K(),
				OM = new K()
			function Mi(t = new vn(), n = new Cd()) {
				On.call(this), (this.type = "Mesh"), (this.geometry = t), (this.material = n), this.updateMorphTargets()
			}
			function NM(t, n, e, i, r, o, s, a, c, l, d, u) {
				ef.fromBufferAttribute(r, l), tf.fromBufferAttribute(r, d), nf.fromBufferAttribute(r, u)
				const h = t.morphTargetInfluences
				if (n.morphTargets && o && h) {
					BM.set(0, 0, 0), IM.set(0, 0, 0), DM.set(0, 0, 0)
					for (let _ = 0, y = o.length; _ < y; _++) {
						const C = h[_],
							x = o[_]
						0 !== C &&
							(UR.fromBufferAttribute(x, l),
							HR.fromBufferAttribute(x, d),
							VR.fromBufferAttribute(x, u),
							s
								? (BM.addScaledVector(UR, C), IM.addScaledVector(HR, C), DM.addScaledVector(VR, C))
								: (BM.addScaledVector(UR.sub(ef), C), IM.addScaledVector(HR.sub(tf), C), DM.addScaledVector(VR.sub(nf), C)))
					}
					ef.add(BM), tf.add(IM), nf.add(DM)
				}
				t.isSkinnedMesh && n.skinning && (t.boneTransform(l, ef), t.boneTransform(d, tf), t.boneTransform(u, nf))
				const f = (function Hve(t, n, e, i, r, o, s, a) {
					let c
					if (
						((c = n.side === Lo ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, n.side !== ey, a)),
						null === c)
					)
						return null
					OM.copy(a), OM.applyMatrix4(t.matrixWorld)
					const l = e.ray.origin.distanceTo(OM)
					return l < e.near || l > e.far ? null : { distance: l, point: OM.clone(), object: t }
				})(t, n, e, i, ef, tf, nf, QR)
				if (f) {
					a &&
						(LM.fromBufferAttribute(a, l),
						RM.fromBufferAttribute(a, d),
						PM.fromBufferAttribute(a, u),
						(f.uv = Ro.getUV(QR, ef, tf, nf, LM, RM, PM, new lt()))),
						c &&
							(LM.fromBufferAttribute(c, l),
							RM.fromBufferAttribute(c, d),
							PM.fromBufferAttribute(c, u),
							(f.uv2 = Ro.getUV(QR, ef, tf, nf, LM, RM, PM, new lt())))
					const _ = { a: l, b: d, c: u, normal: new K(), materialIndex: 0 }
					Ro.getNormal(ef, tf, nf, _.normal), (f.face = _)
				}
				return f
			}
			Mi.prototype = Object.assign(Object.create(On.prototype), {
				constructor: Mi,
				isMesh: !0,
				copy: function (t) {
					return (
						On.prototype.copy.call(this, t),
						void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
						void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
						(this.material = t.material),
						(this.geometry = t.geometry),
						this
					)
				},
				updateMorphTargets: function () {
					const t = this.geometry
					if (t.isBufferGeometry) {
						const n = t.morphAttributes,
							e = Object.keys(n)
						if (e.length > 0) {
							const i = n[e[0]]
							if (void 0 !== i) {
								;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
								for (let r = 0, o = i.length; r < o; r++) {
									const s = i[r].name || String(r)
									this.morphTargetInfluences.push(0), (this.morphTargetDictionary[s] = r)
								}
							}
						}
					} else {
						const n = t.morphTargets
						void 0 !== n &&
							n.length > 0 &&
							console.error(
								"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
							)
					}
				},
				raycast: function (t, n) {
					const e = this.geometry,
						i = this.material,
						r = this.matrixWorld
					if (
						void 0 === i ||
						(null === e.boundingSphere && e.computeBoundingSphere(),
						NR.copy(e.boundingSphere),
						NR.applyMatrix4(r),
						!1 === t.ray.intersectsSphere(NR)) ||
						(zj.copy(r).invert(),
						Kg.copy(t.ray).applyMatrix4(zj),
						null !== e.boundingBox && !1 === Kg.intersectsBox(e.boundingBox))
					)
						return
					let o
					if (e.isBufferGeometry) {
						const s = e.index,
							a = e.attributes.position,
							c = e.morphAttributes.position,
							l = e.morphTargetsRelative,
							d = e.attributes.uv,
							u = e.attributes.uv2,
							h = e.groups,
							f = e.drawRange
						if (null !== s)
							if (Array.isArray(i))
								for (let _ = 0, y = h.length; _ < y; _++) {
									const C = h[_],
										x = i[C.materialIndex]
									for (
										let M = Math.max(C.start, f.start), O = Math.min(C.start + C.count, f.start + f.count);
										M < O;
										M += 3
									) {
										const N = s.getX(M),
											j = s.getX(M + 1),
											le = s.getX(M + 2)
										;(o = NM(this, x, t, Kg, a, c, l, d, u, N, j, le)),
											o && ((o.faceIndex = Math.floor(M / 3)), (o.face.materialIndex = C.materialIndex), n.push(o))
									}
								}
							else
								for (let C = Math.max(0, f.start), x = Math.min(s.count, f.start + f.count); C < x; C += 3) {
									const w = s.getX(C),
										S = s.getX(C + 1),
										M = s.getX(C + 2)
									;(o = NM(this, i, t, Kg, a, c, l, d, u, w, S, M)), o && ((o.faceIndex = Math.floor(C / 3)), n.push(o))
								}
						else if (void 0 !== a)
							if (Array.isArray(i))
								for (let _ = 0, y = h.length; _ < y; _++) {
									const C = h[_],
										x = i[C.materialIndex]
									for (
										let M = Math.max(C.start, f.start), O = Math.min(C.start + C.count, f.start + f.count);
										M < O;
										M += 3
									)
										(o = NM(this, x, t, Kg, a, c, l, d, u, M, M + 1, M + 2)),
											o && ((o.faceIndex = Math.floor(M / 3)), (o.face.materialIndex = C.materialIndex), n.push(o))
								}
							else
								for (let C = Math.max(0, f.start), x = Math.min(a.count, f.start + f.count); C < x; C += 3)
									(o = NM(this, i, t, Kg, a, c, l, d, u, C, C + 1, C + 2)),
										o && ((o.faceIndex = Math.floor(C / 3)), n.push(o))
					} else
						e.isGeometry &&
							console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				}
			})
			class _l extends vn {
				constructor(n = 1, e = 1, i = 1, r = 1, o = 1, s = 1) {
					super(),
						(this.type = "BoxGeometry"),
						(this.parameters = { width: n, height: e, depth: i, widthSegments: r, heightSegments: o, depthSegments: s })
					const a = this
					;(r = Math.floor(r)), (o = Math.floor(o)), (s = Math.floor(s))
					const c = [],
						l = [],
						d = [],
						u = []
					let h = 0,
						f = 0
					function _(y, C, x, w, S, M, O, N, j, le, ae) {
						const ce = M / j,
							ue = O / le,
							Se = M / 2,
							ve = O / 2,
							W = N / 2,
							me = j + 1,
							Z = le + 1
						let Ae = 0,
							Ie = 0
						const Pe = new K()
						for (let nt = 0; nt < Z; nt++) {
							const pt = nt * ue - ve
							for (let kt = 0; kt < me; kt++)
								(Pe[y] = (kt * ce - Se) * w),
									(Pe[C] = pt * S),
									(Pe[x] = W),
									l.push(Pe.x, Pe.y, Pe.z),
									(Pe[y] = 0),
									(Pe[C] = 0),
									(Pe[x] = N > 0 ? 1 : -1),
									d.push(Pe.x, Pe.y, Pe.z),
									u.push(kt / j),
									u.push(1 - nt / le),
									(Ae += 1)
						}
						for (let nt = 0; nt < le; nt++)
							for (let pt = 0; pt < j; pt++) {
								const tn = h + pt + me * (nt + 1),
									Kt = h + (pt + 1) + me * (nt + 1),
									Un = h + (pt + 1) + me * nt
								c.push(h + pt + me * nt, tn, Un), c.push(tn, Kt, Un), (Ie += 6)
							}
						a.addGroup(f, Ie, ae), (f += Ie), (h += Ae)
					}
					_("z", "y", "x", -1, -1, i, e, n, s, o, 0),
						_("z", "y", "x", 1, -1, i, e, -n, s, o, 1),
						_("x", "z", "y", 1, 1, n, i, e, r, s, 2),
						_("x", "z", "y", 1, -1, n, i, -e, r, s, 3),
						_("x", "y", "z", 1, -1, n, e, i, r, o, 4),
						_("x", "y", "z", -1, -1, n, e, -i, r, o, 5),
						this.setIndex(c),
						this.setAttribute("position", new cn(l, 3)),
						this.setAttribute("normal", new cn(d, 3)),
						this.setAttribute("uv", new cn(u, 2))
				}
			}
			function Xg(t) {
				const n = {}
				for (const e in t) {
					n[e] = {}
					for (const i in t[e]) {
						const r = t[e][i]
						n[e][i] =
							r &&
							(r.isColor ||
								r.isMatrix3 ||
								r.isMatrix4 ||
								r.isVector2 ||
								r.isVector3 ||
								r.isVector4 ||
								r.isTexture ||
								r.isQuaternion)
								? r.clone()
								: Array.isArray(r)
								? r.slice()
								: r
					}
				}
				return n
			}
			function zs(t) {
				const n = {}
				for (let e = 0; e < t.length; e++) {
					const i = Xg(t[e])
					for (const r in i) n[r] = i[r]
				}
				return n
			}
			const UM = { clone: Xg, merge: zs }
			var Vve = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
				Qve = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"
			function Ds(t) {
				jr.call(this),
					(this.type = "ShaderMaterial"),
					(this.defines = {}),
					(this.uniforms = {}),
					(this.vertexShader = Vve),
					(this.fragmentShader = Qve),
					(this.linewidth = 1),
					(this.wireframe = !1),
					(this.wireframeLinewidth = 1),
					(this.fog = !1),
					(this.lights = !1),
					(this.clipping = !1),
					(this.skinning = !1),
					(this.morphTargets = !1),
					(this.morphNormals = !1),
					(this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
					(this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
					(this.index0AttributeName = void 0),
					(this.uniformsNeedUpdate = !1),
					(this.glslVersion = null),
					void 0 !== t &&
						(void 0 !== t.attributes &&
							console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
						this.setValues(t))
			}
			function rf() {
				On.call(this),
					(this.type = "Camera"),
					(this.matrixWorldInverse = new Cn()),
					(this.projectionMatrix = new Cn()),
					(this.projectionMatrixInverse = new Cn())
			}
			function Co(t = 50, n = 1, e = 0.1, i = 2e3) {
				rf.call(this),
					(this.type = "PerspectiveCamera"),
					(this.fov = t),
					(this.zoom = 1),
					(this.near = e),
					(this.far = i),
					(this.focus = 10),
					(this.aspect = n),
					(this.view = null),
					(this.filmGauge = 35),
					(this.filmOffset = 0),
					this.updateProjectionMatrix()
			}
			;((Ds.prototype = Object.create(jr.prototype)).constructor = Ds),
				(Ds.prototype.isShaderMaterial = !0),
				(Ds.prototype.copy = function (t) {
					return (
						jr.prototype.copy.call(this, t),
						(this.fragmentShader = t.fragmentShader),
						(this.vertexShader = t.vertexShader),
						(this.uniforms = Xg(t.uniforms)),
						(this.defines = Object.assign({}, t.defines)),
						(this.wireframe = t.wireframe),
						(this.wireframeLinewidth = t.wireframeLinewidth),
						(this.lights = t.lights),
						(this.clipping = t.clipping),
						(this.skinning = t.skinning),
						(this.morphTargets = t.morphTargets),
						(this.morphNormals = t.morphNormals),
						(this.extensions = Object.assign({}, t.extensions)),
						(this.glslVersion = t.glslVersion),
						this
					)
				}),
				(Ds.prototype.toJSON = function (t) {
					const n = jr.prototype.toJSON.call(this, t)
					;(n.glslVersion = this.glslVersion), (n.uniforms = {})
					for (const i in this.uniforms) {
						const o = this.uniforms[i].value
						n.uniforms[i] =
							o && o.isTexture
								? { type: "t", value: o.toJSON(t).uuid }
								: o && o.isColor
								? { type: "c", value: o.getHex() }
								: o && o.isVector2
								? { type: "v2", value: o.toArray() }
								: o && o.isVector3
								? { type: "v3", value: o.toArray() }
								: o && o.isVector4
								? { type: "v4", value: o.toArray() }
								: o && o.isMatrix3
								? { type: "m3", value: o.toArray() }
								: o && o.isMatrix4
								? { type: "m4", value: o.toArray() }
								: { value: o }
					}
					Object.keys(this.defines).length > 0 && (n.defines = this.defines),
						(n.vertexShader = this.vertexShader),
						(n.fragmentShader = this.fragmentShader)
					const e = {}
					for (const i in this.extensions) !0 === this.extensions[i] && (e[i] = !0)
					return Object.keys(e).length > 0 && (n.extensions = e), n
				}),
				(rf.prototype = Object.assign(Object.create(On.prototype), {
					constructor: rf,
					isCamera: !0,
					copy: function (t, n) {
						return (
							On.prototype.copy.call(this, t, n),
							this.matrixWorldInverse.copy(t.matrixWorldInverse),
							this.projectionMatrix.copy(t.projectionMatrix),
							this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
							this
						)
					},
					getWorldDirection: function (t) {
						void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), (t = new K())),
							this.updateWorldMatrix(!0, !1)
						const n = this.matrixWorld.elements
						return t.set(-n[8], -n[9], -n[10]).normalize()
					},
					updateMatrixWorld: function (t) {
						On.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
					},
					updateWorldMatrix: function (t, n) {
						On.prototype.updateWorldMatrix.call(this, t, n), this.matrixWorldInverse.copy(this.matrixWorld).invert()
					},
					clone: function () {
						return new this.constructor().copy(this)
					}
				})),
				(Co.prototype = Object.assign(Object.create(rf.prototype), {
					constructor: Co,
					isPerspectiveCamera: !0,
					copy: function (t, n) {
						return (
							rf.prototype.copy.call(this, t, n),
							(this.fov = t.fov),
							(this.zoom = t.zoom),
							(this.near = t.near),
							(this.far = t.far),
							(this.focus = t.focus),
							(this.aspect = t.aspect),
							(this.view = null === t.view ? null : Object.assign({}, t.view)),
							(this.filmGauge = t.filmGauge),
							(this.filmOffset = t.filmOffset),
							this
						)
					},
					setFocalLength: function (t) {
						const n = (0.5 * this.getFilmHeight()) / t
						;(this.fov = 2 * jn.RAD2DEG * Math.atan(n)), this.updateProjectionMatrix()
					},
					getFocalLength: function () {
						const t = Math.tan(0.5 * jn.DEG2RAD * this.fov)
						return (0.5 * this.getFilmHeight()) / t
					},
					getEffectiveFOV: function () {
						return 2 * jn.RAD2DEG * Math.atan(Math.tan(0.5 * jn.DEG2RAD * this.fov) / this.zoom)
					},
					getFilmWidth: function () {
						return this.filmGauge * Math.min(this.aspect, 1)
					},
					getFilmHeight: function () {
						return this.filmGauge / Math.max(this.aspect, 1)
					},
					setViewOffset: function (t, n, e, i, r, o) {
						;(this.aspect = t / n),
							null === this.view &&
								(this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
							(this.view.enabled = !0),
							(this.view.fullWidth = t),
							(this.view.fullHeight = n),
							(this.view.offsetX = e),
							(this.view.offsetY = i),
							(this.view.width = r),
							(this.view.height = o),
							this.updateProjectionMatrix()
					},
					clearViewOffset: function () {
						null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
					},
					updateProjectionMatrix: function () {
						const t = this.near
						let n = (t * Math.tan(0.5 * jn.DEG2RAD * this.fov)) / this.zoom,
							e = 2 * n,
							i = this.aspect * e,
							r = -0.5 * i
						const o = this.view
						if (null !== this.view && this.view.enabled) {
							const a = o.fullWidth,
								c = o.fullHeight
							;(r += (o.offsetX * i) / a), (n -= (o.offsetY * e) / c), (i *= o.width / a), (e *= o.height / c)
						}
						const s = this.filmOffset
						0 !== s && (r += (t * s) / this.getFilmWidth()),
							this.projectionMatrix.makePerspective(r, r + i, n, n - e, t, this.far),
							this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
					},
					toJSON: function (t) {
						const n = On.prototype.toJSON.call(this, t)
						return (
							(n.object.fov = this.fov),
							(n.object.zoom = this.zoom),
							(n.object.near = this.near),
							(n.object.far = this.far),
							(n.object.focus = this.focus),
							(n.object.aspect = this.aspect),
							null !== this.view && (n.object.view = Object.assign({}, this.view)),
							(n.object.filmGauge = this.filmGauge),
							(n.object.filmOffset = this.filmOffset),
							n
						)
					}
				}))
			class HM extends On {
				constructor(n, e, i) {
					if ((super(), (this.type = "CubeCamera"), !0 !== i.isWebGLCubeRenderTarget))
						return void console.error(
							"THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
						)
					this.renderTarget = i
					const r = new Co(90, 1, n, e)
					;(r.layers = this.layers), r.up.set(0, -1, 0), r.lookAt(new K(1, 0, 0)), this.add(r)
					const o = new Co(90, 1, n, e)
					;(o.layers = this.layers), o.up.set(0, -1, 0), o.lookAt(new K(-1, 0, 0)), this.add(o)
					const s = new Co(90, 1, n, e)
					;(s.layers = this.layers), s.up.set(0, 0, 1), s.lookAt(new K(0, 1, 0)), this.add(s)
					const a = new Co(90, 1, n, e)
					;(a.layers = this.layers), a.up.set(0, 0, -1), a.lookAt(new K(0, -1, 0)), this.add(a)
					const c = new Co(90, 1, n, e)
					;(c.layers = this.layers), c.up.set(0, -1, 0), c.lookAt(new K(0, 0, 1)), this.add(c)
					const l = new Co(90, 1, n, e)
					;(l.layers = this.layers), l.up.set(0, -1, 0), l.lookAt(new K(0, 0, -1)), this.add(l)
				}
				update(n, e) {
					null === this.parent && this.updateMatrixWorld()
					const i = this.renderTarget,
						[r, o, s, a, c, l] = this.children,
						d = n.xr.enabled,
						u = n.getRenderTarget()
					n.xr.enabled = !1
					const h = i.texture.generateMipmaps
					;(i.texture.generateMipmaps = !1),
						n.setRenderTarget(i, 0),
						n.render(e, r),
						n.setRenderTarget(i, 1),
						n.render(e, o),
						n.setRenderTarget(i, 2),
						n.render(e, s),
						n.setRenderTarget(i, 3),
						n.render(e, a),
						n.setRenderTarget(i, 4),
						n.render(e, c),
						(i.texture.generateMipmaps = h),
						n.setRenderTarget(i, 5),
						n.render(e, l),
						n.setRenderTarget(u),
						(n.xr.enabled = d)
				}
			}
			class Zg extends zo {
				constructor(n, e, i, r, o, s, a, c, l, d) {
					super((n = void 0 !== n ? n : []), (e = void 0 !== e ? e : ny), i, r, o, s, (a = void 0 !== a ? a : Xh), c, l, d),
						(this._needsFlipEnvMap = !0),
						(this.flipY = !1)
				}
				get images() {
					return this.image
				}
				set images(n) {
					this.image = n
				}
			}
			Zg.prototype.isCubeTexture = !0
			class VM extends ml {
				constructor(n, e, i) {
					Number.isInteger(e) &&
						(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
						(e = i)),
						super(n, n, e),
						(this.texture = new Zg(
							void 0,
							(e = e || {}).mapping,
							e.wrapS,
							e.wrapT,
							e.magFilter,
							e.minFilter,
							e.format,
							e.type,
							e.anisotropy,
							e.encoding
						)),
						(this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps),
						(this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : xo),
						(this.texture._needsFlipEnvMap = !1)
				}
				fromEquirectangularTexture(n, e) {
					;(this.texture.type = e.type),
						(this.texture.format = ha),
						(this.texture.encoding = e.encoding),
						(this.texture.generateMipmaps = e.generateMipmaps),
						(this.texture.minFilter = e.minFilter),
						(this.texture.magFilter = e.magFilter)
					const i_uniforms = { tEquirect: { value: null } },
						i_vertexShader =
							"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
						i_fragmentShader =
							"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
						r = new _l(5, 5, 5),
						o = new Ds({
							name: "CubemapFromEquirect",
							uniforms: Xg(i_uniforms),
							vertexShader: i_vertexShader,
							fragmentShader: i_fragmentShader,
							side: Lo,
							blending: Fu
						})
					o.uniforms.tEquirect.value = e
					const s = new Mi(r, o),
						a = e.minFilter
					return (
						e.minFilter === Rg && (e.minFilter = xo),
						new HM(1, 10, this).update(n, s),
						(e.minFilter = a),
						s.geometry.dispose(),
						s.material.dispose(),
						this
					)
				}
				clear(n, e, i, r) {
					const o = n.getRenderTarget()
					for (let s = 0; s < 6; s++) n.setRenderTarget(this, s), n.clear(e, i, r)
					n.setRenderTarget(o)
				}
			}
			VM.prototype.isWebGLCubeRenderTarget = !0
			class Jg extends zo {
				constructor(n, e, i, r, o, s, a, c, l, d, u, h) {
					super(null, s, a, c, l, d, r, o, u, h),
						(this.image = { data: n || null, width: e || 1, height: i || 1 }),
						(this.magFilter = void 0 !== l ? l : ts),
						(this.minFilter = void 0 !== d ? d : ts),
						(this.generateMipmaps = !1),
						(this.flipY = !1),
						(this.unpackAlignment = 1),
						(this.needsUpdate = !0)
				}
			}
			Jg.prototype.isDataTexture = !0
			const eb = new xd(),
				QM = new K()
			class My {
				constructor(n = new Al(), e = new Al(), i = new Al(), r = new Al(), o = new Al(), s = new Al()) {
					this.planes = [n, e, i, r, o, s]
				}
				set(n, e, i, r, o, s) {
					const a = this.planes
					return a[0].copy(n), a[1].copy(e), a[2].copy(i), a[3].copy(r), a[4].copy(o), a[5].copy(s), this
				}
				copy(n) {
					const e = this.planes
					for (let i = 0; i < 6; i++) e[i].copy(n.planes[i])
					return this
				}
				setFromProjectionMatrix(n) {
					const e = this.planes,
						i = n.elements,
						r = i[0],
						o = i[1],
						s = i[2],
						a = i[3],
						c = i[4],
						l = i[5],
						d = i[6],
						u = i[7],
						h = i[8],
						f = i[9],
						_ = i[10],
						y = i[11],
						C = i[12],
						x = i[13],
						w = i[14],
						S = i[15]
					return (
						e[0].setComponents(a - r, u - c, y - h, S - C).normalize(),
						e[1].setComponents(a + r, u + c, y + h, S + C).normalize(),
						e[2].setComponents(a + o, u + l, y + f, S + x).normalize(),
						e[3].setComponents(a - o, u - l, y - f, S - x).normalize(),
						e[4].setComponents(a - s, u - d, y - _, S - w).normalize(),
						e[5].setComponents(a + s, u + d, y + _, S + w).normalize(),
						this
					)
				}
				intersectsObject(n) {
					const e = n.geometry
					return (
						null === e.boundingSphere && e.computeBoundingSphere(),
						eb.copy(e.boundingSphere).applyMatrix4(n.matrixWorld),
						this.intersectsSphere(eb)
					)
				}
				intersectsSprite(n) {
					return (
						eb.center.set(0, 0, 0), (eb.radius = 0.7071067811865476), eb.applyMatrix4(n.matrixWorld), this.intersectsSphere(eb)
					)
				}
				intersectsSphere(n) {
					const e = this.planes,
						i = n.center,
						r = -n.radius
					for (let o = 0; o < 6; o++) if (e[o].distanceToPoint(i) < r) return !1
					return !0
				}
				intersectsBox(n) {
					const e = this.planes
					for (let i = 0; i < 6; i++) {
						const r = e[i]
						if (
							((QM.x = r.normal.x > 0 ? n.max.x : n.min.x),
							(QM.y = r.normal.y > 0 ? n.max.y : n.min.y),
							(QM.z = r.normal.z > 0 ? n.max.z : n.min.z),
							r.distanceToPoint(QM) < 0)
						)
							return !1
					}
					return !0
				}
				containsPoint(n) {
					const e = this.planes
					for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(n) < 0) return !1
					return !0
				}
				clone() {
					return new this.constructor().copy(this)
				}
			}
			function Gj() {
				let t = null,
					n = !1,
					e = null,
					i = null
				function r(o, s) {
					e(o, s), (i = t.requestAnimationFrame(r))
				}
				return {
					start: function () {
						!0 !== n && null !== e && ((i = t.requestAnimationFrame(r)), (n = !0))
					},
					stop: function () {
						t.cancelAnimationFrame(i), (n = !1)
					},
					setAnimationLoop: function (o) {
						e = o
					},
					setContext: function (o) {
						t = o
					}
				}
			}
			function zve(t, n) {
				const e = n.isWebGL2,
					i = new WeakMap()
				return {
					get: function s(l) {
						return l.isInterleavedBufferAttribute && (l = l.data), i.get(l)
					},
					remove: function a(l) {
						l.isInterleavedBufferAttribute && (l = l.data)
						const d = i.get(l)
						d && (t.deleteBuffer(d.buffer), i.delete(l))
					},
					update: function c(l, d) {
						if (l.isGLBufferAttribute) {
							const h = i.get(l)
							return void (
								(!h || h.version < l.version) &&
								i.set(l, { buffer: l.buffer, type: l.type, bytesPerElement: l.elementSize, version: l.version })
							)
						}
						l.isInterleavedBufferAttribute && (l = l.data)
						const u = i.get(l)
						void 0 === u
							? i.set(
									l,
									(function r(l, d) {
										const u = l.array,
											h = l.usage,
											f = t.createBuffer()
										t.bindBuffer(d, f), t.bufferData(d, u, h), l.onUploadCallback()
										let _ = 5126
										return (
											u instanceof Float32Array
												? (_ = 5126)
												: u instanceof Float64Array
												? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.")
												: u instanceof Uint16Array
												? l.isFloat16BufferAttribute
													? e
														? (_ = 5131)
														: console.warn(
																"THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
														  )
													: (_ = 5123)
												: u instanceof Int16Array
												? (_ = 5122)
												: u instanceof Uint32Array
												? (_ = 5125)
												: u instanceof Int32Array
												? (_ = 5124)
												: u instanceof Int8Array
												? (_ = 5120)
												: u instanceof Uint8Array && (_ = 5121),
											{ buffer: f, type: _, bytesPerElement: u.BYTES_PER_ELEMENT, version: l.version }
										)
									})(l, d)
							  )
							: u.version < l.version &&
							  ((function o(l, d, u) {
									const h = d.array,
										f = d.updateRange
									t.bindBuffer(u, l),
										-1 === f.count
											? t.bufferSubData(u, 0, h)
											: (e
													? t.bufferSubData(u, f.offset * h.BYTES_PER_ELEMENT, h, f.offset, f.count)
													: t.bufferSubData(
															u,
															f.offset * h.BYTES_PER_ELEMENT,
															h.subarray(f.offset, f.offset + f.count)
													  ),
											  (f.count = -1))
							  })(u.buffer, l, d),
							  (u.version = l.version))
					}
				}
			}
			class sf extends vn {
				constructor(n = 1, e = 1, i = 1, r = 1) {
					super(), (this.type = "PlaneGeometry"), (this.parameters = { width: n, height: e, widthSegments: i, heightSegments: r })
					const o = n / 2,
						s = e / 2,
						a = Math.floor(i),
						c = Math.floor(r),
						l = a + 1,
						d = c + 1,
						u = n / a,
						h = e / c,
						f = [],
						_ = [],
						y = [],
						C = []
					for (let x = 0; x < d; x++) {
						const w = x * h - s
						for (let S = 0; S < l; S++) _.push(S * u - o, -w, 0), y.push(0, 0, 1), C.push(S / a), C.push(1 - x / c)
					}
					for (let x = 0; x < c; x++)
						for (let w = 0; w < a; w++) {
							const M = w + l * (x + 1),
								O = w + 1 + l * (x + 1),
								N = w + 1 + l * x
							f.push(w + l * x, M, N), f.push(M, O, N)
						}
					this.setIndex(f),
						this.setAttribute("position", new cn(_, 3)),
						this.setAttribute("normal", new cn(y, 3)),
						this.setAttribute("uv", new cn(C, 2))
				}
			}
			const Bi = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
					alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
					aomap_fragment:
						"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
					begin_vertex: "vec3 transformed = vec3( position );",
					beginnormal_vertex:
						"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
					bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
					bumpmap_pars_fragment:
						"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
					clipping_planes_fragment:
						"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
					clipping_planes_pars_fragment:
						"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
					clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
					clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
					color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
					color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
					color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
					color_vertex:
						"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
					common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
					cube_uv_reflection_fragment:
						"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
					defaultnormal_vertex:
						"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
					displacementmap_pars_vertex:
						"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
					displacementmap_vertex:
						"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
					emissivemap_fragment:
						"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
					emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
					encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
					encodings_pars_fragment:
						"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
					envmap_fragment:
						"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
					envmap_common_pars_fragment:
						"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
					envmap_pars_fragment:
						"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
					envmap_pars_vertex:
						"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
					envmap_physical_pars_fragment:
						"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
					envmap_vertex:
						"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
					fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
					fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
					fog_fragment:
						"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
					fog_pars_fragment:
						"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
					gradientmap_pars_fragment:
						"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
					lightmap_fragment:
						"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
					lightmap_pars_fragment:
						"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
					lights_lambert_vertex:
						"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
					lights_pars_begin:
						"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
					lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
					lights_toon_pars_fragment:
						"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
					lights_phong_fragment:
						"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
					lights_phong_pars_fragment:
						"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
					lights_physical_fragment:
						"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
					lights_physical_pars_fragment:
						"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
					lights_fragment_begin:
						"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
					lights_fragment_maps:
						"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
					lights_fragment_end:
						"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
					logdepthbuf_fragment:
						"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
					logdepthbuf_pars_fragment:
						"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
					logdepthbuf_pars_vertex:
						"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
					logdepthbuf_vertex:
						"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
					map_fragment:
						"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
					map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
					map_particle_fragment:
						"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
					map_particle_pars_fragment:
						"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					metalnessmap_fragment:
						"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
					metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
					morphnormal_vertex:
						"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
					morphtarget_pars_vertex:
						"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
					morphtarget_vertex:
						"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
					normal_fragment_begin:
						"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
					normal_fragment_maps:
						"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
					normalmap_pars_fragment:
						"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
					clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
					clearcoat_normal_fragment_maps:
						"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
					clearcoat_pars_fragment:
						"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
					packing:
						"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
					project_vertex:
						"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
					dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
					dithering_pars_fragment:
						"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
					roughnessmap_fragment:
						"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
					roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
					shadowmap_pars_fragment:
						"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
					shadowmap_pars_vertex:
						"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
					shadowmap_vertex:
						"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
					shadowmask_pars_fragment:
						"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
					skinbase_vertex:
						"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
					skinning_pars_vertex:
						"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
					skinning_vertex:
						"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
					skinnormal_vertex:
						"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
					specularmap_fragment:
						"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
					specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
					tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
					tonemapping_pars_fragment:
						"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
					transmissionmap_fragment:
						"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
					transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
					uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
					uv_pars_vertex:
						"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
					uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
					uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
					uv2_pars_vertex:
						"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
					uv2_vertex:
						"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
					worldpos_vertex:
						"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
					background_frag:
						"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					background_vert:
						"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
					cube_frag:
						"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					cube_vert:
						"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
					depth_frag:
						"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
					depth_vert:
						"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
					distanceRGBA_frag:
						"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
					distanceRGBA_vert:
						"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
					equirect_frag:
						"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					equirect_vert:
						"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
					linedashed_frag:
						"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
					linedashed_vert:
						"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					meshbasic_frag:
						"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshbasic_vert:
						"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
					meshlambert_frag:
						"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshlambert_vert:
						"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshmatcap_frag:
						"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshmatcap_vert:
						"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
					meshtoon_frag:
						"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshtoon_vert:
						"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphong_frag:
						"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphong_vert:
						"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphysical_frag:
						"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphysical_vert:
						"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					normal_frag:
						"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
					normal_vert:
						"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
					points_frag:
						"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
					points_vert:
						"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
					shadow_frag:
						"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					shadow_vert:
						"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					sprite_frag:
						"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					sprite_vert:
						"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
				},
				Ht = {
					common: {
						diffuse: { value: new Lt(15658734) },
						opacity: { value: 1 },
						map: { value: null },
						uvTransform: { value: new ns() },
						uv2Transform: { value: new ns() },
						alphaMap: { value: null }
					},
					specularmap: { specularMap: { value: null } },
					envmap: {
						envMap: { value: null },
						flipEnvMap: { value: -1 },
						reflectivity: { value: 1 },
						refractionRatio: { value: 0.98 },
						maxMipLevel: { value: 0 }
					},
					aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
					lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
					emissivemap: { emissiveMap: { value: null } },
					bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
					normalmap: { normalMap: { value: null }, normalScale: { value: new lt(1, 1) } },
					displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } },
					roughnessmap: { roughnessMap: { value: null } },
					metalnessmap: { metalnessMap: { value: null } },
					gradientmap: { gradientMap: { value: null } },
					fog: {
						fogDensity: { value: 25e-5 },
						fogNear: { value: 1 },
						fogFar: { value: 2e3 },
						fogColor: { value: new Lt(16777215) }
					},
					lights: {
						ambientLightColor: { value: [] },
						lightProbe: { value: [] },
						directionalLights: { value: [], properties: { direction: {}, color: {} } },
						directionalLightShadows: {
							value: [],
							properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} }
						},
						directionalShadowMap: { value: [] },
						directionalShadowMatrix: { value: [] },
						spotLights: {
							value: [],
							properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} }
						},
						spotLightShadows: {
							value: [],
							properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} }
						},
						spotShadowMap: { value: [] },
						spotShadowMatrix: { value: [] },
						pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
						pointLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {},
								shadowCameraNear: {},
								shadowCameraFar: {}
							}
						},
						pointShadowMap: { value: [] },
						pointShadowMatrix: { value: [] },
						hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
						rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
						ltc_1: { value: null },
						ltc_2: { value: null }
					},
					points: {
						diffuse: { value: new Lt(15658734) },
						opacity: { value: 1 },
						size: { value: 1 },
						scale: { value: 1 },
						map: { value: null },
						alphaMap: { value: null },
						uvTransform: { value: new ns() }
					},
					sprite: {
						diffuse: { value: new Lt(15658734) },
						opacity: { value: 1 },
						center: { value: new lt(0.5, 0.5) },
						rotation: { value: 0 },
						map: { value: null },
						alphaMap: { value: null },
						uvTransform: { value: new ns() }
					}
				},
				vl = {
					basic: {
						uniforms: zs([Ht.common, Ht.specularmap, Ht.envmap, Ht.aomap, Ht.lightmap, Ht.fog]),
						vertexShader: Bi.meshbasic_vert,
						fragmentShader: Bi.meshbasic_frag
					},
					lambert: {
						uniforms: zs([
							Ht.common,
							Ht.specularmap,
							Ht.envmap,
							Ht.aomap,
							Ht.lightmap,
							Ht.emissivemap,
							Ht.fog,
							Ht.lights,
							{ emissive: { value: new Lt(0) } }
						]),
						vertexShader: Bi.meshlambert_vert,
						fragmentShader: Bi.meshlambert_frag
					},
					phong: {
						uniforms: zs([
							Ht.common,
							Ht.specularmap,
							Ht.envmap,
							Ht.aomap,
							Ht.lightmap,
							Ht.emissivemap,
							Ht.bumpmap,
							Ht.normalmap,
							Ht.displacementmap,
							Ht.fog,
							Ht.lights,
							{ emissive: { value: new Lt(0) }, specular: { value: new Lt(1118481) }, shininess: { value: 30 } }
						]),
						vertexShader: Bi.meshphong_vert,
						fragmentShader: Bi.meshphong_frag
					},
					standard: {
						uniforms: zs([
							Ht.common,
							Ht.envmap,
							Ht.aomap,
							Ht.lightmap,
							Ht.emissivemap,
							Ht.bumpmap,
							Ht.normalmap,
							Ht.displacementmap,
							Ht.roughnessmap,
							Ht.metalnessmap,
							Ht.fog,
							Ht.lights,
							{
								emissive: { value: new Lt(0) },
								roughness: { value: 1 },
								metalness: { value: 0 },
								envMapIntensity: { value: 1 }
							}
						]),
						vertexShader: Bi.meshphysical_vert,
						fragmentShader: Bi.meshphysical_frag
					},
					toon: {
						uniforms: zs([
							Ht.common,
							Ht.aomap,
							Ht.lightmap,
							Ht.emissivemap,
							Ht.bumpmap,
							Ht.normalmap,
							Ht.displacementmap,
							Ht.gradientmap,
							Ht.fog,
							Ht.lights,
							{ emissive: { value: new Lt(0) } }
						]),
						vertexShader: Bi.meshtoon_vert,
						fragmentShader: Bi.meshtoon_frag
					},
					matcap: {
						uniforms: zs([Ht.common, Ht.bumpmap, Ht.normalmap, Ht.displacementmap, Ht.fog, { matcap: { value: null } }]),
						vertexShader: Bi.meshmatcap_vert,
						fragmentShader: Bi.meshmatcap_frag
					},
					points: { uniforms: zs([Ht.points, Ht.fog]), vertexShader: Bi.points_vert, fragmentShader: Bi.points_frag },
					dashed: {
						uniforms: zs([Ht.common, Ht.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]),
						vertexShader: Bi.linedashed_vert,
						fragmentShader: Bi.linedashed_frag
					},
					depth: { uniforms: zs([Ht.common, Ht.displacementmap]), vertexShader: Bi.depth_vert, fragmentShader: Bi.depth_frag },
					normal: {
						uniforms: zs([Ht.common, Ht.bumpmap, Ht.normalmap, Ht.displacementmap, { opacity: { value: 1 } }]),
						vertexShader: Bi.normal_vert,
						fragmentShader: Bi.normal_frag
					},
					sprite: { uniforms: zs([Ht.sprite, Ht.fog]), vertexShader: Bi.sprite_vert, fragmentShader: Bi.sprite_frag },
					background: {
						uniforms: { uvTransform: { value: new ns() }, t2D: { value: null } },
						vertexShader: Bi.background_vert,
						fragmentShader: Bi.background_frag
					},
					cube: {
						uniforms: zs([Ht.envmap, { opacity: { value: 1 } }]),
						vertexShader: Bi.cube_vert,
						fragmentShader: Bi.cube_frag
					},
					equirect: {
						uniforms: { tEquirect: { value: null } },
						vertexShader: Bi.equirect_vert,
						fragmentShader: Bi.equirect_frag
					},
					distanceRGBA: {
						uniforms: zs([
							Ht.common,
							Ht.displacementmap,
							{ referencePosition: { value: new K() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }
						]),
						vertexShader: Bi.distanceRGBA_vert,
						fragmentShader: Bi.distanceRGBA_frag
					},
					shadow: {
						uniforms: zs([Ht.lights, Ht.fog, { color: { value: new Lt(0) }, opacity: { value: 1 } }]),
						vertexShader: Bi.shadow_vert,
						fragmentShader: Bi.shadow_frag
					}
				}
			function uxe(t, n, e, i, r) {
				const o = new Lt(0)
				let a,
					c,
					s = 0,
					l = null,
					d = 0,
					u = null
				function f(_, y) {
					e.buffers.color.setClear(_.r, _.g, _.b, y, r)
				}
				return {
					getClearColor: function () {
						return o
					},
					setClearColor: function (_, y = 1) {
						o.set(_), (s = y), f(o, s)
					},
					getClearAlpha: function () {
						return s
					},
					setClearAlpha: function (_) {
						;(s = _), f(o, s)
					},
					render: function h(_, y, C, x) {
						let w = !0 === y.isScene ? y.background : null
						w && w.isTexture && (w = n.get(w))
						const S = t.xr,
							M = S.getSession && S.getSession()
						M && "additive" === M.environmentBlendMode && (w = null),
							null === w ? f(o, s) : w && w.isColor && (f(w, 1), (x = !0)),
							(t.autoClear || x) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
							w && (w.isCubeTexture || w.isWebGLCubeRenderTarget || w.mapping === Lg)
								? (void 0 === c &&
										((c = new Mi(
											new _l(1, 1, 1),
											new Ds({
												name: "BackgroundCubeMaterial",
												uniforms: Xg(vl.cube.uniforms),
												vertexShader: vl.cube.vertexShader,
												fragmentShader: vl.cube.fragmentShader,
												side: Lo,
												depthTest: !1,
												depthWrite: !1,
												fog: !1
											})
										)),
										c.geometry.deleteAttribute("normal"),
										c.geometry.deleteAttribute("uv"),
										(c.onBeforeRender = function (O, N, j) {
											this.matrixWorld.copyPosition(j.matrixWorld)
										}),
										Object.defineProperty(c.material, "envMap", {
											get: function () {
												return this.uniforms.envMap.value
											}
										}),
										i.update(c)),
								  w.isWebGLCubeRenderTarget && (w = w.texture),
								  (c.material.uniforms.envMap.value = w),
								  (c.material.uniforms.flipEnvMap.value = w.isCubeTexture && w._needsFlipEnvMap ? -1 : 1),
								  (l !== w || d !== w.version || u !== t.toneMapping) &&
										((c.material.needsUpdate = !0), (l = w), (d = w.version), (u = t.toneMapping)),
								  _.unshift(c, c.geometry, c.material, 0, 0, null))
								: w &&
								  w.isTexture &&
								  (void 0 === a &&
										((a = new Mi(
											new sf(2, 2),
											new Ds({
												name: "BackgroundMaterial",
												uniforms: Xg(vl.background.uniforms),
												vertexShader: vl.background.vertexShader,
												fragmentShader: vl.background.fragmentShader,
												side: Ig,
												depthTest: !1,
												depthWrite: !1,
												fog: !1
											})
										)),
										a.geometry.deleteAttribute("normal"),
										Object.defineProperty(a.material, "map", {
											get: function () {
												return this.uniforms.t2D.value
											}
										}),
										i.update(a)),
								  (a.material.uniforms.t2D.value = w),
								  !0 === w.matrixAutoUpdate && w.updateMatrix(),
								  a.material.uniforms.uvTransform.value.copy(w.matrix),
								  (l !== w || d !== w.version || u !== t.toneMapping) &&
										((a.material.needsUpdate = !0), (l = w), (d = w.version), (u = t.toneMapping)),
								  _.unshift(a, a.geometry, a.material, 0, 0, null))
					}
				}
			}
			function hxe(t, n, e, i) {
				const r = t.getParameter(34921),
					o = i.isWebGL2 ? null : n.get("OES_vertex_array_object"),
					s = i.isWebGL2 || null !== o,
					a = {},
					c = y(null)
				let l = c
				function h(ve) {
					return i.isWebGL2 ? t.bindVertexArray(ve) : o.bindVertexArrayOES(ve)
				}
				function f(ve) {
					return i.isWebGL2 ? t.deleteVertexArray(ve) : o.deleteVertexArrayOES(ve)
				}
				function y(ve) {
					const W = [],
						me = [],
						Z = []
					for (let Ae = 0; Ae < r; Ae++) (W[Ae] = 0), (me[Ae] = 0), (Z[Ae] = 0)
					return {
						geometry: null,
						program: null,
						wireframe: !1,
						newAttributes: W,
						enabledAttributes: me,
						attributeDivisors: Z,
						object: ve,
						attributes: {},
						index: null
					}
				}
				function w() {
					const ve = l.newAttributes
					for (let W = 0, me = ve.length; W < me; W++) ve[W] = 0
				}
				function S(ve) {
					M(ve, 0)
				}
				function M(ve, W) {
					const Z = l.enabledAttributes,
						Ae = l.attributeDivisors
					;(l.newAttributes[ve] = 1),
						0 === Z[ve] && (t.enableVertexAttribArray(ve), (Z[ve] = 1)),
						Ae[ve] !== W &&
							((i.isWebGL2 ? t : n.get("ANGLE_instanced_arrays"))[
								i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
							](ve, W),
							(Ae[ve] = W))
				}
				function O() {
					const ve = l.newAttributes,
						W = l.enabledAttributes
					for (let me = 0, Z = W.length; me < Z; me++) W[me] !== ve[me] && (t.disableVertexAttribArray(me), (W[me] = 0))
				}
				function N(ve, W, me, Z, Ae, Ie) {
					!0 !== i.isWebGL2 || (5124 !== me && 5125 !== me)
						? t.vertexAttribPointer(ve, W, me, Z, Ae, Ie)
						: t.vertexAttribIPointer(ve, W, me, Ae, Ie)
				}
				function ue() {
					Se(), l !== c && ((l = c), h(l.object))
				}
				function Se() {
					;(c.geometry = null), (c.program = null), (c.wireframe = !1)
				}
				return {
					setup: function d(ve, W, me, Z, Ae) {
						let Ie = !1
						if (s) {
							const Pe = (function _(ve, W, me) {
								const Z = !0 === me.wireframe
								let Ae = a[ve.id]
								void 0 === Ae && ((Ae = {}), (a[ve.id] = Ae))
								let Ie = Ae[W.id]
								void 0 === Ie && ((Ie = {}), (Ae[W.id] = Ie))
								let Pe = Ie[Z]
								return (
									void 0 === Pe &&
										((Pe = y(
											(function u() {
												return i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()
											})()
										)),
										(Ie[Z] = Pe)),
									Pe
								)
							})(Z, me, W)
							l !== Pe && ((l = Pe), h(l.object)),
								(Ie = (function C(ve, W) {
									const me = l.attributes,
										Z = ve.attributes
									let Ae = 0
									for (const Ie in Z) {
										const Pe = me[Ie],
											nt = Z[Ie]
										if (void 0 === Pe || Pe.attribute !== nt || Pe.data !== nt.data) return !0
										Ae++
									}
									return l.attributesNum !== Ae || l.index !== W
								})(Z, Ae)),
								Ie &&
									(function x(ve, W) {
										const me = {},
											Z = ve.attributes
										let Ae = 0
										for (const Ie in Z) {
											const Pe = Z[Ie],
												nt = {}
											;(nt.attribute = Pe), Pe.data && (nt.data = Pe.data), (me[Ie] = nt), Ae++
										}
										;(l.attributes = me), (l.attributesNum = Ae), (l.index = W)
									})(Z, Ae)
						} else {
							const Pe = !0 === W.wireframe
							;(l.geometry !== Z.id || l.program !== me.id || l.wireframe !== Pe) &&
								((l.geometry = Z.id), (l.program = me.id), (l.wireframe = Pe), (Ie = !0))
						}
						!0 === ve.isInstancedMesh && (Ie = !0),
							null !== Ae && e.update(Ae, 34963),
							Ie &&
								((function j(ve, W, me, Z) {
									if (
										!1 === i.isWebGL2 &&
										(ve.isInstancedMesh || Z.isInstancedBufferGeometry) &&
										null === n.get("ANGLE_instanced_arrays")
									)
										return
									w()
									const Ae = Z.attributes,
										Ie = me.getAttributes(),
										Pe = W.defaultAttributeValues
									for (const nt in Ie) {
										const pt = Ie[nt]
										if (pt >= 0) {
											const kt = Ae[nt]
											if (void 0 !== kt) {
												const tn = kt.normalized,
													Kt = kt.itemSize,
													Un = e.get(kt)
												if (void 0 === Un) continue
												const dt = Un.buffer,
													nn = Un.type,
													Sn = Un.bytesPerElement
												if (kt.isInterleavedBufferAttribute) {
													const Hn = kt.data,
														kn = Hn.stride,
														Ii = kt.offset
													Hn && Hn.isInstancedInterleavedBuffer
														? (M(pt, Hn.meshPerAttribute),
														  void 0 === Z._maxInstanceCount &&
																(Z._maxInstanceCount = Hn.meshPerAttribute * Hn.count))
														: S(pt),
														t.bindBuffer(34962, dt),
														N(pt, Kt, nn, tn, kn * Sn, Ii * Sn)
												} else
													kt.isInstancedBufferAttribute
														? (M(pt, kt.meshPerAttribute),
														  void 0 === Z._maxInstanceCount &&
																(Z._maxInstanceCount = kt.meshPerAttribute * kt.count))
														: S(pt),
														t.bindBuffer(34962, dt),
														N(pt, Kt, nn, tn, 0, 0)
											} else if ("instanceMatrix" === nt) {
												const tn = e.get(ve.instanceMatrix)
												if (void 0 === tn) continue
												const Kt = tn.buffer,
													Un = tn.type
												M(pt + 0, 1),
													M(pt + 1, 1),
													M(pt + 2, 1),
													M(pt + 3, 1),
													t.bindBuffer(34962, Kt),
													t.vertexAttribPointer(pt + 0, 4, Un, !1, 64, 0),
													t.vertexAttribPointer(pt + 1, 4, Un, !1, 64, 16),
													t.vertexAttribPointer(pt + 2, 4, Un, !1, 64, 32),
													t.vertexAttribPointer(pt + 3, 4, Un, !1, 64, 48)
											} else if ("instanceColor" === nt) {
												const tn = e.get(ve.instanceColor)
												if (void 0 === tn) continue
												const Kt = tn.buffer,
													Un = tn.type
												M(pt, 1), t.bindBuffer(34962, Kt), t.vertexAttribPointer(pt, 3, Un, !1, 12, 0)
											} else if (void 0 !== Pe) {
												const tn = Pe[nt]
												if (void 0 !== tn)
													switch (tn.length) {
														case 2:
															t.vertexAttrib2fv(pt, tn)
															break
														case 3:
															t.vertexAttrib3fv(pt, tn)
															break
														case 4:
															t.vertexAttrib4fv(pt, tn)
															break
														default:
															t.vertexAttrib1fv(pt, tn)
													}
											}
										}
									}
									O()
								})(ve, W, me, Z),
								null !== Ae && t.bindBuffer(34963, e.get(Ae).buffer))
					},
					reset: ue,
					resetDefaultState: Se,
					dispose: function le() {
						ue()
						for (const ve in a) {
							const W = a[ve]
							for (const me in W) {
								const Z = W[me]
								for (const Ae in Z) f(Z[Ae].object), delete Z[Ae]
								delete W[me]
							}
							delete a[ve]
						}
					},
					releaseStatesOfGeometry: function ae(ve) {
						if (void 0 === a[ve.id]) return
						const W = a[ve.id]
						for (const me in W) {
							const Z = W[me]
							for (const Ae in Z) f(Z[Ae].object), delete Z[Ae]
							delete W[me]
						}
						delete a[ve.id]
					},
					releaseStatesOfProgram: function ce(ve) {
						for (const W in a) {
							const me = a[W]
							if (void 0 === me[ve.id]) continue
							const Z = me[ve.id]
							for (const Ae in Z) f(Z[Ae].object), delete Z[Ae]
							delete me[ve.id]
						}
					},
					initAttributes: w,
					enableAttribute: S,
					disableUnusedAttributes: O
				}
			}
			function fxe(t, n, e, i) {
				const r = i.isWebGL2
				let o
				;(this.setMode = function s(l) {
					o = l
				}),
					(this.render = function a(l, d) {
						t.drawArrays(o, l, d), e.update(d, o, 1)
					}),
					(this.renderInstances = function c(l, d, u) {
						if (0 === u) return
						let h, f
						if (r) (h = t), (f = "drawArraysInstanced")
						else if (((h = n.get("ANGLE_instanced_arrays")), (f = "drawArraysInstancedANGLE"), null === h))
							return void console.error(
								"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							)
						h[f](o, l, d, u), e.update(d, o, u)
					})
			}
			function mxe(t, n, e) {
				let i
				function o(N) {
					if ("highp" === N) {
						if (
							t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
							t.getShaderPrecisionFormat(35632, 36338).precision > 0
						)
							return "highp"
						N = "mediump"
					}
					return "mediump" === N &&
						t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
						t.getShaderPrecisionFormat(35632, 36337).precision > 0
						? "mediump"
						: "lowp"
				}
				const s =
					(typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext) ||
					(typeof WebGL2ComputeRenderingContext < "u" && t instanceof WebGL2ComputeRenderingContext)
				let a = void 0 !== e.precision ? e.precision : "highp"
				const c = o(a)
				c !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", c, "instead."), (a = c))
				const l = !0 === e.logarithmicDepthBuffer,
					d = t.getParameter(34930),
					u = t.getParameter(35660),
					h = t.getParameter(3379),
					f = t.getParameter(34076),
					_ = t.getParameter(34921),
					y = t.getParameter(36347),
					C = t.getParameter(36348),
					x = t.getParameter(36349),
					w = u > 0,
					S = s || n.has("OES_texture_float")
				return {
					isWebGL2: s,
					getMaxAnisotropy: function r() {
						if (void 0 !== i) return i
						if (!0 === n.has("EXT_texture_filter_anisotropic")) {
							const N = n.get("EXT_texture_filter_anisotropic")
							i = t.getParameter(N.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
						} else i = 0
						return i
					},
					getMaxPrecision: o,
					precision: a,
					logarithmicDepthBuffer: l,
					maxTextures: d,
					maxVertexTextures: u,
					maxTextureSize: h,
					maxCubemapSize: f,
					maxAttributes: _,
					maxVertexUniforms: y,
					maxVaryings: C,
					maxFragmentUniforms: x,
					vertexTextures: w,
					floatFragmentTextures: S,
					floatVertexTextures: w && S,
					maxSamples: s ? t.getParameter(36183) : 0
				}
			}
			function pxe(t) {
				const n = this
				let e = null,
					i = 0,
					r = !1,
					o = !1
				const s = new Al(),
					a = new ns(),
					c = { value: null, needsUpdate: !1 }
				function l() {
					c.value !== e && ((c.value = e), (c.needsUpdate = i > 0)), (n.numPlanes = i), (n.numIntersection = 0)
				}
				function d(u, h, f, _) {
					const y = null !== u ? u.length : 0
					let C = null
					if (0 !== y) {
						if (((C = c.value), !0 !== _ || null === C)) {
							const x = f + 4 * y,
								w = h.matrixWorldInverse
							a.getNormalMatrix(w), (null === C || C.length < x) && (C = new Float32Array(x))
							for (let S = 0, M = f; S !== y; ++S, M += 4)
								s.copy(u[S]).applyMatrix4(w, a), s.normal.toArray(C, M), (C[M + 3] = s.constant)
						}
						;(c.value = C), (c.needsUpdate = !0)
					}
					return (n.numPlanes = y), (n.numIntersection = 0), C
				}
				;(this.uniform = c),
					(this.numPlanes = 0),
					(this.numIntersection = 0),
					(this.init = function (u, h, f) {
						const _ = 0 !== u.length || h || 0 !== i || r
						return (r = h), (e = d(u, f, 0)), (i = u.length), _
					}),
					(this.beginShadows = function () {
						;(o = !0), d(null)
					}),
					(this.endShadows = function () {
						;(o = !1), l()
					}),
					(this.setState = function (u, h, f) {
						const _ = u.clippingPlanes,
							y = u.clipIntersection,
							C = u.clipShadows,
							x = t.get(u)
						if (!r || null === _ || 0 === _.length || (o && !C)) o ? d(null) : l()
						else {
							const w = o ? 0 : i,
								S = 4 * w
							let M = x.clippingState || null
							;(c.value = M), (M = d(_, h, S, f))
							for (let O = 0; O !== S; ++O) M[O] = e[O]
							;(x.clippingState = M), (this.numIntersection = y ? this.numPlanes : 0), (this.numPlanes += w)
						}
					})
			}
			function Axe(t) {
				let n = new WeakMap()
				function e(s, a) {
					return a === fM ? (s.mapping = ny) : a === mM && (s.mapping = iy), s
				}
				function r(s) {
					const a = s.target
					a.removeEventListener("dispose", r)
					const c = n.get(a)
					void 0 !== c && (n.delete(a), c.dispose())
				}
				return {
					get: function i(s) {
						if (s && s.isTexture) {
							const a = s.mapping
							if (a === fM || a === mM) {
								if (n.has(s)) return e(n.get(s).texture, s.mapping)
								{
									const c = s.image
									if (c && c.height > 0) {
										const l = t.getRenderTarget(),
											d = new VM(c.height / 2)
										return (
											d.fromEquirectangularTexture(t, s),
											n.set(s, d),
											t.setRenderTarget(l),
											s.addEventListener("dispose", r),
											e(d.texture, s.mapping)
										)
									}
									return null
								}
							}
						}
						return s
					},
					dispose: function o() {
						n = new WeakMap()
					}
				}
			}
			function gxe(t) {
				const n = {}
				function e(i) {
					if (void 0 !== n[i]) return n[i]
					let r
					switch (i) {
						case "WEBGL_depth_texture":
							r =
								t.getExtension("WEBGL_depth_texture") ||
								t.getExtension("MOZ_WEBGL_depth_texture") ||
								t.getExtension("WEBKIT_WEBGL_depth_texture")
							break
						case "EXT_texture_filter_anisotropic":
							r =
								t.getExtension("EXT_texture_filter_anisotropic") ||
								t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
								t.getExtension("WEBKIT_EXT_texture_filter_anisotropic")
							break
						case "WEBGL_compressed_texture_s3tc":
							r =
								t.getExtension("WEBGL_compressed_texture_s3tc") ||
								t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
								t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")
							break
						case "WEBGL_compressed_texture_pvrtc":
							r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")
							break
						default:
							r = t.getExtension(i)
					}
					return (n[i] = r), r
				}
				return {
					has: function (i) {
						return null !== e(i)
					},
					init: function (i) {
						i.isWebGL2
							? e("EXT_color_buffer_float")
							: (e("WEBGL_depth_texture"),
							  e("OES_texture_float"),
							  e("OES_texture_half_float"),
							  e("OES_texture_half_float_linear"),
							  e("OES_standard_derivatives"),
							  e("OES_element_index_uint"),
							  e("OES_vertex_array_object"),
							  e("ANGLE_instanced_arrays")),
							e("OES_texture_float_linear"),
							e("EXT_color_buffer_half_float")
					},
					get: function (i) {
						const r = e(i)
						return null === r && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r
					}
				}
			}
			function bxe(t, n, e, i) {
				const r = {},
					o = new WeakMap()
				function s(u) {
					const h = u.target
					null !== h.index && n.remove(h.index)
					for (const _ in h.attributes) n.remove(h.attributes[_])
					h.removeEventListener("dispose", s), delete r[h.id]
					const f = o.get(h)
					f && (n.remove(f), o.delete(h)),
						i.releaseStatesOfGeometry(h),
						!0 === h.isInstancedBufferGeometry && delete h._maxInstanceCount,
						e.memory.geometries--
				}
				function l(u) {
					const h = [],
						f = u.index,
						_ = u.attributes.position
					let y = 0
					if (null !== f) {
						const w = f.array
						y = f.version
						for (let S = 0, M = w.length; S < M; S += 3) {
							const O = w[S + 0],
								N = w[S + 1],
								j = w[S + 2]
							h.push(O, N, N, j, j, O)
						}
					} else {
						y = _.version
						for (let S = 0, M = _.array.length / 3 - 1; S < M; S += 3) {
							const O = S + 0,
								N = S + 1,
								j = S + 2
							h.push(O, N, N, j, j, O)
						}
					}
					const C = new (Qj(h) > 65535 ? up : dp)(h, 1)
					C.version = y
					const x = o.get(u)
					x && n.remove(x), o.set(u, C)
				}
				return {
					get: function a(u, h) {
						return !0 === r[h.id] || (h.addEventListener("dispose", s), (r[h.id] = !0), e.memory.geometries++), h
					},
					update: function c(u) {
						const h = u.attributes
						for (const _ in h) n.update(h[_], 34962)
						const f = u.morphAttributes
						for (const _ in f) {
							const y = f[_]
							for (let C = 0, x = y.length; C < x; C++) n.update(y[C], 34962)
						}
					},
					getWireframeAttribute: function d(u) {
						const h = o.get(u)
						if (h) {
							const f = u.index
							null !== f && h.version < f.version && l(u)
						} else l(u)
						return o.get(u)
					}
				}
			}
			function _xe(t, n, e, i) {
				const r = i.isWebGL2
				let o, a, c
				;(this.setMode = function s(h) {
					o = h
				}),
					(this.setIndex = function l(h) {
						;(a = h.type), (c = h.bytesPerElement)
					}),
					(this.render = function d(h, f) {
						t.drawElements(o, f, a, h * c), e.update(f, o, 1)
					}),
					(this.renderInstances = function u(h, f, _) {
						if (0 === _) return
						let y, C
						if (r) (y = t), (C = "drawElementsInstanced")
						else if (((y = n.get("ANGLE_instanced_arrays")), (C = "drawElementsInstancedANGLE"), null === y))
							return void console.error(
								"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							)
						y[C](o, f, a, h * c, _), e.update(f, o, _)
					})
			}
			function vxe(t) {
				const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
				return {
					memory: { geometries: 0, textures: 0 },
					render: e,
					programs: null,
					autoReset: !0,
					reset: function r() {
						e.frame++, (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0)
					},
					update: function i(o, s, a) {
						switch ((e.calls++, s)) {
							case 4:
								e.triangles += a * (o / 3)
								break
							case 1:
								e.lines += a * (o / 2)
								break
							case 3:
								e.lines += a * (o - 1)
								break
							case 2:
								e.lines += a * o
								break
							case 0:
								e.points += a * o
								break
							default:
								console.error("THREE.WebGLInfo: Unknown draw mode:", s)
						}
					}
				}
			}
			function yxe(t, n) {
				return t[0] - n[0]
			}
			function wxe(t, n) {
				return Math.abs(n[1]) - Math.abs(t[1])
			}
			function xxe(t) {
				const n = {},
					e = new Float32Array(8),
					i = []
				for (let o = 0; o < 8; o++) i[o] = [o, 0]
				return {
					update: function r(o, s, a, c) {
						const l = o.morphTargetInfluences,
							d = void 0 === l ? 0 : l.length
						let u = n[s.id]
						if (void 0 === u) {
							u = []
							for (let C = 0; C < d; C++) u[C] = [C, 0]
							n[s.id] = u
						}
						for (let C = 0; C < d; C++) {
							const x = u[C]
							;(x[0] = C), (x[1] = l[C])
						}
						u.sort(wxe)
						for (let C = 0; C < 8; C++)
							C < d && u[C][1]
								? ((i[C][0] = u[C][0]), (i[C][1] = u[C][1]))
								: ((i[C][0] = Number.MAX_SAFE_INTEGER), (i[C][1] = 0))
						i.sort(yxe)
						const h = a.morphTargets && s.morphAttributes.position,
							f = a.morphNormals && s.morphAttributes.normal
						let _ = 0
						for (let C = 0; C < 8; C++) {
							const x = i[C],
								w = x[0],
								S = x[1]
							w !== Number.MAX_SAFE_INTEGER && S
								? (h && s.getAttribute("morphTarget" + C) !== h[w] && s.setAttribute("morphTarget" + C, h[w]),
								  f && s.getAttribute("morphNormal" + C) !== f[w] && s.setAttribute("morphNormal" + C, f[w]),
								  (e[C] = S),
								  (_ += S))
								: (h && !0 === s.hasAttribute("morphTarget" + C) && s.deleteAttribute("morphTarget" + C),
								  f && !0 === s.hasAttribute("morphNormal" + C) && s.deleteAttribute("morphNormal" + C),
								  (e[C] = 0))
						}
						const y = s.morphTargetsRelative ? 1 : 1 - _
						c.getUniforms().setValue(t, "morphTargetBaseInfluence", y), c.getUniforms().setValue(t, "morphTargetInfluences", e)
					}
				}
			}
			function Cxe(t, n, e, i) {
				let r = new WeakMap()
				function a(c) {
					const l = c.target
					l.removeEventListener("dispose", a), e.remove(l.instanceMatrix), null !== l.instanceColor && e.remove(l.instanceColor)
				}
				return {
					update: function o(c) {
						const l = i.render.frame,
							u = n.get(c, c.geometry)
						return (
							r.get(u) !== l && (n.update(u), r.set(u, l)),
							c.isInstancedMesh &&
								(!1 === c.hasEventListener("dispose", a) && c.addEventListener("dispose", a),
								e.update(c.instanceMatrix, 34962),
								null !== c.instanceColor && e.update(c.instanceColor, 34962)),
							u
						)
					},
					dispose: function s() {
						r = new WeakMap()
					}
				}
			}
			vl.physical = {
				uniforms: zs([
					vl.standard.uniforms,
					{
						clearcoat: { value: 0 },
						clearcoatMap: { value: null },
						clearcoatRoughness: { value: 0 },
						clearcoatRoughnessMap: { value: null },
						clearcoatNormalScale: { value: new lt(1, 1) },
						clearcoatNormalMap: { value: null },
						sheen: { value: new Lt(0) },
						transmission: { value: 0 },
						transmissionMap: { value: null }
					}
				]),
				vertexShader: Bi.meshphysical_vert,
				fragmentShader: Bi.meshphysical_frag
			}
			class zR extends zo {
				constructor(n = null, e = 1, i = 1, r = 1) {
					super(null),
						(this.image = { data: n, width: e, height: i, depth: r }),
						(this.magFilter = ts),
						(this.minFilter = ts),
						(this.wrapR = ua),
						(this.generateMipmaps = !1),
						(this.flipY = !1),
						(this.needsUpdate = !0)
				}
			}
			zR.prototype.isDataTexture2DArray = !0
			class GR extends zo {
				constructor(n = null, e = 1, i = 1, r = 1) {
					super(null),
						(this.image = { data: n, width: e, height: i, depth: r }),
						(this.magFilter = ts),
						(this.minFilter = ts),
						(this.wrapR = ua),
						(this.generateMipmaps = !1),
						(this.flipY = !1),
						(this.needsUpdate = !0)
				}
			}
			GR.prototype.isDataTexture3D = !0
			const $j = new zo(),
				Exe = new zR(),
				Mxe = new GR(),
				Wj = new Zg(),
				jj = [],
				Kj = [],
				Xj = new Float32Array(16),
				Yj = new Float32Array(9),
				qj = new Float32Array(4)
			function tb(t, n, e) {
				const i = t[0]
				if (i <= 0 || i > 0) return t
				const r = n * e
				let o = jj[r]
				if ((void 0 === o && ((o = new Float32Array(r)), (jj[r] = o)), 0 !== n)) {
					i.toArray(o, 0)
					for (let s = 1, a = 0; s !== n; ++s) (a += e), t[s].toArray(o, a)
				}
				return o
			}
			function Uc(t, n) {
				if (t.length !== n.length) return !1
				for (let e = 0, i = t.length; e < i; e++) if (t[e] !== n[e]) return !1
				return !0
			}
			function sc(t, n) {
				for (let e = 0, i = n.length; e < i; e++) t[e] = n[e]
			}
			function Zj(t, n) {
				let e = Kj[n]
				void 0 === e && ((e = new Int32Array(n)), (Kj[n] = e))
				for (let i = 0; i !== n; ++i) e[i] = t.allocateTextureUnit()
				return e
			}
			function Sxe(t, n) {
				const e = this.cache
				e[0] !== n && (t.uniform1f(this.addr, n), (e[0] = n))
			}
			function kxe(t, n) {
				const e = this.cache
				if (void 0 !== n.x) (e[0] !== n.x || e[1] !== n.y) && (t.uniform2f(this.addr, n.x, n.y), (e[0] = n.x), (e[1] = n.y))
				else {
					if (Uc(e, n)) return
					t.uniform2fv(this.addr, n), sc(e, n)
				}
			}
			function Txe(t, n) {
				const e = this.cache
				if (void 0 !== n.x)
					(e[0] !== n.x || e[1] !== n.y || e[2] !== n.z) &&
						(t.uniform3f(this.addr, n.x, n.y, n.z), (e[0] = n.x), (e[1] = n.y), (e[2] = n.z))
				else if (void 0 !== n.r)
					(e[0] !== n.r || e[1] !== n.g || e[2] !== n.b) &&
						(t.uniform3f(this.addr, n.r, n.g, n.b), (e[0] = n.r), (e[1] = n.g), (e[2] = n.b))
				else {
					if (Uc(e, n)) return
					t.uniform3fv(this.addr, n), sc(e, n)
				}
			}
			function Fxe(t, n) {
				const e = this.cache
				if (void 0 !== n.x)
					(e[0] !== n.x || e[1] !== n.y || e[2] !== n.z || e[3] !== n.w) &&
						(t.uniform4f(this.addr, n.x, n.y, n.z, n.w), (e[0] = n.x), (e[1] = n.y), (e[2] = n.z), (e[3] = n.w))
				else {
					if (Uc(e, n)) return
					t.uniform4fv(this.addr, n), sc(e, n)
				}
			}
			function Bxe(t, n) {
				const e = this.cache,
					i = n.elements
				if (void 0 === i) {
					if (Uc(e, n)) return
					t.uniformMatrix2fv(this.addr, !1, n), sc(e, n)
				} else {
					if (Uc(e, i)) return
					qj.set(i), t.uniformMatrix2fv(this.addr, !1, qj), sc(e, i)
				}
			}
			function Ixe(t, n) {
				const e = this.cache,
					i = n.elements
				if (void 0 === i) {
					if (Uc(e, n)) return
					t.uniformMatrix3fv(this.addr, !1, n), sc(e, n)
				} else {
					if (Uc(e, i)) return
					Yj.set(i), t.uniformMatrix3fv(this.addr, !1, Yj), sc(e, i)
				}
			}
			function Dxe(t, n) {
				const e = this.cache,
					i = n.elements
				if (void 0 === i) {
					if (Uc(e, n)) return
					t.uniformMatrix4fv(this.addr, !1, n), sc(e, n)
				} else {
					if (Uc(e, i)) return
					Xj.set(i), t.uniformMatrix4fv(this.addr, !1, Xj), sc(e, i)
				}
			}
			function Lxe(t, n, e) {
				const i = this.cache,
					r = e.allocateTextureUnit()
				i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), e.safeSetTexture2D(n || $j, r)
			}
			function Rxe(t, n, e) {
				const i = this.cache,
					r = e.allocateTextureUnit()
				i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), e.setTexture2DArray(n || Exe, r)
			}
			function Pxe(t, n, e) {
				const i = this.cache,
					r = e.allocateTextureUnit()
				i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), e.setTexture3D(n || Mxe, r)
			}
			function Oxe(t, n, e) {
				const i = this.cache,
					r = e.allocateTextureUnit()
				i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), e.safeSetTextureCube(n || Wj, r)
			}
			function Nxe(t, n) {
				const e = this.cache
				e[0] !== n && (t.uniform1i(this.addr, n), (e[0] = n))
			}
			function Uxe(t, n) {
				const e = this.cache
				Uc(e, n) || (t.uniform2iv(this.addr, n), sc(e, n))
			}
			function Hxe(t, n) {
				const e = this.cache
				Uc(e, n) || (t.uniform3iv(this.addr, n), sc(e, n))
			}
			function Vxe(t, n) {
				const e = this.cache
				Uc(e, n) || (t.uniform4iv(this.addr, n), sc(e, n))
			}
			function Qxe(t, n) {
				const e = this.cache
				e[0] !== n && (t.uniform1ui(this.addr, n), (e[0] = n))
			}
			function Gxe(t, n) {
				t.uniform1fv(this.addr, n)
			}
			function $xe(t, n) {
				t.uniform1iv(this.addr, n)
			}
			function Wxe(t, n) {
				t.uniform2iv(this.addr, n)
			}
			function jxe(t, n) {
				t.uniform3iv(this.addr, n)
			}
			function Kxe(t, n) {
				t.uniform4iv(this.addr, n)
			}
			function Xxe(t, n) {
				const e = tb(n, this.size, 2)
				t.uniform2fv(this.addr, e)
			}
			function Yxe(t, n) {
				const e = tb(n, this.size, 3)
				t.uniform3fv(this.addr, e)
			}
			function qxe(t, n) {
				const e = tb(n, this.size, 4)
				t.uniform4fv(this.addr, e)
			}
			function Zxe(t, n) {
				const e = tb(n, this.size, 4)
				t.uniformMatrix2fv(this.addr, !1, e)
			}
			function Jxe(t, n) {
				const e = tb(n, this.size, 9)
				t.uniformMatrix3fv(this.addr, !1, e)
			}
			function e1e(t, n) {
				const e = tb(n, this.size, 16)
				t.uniformMatrix4fv(this.addr, !1, e)
			}
			function t1e(t, n, e) {
				const i = n.length,
					r = Zj(e, i)
				t.uniform1iv(this.addr, r)
				for (let o = 0; o !== i; ++o) e.safeSetTexture2D(n[o] || $j, r[o])
			}
			function n1e(t, n, e) {
				const i = n.length,
					r = Zj(e, i)
				t.uniform1iv(this.addr, r)
				for (let o = 0; o !== i; ++o) e.safeSetTextureCube(n[o] || Wj, r[o])
			}
			function r1e(t, n, e) {
				;(this.id = t),
					(this.addr = e),
					(this.cache = []),
					(this.setValue = (function zxe(t) {
						switch (t) {
							case 5126:
								return Sxe
							case 35664:
								return kxe
							case 35665:
								return Txe
							case 35666:
								return Fxe
							case 35674:
								return Bxe
							case 35675:
								return Ixe
							case 35676:
								return Dxe
							case 5124:
							case 35670:
								return Nxe
							case 35667:
							case 35671:
								return Uxe
							case 35668:
							case 35672:
								return Hxe
							case 35669:
							case 35673:
								return Vxe
							case 5125:
								return Qxe
							case 35678:
							case 36198:
							case 36298:
							case 36306:
							case 35682:
								return Lxe
							case 35679:
							case 36299:
							case 36307:
								return Pxe
							case 35680:
							case 36300:
							case 36308:
							case 36293:
								return Oxe
							case 36289:
							case 36303:
							case 36311:
							case 36292:
								return Rxe
						}
					})(n.type))
			}
			function Jj(t, n, e) {
				;(this.id = t),
					(this.addr = e),
					(this.cache = []),
					(this.size = n.size),
					(this.setValue = (function i1e(t) {
						switch (t) {
							case 5126:
								return Gxe
							case 35664:
								return Xxe
							case 35665:
								return Yxe
							case 35666:
								return qxe
							case 35674:
								return Zxe
							case 35675:
								return Jxe
							case 35676:
								return e1e
							case 5124:
							case 35670:
								return $xe
							case 35667:
							case 35671:
								return Wxe
							case 35668:
							case 35672:
								return jxe
							case 35669:
							case 35673:
								return Kxe
							case 35678:
							case 36198:
							case 36298:
							case 36306:
							case 35682:
								return t1e
							case 35680:
							case 36300:
							case 36308:
							case 36293:
								return n1e
						}
					})(n.type))
			}
			function e7(t) {
				;(this.id = t), (this.seq = []), (this.map = {})
			}
			;(Jj.prototype.updateCache = function (t) {
				const n = this.cache
				t instanceof Float32Array && n.length !== t.length && (this.cache = new Float32Array(t.length)), sc(n, t)
			}),
				(e7.prototype.setValue = function (t, n, e) {
					const i = this.seq
					for (let r = 0, o = i.length; r !== o; ++r) {
						const s = i[r]
						s.setValue(t, n[s.id], e)
					}
				})
			const $R = /(\w+)(\])?(\[|\.)?/g
			function t7(t, n) {
				t.seq.push(n), (t.map[n.id] = n)
			}
			function o1e(t, n, e) {
				const i = t.name,
					r = i.length
				for ($R.lastIndex = 0; ; ) {
					const o = $R.exec(i)
					let a = o[1]
					const l = o[3]
					if (("]" === o[2] && (a |= 0), void 0 === l || ("[" === l && $R.lastIndex + 2 === r))) {
						t7(e, void 0 === l ? new r1e(a, t, n) : new Jj(a, t, n))
						break
					}
					{
						let u = e.map[a]
						void 0 === u && ((u = new e7(a)), t7(e, u)), (e = u)
					}
				}
			}
			function af(t, n) {
				;(this.seq = []), (this.map = {})
				const e = t.getProgramParameter(n, 35718)
				for (let i = 0; i < e; ++i) {
					const r = t.getActiveUniform(n, i)
					o1e(r, t.getUniformLocation(n, r.name), this)
				}
			}
			function n7(t, n, e) {
				const i = t.createShader(n)
				return t.shaderSource(i, e), t.compileShader(i), i
			}
			;(af.prototype.setValue = function (t, n, e, i) {
				const r = this.map[n]
				void 0 !== r && r.setValue(t, e, i)
			}),
				(af.prototype.setOptional = function (t, n, e) {
					const i = n[e]
					void 0 !== i && this.setValue(t, e, i)
				}),
				(af.upload = function (t, n, e, i) {
					for (let r = 0, o = n.length; r !== o; ++r) {
						const s = n[r],
							a = e[s.id]
						!1 !== a.needsUpdate && s.setValue(t, a.value, i)
					}
				}),
				(af.seqWithValue = function (t, n) {
					const e = []
					for (let i = 0, r = t.length; i !== r; ++i) {
						const o = t[i]
						o.id in n && e.push(o)
					}
					return e
				})
			let s1e = 0
			function i7(t) {
				switch (t) {
					case fa:
						return ["Linear", "( value )"]
					case hy:
						return ["sRGB", "( value )"]
					case vM:
						return ["RGBE", "( value )"]
					case gR:
						return ["RGBM", "( value, 7.0 )"]
					case bR:
						return ["RGBM", "( value, 16.0 )"]
					case _R:
						return ["RGBD", "( value, 256.0 )"]
					case _M:
						return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]
					case Mj:
						return ["LogLuv", "( value )"]
					default:
						return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
				}
			}
			function r7(t, n, e) {
				const i = t.getShaderParameter(n, 35713),
					r = t.getShaderInfoLog(n).trim()
				return i && "" === r
					? ""
					: "THREE.WebGLShader: gl.getShaderInfoLog() " +
							e +
							"\n" +
							r +
							(function a1e(t) {
								const n = t.split("\n")
								for (let e = 0; e < n.length; e++) n[e] = e + 1 + ": " + n[e]
								return n.join("\n")
							})(t.getShaderSource(n))
			}
			function Sy(t, n) {
				const e = i7(n)
				return "vec4 " + t + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }"
			}
			function c1e(t, n) {
				const e = i7(n)
				return "vec4 " + t + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }"
			}
			function l1e(t, n) {
				let e
				switch (n) {
					case EW:
						e = "Linear"
						break
					case MW:
						e = "Reinhard"
						break
					case SW:
						e = "OptimizedCineon"
						break
					case kW:
						e = "ACESFilmic"
						break
					case TW:
						e = "Custom"
						break
					default:
						console.warn("THREE.WebGLProgram: Unsupported toneMapping:", n), (e = "Linear")
				}
				return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
			}
			function ky(t) {
				return "" !== t
			}
			function o7(t, n) {
				return t
					.replace(/NUM_DIR_LIGHTS/g, n.numDirLights)
					.replace(/NUM_SPOT_LIGHTS/g, n.numSpotLights)
					.replace(/NUM_RECT_AREA_LIGHTS/g, n.numRectAreaLights)
					.replace(/NUM_POINT_LIGHTS/g, n.numPointLights)
					.replace(/NUM_HEMI_LIGHTS/g, n.numHemiLights)
					.replace(/NUM_DIR_LIGHT_SHADOWS/g, n.numDirLightShadows)
					.replace(/NUM_SPOT_LIGHT_SHADOWS/g, n.numSpotLightShadows)
					.replace(/NUM_POINT_LIGHT_SHADOWS/g, n.numPointLightShadows)
			}
			function s7(t, n) {
				return t
					.replace(/NUM_CLIPPING_PLANES/g, n.numClippingPlanes)
					.replace(/UNION_CLIPPING_PLANES/g, n.numClippingPlanes - n.numClipIntersection)
			}
			const f1e = /^[ \t]*#include +<([\w\d./]+)>/gm
			function WR(t) {
				return t.replace(f1e, m1e)
			}
			function m1e(t, n) {
				const e = Bi[n]
				if (void 0 === e) throw new Error("Can not resolve #include <" + n + ">")
				return WR(e)
			}
			const p1e = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
				A1e =
					/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
			function a7(t) {
				return t.replace(A1e, c7).replace(p1e, g1e)
			}
			function g1e(t, n, e, i) {
				return (
					console.warn(
						"WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
					),
					c7(0, n, e, i)
				)
			}
			function c7(t, n, e, i) {
				let r = ""
				for (let o = parseInt(n); o < parseInt(e); o++)
					r += i.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o)
				return r
			}
			function l7(t) {
				let n = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"
				return (
					"highp" === t.precision
						? (n += "\n#define HIGH_PRECISION")
						: "mediump" === t.precision
						? (n += "\n#define MEDIUM_PRECISION")
						: "lowp" === t.precision && (n += "\n#define LOW_PRECISION"),
					n
				)
			}
			function w1e(t, n, e, i) {
				const r = t.getContext(),
					o = e.defines
				let s = e.vertexShader,
					a = e.fragmentShader
				const c = (function b1e(t) {
						let n = "SHADOWMAP_TYPE_BASIC"
						return (
							t.shadowMapType === YL
								? (n = "SHADOWMAP_TYPE_PCF")
								: t.shadowMapType === iW
								? (n = "SHADOWMAP_TYPE_PCF_SOFT")
								: t.shadowMapType === Bg && (n = "SHADOWMAP_TYPE_VSM"),
							n
						)
					})(e),
					l = (function _1e(t) {
						let n = "ENVMAP_TYPE_CUBE"
						if (t.envMap)
							switch (t.envMapMode) {
								case ny:
								case iy:
									n = "ENVMAP_TYPE_CUBE"
									break
								case Lg:
								case ry:
									n = "ENVMAP_TYPE_CUBE_UV"
							}
						return n
					})(e),
					d = (function v1e(t) {
						let n = "ENVMAP_MODE_REFLECTION"
						if (t.envMap)
							switch (t.envMapMode) {
								case iy:
								case ry:
									n = "ENVMAP_MODE_REFRACTION"
							}
						return n
					})(e),
					u = (function y1e(t) {
						let n = "ENVMAP_BLENDING_NONE"
						if (t.envMap)
							switch (t.combine) {
								case ty:
									n = "ENVMAP_BLENDING_MULTIPLY"
									break
								case xW:
									n = "ENVMAP_BLENDING_MIX"
									break
								case CW:
									n = "ENVMAP_BLENDING_ADD"
							}
						return n
					})(e),
					h = t.gammaFactor > 0 ? t.gammaFactor : 1,
					f = e.isWebGL2
						? ""
						: (function d1e(t) {
								return [
									t.extensionDerivatives ||
									t.envMapCubeUV ||
									t.bumpMap ||
									t.tangentSpaceNormalMap ||
									t.clearcoatNormalMap ||
									t.flatShading ||
									"physical" === t.shaderID
										? "#extension GL_OES_standard_derivatives : enable"
										: "",
									(t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth
										? "#extension GL_EXT_frag_depth : enable"
										: "",
									t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
										? "#extension GL_EXT_draw_buffers : require"
										: "",
									(t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod
										? "#extension GL_EXT_shader_texture_lod : enable"
										: ""
								]
									.filter(ky)
									.join("\n")
						  })(e),
					_ = (function u1e(t) {
						const n = []
						for (const e in t) {
							const i = t[e]
							!1 !== i && n.push("#define " + e + " " + i)
						}
						return n.join("\n")
					})(o),
					y = r.createProgram()
				let C,
					x,
					w = e.glslVersion ? "#version " + e.glslVersion + "\n" : ""
				e.isRawShaderMaterial
					? ((C = [_].filter(ky).join("\n")),
					  C.length > 0 && (C += "\n"),
					  (x = [f, _].filter(ky).join("\n")),
					  x.length > 0 && (x += "\n"))
					: ((C = [
							l7(e),
							"#define SHADER_NAME " + e.shaderName,
							_,
							e.instancing ? "#define USE_INSTANCING" : "",
							e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
							e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
							"#define GAMMA_FACTOR " + h,
							"#define MAX_BONES " + e.maxBones,
							e.useFog && e.fog ? "#define USE_FOG" : "",
							e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
							e.map ? "#define USE_MAP" : "",
							e.envMap ? "#define USE_ENVMAP" : "",
							e.envMap ? "#define " + d : "",
							e.lightMap ? "#define USE_LIGHTMAP" : "",
							e.aoMap ? "#define USE_AOMAP" : "",
							e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
							e.bumpMap ? "#define USE_BUMPMAP" : "",
							e.normalMap ? "#define USE_NORMALMAP" : "",
							e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
							e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
							e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
							e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
							e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
							e.displacementMap && e.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
							e.specularMap ? "#define USE_SPECULARMAP" : "",
							e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
							e.metalnessMap ? "#define USE_METALNESSMAP" : "",
							e.alphaMap ? "#define USE_ALPHAMAP" : "",
							e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
							e.vertexTangents ? "#define USE_TANGENT" : "",
							e.vertexColors ? "#define USE_COLOR" : "",
							e.vertexUvs ? "#define USE_UV" : "",
							e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
							e.flatShading ? "#define FLAT_SHADED" : "",
							e.skinning ? "#define USE_SKINNING" : "",
							e.useVertexTexture ? "#define BONE_TEXTURE" : "",
							e.morphTargets ? "#define USE_MORPHTARGETS" : "",
							e.morphNormals && !1 === e.flatShading ? "#define USE_MORPHNORMALS" : "",
							e.doubleSided ? "#define DOUBLE_SIDED" : "",
							e.flipSided ? "#define FLIP_SIDED" : "",
							e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
							e.shadowMapEnabled ? "#define " + c : "",
							e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
							e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
							e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
							"uniform mat4 modelMatrix;",
							"uniform mat4 modelViewMatrix;",
							"uniform mat4 projectionMatrix;",
							"uniform mat4 viewMatrix;",
							"uniform mat3 normalMatrix;",
							"uniform vec3 cameraPosition;",
							"uniform bool isOrthographic;",
							"#ifdef USE_INSTANCING",
							"\tattribute mat4 instanceMatrix;",
							"#endif",
							"#ifdef USE_INSTANCING_COLOR",
							"\tattribute vec3 instanceColor;",
							"#endif",
							"attribute vec3 position;",
							"attribute vec3 normal;",
							"attribute vec2 uv;",
							"#ifdef USE_TANGENT",
							"\tattribute vec4 tangent;",
							"#endif",
							"#ifdef USE_COLOR",
							"\tattribute vec3 color;",
							"#endif",
							"#ifdef USE_MORPHTARGETS",
							"\tattribute vec3 morphTarget0;",
							"\tattribute vec3 morphTarget1;",
							"\tattribute vec3 morphTarget2;",
							"\tattribute vec3 morphTarget3;",
							"\t#ifdef USE_MORPHNORMALS",
							"\t\tattribute vec3 morphNormal0;",
							"\t\tattribute vec3 morphNormal1;",
							"\t\tattribute vec3 morphNormal2;",
							"\t\tattribute vec3 morphNormal3;",
							"\t#else",
							"\t\tattribute vec3 morphTarget4;",
							"\t\tattribute vec3 morphTarget5;",
							"\t\tattribute vec3 morphTarget6;",
							"\t\tattribute vec3 morphTarget7;",
							"\t#endif",
							"#endif",
							"#ifdef USE_SKINNING",
							"\tattribute vec4 skinIndex;",
							"\tattribute vec4 skinWeight;",
							"#endif",
							"\n"
					  ]
							.filter(ky)
							.join("\n")),
					  (x = [
							f,
							l7(e),
							"#define SHADER_NAME " + e.shaderName,
							_,
							e.alphaTest ? "#define ALPHATEST " + e.alphaTest + (e.alphaTest % 1 ? "" : ".0") : "",
							"#define GAMMA_FACTOR " + h,
							e.useFog && e.fog ? "#define USE_FOG" : "",
							e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
							e.map ? "#define USE_MAP" : "",
							e.matcap ? "#define USE_MATCAP" : "",
							e.envMap ? "#define USE_ENVMAP" : "",
							e.envMap ? "#define " + l : "",
							e.envMap ? "#define " + d : "",
							e.envMap ? "#define " + u : "",
							e.lightMap ? "#define USE_LIGHTMAP" : "",
							e.aoMap ? "#define USE_AOMAP" : "",
							e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
							e.bumpMap ? "#define USE_BUMPMAP" : "",
							e.normalMap ? "#define USE_NORMALMAP" : "",
							e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
							e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
							e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
							e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
							e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
							e.specularMap ? "#define USE_SPECULARMAP" : "",
							e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
							e.metalnessMap ? "#define USE_METALNESSMAP" : "",
							e.alphaMap ? "#define USE_ALPHAMAP" : "",
							e.sheen ? "#define USE_SHEEN" : "",
							e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
							e.vertexTangents ? "#define USE_TANGENT" : "",
							e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "",
							e.vertexUvs ? "#define USE_UV" : "",
							e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
							e.gradientMap ? "#define USE_GRADIENTMAP" : "",
							e.flatShading ? "#define FLAT_SHADED" : "",
							e.doubleSided ? "#define DOUBLE_SIDED" : "",
							e.flipSided ? "#define FLIP_SIDED" : "",
							e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
							e.shadowMapEnabled ? "#define " + c : "",
							e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
							e.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
							e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
							e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
							(e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod
								? "#define TEXTURE_LOD_EXT"
								: "",
							"uniform mat4 viewMatrix;",
							"uniform vec3 cameraPosition;",
							"uniform bool isOrthographic;",
							e.toneMapping !== Jm ? "#define TONE_MAPPING" : "",
							e.toneMapping !== Jm ? Bi.tonemapping_pars_fragment : "",
							e.toneMapping !== Jm ? l1e("toneMapping", e.toneMapping) : "",
							e.dithering ? "#define DITHERING" : "",
							Bi.encodings_pars_fragment,
							e.map ? Sy("mapTexelToLinear", e.mapEncoding) : "",
							e.matcap ? Sy("matcapTexelToLinear", e.matcapEncoding) : "",
							e.envMap ? Sy("envMapTexelToLinear", e.envMapEncoding) : "",
							e.emissiveMap ? Sy("emissiveMapTexelToLinear", e.emissiveMapEncoding) : "",
							e.lightMap ? Sy("lightMapTexelToLinear", e.lightMapEncoding) : "",
							c1e("linearToOutputTexel", e.outputEncoding),
							e.depthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
							"\n"
					  ]
							.filter(ky)
							.join("\n"))),
					(s = WR(s)),
					(s = o7(s, e)),
					(s = s7(s, e)),
					(a = WR(a)),
					(a = o7(a, e)),
					(a = s7(a, e)),
					(s = a7(s)),
					(a = a7(a)),
					e.isWebGL2 &&
						!0 !== e.isRawShaderMaterial &&
						((w = "#version 300 es\n"),
						(C = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + C),
						(x =
							[
								"#define varying in",
								e.glslVersion === vR ? "" : "out highp vec4 pc_fragColor;",
								e.glslVersion === vR ? "" : "#define gl_FragColor pc_fragColor",
								"#define gl_FragDepthEXT gl_FragDepth",
								"#define texture2D texture",
								"#define textureCube texture",
								"#define texture2DProj textureProj",
								"#define texture2DLodEXT textureLod",
								"#define texture2DProjLodEXT textureProjLod",
								"#define textureCubeLodEXT textureLod",
								"#define texture2DGradEXT textureGrad",
								"#define texture2DProjGradEXT textureProjGrad",
								"#define textureCubeGradEXT textureGrad"
							].join("\n") +
							"\n" +
							x))
				const M = w + x + a,
					O = n7(r, 35633, w + C + s),
					N = n7(r, 35632, M)
				if (
					(r.attachShader(y, O),
					r.attachShader(y, N),
					void 0 !== e.index0AttributeName
						? r.bindAttribLocation(y, 0, e.index0AttributeName)
						: !0 === e.morphTargets && r.bindAttribLocation(y, 0, "position"),
					r.linkProgram(y),
					t.debug.checkShaderErrors)
				) {
					const ae = r.getProgramInfoLog(y).trim(),
						ce = r.getShaderInfoLog(O).trim(),
						ue = r.getShaderInfoLog(N).trim()
					let Se = !0,
						ve = !0
					if (!1 === r.getProgramParameter(y, 35714)) {
						Se = !1
						const W = r7(r, O, "vertex"),
							me = r7(r, N, "fragment")
						console.error(
							"THREE.WebGLProgram: shader error: ",
							r.getError(),
							"35715",
							r.getProgramParameter(y, 35715),
							"gl.getProgramInfoLog",
							ae,
							W,
							me
						)
					} else
						"" !== ae ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", ae) : ("" === ce || "" === ue) && (ve = !1)
					ve &&
						(this.diagnostics = {
							runnable: Se,
							programLog: ae,
							vertexShader: { log: ce, prefix: C },
							fragmentShader: { log: ue, prefix: x }
						})
				}
				let j, le
				return (
					r.deleteShader(O),
					r.deleteShader(N),
					(this.getUniforms = function () {
						return void 0 === j && (j = new af(r, y)), j
					}),
					(this.getAttributes = function () {
						return (
							void 0 === le &&
								(le = (function h1e(t, n) {
									const e = {},
										i = t.getProgramParameter(n, 35721)
									for (let r = 0; r < i; r++) {
										const s = t.getActiveAttrib(n, r).name
										e[s] = t.getAttribLocation(n, s)
									}
									return e
								})(r, y)),
							le
						)
					}),
					(this.destroy = function () {
						i.releaseStatesOfProgram(this), r.deleteProgram(y), (this.program = void 0)
					}),
					(this.name = e.shaderName),
					(this.id = s1e++),
					(this.cacheKey = n),
					(this.usedTimes = 1),
					(this.program = y),
					(this.vertexShader = O),
					(this.fragmentShader = N),
					this
				)
			}
			function x1e(t, n, e, i, r, o) {
				const s = [],
					a = i.isWebGL2,
					c = i.logarithmicDepthBuffer,
					l = i.floatVertexTextures,
					d = i.maxVertexUniforms,
					u = i.vertexTextures
				let h = i.precision
				const f = {
						MeshDepthMaterial: "depth",
						MeshDistanceMaterial: "distanceRGBA",
						MeshNormalMaterial: "normal",
						MeshBasicMaterial: "basic",
						MeshLambertMaterial: "lambert",
						MeshPhongMaterial: "phong",
						MeshToonMaterial: "toon",
						MeshStandardMaterial: "physical",
						MeshPhysicalMaterial: "physical",
						MeshMatcapMaterial: "matcap",
						LineBasicMaterial: "basic",
						LineDashedMaterial: "dashed",
						PointsMaterial: "points",
						ShadowMaterial: "shadow",
						SpriteMaterial: "sprite"
					},
					_ = [
						"precision",
						"isWebGL2",
						"supportsVertexTextures",
						"outputEncoding",
						"instancing",
						"instancingColor",
						"map",
						"mapEncoding",
						"matcap",
						"matcapEncoding",
						"envMap",
						"envMapMode",
						"envMapEncoding",
						"envMapCubeUV",
						"lightMap",
						"lightMapEncoding",
						"aoMap",
						"emissiveMap",
						"emissiveMapEncoding",
						"bumpMap",
						"normalMap",
						"objectSpaceNormalMap",
						"tangentSpaceNormalMap",
						"clearcoatMap",
						"clearcoatRoughnessMap",
						"clearcoatNormalMap",
						"displacementMap",
						"specularMap",
						"roughnessMap",
						"metalnessMap",
						"gradientMap",
						"alphaMap",
						"combine",
						"vertexColors",
						"vertexTangents",
						"vertexUvs",
						"uvsVertexOnly",
						"fog",
						"useFog",
						"fogExp2",
						"flatShading",
						"sizeAttenuation",
						"logarithmicDepthBuffer",
						"skinning",
						"maxBones",
						"useVertexTexture",
						"morphTargets",
						"morphNormals",
						"maxMorphTargets",
						"maxMorphNormals",
						"premultipliedAlpha",
						"numDirLights",
						"numPointLights",
						"numSpotLights",
						"numHemiLights",
						"numRectAreaLights",
						"numDirLightShadows",
						"numPointLightShadows",
						"numSpotLightShadows",
						"shadowMapEnabled",
						"shadowMapType",
						"toneMapping",
						"physicallyCorrectLights",
						"alphaTest",
						"doubleSided",
						"flipSided",
						"numClippingPlanes",
						"numClipIntersection",
						"depthPacking",
						"dithering",
						"sheen",
						"transmissionMap"
					]
				function C(N) {
					let j
					return (
						N && N.isTexture
							? (j = N.encoding)
							: N && N.isWebGLRenderTarget
							? (console.warn(
									"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
							  ),
							  (j = N.texture.encoding))
							: (j = fa),
						j
					)
				}
				return {
					getParameters: function x(N, j, le, ae, ce) {
						const ue = ae.fog,
							ve = n.get(N.envMap || (N.isMeshStandardMaterial ? ae.environment : null)),
							W = f[N.type],
							me = ce.isSkinnedMesh
								? (function y(N) {
										const le = N.skeleton.bones
										if (l) return 1024
										{
											const ce = Math.floor((d - 20) / 4),
												ue = Math.min(ce, le.length)
											return ue < le.length
												? (console.warn(
														"THREE.WebGLRenderer: Skeleton has " +
															le.length +
															" bones. This GPU supports " +
															ue +
															"."
												  ),
												  0)
												: ue
										}
								  })(ce)
								: 0
						let Z, Ae
						if (
							(null !== N.precision &&
								((h = i.getMaxPrecision(N.precision)),
								h !== N.precision &&
									console.warn("THREE.WebGLProgram.getParameters:", N.precision, "not supported, using", h, "instead.")),
							W)
						) {
							const nt = vl[W]
							;(Z = nt.vertexShader), (Ae = nt.fragmentShader)
						} else (Z = N.vertexShader), (Ae = N.fragmentShader)
						const Ie = t.getRenderTarget()
						return {
							isWebGL2: a,
							shaderID: W,
							shaderName: N.type,
							vertexShader: Z,
							fragmentShader: Ae,
							defines: N.defines,
							isRawShaderMaterial: !0 === N.isRawShaderMaterial,
							glslVersion: N.glslVersion,
							precision: h,
							instancing: !0 === ce.isInstancedMesh,
							instancingColor: !0 === ce.isInstancedMesh && null !== ce.instanceColor,
							supportsVertexTextures: u,
							outputEncoding: null !== Ie ? C(Ie.texture) : t.outputEncoding,
							map: !!N.map,
							mapEncoding: C(N.map),
							matcap: !!N.matcap,
							matcapEncoding: C(N.matcap),
							envMap: !!ve,
							envMapMode: ve && ve.mapping,
							envMapEncoding: C(ve),
							envMapCubeUV: !!ve && (ve.mapping === Lg || ve.mapping === ry),
							lightMap: !!N.lightMap,
							lightMapEncoding: C(N.lightMap),
							aoMap: !!N.aoMap,
							emissiveMap: !!N.emissiveMap,
							emissiveMapEncoding: C(N.emissiveMap),
							bumpMap: !!N.bumpMap,
							normalMap: !!N.normalMap,
							objectSpaceNormalMap: N.normalMapType === Tj,
							tangentSpaceNormalMap: N.normalMapType === rp,
							clearcoatMap: !!N.clearcoatMap,
							clearcoatRoughnessMap: !!N.clearcoatRoughnessMap,
							clearcoatNormalMap: !!N.clearcoatNormalMap,
							displacementMap: !!N.displacementMap,
							roughnessMap: !!N.roughnessMap,
							metalnessMap: !!N.metalnessMap,
							specularMap: !!N.specularMap,
							alphaMap: !!N.alphaMap,
							gradientMap: !!N.gradientMap,
							sheen: !!N.sheen,
							transmissionMap: !!N.transmissionMap,
							combine: N.combine,
							vertexTangents: N.normalMap && N.vertexTangents,
							vertexColors: N.vertexColors,
							vertexUvs: !!(
								N.map ||
								N.bumpMap ||
								N.normalMap ||
								N.specularMap ||
								N.alphaMap ||
								N.emissiveMap ||
								N.roughnessMap ||
								N.metalnessMap ||
								N.clearcoatMap ||
								N.clearcoatRoughnessMap ||
								N.clearcoatNormalMap ||
								N.displacementMap ||
								N.transmissionMap
							),
							uvsVertexOnly: !(
								N.map ||
								N.bumpMap ||
								N.normalMap ||
								N.specularMap ||
								N.alphaMap ||
								N.emissiveMap ||
								N.roughnessMap ||
								N.metalnessMap ||
								N.clearcoatNormalMap ||
								N.transmissionMap ||
								!N.displacementMap
							),
							fog: !!ue,
							useFog: N.fog,
							fogExp2: ue && ue.isFogExp2,
							flatShading: !!N.flatShading,
							sizeAttenuation: N.sizeAttenuation,
							logarithmicDepthBuffer: c,
							skinning: N.skinning && me > 0,
							maxBones: me,
							useVertexTexture: l,
							morphTargets: N.morphTargets,
							morphNormals: N.morphNormals,
							maxMorphTargets: t.maxMorphTargets,
							maxMorphNormals: t.maxMorphNormals,
							numDirLights: j.directional.length,
							numPointLights: j.point.length,
							numSpotLights: j.spot.length,
							numRectAreaLights: j.rectArea.length,
							numHemiLights: j.hemi.length,
							numDirLightShadows: j.directionalShadowMap.length,
							numPointLightShadows: j.pointShadowMap.length,
							numSpotLightShadows: j.spotShadowMap.length,
							numClippingPlanes: o.numPlanes,
							numClipIntersection: o.numIntersection,
							dithering: N.dithering,
							shadowMapEnabled: t.shadowMap.enabled && le.length > 0,
							shadowMapType: t.shadowMap.type,
							toneMapping: N.toneMapped ? t.toneMapping : Jm,
							physicallyCorrectLights: t.physicallyCorrectLights,
							premultipliedAlpha: N.premultipliedAlpha,
							alphaTest: N.alphaTest,
							doubleSided: N.side === ey,
							flipSided: N.side === Lo,
							depthPacking: void 0 !== N.depthPacking && N.depthPacking,
							index0AttributeName: N.index0AttributeName,
							extensionDerivatives: N.extensions && N.extensions.derivatives,
							extensionFragDepth: N.extensions && N.extensions.fragDepth,
							extensionDrawBuffers: N.extensions && N.extensions.drawBuffers,
							extensionShaderTextureLOD: N.extensions && N.extensions.shaderTextureLOD,
							rendererExtensionFragDepth: a || e.has("EXT_frag_depth"),
							rendererExtensionDrawBuffers: a || e.has("WEBGL_draw_buffers"),
							rendererExtensionShaderTextureLod: a || e.has("EXT_shader_texture_lod"),
							customProgramCacheKey: N.customProgramCacheKey()
						}
					},
					getProgramCacheKey: function w(N) {
						const j = []
						if ((N.shaderID ? j.push(N.shaderID) : (j.push(N.fragmentShader), j.push(N.vertexShader)), void 0 !== N.defines))
							for (const le in N.defines) j.push(le), j.push(N.defines[le])
						if (!1 === N.isRawShaderMaterial) {
							for (let le = 0; le < _.length; le++) j.push(N[_[le]])
							j.push(t.outputEncoding), j.push(t.gammaFactor)
						}
						return j.push(N.customProgramCacheKey), j.join()
					},
					getUniforms: function S(N) {
						const j = f[N.type]
						let le
						return (le = j ? UM.clone(vl[j].uniforms) : N.uniforms), le
					},
					acquireProgram: function M(N, j) {
						let le
						for (let ae = 0, ce = s.length; ae < ce; ae++) {
							const ue = s[ae]
							if (ue.cacheKey === j) {
								;(le = ue), ++le.usedTimes
								break
							}
						}
						return void 0 === le && ((le = new w1e(t, j, N, r)), s.push(le)), le
					},
					releaseProgram: function O(N) {
						if (0 == --N.usedTimes) {
							const j = s.indexOf(N)
							;(s[j] = s[s.length - 1]), s.pop(), N.destroy()
						}
					},
					programs: s
				}
			}
			function C1e() {
				let t = new WeakMap()
				return {
					get: function n(o) {
						let s = t.get(o)
						return void 0 === s && ((s = {}), t.set(o, s)), s
					},
					remove: function e(o) {
						t.delete(o)
					},
					update: function i(o, s, a) {
						t.get(o)[s] = a
					},
					dispose: function r() {
						t = new WeakMap()
					}
				}
			}
			function E1e(t, n) {
				return t.groupOrder !== n.groupOrder
					? t.groupOrder - n.groupOrder
					: t.renderOrder !== n.renderOrder
					? t.renderOrder - n.renderOrder
					: t.program !== n.program
					? t.program.id - n.program.id
					: t.material.id !== n.material.id
					? t.material.id - n.material.id
					: t.z !== n.z
					? t.z - n.z
					: t.id - n.id
			}
			function M1e(t, n) {
				return t.groupOrder !== n.groupOrder
					? t.groupOrder - n.groupOrder
					: t.renderOrder !== n.renderOrder
					? t.renderOrder - n.renderOrder
					: t.z !== n.z
					? n.z - t.z
					: t.id - n.id
			}
			function d7(t) {
				const n = []
				let e = 0
				const i = [],
					r = [],
					o = { id: -1 }
				function a(h, f, _, y, C, x) {
					let w = n[e]
					const S = t.get(_)
					return (
						void 0 === w
							? ((w = {
									id: h.id,
									object: h,
									geometry: f,
									material: _,
									program: S.program || o,
									groupOrder: y,
									renderOrder: h.renderOrder,
									z: C,
									group: x
							  }),
							  (n[e] = w))
							: ((w.id = h.id),
							  (w.object = h),
							  (w.geometry = f),
							  (w.material = _),
							  (w.program = S.program || o),
							  (w.groupOrder = y),
							  (w.renderOrder = h.renderOrder),
							  (w.z = C),
							  (w.group = x)),
						e++,
						w
					)
				}
				return {
					opaque: i,
					transparent: r,
					init: function s() {
						;(e = 0), (i.length = 0), (r.length = 0)
					},
					push: function c(h, f, _, y, C, x) {
						const w = a(h, f, _, y, C, x)
						;(!0 === _.transparent ? r : i).push(w)
					},
					unshift: function l(h, f, _, y, C, x) {
						const w = a(h, f, _, y, C, x)
						;(!0 === _.transparent ? r : i).unshift(w)
					},
					finish: function u() {
						for (let h = e, f = n.length; h < f; h++) {
							const _ = n[h]
							if (null === _.id) break
							;(_.id = null),
								(_.object = null),
								(_.geometry = null),
								(_.material = null),
								(_.program = null),
								(_.group = null)
						}
					},
					sort: function d(h, f) {
						i.length > 1 && i.sort(h || E1e), r.length > 1 && r.sort(f || M1e)
					}
				}
			}
			function S1e(t) {
				let n = new WeakMap()
				return {
					get: function e(r, o) {
						let s
						return (
							!1 === n.has(r)
								? ((s = new d7(t)), n.set(r, [s]))
								: o >= n.get(r).length
								? ((s = new d7(t)), n.get(r).push(s))
								: (s = n.get(r)[o]),
							s
						)
					},
					dispose: function i() {
						n = new WeakMap()
					}
				}
			}
			function k1e() {
				const t = {}
				return {
					get: function (n) {
						if (void 0 !== t[n.id]) return t[n.id]
						let e
						switch (n.type) {
							case "DirectionalLight":
								e = { direction: new K(), color: new Lt() }
								break
							case "SpotLight":
								e = {
									position: new K(),
									direction: new K(),
									color: new Lt(),
									distance: 0,
									coneCos: 0,
									penumbraCos: 0,
									decay: 0
								}
								break
							case "PointLight":
								e = { position: new K(), color: new Lt(), distance: 0, decay: 0 }
								break
							case "HemisphereLight":
								e = { direction: new K(), skyColor: new Lt(), groundColor: new Lt() }
								break
							case "RectAreaLight":
								e = { color: new Lt(), position: new K(), halfWidth: new K(), halfHeight: new K() }
						}
						return (t[n.id] = e), e
					}
				}
			}
			let F1e = 0
			function B1e(t, n) {
				return (n.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
			}
			function I1e(t, n) {
				const e = new k1e(),
					i = (function T1e() {
						const t = {}
						return {
							get: function (n) {
								if (void 0 !== t[n.id]) return t[n.id]
								let e
								switch (n.type) {
									case "DirectionalLight":
									case "SpotLight":
										e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new lt() }
										break
									case "PointLight":
										e = {
											shadowBias: 0,
											shadowNormalBias: 0,
											shadowRadius: 1,
											shadowMapSize: new lt(),
											shadowCameraNear: 1,
											shadowCameraFar: 1e3
										}
								}
								return (t[n.id] = e), e
							}
						}
					})(),
					r = {
						version: 0,
						hash: {
							directionalLength: -1,
							pointLength: -1,
							spotLength: -1,
							rectAreaLength: -1,
							hemiLength: -1,
							numDirectionalShadows: -1,
							numPointShadows: -1,
							numSpotShadows: -1
						},
						ambient: [0, 0, 0],
						probe: [],
						directional: [],
						directionalShadow: [],
						directionalShadowMap: [],
						directionalShadowMatrix: [],
						spot: [],
						spotShadow: [],
						spotShadowMap: [],
						spotShadowMatrix: [],
						rectArea: [],
						rectAreaLTC1: null,
						rectAreaLTC2: null,
						point: [],
						pointShadow: [],
						pointShadowMap: [],
						pointShadowMatrix: [],
						hemi: []
					}
				for (let d = 0; d < 9; d++) r.probe.push(new K())
				const o = new K(),
					s = new Cn(),
					a = new Cn()
				return {
					setup: function c(d) {
						let u = 0,
							h = 0,
							f = 0
						for (let j = 0; j < 9; j++) r.probe[j].set(0, 0, 0)
						let _ = 0,
							y = 0,
							C = 0,
							x = 0,
							w = 0,
							S = 0,
							M = 0,
							O = 0
						d.sort(B1e)
						for (let j = 0, le = d.length; j < le; j++) {
							const ae = d[j],
								ce = ae.color,
								ue = ae.intensity,
								Se = ae.distance,
								ve = ae.shadow && ae.shadow.map ? ae.shadow.map.texture : null
							if (ae.isAmbientLight) (u += ce.r * ue), (h += ce.g * ue), (f += ce.b * ue)
							else if (ae.isLightProbe) for (let W = 0; W < 9; W++) r.probe[W].addScaledVector(ae.sh.coefficients[W], ue)
							else if (ae.isDirectionalLight) {
								const W = e.get(ae)
								if ((W.color.copy(ae.color).multiplyScalar(ae.intensity), ae.castShadow)) {
									const me = ae.shadow,
										Z = i.get(ae)
									;(Z.shadowBias = me.bias),
										(Z.shadowNormalBias = me.normalBias),
										(Z.shadowRadius = me.radius),
										(Z.shadowMapSize = me.mapSize),
										(r.directionalShadow[_] = Z),
										(r.directionalShadowMap[_] = ve),
										(r.directionalShadowMatrix[_] = ae.shadow.matrix),
										S++
								}
								;(r.directional[_] = W), _++
							} else if (ae.isSpotLight) {
								const W = e.get(ae)
								if (
									(W.position.setFromMatrixPosition(ae.matrixWorld),
									W.color.copy(ce).multiplyScalar(ue),
									(W.distance = Se),
									(W.coneCos = Math.cos(ae.angle)),
									(W.penumbraCos = Math.cos(ae.angle * (1 - ae.penumbra))),
									(W.decay = ae.decay),
									ae.castShadow)
								) {
									const me = ae.shadow,
										Z = i.get(ae)
									;(Z.shadowBias = me.bias),
										(Z.shadowNormalBias = me.normalBias),
										(Z.shadowRadius = me.radius),
										(Z.shadowMapSize = me.mapSize),
										(r.spotShadow[C] = Z),
										(r.spotShadowMap[C] = ve),
										(r.spotShadowMatrix[C] = ae.shadow.matrix),
										O++
								}
								;(r.spot[C] = W), C++
							} else if (ae.isRectAreaLight) {
								const W = e.get(ae)
								W.color.copy(ce).multiplyScalar(ue),
									W.halfWidth.set(0.5 * ae.width, 0, 0),
									W.halfHeight.set(0, 0.5 * ae.height, 0),
									(r.rectArea[x] = W),
									x++
							} else if (ae.isPointLight) {
								const W = e.get(ae)
								if (
									(W.color.copy(ae.color).multiplyScalar(ae.intensity),
									(W.distance = ae.distance),
									(W.decay = ae.decay),
									ae.castShadow)
								) {
									const me = ae.shadow,
										Z = i.get(ae)
									;(Z.shadowBias = me.bias),
										(Z.shadowNormalBias = me.normalBias),
										(Z.shadowRadius = me.radius),
										(Z.shadowMapSize = me.mapSize),
										(Z.shadowCameraNear = me.camera.near),
										(Z.shadowCameraFar = me.camera.far),
										(r.pointShadow[y] = Z),
										(r.pointShadowMap[y] = ve),
										(r.pointShadowMatrix[y] = ae.shadow.matrix),
										M++
								}
								;(r.point[y] = W), y++
							} else if (ae.isHemisphereLight) {
								const W = e.get(ae)
								W.skyColor.copy(ae.color).multiplyScalar(ue),
									W.groundColor.copy(ae.groundColor).multiplyScalar(ue),
									(r.hemi[w] = W),
									w++
							}
						}
						x > 0 &&
							(n.isWebGL2 || !0 === t.has("OES_texture_float_linear")
								? ((r.rectAreaLTC1 = Ht.LTC_FLOAT_1), (r.rectAreaLTC2 = Ht.LTC_FLOAT_2))
								: !0 === t.has("OES_texture_half_float_linear")
								? ((r.rectAreaLTC1 = Ht.LTC_HALF_1), (r.rectAreaLTC2 = Ht.LTC_HALF_2))
								: console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
							(r.ambient[0] = u),
							(r.ambient[1] = h),
							(r.ambient[2] = f)
						const N = r.hash
						;(N.directionalLength !== _ ||
							N.pointLength !== y ||
							N.spotLength !== C ||
							N.rectAreaLength !== x ||
							N.hemiLength !== w ||
							N.numDirectionalShadows !== S ||
							N.numPointShadows !== M ||
							N.numSpotShadows !== O) &&
							((r.directional.length = _),
							(r.spot.length = C),
							(r.rectArea.length = x),
							(r.point.length = y),
							(r.hemi.length = w),
							(r.directionalShadow.length = S),
							(r.directionalShadowMap.length = S),
							(r.pointShadow.length = M),
							(r.pointShadowMap.length = M),
							(r.spotShadow.length = O),
							(r.spotShadowMap.length = O),
							(r.directionalShadowMatrix.length = S),
							(r.pointShadowMatrix.length = M),
							(r.spotShadowMatrix.length = O),
							(N.directionalLength = _),
							(N.pointLength = y),
							(N.spotLength = C),
							(N.rectAreaLength = x),
							(N.hemiLength = w),
							(N.numDirectionalShadows = S),
							(N.numPointShadows = M),
							(N.numSpotShadows = O),
							(r.version = F1e++))
					},
					setupView: function l(d, u) {
						let h = 0,
							f = 0,
							_ = 0,
							y = 0,
							C = 0
						const x = u.matrixWorldInverse
						for (let w = 0, S = d.length; w < S; w++) {
							const M = d[w]
							if (M.isDirectionalLight) {
								const O = r.directional[h]
								O.direction.setFromMatrixPosition(M.matrixWorld),
									o.setFromMatrixPosition(M.target.matrixWorld),
									O.direction.sub(o),
									O.direction.transformDirection(x),
									h++
							} else if (M.isSpotLight) {
								const O = r.spot[_]
								O.position.setFromMatrixPosition(M.matrixWorld),
									O.position.applyMatrix4(x),
									O.direction.setFromMatrixPosition(M.matrixWorld),
									o.setFromMatrixPosition(M.target.matrixWorld),
									O.direction.sub(o),
									O.direction.transformDirection(x),
									_++
							} else if (M.isRectAreaLight) {
								const O = r.rectArea[y]
								O.position.setFromMatrixPosition(M.matrixWorld),
									O.position.applyMatrix4(x),
									a.identity(),
									s.copy(M.matrixWorld),
									s.premultiply(x),
									a.extractRotation(s),
									O.halfWidth.set(0.5 * M.width, 0, 0),
									O.halfHeight.set(0, 0.5 * M.height, 0),
									O.halfWidth.applyMatrix4(a),
									O.halfHeight.applyMatrix4(a),
									y++
							} else if (M.isPointLight) {
								const O = r.point[f]
								O.position.setFromMatrixPosition(M.matrixWorld), O.position.applyMatrix4(x), f++
							} else if (M.isHemisphereLight) {
								const O = r.hemi[C]
								O.direction.setFromMatrixPosition(M.matrixWorld),
									O.direction.transformDirection(x),
									O.direction.normalize(),
									C++
							}
						}
					},
					state: r
				}
			}
			function u7(t, n) {
				const e = new I1e(t, n),
					i = [],
					r = []
				return {
					init: function o() {
						;(i.length = 0), (r.length = 0)
					},
					state: { lightsArray: i, shadowsArray: r, lights: e },
					setupLights: function c() {
						e.setup(i)
					},
					setupLightsView: function l(u) {
						e.setupView(i, u)
					},
					pushLight: function s(u) {
						i.push(u)
					},
					pushShadow: function a(u) {
						r.push(u)
					}
				}
			}
			function D1e(t, n) {
				let e = new WeakMap()
				return {
					get: function i(o, s = 0) {
						let a
						return (
							!1 === e.has(o)
								? ((a = new u7(t, n)), e.set(o, [a]))
								: s >= e.get(o).length
								? ((a = new u7(t, n)), e.get(o).push(a))
								: (a = e.get(o)[s]),
							a
						)
					},
					dispose: function r() {
						e = new WeakMap()
					}
				}
			}
			class zM extends jr {
				constructor(n) {
					super(),
						(this.type = "MeshDepthMaterial"),
						(this.depthPacking = Sj),
						(this.skinning = !1),
						(this.morphTargets = !1),
						(this.map = null),
						(this.alphaMap = null),
						(this.displacementMap = null),
						(this.displacementScale = 1),
						(this.displacementBias = 0),
						(this.wireframe = !1),
						(this.wireframeLinewidth = 1),
						(this.fog = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						(this.depthPacking = n.depthPacking),
						(this.skinning = n.skinning),
						(this.morphTargets = n.morphTargets),
						(this.map = n.map),
						(this.alphaMap = n.alphaMap),
						(this.displacementMap = n.displacementMap),
						(this.displacementScale = n.displacementScale),
						(this.displacementBias = n.displacementBias),
						(this.wireframe = n.wireframe),
						(this.wireframeLinewidth = n.wireframeLinewidth),
						this
					)
				}
			}
			zM.prototype.isMeshDepthMaterial = !0
			class GM extends jr {
				constructor(n) {
					super(),
						(this.type = "MeshDistanceMaterial"),
						(this.referencePosition = new K()),
						(this.nearDistance = 1),
						(this.farDistance = 1e3),
						(this.skinning = !1),
						(this.morphTargets = !1),
						(this.map = null),
						(this.alphaMap = null),
						(this.displacementMap = null),
						(this.displacementScale = 1),
						(this.displacementBias = 0),
						(this.fog = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						this.referencePosition.copy(n.referencePosition),
						(this.nearDistance = n.nearDistance),
						(this.farDistance = n.farDistance),
						(this.skinning = n.skinning),
						(this.morphTargets = n.morphTargets),
						(this.map = n.map),
						(this.alphaMap = n.alphaMap),
						(this.displacementMap = n.displacementMap),
						(this.displacementScale = n.displacementScale),
						(this.displacementBias = n.displacementBias),
						this
					)
				}
			}
			GM.prototype.isMeshDistanceMaterial = !0
			var L1e =
					"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
				R1e = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"
			function h7(t, n, e) {
				let i = new My()
				const r = new lt(),
					o = new lt(),
					s = new lr(),
					a = [],
					c = [],
					l = {},
					d = { 0: Lo, 1: Ig, 2: ey },
					u = new Ds({
						defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
						uniforms: { shadow_pass: { value: null }, resolution: { value: new lt() }, radius: { value: 4 } },
						vertexShader: R1e,
						fragmentShader: L1e
					}),
					h = u.clone()
				h.defines.HORIZONTAL_PASS = 1
				const f = new vn()
				f.setAttribute("position", new xn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3))
				const _ = new Mi(f, u),
					y = this
				function C(O, N) {
					const j = n.update(_)
					;(u.uniforms.shadow_pass.value = O.map.texture),
						(u.uniforms.resolution.value = O.mapSize),
						(u.uniforms.radius.value = O.radius),
						t.setRenderTarget(O.mapPass),
						t.clear(),
						t.renderBufferDirect(N, null, j, u, _, null),
						(h.uniforms.shadow_pass.value = O.mapPass.texture),
						(h.uniforms.resolution.value = O.mapSize),
						(h.uniforms.radius.value = O.radius),
						t.setRenderTarget(O.map),
						t.clear(),
						t.renderBufferDirect(N, null, j, h, _, null)
				}
				function x(O, N, j) {
					const le = (O << 0) | (N << 1) | (j << 2)
					let ae = a[le]
					return void 0 === ae && ((ae = new zM({ depthPacking: kj, morphTargets: O, skinning: N })), (a[le] = ae)), ae
				}
				function w(O, N, j) {
					const le = (O << 0) | (N << 1) | (j << 2)
					let ae = c[le]
					return void 0 === ae && ((ae = new GM({ morphTargets: O, skinning: N })), (c[le] = ae)), ae
				}
				function S(O, N, j, le, ae, ce, ue) {
					let Se = null,
						ve = x,
						W = O.customDepthMaterial
					if ((!0 === le.isPointLight && ((ve = w), (W = O.customDistanceMaterial)), void 0 === W)) {
						let me = !1
						!0 === j.morphTargets &&
							(me = N.morphAttributes && N.morphAttributes.position && N.morphAttributes.position.length > 0)
						let Z = !1
						!0 === O.isSkinnedMesh &&
							(!0 === j.skinning
								? (Z = !0)
								: console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", O)),
							(Se = ve(me, Z, !0 === O.isInstancedMesh))
					} else Se = W
					if (t.localClippingEnabled && !0 === j.clipShadows && 0 !== j.clippingPlanes.length) {
						const me = Se.uuid,
							Z = j.uuid
						let Ae = l[me]
						void 0 === Ae && ((Ae = {}), (l[me] = Ae))
						let Ie = Ae[Z]
						void 0 === Ie && ((Ie = Se.clone()), (Ae[Z] = Ie)), (Se = Ie)
					}
					return (
						(Se.visible = j.visible),
						(Se.wireframe = j.wireframe),
						(Se.side =
							ue === Bg ? (null !== j.shadowSide ? j.shadowSide : j.side) : null !== j.shadowSide ? j.shadowSide : d[j.side]),
						(Se.clipShadows = j.clipShadows),
						(Se.clippingPlanes = j.clippingPlanes),
						(Se.clipIntersection = j.clipIntersection),
						(Se.wireframeLinewidth = j.wireframeLinewidth),
						(Se.linewidth = j.linewidth),
						!0 === le.isPointLight &&
							!0 === Se.isMeshDistanceMaterial &&
							(Se.referencePosition.setFromMatrixPosition(le.matrixWorld), (Se.nearDistance = ae), (Se.farDistance = ce)),
						Se
					)
				}
				function M(O, N, j, le, ae) {
					if (!1 === O.visible) return
					if (
						O.layers.test(N.layers) &&
						(O.isMesh || O.isLine || O.isPoints) &&
						(O.castShadow || (O.receiveShadow && ae === Bg)) &&
						(!O.frustumCulled || i.intersectsObject(O))
					) {
						O.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse, O.matrixWorld)
						const Se = n.update(O),
							ve = O.material
						if (Array.isArray(ve)) {
							const W = Se.groups
							for (let me = 0, Z = W.length; me < Z; me++) {
								const Ae = W[me],
									Ie = ve[Ae.materialIndex]
								if (Ie && Ie.visible) {
									const Pe = S(O, Se, Ie, le, j.near, j.far, ae)
									t.renderBufferDirect(j, null, Se, Pe, O, Ae)
								}
							}
						} else if (ve.visible) {
							const W = S(O, Se, ve, le, j.near, j.far, ae)
							t.renderBufferDirect(j, null, Se, W, O, null)
						}
					}
					const ue = O.children
					for (let Se = 0, ve = ue.length; Se < ve; Se++) M(ue[Se], N, j, le, ae)
				}
				;(this.enabled = !1),
					(this.autoUpdate = !0),
					(this.needsUpdate = !1),
					(this.type = YL),
					(this.render = function (O, N, j) {
						if (!1 === y.enabled || (!1 === y.autoUpdate && !1 === y.needsUpdate) || 0 === O.length) return
						const le = t.getRenderTarget(),
							ae = t.getActiveCubeFace(),
							ce = t.getActiveMipmapLevel(),
							ue = t.state
						ue.setBlending(Fu), ue.buffers.color.setClear(1, 1, 1, 1), ue.buffers.depth.setTest(!0), ue.setScissorTest(!1)
						for (let Se = 0, ve = O.length; Se < ve; Se++) {
							const W = O[Se],
								me = W.shadow
							if (void 0 === me) {
								console.warn("THREE.WebGLShadowMap:", W, "has no shadow.")
								continue
							}
							if (!1 === me.autoUpdate && !1 === me.needsUpdate) continue
							r.copy(me.mapSize)
							const Z = me.getFrameExtents()
							if (
								(r.multiply(Z),
								o.copy(me.mapSize),
								(r.x > e || r.y > e) &&
									(r.x > e && ((o.x = Math.floor(e / Z.x)), (r.x = o.x * Z.x), (me.mapSize.x = o.x)),
									r.y > e && ((o.y = Math.floor(e / Z.y)), (r.y = o.y * Z.y), (me.mapSize.y = o.y))),
								null === me.map && !me.isPointLightShadow && this.type === Bg)
							) {
								const Ie = { minFilter: xo, magFilter: xo, format: ha }
								;(me.map = new ml(r.x, r.y, Ie)),
									(me.map.texture.name = W.name + ".shadowMap"),
									(me.mapPass = new ml(r.x, r.y, Ie)),
									me.camera.updateProjectionMatrix()
							}
							null === me.map &&
								((me.map = new ml(r.x, r.y, { minFilter: ts, magFilter: ts, format: ha })),
								(me.map.texture.name = W.name + ".shadowMap"),
								me.camera.updateProjectionMatrix()),
								t.setRenderTarget(me.map),
								t.clear()
							const Ae = me.getViewportCount()
							for (let Ie = 0; Ie < Ae; Ie++) {
								const Pe = me.getViewport(Ie)
								s.set(o.x * Pe.x, o.y * Pe.y, o.x * Pe.z, o.y * Pe.w),
									ue.viewport(s),
									me.updateMatrices(W, Ie),
									(i = me.getFrustum()),
									M(N, j, me.camera, W, this.type)
							}
							!me.isPointLightShadow && this.type === Bg && C(me, j), (me.needsUpdate = !1)
						}
						;(y.needsUpdate = !1), t.setRenderTarget(le, ae, ce)
					})
			}
			function P1e(t, n, e) {
				const i = e.isWebGL2,
					a = new (function r() {
						let Be = !1
						const It = new lr()
						let en = null
						const An = new lr(0, 0, 0, 0)
						return {
							setMask: function (Bt) {
								en !== Bt && !Be && (t.colorMask(Bt, Bt, Bt, Bt), (en = Bt))
							},
							setLocked: function (Bt) {
								Be = Bt
							},
							setClear: function (Bt, Vn, Gn, In, Rn) {
								!0 === Rn && ((Bt *= In), (Vn *= In), (Gn *= In)),
									It.set(Bt, Vn, Gn, In),
									!1 === An.equals(It) && (t.clearColor(Bt, Vn, Gn, In), An.copy(It))
							},
							reset: function () {
								;(Be = !1), (en = null), An.set(-1, 0, 0, 0)
							}
						}
					})(),
					c = new (function o() {
						let Be = !1,
							It = null,
							en = null,
							An = null
						return {
							setTest: function (Bt) {
								Bt ? nt(2929) : pt(2929)
							},
							setMask: function (Bt) {
								It !== Bt && !Be && (t.depthMask(Bt), (It = Bt))
							},
							setFunc: function (Bt) {
								if (en !== Bt) {
									if (Bt)
										switch (Bt) {
											case AW:
												t.depthFunc(512)
												break
											case gW:
												t.depthFunc(519)
												break
											case bW:
												t.depthFunc(513)
												break
											case uM:
												t.depthFunc(515)
												break
											case _W:
												t.depthFunc(514)
												break
											case vW:
												t.depthFunc(518)
												break
											case yW:
												t.depthFunc(516)
												break
											case wW:
												t.depthFunc(517)
												break
											default:
												t.depthFunc(515)
										}
									else t.depthFunc(515)
									en = Bt
								}
							},
							setLocked: function (Bt) {
								Be = Bt
							},
							setClear: function (Bt) {
								An !== Bt && (t.clearDepth(Bt), (An = Bt))
							},
							reset: function () {
								;(Be = !1), (It = null), (en = null), (An = null)
							}
						}
					})(),
					l = new (function s() {
						let Be = !1,
							It = null,
							en = null,
							An = null,
							Bt = null,
							Vn = null,
							Gn = null,
							In = null,
							Rn = null
						return {
							setTest: function (Pn) {
								Be || (Pn ? nt(2960) : pt(2960))
							},
							setMask: function (Pn) {
								It !== Pn && !Be && (t.stencilMask(Pn), (It = Pn))
							},
							setFunc: function (Pn, fo, Oa) {
								;(en !== Pn || An !== fo || Bt !== Oa) && (t.stencilFunc(Pn, fo, Oa), (en = Pn), (An = fo), (Bt = Oa))
							},
							setOp: function (Pn, fo, Oa) {
								;(Vn !== Pn || Gn !== fo || In !== Oa) && (t.stencilOp(Pn, fo, Oa), (Vn = Pn), (Gn = fo), (In = Oa))
							},
							setLocked: function (Pn) {
								Be = Pn
							},
							setClear: function (Pn) {
								Rn !== Pn && (t.clearStencil(Pn), (Rn = Pn))
							},
							reset: function () {
								;(Be = !1),
									(It = null),
									(en = null),
									(An = null),
									(Bt = null),
									(Vn = null),
									(Gn = null),
									(In = null),
									(Rn = null)
							}
						}
					})()
				let d = {},
					u = null,
					h = !1,
					f = null,
					_ = null,
					y = null,
					C = null,
					x = null,
					w = null,
					S = null,
					M = !1,
					O = null,
					N = null,
					j = null,
					le = null,
					ae = null
				const ce = t.getParameter(35661)
				let ue = !1,
					Se = 0
				const ve = t.getParameter(7938)
				;-1 !== ve.indexOf("WebGL")
					? ((Se = parseFloat(/^WebGL (\d)/.exec(ve)[1])), (ue = Se >= 1))
					: -1 !== ve.indexOf("OpenGL ES") && ((Se = parseFloat(/^OpenGL ES (\d)/.exec(ve)[1])), (ue = Se >= 2))
				let W = null,
					me = {}
				const Z = new lr(),
					Ae = new lr()
				function Ie(Be, It, en) {
					const An = new Uint8Array(4),
						Bt = t.createTexture()
					t.bindTexture(Be, Bt), t.texParameteri(Be, 10241, 9728), t.texParameteri(Be, 10240, 9728)
					for (let Vn = 0; Vn < en; Vn++) t.texImage2D(It + Vn, 0, 6408, 1, 1, 0, 6408, 5121, An)
					return Bt
				}
				const Pe = {}
				function nt(Be) {
					!0 !== d[Be] && (t.enable(Be), (d[Be] = !0))
				}
				function pt(Be) {
					!1 !== d[Be] && (t.disable(Be), (d[Be] = !1))
				}
				;(Pe[3553] = Ie(3553, 3553, 1)),
					(Pe[34067] = Ie(34067, 34069, 6)),
					a.setClear(0, 0, 0, 1),
					c.setClear(1),
					l.setClear(0),
					nt(2929),
					c.setFunc(uM),
					nn(!1),
					Sn(XL),
					nt(2884),
					Un(Fu)
				const tn = { [Zm]: 32774, [oW]: 32778, [sW]: 32779 }
				if (i) (tn[tR] = 32775), (tn[nR] = 32776)
				else {
					const Be = n.get("EXT_blend_minmax")
					null !== Be && ((tn[tR] = Be.MIN_EXT), (tn[nR] = Be.MAX_EXT))
				}
				const Kt = {
					[aW]: 0,
					[cW]: 1,
					[lW]: 768,
					[iR]: 770,
					[pW]: 776,
					[fW]: 774,
					[uW]: 772,
					[dW]: 769,
					[rR]: 771,
					[mW]: 775,
					[hW]: 773
				}
				function Un(Be, It, en, An, Bt, Vn, Gn, In) {
					if (Be !== Fu) {
						if ((!1 === h && (nt(3042), (h = !0)), Be === rW))
							(Bt = Bt || It),
								(Vn = Vn || en),
								(Gn = Gn || An),
								(It !== _ || Bt !== x) && (t.blendEquationSeparate(tn[It], tn[Bt]), (_ = It), (x = Bt)),
								(en !== y || An !== C || Vn !== w || Gn !== S) &&
									(t.blendFuncSeparate(Kt[en], Kt[An], Kt[Vn], Kt[Gn]), (y = en), (C = An), (w = Vn), (S = Gn)),
								(f = Be),
								(M = null)
						else if (Be !== f || In !== M) {
							if (((_ !== Zm || x !== Zm) && (t.blendEquation(32774), (_ = Zm), (x = Zm)), In))
								switch (Be) {
									case Dg:
										t.blendFuncSeparate(1, 771, 1, 771)
										break
									case ZL:
										t.blendFunc(1, 1)
										break
									case JL:
										t.blendFuncSeparate(0, 0, 769, 771)
										break
									case eR:
										t.blendFuncSeparate(0, 768, 0, 770)
										break
									default:
										console.error("THREE.WebGLState: Invalid blending: ", Be)
								}
							else
								switch (Be) {
									case Dg:
										t.blendFuncSeparate(770, 771, 1, 771)
										break
									case ZL:
										t.blendFunc(770, 1)
										break
									case JL:
										t.blendFunc(0, 769)
										break
									case eR:
										t.blendFunc(0, 768)
										break
									default:
										console.error("THREE.WebGLState: Invalid blending: ", Be)
								}
							;(y = null), (C = null), (w = null), (S = null), (f = Be), (M = In)
						}
					} else !0 === h && (pt(3042), (h = !1))
				}
				function nn(Be) {
					O !== Be && (t.frontFace(Be ? 2304 : 2305), (O = Be))
				}
				function Sn(Be) {
					Be !== tW ? (nt(2884), Be !== N && t.cullFace(Be === XL ? 1029 : Be === nW ? 1028 : 1032)) : pt(2884), (N = Be)
				}
				function kn(Be, It, en) {
					Be ? (nt(32823), (le !== It || ae !== en) && (t.polygonOffset(It, en), (le = It), (ae = en))) : pt(32823)
				}
				function Et(Be) {
					void 0 === Be && (Be = 33984 + ce - 1), W !== Be && (t.activeTexture(Be), (W = Be))
				}
				return {
					buffers: { color: a, depth: c, stencil: l },
					enable: nt,
					disable: pt,
					useProgram: function kt(Be) {
						return u !== Be && (t.useProgram(Be), (u = Be), !0)
					},
					setBlending: Un,
					setMaterial: function dt(Be, It) {
						Be.side === ey ? pt(2884) : nt(2884)
						let en = Be.side === Lo
						It && (en = !en),
							nn(en),
							Be.blending === Dg && !1 === Be.transparent
								? Un(Fu)
								: Un(
										Be.blending,
										Be.blendEquation,
										Be.blendSrc,
										Be.blendDst,
										Be.blendEquationAlpha,
										Be.blendSrcAlpha,
										Be.blendDstAlpha,
										Be.premultipliedAlpha
								  ),
							c.setFunc(Be.depthFunc),
							c.setTest(Be.depthTest),
							c.setMask(Be.depthWrite),
							a.setMask(Be.colorWrite)
						const An = Be.stencilWrite
						l.setTest(An),
							An &&
								(l.setMask(Be.stencilWriteMask),
								l.setFunc(Be.stencilFunc, Be.stencilRef, Be.stencilFuncMask),
								l.setOp(Be.stencilFail, Be.stencilZFail, Be.stencilZPass)),
							kn(Be.polygonOffset, Be.polygonOffsetFactor, Be.polygonOffsetUnits)
					},
					setFlipSided: nn,
					setCullFace: Sn,
					setLineWidth: function Hn(Be) {
						Be !== j && (ue && t.lineWidth(Be), (j = Be))
					},
					setPolygonOffset: kn,
					setScissorTest: function Ii(Be) {
						Be ? nt(3089) : pt(3089)
					},
					activeTexture: Et,
					bindTexture: function Tt(Be, It) {
						null === W && Et()
						let en = me[W]
						void 0 === en && ((en = { type: void 0, texture: void 0 }), (me[W] = en)),
							(en.type !== Be || en.texture !== It) && (t.bindTexture(Be, It || Pe[Be]), (en.type = Be), (en.texture = It))
					},
					unbindTexture: function Ut() {
						const Be = me[W]
						void 0 !== Be && void 0 !== Be.type && (t.bindTexture(Be.type, null), (Be.type = void 0), (Be.texture = void 0))
					},
					compressedTexImage2D: function Fn() {
						try {
							t.compressedTexImage2D.apply(t, arguments)
						} catch (Be) {
							console.error("THREE.WebGLState:", Be)
						}
					},
					texImage2D: function ln() {
						try {
							t.texImage2D.apply(t, arguments)
						} catch (Be) {
							console.error("THREE.WebGLState:", Be)
						}
					},
					texImage3D: function oe() {
						try {
							t.texImage3D.apply(t, arguments)
						} catch (Be) {
							console.error("THREE.WebGLState:", Be)
						}
					},
					scissor: function ne(Be) {
						!1 === Z.equals(Be) && (t.scissor(Be.x, Be.y, Be.z, Be.w), Z.copy(Be))
					},
					viewport: function _t(Be) {
						!1 === Ae.equals(Be) && (t.viewport(Be.x, Be.y, Be.z, Be.w), Ae.copy(Be))
					},
					reset: function xt() {
						t.disable(3042),
							t.disable(2884),
							t.disable(2929),
							t.disable(32823),
							t.disable(3089),
							t.disable(2960),
							t.blendEquation(32774),
							t.blendFunc(1, 0),
							t.blendFuncSeparate(1, 0, 1, 0),
							t.colorMask(!0, !0, !0, !0),
							t.clearColor(0, 0, 0, 0),
							t.depthMask(!0),
							t.depthFunc(513),
							t.clearDepth(1),
							t.stencilMask(4294967295),
							t.stencilFunc(519, 0, 4294967295),
							t.stencilOp(7680, 7680, 7680),
							t.clearStencil(0),
							t.cullFace(1029),
							t.frontFace(2305),
							t.polygonOffset(0, 0),
							t.activeTexture(33984),
							t.useProgram(null),
							t.lineWidth(1),
							t.scissor(0, 0, t.canvas.width, t.canvas.height),
							t.viewport(0, 0, t.canvas.width, t.canvas.height),
							(d = {}),
							(W = null),
							(me = {}),
							(u = null),
							(h = !1),
							(f = null),
							(_ = null),
							(y = null),
							(C = null),
							(x = null),
							(w = null),
							(S = null),
							(M = !1),
							(O = null),
							(N = null),
							(j = null),
							(le = null),
							(ae = null),
							a.reset(),
							c.reset(),
							l.reset()
					}
				}
			}
			function O1e(t, n, e, i, r, o, s) {
				const a = r.isWebGL2,
					c = r.maxTextures,
					l = r.maxCubemapSize,
					d = r.maxTextureSize,
					u = r.maxSamples,
					h = new WeakMap()
				let f,
					_ = !1
				try {
					_ = typeof OffscreenCanvas < "u" && null !== new OffscreenCanvas(1, 1).getContext("2d")
				} catch {}
				function y(oe, ne) {
					return _ ? new OffscreenCanvas(oe, ne) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
				}
				function C(oe, ne, _t, xt) {
					let Be = 1
					if (((oe.width > xt || oe.height > xt) && (Be = xt / Math.max(oe.width, oe.height)), Be < 1 || !0 === ne)) {
						if (
							(typeof HTMLImageElement < "u" && oe instanceof HTMLImageElement) ||
							(typeof HTMLCanvasElement < "u" && oe instanceof HTMLCanvasElement) ||
							(typeof ImageBitmap < "u" && oe instanceof ImageBitmap)
						) {
							const It = ne ? jn.floorPowerOfTwo : Math.floor,
								en = It(Be * oe.width),
								An = It(Be * oe.height)
							void 0 === f && (f = y(en, An))
							const Bt = _t ? y(en, An) : f
							return (
								(Bt.width = en),
								(Bt.height = An),
								Bt.getContext("2d").drawImage(oe, 0, 0, en, An),
								console.warn(
									"THREE.WebGLRenderer: Texture has been resized from (" +
										oe.width +
										"x" +
										oe.height +
										") to (" +
										en +
										"x" +
										An +
										")."
								),
								Bt
							)
						}
						return (
							"data" in oe &&
								console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + oe.width + "x" + oe.height + ")."),
							oe
						)
					}
					return oe
				}
				function x(oe) {
					return jn.isPowerOfTwo(oe.width) && jn.isPowerOfTwo(oe.height)
				}
				function S(oe, ne) {
					return oe.generateMipmaps && ne && oe.minFilter !== ts && oe.minFilter !== xo
				}
				function M(oe, ne, _t, xt) {
					t.generateMipmap(oe), (i.get(ne).__maxMipLevel = Math.log2(Math.max(_t, xt)))
				}
				function O(oe, ne, _t) {
					if (!1 === a) return ne
					if (null !== oe) {
						if (void 0 !== t[oe]) return t[oe]
						console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + oe + "'")
					}
					let xt = ne
					return (
						6403 === ne && (5126 === _t && (xt = 33326), 5131 === _t && (xt = 33325), 5121 === _t && (xt = 33321)),
						6407 === ne && (5126 === _t && (xt = 34837), 5131 === _t && (xt = 34843), 5121 === _t && (xt = 32849)),
						6408 === ne && (5126 === _t && (xt = 34836), 5131 === _t && (xt = 34842), 5121 === _t && (xt = 32856)),
						(33325 === xt || 33326 === xt || 34842 === xt || 34836 === xt) && n.get("EXT_color_buffer_float"),
						xt
					)
				}
				function N(oe) {
					return oe === ts || oe === pM || oe === AM ? 9728 : 9729
				}
				function j(oe) {
					const ne = oe.target
					ne.removeEventListener("dispose", j),
						(function ae(oe) {
							const ne = i.get(oe)
							void 0 !== ne.__webglInit && (t.deleteTexture(ne.__webglTexture), i.remove(oe))
						})(ne),
						ne.isVideoTexture && h.delete(ne),
						s.memory.textures--
				}
				function le(oe) {
					const ne = oe.target
					ne.removeEventListener("dispose", le),
						(function ce(oe) {
							const ne = oe.texture,
								_t = i.get(oe),
								xt = i.get(ne)
							if (oe) {
								if (
									(void 0 !== xt.__webglTexture && t.deleteTexture(xt.__webglTexture),
									oe.depthTexture && oe.depthTexture.dispose(),
									oe.isWebGLCubeRenderTarget)
								)
									for (let Be = 0; Be < 6; Be++)
										t.deleteFramebuffer(_t.__webglFramebuffer[Be]),
											_t.__webglDepthbuffer && t.deleteRenderbuffer(_t.__webglDepthbuffer[Be])
								else
									t.deleteFramebuffer(_t.__webglFramebuffer),
										_t.__webglDepthbuffer && t.deleteRenderbuffer(_t.__webglDepthbuffer),
										_t.__webglMultisampledFramebuffer && t.deleteFramebuffer(_t.__webglMultisampledFramebuffer),
										_t.__webglColorRenderbuffer && t.deleteRenderbuffer(_t.__webglColorRenderbuffer),
										_t.__webglDepthRenderbuffer && t.deleteRenderbuffer(_t.__webglDepthRenderbuffer)
								i.remove(ne), i.remove(oe)
							}
						})(ne),
						s.memory.textures--
				}
				let ue = 0
				function W(oe, ne) {
					const _t = i.get(oe)
					if (
						(oe.isVideoTexture &&
							(function Et(oe) {
								const ne = s.render.frame
								h.get(oe) !== ne && (h.set(oe, ne), oe.update())
							})(oe),
						oe.version > 0 && _t.__version !== oe.version)
					) {
						const xt = oe.image
						if (void 0 === xt) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined")
						else {
							if (!1 !== xt.complete) return void kt(_t, oe, ne)
							console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
						}
					}
					e.activeTexture(33984 + ne), e.bindTexture(3553, _t.__webglTexture)
				}
				function Ae(oe, ne) {
					const _t = i.get(oe)
					oe.version > 0 && _t.__version !== oe.version
						? (function tn(oe, ne, _t) {
								if (6 !== ne.image.length) return
								pt(oe, ne),
									e.activeTexture(33984 + _t),
									e.bindTexture(34067, oe.__webglTexture),
									t.pixelStorei(37440, ne.flipY),
									t.pixelStorei(37441, ne.premultiplyAlpha),
									t.pixelStorei(3317, ne.unpackAlignment),
									t.pixelStorei(37443, 0)
								const xt = ne && (ne.isCompressedTexture || ne.image[0].isCompressedTexture),
									Be = ne.image[0] && ne.image[0].isDataTexture,
									It = []
								for (let Rn = 0; Rn < 6; Rn++)
									It[Rn] = xt || Be ? (Be ? ne.image[Rn].image : ne.image[Rn]) : C(ne.image[Rn], !1, !0, l)
								const en = It[0],
									An = x(en) || a,
									Bt = o.convert(ne.format),
									Vn = o.convert(ne.type),
									Gn = O(ne.internalFormat, Bt, Vn)
								let In
								if ((nt(34067, ne, An), xt)) {
									for (let Rn = 0; Rn < 6; Rn++) {
										In = It[Rn].mipmaps
										for (let Pn = 0; Pn < In.length; Pn++) {
											const fo = In[Pn]
											ne.format !== ha && ne.format !== Xh
												? null !== Bt
													? e.compressedTexImage2D(34069 + Rn, Pn, Gn, fo.width, fo.height, 0, fo.data)
													: console.warn(
															"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
													  )
												: e.texImage2D(34069 + Rn, Pn, Gn, fo.width, fo.height, 0, Bt, Vn, fo.data)
										}
									}
									oe.__maxMipLevel = In.length - 1
								} else {
									In = ne.mipmaps
									for (let Rn = 0; Rn < 6; Rn++)
										if (Be) {
											e.texImage2D(34069 + Rn, 0, Gn, It[Rn].width, It[Rn].height, 0, Bt, Vn, It[Rn].data)
											for (let Pn = 0; Pn < In.length; Pn++) {
												const Oa = In[Pn].image[Rn].image
												e.texImage2D(34069 + Rn, Pn + 1, Gn, Oa.width, Oa.height, 0, Bt, Vn, Oa.data)
											}
										} else {
											e.texImage2D(34069 + Rn, 0, Gn, Bt, Vn, It[Rn])
											for (let Pn = 0; Pn < In.length; Pn++)
												e.texImage2D(34069 + Rn, Pn + 1, Gn, Bt, Vn, In[Pn].image[Rn])
										}
									oe.__maxMipLevel = In.length
								}
								S(ne, An) && M(34067, ne, en.width, en.height), (oe.__version = ne.version), ne.onUpdate && ne.onUpdate(ne)
						  })(_t, oe, ne)
						: (e.activeTexture(33984 + ne), e.bindTexture(34067, _t.__webglTexture))
				}
				const Ie = { [ep]: 10497, [ua]: 33071, [oy]: 33648 },
					Pe = { [ts]: 9728, [pM]: 9984, [AM]: 9986, [xo]: 9729, [oR]: 9985, [Rg]: 9987 }
				function nt(oe, ne, _t) {
					if (
						(_t
							? (t.texParameteri(oe, 10242, Ie[ne.wrapS]),
							  t.texParameteri(oe, 10243, Ie[ne.wrapT]),
							  (32879 === oe || 35866 === oe) && t.texParameteri(oe, 32882, Ie[ne.wrapR]),
							  t.texParameteri(oe, 10240, Pe[ne.magFilter]),
							  t.texParameteri(oe, 10241, Pe[ne.minFilter]))
							: (t.texParameteri(oe, 10242, 33071),
							  t.texParameteri(oe, 10243, 33071),
							  (32879 === oe || 35866 === oe) && t.texParameteri(oe, 32882, 33071),
							  (ne.wrapS !== ua || ne.wrapT !== ua) &&
									console.warn(
										"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
									),
							  t.texParameteri(oe, 10240, N(ne.magFilter)),
							  t.texParameteri(oe, 10241, N(ne.minFilter)),
							  ne.minFilter !== ts &&
									ne.minFilter !== xo &&
									console.warn(
										"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
									)),
						!0 === n.has("EXT_texture_filter_anisotropic"))
					) {
						const xt = n.get("EXT_texture_filter_anisotropic")
						if (
							(ne.type === Bu && !1 === n.has("OES_texture_float_linear")) ||
							(!1 === a && ne.type === cy && !1 === n.has("OES_texture_half_float_linear"))
						)
							return
						;(ne.anisotropy > 1 || i.get(ne).__currentAnisotropy) &&
							(t.texParameterf(oe, xt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(ne.anisotropy, r.getMaxAnisotropy())),
							(i.get(ne).__currentAnisotropy = ne.anisotropy))
					}
				}
				function pt(oe, ne) {
					void 0 === oe.__webglInit &&
						((oe.__webglInit = !0),
						ne.addEventListener("dispose", j),
						(oe.__webglTexture = t.createTexture()),
						s.memory.textures++)
				}
				function kt(oe, ne, _t) {
					let xt = 3553
					ne.isDataTexture2DArray && (xt = 35866),
						ne.isDataTexture3D && (xt = 32879),
						pt(oe, ne),
						e.activeTexture(33984 + _t),
						e.bindTexture(xt, oe.__webglTexture),
						t.pixelStorei(37440, ne.flipY),
						t.pixelStorei(37441, ne.premultiplyAlpha),
						t.pixelStorei(3317, ne.unpackAlignment),
						t.pixelStorei(37443, 0)
					const Be =
							(function w(oe) {
								return !a && (oe.wrapS !== ua || oe.wrapT !== ua || (oe.minFilter !== ts && oe.minFilter !== xo))
							})(ne) && !1 === x(ne.image),
						It = C(ne.image, Be, !1, d),
						en = x(It) || a,
						An = o.convert(ne.format)
					let Gn,
						Bt = o.convert(ne.type),
						Vn = O(ne.internalFormat, An, Bt)
					nt(xt, ne, en)
					const In = ne.mipmaps
					if (ne.isDepthTexture)
						(Vn = 6402),
							a
								? (Vn = ne.type === Bu ? 36012 : ne.type === ay ? 33190 : ne.type === Og ? 35056 : 33189)
								: ne.type === Bu && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
							ne.format === tp &&
								6402 === Vn &&
								ne.type !== sy &&
								ne.type !== ay &&
								(console.warn(
									"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
								),
								(ne.type = sy),
								(Bt = o.convert(ne.type))),
							ne.format === Ng &&
								6402 === Vn &&
								((Vn = 34041),
								ne.type !== Og &&
									(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
									(ne.type = Og),
									(Bt = o.convert(ne.type)))),
							e.texImage2D(3553, 0, Vn, It.width, It.height, 0, An, Bt, null)
					else if (ne.isDataTexture)
						if (In.length > 0 && en) {
							for (let Rn = 0, Pn = In.length; Rn < Pn; Rn++)
								(Gn = In[Rn]), e.texImage2D(3553, Rn, Vn, Gn.width, Gn.height, 0, An, Bt, Gn.data)
							;(ne.generateMipmaps = !1), (oe.__maxMipLevel = In.length - 1)
						} else e.texImage2D(3553, 0, Vn, It.width, It.height, 0, An, Bt, It.data), (oe.__maxMipLevel = 0)
					else if (ne.isCompressedTexture) {
						for (let Rn = 0, Pn = In.length; Rn < Pn; Rn++)
							(Gn = In[Rn]),
								ne.format !== ha && ne.format !== Xh
									? null !== An
										? e.compressedTexImage2D(3553, Rn, Vn, Gn.width, Gn.height, 0, Gn.data)
										: console.warn(
												"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
										  )
									: e.texImage2D(3553, Rn, Vn, Gn.width, Gn.height, 0, An, Bt, Gn.data)
						oe.__maxMipLevel = In.length - 1
					} else if (ne.isDataTexture2DArray)
						e.texImage3D(35866, 0, Vn, It.width, It.height, It.depth, 0, An, Bt, It.data), (oe.__maxMipLevel = 0)
					else if (ne.isDataTexture3D)
						e.texImage3D(32879, 0, Vn, It.width, It.height, It.depth, 0, An, Bt, It.data), (oe.__maxMipLevel = 0)
					else if (In.length > 0 && en) {
						for (let Rn = 0, Pn = In.length; Rn < Pn; Rn++) (Gn = In[Rn]), e.texImage2D(3553, Rn, Vn, An, Bt, Gn)
						;(ne.generateMipmaps = !1), (oe.__maxMipLevel = In.length - 1)
					} else e.texImage2D(3553, 0, Vn, An, Bt, It), (oe.__maxMipLevel = 0)
					S(ne, en) && M(xt, ne, It.width, It.height), (oe.__version = ne.version), ne.onUpdate && ne.onUpdate(ne)
				}
				function Kt(oe, ne, _t, xt) {
					const Be = ne.texture,
						It = o.convert(Be.format),
						en = o.convert(Be.type),
						An = O(Be.internalFormat, It, en)
					32879 === xt || 35866 === xt
						? e.texImage3D(xt, 0, An, ne.width, ne.height, ne.depth, 0, It, en, null)
						: e.texImage2D(xt, 0, An, ne.width, ne.height, 0, It, en, null),
						t.bindFramebuffer(36160, oe),
						t.framebufferTexture2D(36160, _t, xt, i.get(Be).__webglTexture, 0),
						t.bindFramebuffer(36160, null)
				}
				function Un(oe, ne, _t) {
					if ((t.bindRenderbuffer(36161, oe), ne.depthBuffer && !ne.stencilBuffer)) {
						let xt = 33189
						if (_t) {
							const Be = ne.depthTexture
							Be && Be.isDepthTexture && (Be.type === Bu ? (xt = 36012) : Be.type === ay && (xt = 33190))
							const It = Ii(ne)
							t.renderbufferStorageMultisample(36161, It, xt, ne.width, ne.height)
						} else t.renderbufferStorage(36161, xt, ne.width, ne.height)
						t.framebufferRenderbuffer(36160, 36096, 36161, oe)
					} else if (ne.depthBuffer && ne.stencilBuffer) {
						if (_t) {
							const xt = Ii(ne)
							t.renderbufferStorageMultisample(36161, xt, 35056, ne.width, ne.height)
						} else t.renderbufferStorage(36161, 34041, ne.width, ne.height)
						t.framebufferRenderbuffer(36160, 33306, 36161, oe)
					} else {
						const xt = ne.texture,
							Be = o.convert(xt.format),
							It = o.convert(xt.type),
							en = O(xt.internalFormat, Be, It)
						if (_t) {
							const An = Ii(ne)
							t.renderbufferStorageMultisample(36161, An, en, ne.width, ne.height)
						} else t.renderbufferStorage(36161, en, ne.width, ne.height)
					}
					t.bindRenderbuffer(36161, null)
				}
				function Ii(oe) {
					return a && oe.isWebGLMultisampleRenderTarget ? Math.min(u, oe.samples) : 0
				}
				let Tt = !1,
					Ut = !1
				;(this.allocateTextureUnit = function ve() {
					const oe = ue
					return (
						oe >= c &&
							console.warn("THREE.WebGLTextures: Trying to use " + oe + " texture units while this GPU supports only " + c),
						(ue += 1),
						oe
					)
				}),
					(this.resetTextureUnits = function Se() {
						ue = 0
					}),
					(this.setTexture2D = W),
					(this.setTexture2DArray = function me(oe, ne) {
						const _t = i.get(oe)
						oe.version > 0 && _t.__version !== oe.version
							? kt(_t, oe, ne)
							: (e.activeTexture(33984 + ne), e.bindTexture(35866, _t.__webglTexture))
					}),
					(this.setTexture3D = function Z(oe, ne) {
						const _t = i.get(oe)
						oe.version > 0 && _t.__version !== oe.version
							? kt(_t, oe, ne)
							: (e.activeTexture(33984 + ne), e.bindTexture(32879, _t.__webglTexture))
					}),
					(this.setTextureCube = Ae),
					(this.setupRenderTarget = function Sn(oe) {
						const ne = oe.texture,
							_t = i.get(oe),
							xt = i.get(ne)
						oe.addEventListener("dispose", le), (xt.__webglTexture = t.createTexture()), s.memory.textures++
						const Be = !0 === oe.isWebGLCubeRenderTarget,
							It = !0 === oe.isWebGLMultisampleRenderTarget,
							en = ne.isDataTexture3D || ne.isDataTexture2DArray,
							An = x(oe) || a
						if (
							(a &&
								ne.format === Xh &&
								(ne.type === Bu || ne.type === cy) &&
								((ne.format = ha),
								console.warn(
									"THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
								)),
							Be)
						) {
							_t.__webglFramebuffer = []
							for (let Bt = 0; Bt < 6; Bt++) _t.__webglFramebuffer[Bt] = t.createFramebuffer()
						} else if (((_t.__webglFramebuffer = t.createFramebuffer()), It))
							if (a) {
								;(_t.__webglMultisampledFramebuffer = t.createFramebuffer()),
									(_t.__webglColorRenderbuffer = t.createRenderbuffer()),
									t.bindRenderbuffer(36161, _t.__webglColorRenderbuffer)
								const Bt = o.convert(ne.format),
									Vn = o.convert(ne.type),
									Gn = O(ne.internalFormat, Bt, Vn),
									In = Ii(oe)
								t.renderbufferStorageMultisample(36161, In, Gn, oe.width, oe.height),
									t.bindFramebuffer(36160, _t.__webglMultisampledFramebuffer),
									t.framebufferRenderbuffer(36160, 36064, 36161, _t.__webglColorRenderbuffer),
									t.bindRenderbuffer(36161, null),
									oe.depthBuffer &&
										((_t.__webglDepthRenderbuffer = t.createRenderbuffer()), Un(_t.__webglDepthRenderbuffer, oe, !0)),
									t.bindFramebuffer(36160, null)
							} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
						if (Be) {
							e.bindTexture(34067, xt.__webglTexture), nt(34067, ne, An)
							for (let Bt = 0; Bt < 6; Bt++) Kt(_t.__webglFramebuffer[Bt], oe, 36064, 34069 + Bt)
							S(ne, An) && M(34067, ne, oe.width, oe.height), e.bindTexture(34067, null)
						} else {
							let Bt = 3553
							en &&
								(a
									? (Bt = ne.isDataTexture3D ? 32879 : 35866)
									: console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),
								e.bindTexture(Bt, xt.__webglTexture),
								nt(Bt, ne, An),
								Kt(_t.__webglFramebuffer, oe, 36064, Bt),
								S(ne, An) && M(3553, ne, oe.width, oe.height),
								e.bindTexture(3553, null)
						}
						oe.depthBuffer &&
							(function nn(oe) {
								const ne = i.get(oe),
									_t = !0 === oe.isWebGLCubeRenderTarget
								if (oe.depthTexture) {
									if (_t) throw new Error("target.depthTexture not supported in Cube render targets")
									!(function dt(oe, ne) {
										if (ne && ne.isWebGLCubeRenderTarget)
											throw new Error("Depth Texture with cube render targets is not supported")
										if ((t.bindFramebuffer(36160, oe), !ne.depthTexture || !ne.depthTexture.isDepthTexture))
											throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture")
										;(!i.get(ne.depthTexture).__webglTexture ||
											ne.depthTexture.image.width !== ne.width ||
											ne.depthTexture.image.height !== ne.height) &&
											((ne.depthTexture.image.width = ne.width),
											(ne.depthTexture.image.height = ne.height),
											(ne.depthTexture.needsUpdate = !0)),
											W(ne.depthTexture, 0)
										const xt = i.get(ne.depthTexture).__webglTexture
										if (ne.depthTexture.format === tp) t.framebufferTexture2D(36160, 36096, 3553, xt, 0)
										else {
											if (ne.depthTexture.format !== Ng) throw new Error("Unknown depthTexture format")
											t.framebufferTexture2D(36160, 33306, 3553, xt, 0)
										}
									})(ne.__webglFramebuffer, oe)
								} else if (_t) {
									ne.__webglDepthbuffer = []
									for (let xt = 0; xt < 6; xt++)
										t.bindFramebuffer(36160, ne.__webglFramebuffer[xt]),
											(ne.__webglDepthbuffer[xt] = t.createRenderbuffer()),
											Un(ne.__webglDepthbuffer[xt], oe, !1)
								} else
									t.bindFramebuffer(36160, ne.__webglFramebuffer),
										(ne.__webglDepthbuffer = t.createRenderbuffer()),
										Un(ne.__webglDepthbuffer, oe, !1)
								t.bindFramebuffer(36160, null)
							})(oe)
					}),
					(this.updateRenderTargetMipmap = function Hn(oe) {
						const ne = oe.texture
						if (S(ne, x(oe) || a)) {
							const xt = oe.isWebGLCubeRenderTarget ? 34067 : 3553,
								Be = i.get(ne).__webglTexture
							e.bindTexture(xt, Be), M(xt, ne, oe.width, oe.height), e.bindTexture(xt, null)
						}
					}),
					(this.updateMultisampleRenderTarget = function kn(oe) {
						if (oe.isWebGLMultisampleRenderTarget)
							if (a) {
								const ne = i.get(oe)
								t.bindFramebuffer(36008, ne.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, ne.__webglFramebuffer)
								const _t = oe.width,
									xt = oe.height
								let Be = 16384
								oe.depthBuffer && (Be |= 256),
									oe.stencilBuffer && (Be |= 1024),
									t.blitFramebuffer(0, 0, _t, xt, 0, 0, _t, xt, Be, 9728),
									t.bindFramebuffer(36160, ne.__webglMultisampledFramebuffer)
							} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
					}),
					(this.safeSetTexture2D = function Fn(oe, ne) {
						oe &&
							oe.isWebGLRenderTarget &&
							(!1 === Tt &&
								(console.warn(
									"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
								),
								(Tt = !0)),
							(oe = oe.texture)),
							W(oe, ne)
					}),
					(this.safeSetTextureCube = function ln(oe, ne) {
						oe &&
							oe.isWebGLCubeRenderTarget &&
							(!1 === Ut &&
								(console.warn(
									"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
								),
								(Ut = !0)),
							(oe = oe.texture)),
							Ae(oe, ne)
					})
			}
			function f7(t, n, e) {
				const i = e.isWebGL2
				return {
					convert: function r(o) {
						let s
						if (o === Pg) return 5121
						if (o === DW) return 32819
						if (o === LW) return 32820
						if (o === RW) return 33635
						if (o === FW) return 5120
						if (o === BW) return 5122
						if (o === sy) return 5123
						if (o === IW) return 5124
						if (o === ay) return 5125
						if (o === Bu) return 5126
						if (o === cy) return i ? 5131 : ((s = n.get("OES_texture_half_float")), null !== s ? s.HALF_FLOAT_OES : null)
						if (o === PW) return 6406
						if (o === Xh) return 6407
						if (o === ha) return 6408
						if (o === OW) return 6409
						if (o === NW) return 6410
						if (o === tp) return 6402
						if (o === Ng) return 34041
						if (o === HW) return 6403
						if (o === VW) return 36244
						if (o === QW) return 33319
						if (o === zW) return 33320
						if (o === GW) return 36248
						if (o === $W) return 36249
						if (o === sR || o === aR || o === cR || o === lR) {
							if (((s = n.get("WEBGL_compressed_texture_s3tc")), null === s)) return null
							if (o === sR) return s.COMPRESSED_RGB_S3TC_DXT1_EXT
							if (o === aR) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT
							if (o === cR) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT
							if (o === lR) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
						}
						if (o === dR || o === uR || o === hR || o === fR) {
							if (((s = n.get("WEBGL_compressed_texture_pvrtc")), null === s)) return null
							if (o === dR) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
							if (o === uR) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
							if (o === hR) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
							if (o === fR) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
						}
						if (o === WW) return (s = n.get("WEBGL_compressed_texture_etc1")), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
						if ((o === mR || o === pR) && ((s = n.get("WEBGL_compressed_texture_etc")), null !== s)) {
							if (o === mR) return s.COMPRESSED_RGB8_ETC2
							if (o === pR) return s.COMPRESSED_RGBA8_ETC2_EAC
						}
						return o === jW ||
							o === KW ||
							o === XW ||
							o === YW ||
							o === qW ||
							o === ZW ||
							o === JW ||
							o === ej ||
							o === tj ||
							o === nj ||
							o === ij ||
							o === rj ||
							o === oj ||
							o === sj ||
							o === cj ||
							o === lj ||
							o === dj ||
							o === uj ||
							o === hj ||
							o === fj ||
							o === mj ||
							o === pj ||
							o === Aj ||
							o === gj ||
							o === bj ||
							o === _j ||
							o === vj ||
							o === yj
							? ((s = n.get("WEBGL_compressed_texture_astc")), null !== s ? o : null)
							: o === aj
							? ((s = n.get("EXT_texture_compression_bptc")), null !== s ? o : null)
							: o === Og
							? i
								? 34042
								: ((s = n.get("WEBGL_depth_texture")), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
							: void 0
					}
				}
			}
			function $M(t = []) {
				Co.call(this), (this.cameras = t)
			}
			$M.prototype = Object.assign(Object.create(Co.prototype), { constructor: $M, isArrayCamera: !0 })
			class ps extends On {
				constructor() {
					super(), (this.type = "Group")
				}
			}
			function Ty() {
				;(this._targetRay = null), (this._grip = null), (this._hand = null)
			}
			function m7(t, n) {
				const e = this
				let i = null,
					r = 1,
					o = null,
					s = "local-floor",
					a = null
				const c = [],
					l = new Map(),
					d = new Co()
				d.layers.enable(1), (d.viewport = new lr())
				const u = new Co()
				u.layers.enable(2), (u.viewport = new lr())
				const h = [d, u],
					f = new $M()
				f.layers.enable(1), f.layers.enable(2)
				let _ = null,
					y = null
				function C(ce) {
					const ue = l.get(ce.inputSource)
					ue && ue.dispatchEvent({ type: ce.type, data: ce.inputSource })
				}
				function x() {
					l.forEach(function (ce, ue) {
						ce.disconnect(ue)
					}),
						l.clear(),
						(_ = null),
						(y = null),
						t.setFramebuffer(null),
						t.setRenderTarget(t.getRenderTarget()),
						ae.stop(),
						(e.isPresenting = !1),
						e.dispatchEvent({ type: "sessionend" })
				}
				function w(ce) {
					const ue = i.inputSources
					for (let Se = 0; Se < c.length; Se++) l.set(ue[Se], c[Se])
					for (let Se = 0; Se < ce.removed.length; Se++) {
						const ve = ce.removed[Se],
							W = l.get(ve)
						W && (W.dispatchEvent({ type: "disconnected", data: ve }), l.delete(ve))
					}
					for (let Se = 0; Se < ce.added.length; Se++) {
						const ve = ce.added[Se],
							W = l.get(ve)
						W && W.dispatchEvent({ type: "connected", data: ve })
					}
				}
				;(this.enabled = !1),
					(this.isPresenting = !1),
					(this.getController = function (ce) {
						let ue = c[ce]
						return void 0 === ue && ((ue = new Ty()), (c[ce] = ue)), ue.getTargetRaySpace()
					}),
					(this.getControllerGrip = function (ce) {
						let ue = c[ce]
						return void 0 === ue && ((ue = new Ty()), (c[ce] = ue)), ue.getGripSpace()
					}),
					(this.getHand = function (ce) {
						let ue = c[ce]
						return void 0 === ue && ((ue = new Ty()), (c[ce] = ue)), ue.getHandSpace()
					}),
					(this.setFramebufferScaleFactor = function (ce) {
						;(r = ce),
							!0 === e.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
					}),
					(this.setReferenceSpaceType = function (ce) {
						;(s = ce),
							!0 === e.isPresenting &&
								console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
					}),
					(this.getReferenceSpace = function () {
						return o
					}),
					(this.getSession = function () {
						return i
					}),
					(this.setSession = (function () {
						var ce = _r(function* (ue) {
							if (((i = ue), null !== i)) {
								i.addEventListener("select", C),
									i.addEventListener("selectstart", C),
									i.addEventListener("selectend", C),
									i.addEventListener("squeeze", C),
									i.addEventListener("squeezestart", C),
									i.addEventListener("squeezeend", C),
									i.addEventListener("end", x),
									i.addEventListener("inputsourceschange", w)
								const Se = n.getContextAttributes()
								!0 !== Se.xrCompatible && (yield n.makeXRCompatible())
								const W = new XRWebGLLayer(i, n, {
									antialias: Se.antialias,
									alpha: Se.alpha,
									depth: Se.depth,
									stencil: Se.stencil,
									framebufferScaleFactor: r
								})
								i.updateRenderState({ baseLayer: W }),
									(o = yield i.requestReferenceSpace(s)),
									ae.setContext(i),
									ae.start(),
									(e.isPresenting = !0),
									e.dispatchEvent({ type: "sessionstart" })
							}
						})
						return function (ue) {
							return ce.apply(this, arguments)
						}
					})())
				const S = new K(),
					M = new K()
				function N(ce, ue) {
					null === ue ? ce.matrixWorld.copy(ce.matrix) : ce.matrixWorld.multiplyMatrices(ue.matrixWorld, ce.matrix),
						ce.matrixWorldInverse.copy(ce.matrixWorld).invert()
				}
				this.getCamera = function (ce) {
					;(f.near = u.near = d.near = ce.near),
						(f.far = u.far = d.far = ce.far),
						(_ !== f.near || y !== f.far) &&
							(i.updateRenderState({ depthNear: f.near, depthFar: f.far }), (_ = f.near), (y = f.far))
					const ue = ce.parent,
						Se = f.cameras
					N(f, ue)
					for (let W = 0; W < Se.length; W++) N(Se[W], ue)
					ce.matrixWorld.copy(f.matrixWorld), ce.matrix.copy(f.matrix), ce.matrix.decompose(ce.position, ce.quaternion, ce.scale)
					const ve = ce.children
					for (let W = 0, me = ve.length; W < me; W++) ve[W].updateMatrixWorld(!0)
					return (
						2 === Se.length
							? (function O(ce, ue, Se) {
									S.setFromMatrixPosition(ue.matrixWorld), M.setFromMatrixPosition(Se.matrixWorld)
									const ve = S.distanceTo(M),
										W = ue.projectionMatrix.elements,
										me = Se.projectionMatrix.elements,
										Z = W[14] / (W[10] - 1),
										Ae = W[14] / (W[10] + 1),
										Ie = (W[9] + 1) / W[5],
										Pe = (W[9] - 1) / W[5],
										nt = (W[8] - 1) / W[0],
										pt = (me[8] + 1) / me[0],
										kt = Z * nt,
										tn = Z * pt,
										Kt = ve / (-nt + pt),
										Un = Kt * -nt
									ue.matrixWorld.decompose(ce.position, ce.quaternion, ce.scale),
										ce.translateX(Un),
										ce.translateZ(Kt),
										ce.matrixWorld.compose(ce.position, ce.quaternion, ce.scale),
										ce.matrixWorldInverse.copy(ce.matrixWorld).invert()
									const dt = Z + Kt,
										nn = Ae + Kt
									ce.projectionMatrix.makePerspective(
										kt - Un,
										tn + (ve - Un),
										((Ie * Ae) / nn) * dt,
										((Pe * Ae) / nn) * dt,
										dt,
										nn
									)
							  })(f, d, u)
							: f.projectionMatrix.copy(d.projectionMatrix),
						f
					)
				}
				let j = null
				const ae = new Gj()
				ae.setAnimationLoop(function le(ce, ue) {
					if (((a = ue.getViewerPose(o)), null !== a)) {
						const ve = a.views,
							W = i.renderState.baseLayer
						t.setFramebuffer(W.framebuffer)
						let me = !1
						ve.length !== f.cameras.length && ((f.cameras.length = 0), (me = !0))
						for (let Z = 0; Z < ve.length; Z++) {
							const Ae = ve[Z],
								Ie = W.getViewport(Ae),
								Pe = h[Z]
							Pe.matrix.fromArray(Ae.transform.matrix),
								Pe.projectionMatrix.fromArray(Ae.projectionMatrix),
								Pe.viewport.set(Ie.x, Ie.y, Ie.width, Ie.height),
								0 === Z && f.matrix.copy(Pe.matrix),
								!0 === me && f.cameras.push(Pe)
						}
					}
					const Se = i.inputSources
					for (let ve = 0; ve < c.length; ve++) c[ve].update(Se[ve], ue, o)
					j && j(ce, ue)
				}),
					(this.setAnimationLoop = function (ce) {
						j = ce
					}),
					(this.dispose = function () {})
			}
			function N1e(t) {
				function i(x, w) {
					;(x.opacity.value = w.opacity),
						w.color && x.diffuse.value.copy(w.color),
						w.emissive && x.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity),
						w.map && (x.map.value = w.map),
						w.alphaMap && (x.alphaMap.value = w.alphaMap),
						w.specularMap && (x.specularMap.value = w.specularMap)
					const S = t.get(w).envMap
					if (S) {
						;(x.envMap.value = S),
							(x.flipEnvMap.value = S.isCubeTexture && S._needsFlipEnvMap ? -1 : 1),
							(x.reflectivity.value = w.reflectivity),
							(x.refractionRatio.value = w.refractionRatio)
						const N = t.get(S).__maxMipLevel
						void 0 !== N && (x.maxMipLevel.value = N)
					}
					let M, O
					w.lightMap && ((x.lightMap.value = w.lightMap), (x.lightMapIntensity.value = w.lightMapIntensity)),
						w.aoMap && ((x.aoMap.value = w.aoMap), (x.aoMapIntensity.value = w.aoMapIntensity)),
						w.map
							? (M = w.map)
							: w.specularMap
							? (M = w.specularMap)
							: w.displacementMap
							? (M = w.displacementMap)
							: w.normalMap
							? (M = w.normalMap)
							: w.bumpMap
							? (M = w.bumpMap)
							: w.roughnessMap
							? (M = w.roughnessMap)
							: w.metalnessMap
							? (M = w.metalnessMap)
							: w.alphaMap
							? (M = w.alphaMap)
							: w.emissiveMap
							? (M = w.emissiveMap)
							: w.clearcoatMap
							? (M = w.clearcoatMap)
							: w.clearcoatNormalMap
							? (M = w.clearcoatNormalMap)
							: w.clearcoatRoughnessMap && (M = w.clearcoatRoughnessMap),
						void 0 !== M &&
							(M.isWebGLRenderTarget && (M = M.texture),
							!0 === M.matrixAutoUpdate && M.updateMatrix(),
							x.uvTransform.value.copy(M.matrix)),
						w.aoMap ? (O = w.aoMap) : w.lightMap && (O = w.lightMap),
						void 0 !== O &&
							(O.isWebGLRenderTarget && (O = O.texture),
							!0 === O.matrixAutoUpdate && O.updateMatrix(),
							x.uv2Transform.value.copy(O.matrix))
				}
				function u(x, w) {
					;(x.roughness.value = w.roughness),
						(x.metalness.value = w.metalness),
						w.roughnessMap && (x.roughnessMap.value = w.roughnessMap),
						w.metalnessMap && (x.metalnessMap.value = w.metalnessMap),
						w.emissiveMap && (x.emissiveMap.value = w.emissiveMap),
						w.bumpMap &&
							((x.bumpMap.value = w.bumpMap), (x.bumpScale.value = w.bumpScale), w.side === Lo && (x.bumpScale.value *= -1)),
						w.normalMap &&
							((x.normalMap.value = w.normalMap),
							x.normalScale.value.copy(w.normalScale),
							w.side === Lo && x.normalScale.value.negate()),
						w.displacementMap &&
							((x.displacementMap.value = w.displacementMap),
							(x.displacementScale.value = w.displacementScale),
							(x.displacementBias.value = w.displacementBias)),
						t.get(w).envMap && (x.envMapIntensity.value = w.envMapIntensity)
				}
				return {
					refreshFogUniforms: function n(x, w) {
						x.fogColor.value.copy(w.color),
							w.isFog
								? ((x.fogNear.value = w.near), (x.fogFar.value = w.far))
								: w.isFogExp2 && (x.fogDensity.value = w.density)
					},
					refreshMaterialUniforms: function e(x, w, S, M) {
						w.isMeshBasicMaterial
							? i(x, w)
							: w.isMeshLambertMaterial
							? (i(x, w),
							  (function c(x, w) {
									w.emissiveMap && (x.emissiveMap.value = w.emissiveMap)
							  })(x, w))
							: w.isMeshToonMaterial
							? (i(x, w),
							  (function d(x, w) {
									w.gradientMap && (x.gradientMap.value = w.gradientMap),
										w.emissiveMap && (x.emissiveMap.value = w.emissiveMap),
										w.bumpMap &&
											((x.bumpMap.value = w.bumpMap),
											(x.bumpScale.value = w.bumpScale),
											w.side === Lo && (x.bumpScale.value *= -1)),
										w.normalMap &&
											((x.normalMap.value = w.normalMap),
											x.normalScale.value.copy(w.normalScale),
											w.side === Lo && x.normalScale.value.negate()),
										w.displacementMap &&
											((x.displacementMap.value = w.displacementMap),
											(x.displacementScale.value = w.displacementScale),
											(x.displacementBias.value = w.displacementBias))
							  })(x, w))
							: w.isMeshPhongMaterial
							? (i(x, w),
							  (function l(x, w) {
									x.specular.value.copy(w.specular),
										(x.shininess.value = Math.max(w.shininess, 1e-4)),
										w.emissiveMap && (x.emissiveMap.value = w.emissiveMap),
										w.bumpMap &&
											((x.bumpMap.value = w.bumpMap),
											(x.bumpScale.value = w.bumpScale),
											w.side === Lo && (x.bumpScale.value *= -1)),
										w.normalMap &&
											((x.normalMap.value = w.normalMap),
											x.normalScale.value.copy(w.normalScale),
											w.side === Lo && x.normalScale.value.negate()),
										w.displacementMap &&
											((x.displacementMap.value = w.displacementMap),
											(x.displacementScale.value = w.displacementScale),
											(x.displacementBias.value = w.displacementBias))
							  })(x, w))
							: w.isMeshStandardMaterial
							? (i(x, w),
							  w.isMeshPhysicalMaterial
									? (function h(x, w) {
											u(x, w),
												(x.reflectivity.value = w.reflectivity),
												(x.clearcoat.value = w.clearcoat),
												(x.clearcoatRoughness.value = w.clearcoatRoughness),
												w.sheen && x.sheen.value.copy(w.sheen),
												w.clearcoatMap && (x.clearcoatMap.value = w.clearcoatMap),
												w.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = w.clearcoatRoughnessMap),
												w.clearcoatNormalMap &&
													(x.clearcoatNormalScale.value.copy(w.clearcoatNormalScale),
													(x.clearcoatNormalMap.value = w.clearcoatNormalMap),
													w.side === Lo && x.clearcoatNormalScale.value.negate()),
												(x.transmission.value = w.transmission),
												w.transmissionMap && (x.transmissionMap.value = w.transmissionMap)
									  })(x, w)
									: u(x, w))
							: w.isMeshMatcapMaterial
							? (i(x, w),
							  (function f(x, w) {
									w.matcap && (x.matcap.value = w.matcap),
										w.bumpMap &&
											((x.bumpMap.value = w.bumpMap),
											(x.bumpScale.value = w.bumpScale),
											w.side === Lo && (x.bumpScale.value *= -1)),
										w.normalMap &&
											((x.normalMap.value = w.normalMap),
											x.normalScale.value.copy(w.normalScale),
											w.side === Lo && x.normalScale.value.negate()),
										w.displacementMap &&
											((x.displacementMap.value = w.displacementMap),
											(x.displacementScale.value = w.displacementScale),
											(x.displacementBias.value = w.displacementBias))
							  })(x, w))
							: w.isMeshDepthMaterial
							? (i(x, w),
							  (function _(x, w) {
									w.displacementMap &&
										((x.displacementMap.value = w.displacementMap),
										(x.displacementScale.value = w.displacementScale),
										(x.displacementBias.value = w.displacementBias))
							  })(x, w))
							: w.isMeshDistanceMaterial
							? (i(x, w),
							  (function y(x, w) {
									w.displacementMap &&
										((x.displacementMap.value = w.displacementMap),
										(x.displacementScale.value = w.displacementScale),
										(x.displacementBias.value = w.displacementBias)),
										x.referencePosition.value.copy(w.referencePosition),
										(x.nearDistance.value = w.nearDistance),
										(x.farDistance.value = w.farDistance)
							  })(x, w))
							: w.isMeshNormalMaterial
							? (i(x, w),
							  (function C(x, w) {
									w.bumpMap &&
										((x.bumpMap.value = w.bumpMap),
										(x.bumpScale.value = w.bumpScale),
										w.side === Lo && (x.bumpScale.value *= -1)),
										w.normalMap &&
											((x.normalMap.value = w.normalMap),
											x.normalScale.value.copy(w.normalScale),
											w.side === Lo && x.normalScale.value.negate()),
										w.displacementMap &&
											((x.displacementMap.value = w.displacementMap),
											(x.displacementScale.value = w.displacementScale),
											(x.displacementBias.value = w.displacementBias))
							  })(x, w))
							: w.isLineBasicMaterial
							? ((function r(x, w) {
									x.diffuse.value.copy(w.color), (x.opacity.value = w.opacity)
							  })(x, w),
							  w.isLineDashedMaterial &&
									(function o(x, w) {
										;(x.dashSize.value = w.dashSize),
											(x.totalSize.value = w.dashSize + w.gapSize),
											(x.scale.value = w.scale)
									})(x, w))
							: w.isPointsMaterial
							? (function s(x, w, S, M) {
									let O
									x.diffuse.value.copy(w.color),
										(x.opacity.value = w.opacity),
										(x.size.value = w.size * S),
										(x.scale.value = 0.5 * M),
										w.map && (x.map.value = w.map),
										w.alphaMap && (x.alphaMap.value = w.alphaMap),
										w.map ? (O = w.map) : w.alphaMap && (O = w.alphaMap),
										void 0 !== O && (!0 === O.matrixAutoUpdate && O.updateMatrix(), x.uvTransform.value.copy(O.matrix))
							  })(x, w, S, M)
							: w.isSpriteMaterial
							? (function a(x, w) {
									let S
									x.diffuse.value.copy(w.color),
										(x.opacity.value = w.opacity),
										(x.rotation.value = w.rotation),
										w.map && (x.map.value = w.map),
										w.alphaMap && (x.alphaMap.value = w.alphaMap),
										w.map ? (S = w.map) : w.alphaMap && (S = w.alphaMap),
										void 0 !== S && (!0 === S.matrixAutoUpdate && S.updateMatrix(), x.uvTransform.value.copy(S.matrix))
							  })(x, w)
							: w.isShadowMaterial
							? (x.color.value.copy(w.color), (x.opacity.value = w.opacity))
							: w.isShaderMaterial && (w.uniformsNeedUpdate = !1)
					}
				}
			}
			function dr(t) {
				const n =
						void 0 !== (t = t || {}).canvas
							? t.canvas
							: (function U1e() {
									const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
									return (t.style.display = "block"), t
							  })(),
					e = void 0 !== t.context ? t.context : null,
					i = void 0 !== t.alpha && t.alpha,
					r = void 0 === t.depth || t.depth,
					o = void 0 === t.stencil || t.stencil,
					s = void 0 !== t.antialias && t.antialias,
					a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
					c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
					l = void 0 !== t.powerPreference ? t.powerPreference : "default",
					d = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat
				let u = null,
					h = null
				const f = [],
					_ = []
				;(this.domElement = n),
					(this.debug = { checkShaderErrors: !0 }),
					(this.autoClear = !0),
					(this.autoClearColor = !0),
					(this.autoClearDepth = !0),
					(this.autoClearStencil = !0),
					(this.sortObjects = !0),
					(this.clippingPlanes = []),
					(this.localClippingEnabled = !1),
					(this.gammaFactor = 2),
					(this.outputEncoding = fa),
					(this.physicallyCorrectLights = !1),
					(this.toneMapping = Jm),
					(this.toneMappingExposure = 1),
					(this.maxMorphTargets = 8),
					(this.maxMorphNormals = 4)
				const y = this
				let C = !1,
					x = null,
					w = 0,
					S = 0,
					M = null,
					O = null,
					N = -1,
					j = null
				const le = new lr(),
					ae = new lr()
				let ce = null,
					ue = n.width,
					Se = n.height,
					ve = 1,
					W = null,
					me = null
				const Z = new lr(0, 0, ue, Se),
					Ae = new lr(0, 0, ue, Se)
				let Ie = !1
				const Pe = new My()
				let nt = !1,
					pt = !1
				const kt = new Cn(),
					tn = new K(),
					Kt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }
				function Un() {
					return null === M ? ve : 1
				}
				let Sn,
					Hn,
					kn,
					Ii,
					Et,
					Tt,
					Ut,
					Fn,
					ln,
					oe,
					ne,
					_t,
					xt,
					Be,
					It,
					en,
					An,
					Bt,
					Vn,
					Gn,
					In,
					dt = e
				function nn(se, ut) {
					for (let tt = 0; tt < se.length; tt++) {
						const $t = n.getContext(se[tt], ut)
						if (null !== $t) return $t
					}
					return null
				}
				try {
					const se = {
						alpha: i,
						depth: r,
						stencil: o,
						antialias: s,
						premultipliedAlpha: a,
						preserveDrawingBuffer: c,
						powerPreference: l,
						failIfMajorPerformanceCaveat: d
					}
					if (
						(n.addEventListener("webglcontextlost", Oa, !1), n.addEventListener("webglcontextrestored", See, !1), null === dt)
					) {
						const ut = ["webgl2", "webgl", "experimental-webgl"]
						if ((!0 === y.isWebGL1Renderer && ut.shift(), (dt = nn(ut, se)), null === dt))
							throw nn(ut)
								? new Error("Error creating WebGL context with your selected attributes.")
								: new Error("Error creating WebGL context.")
					}
					void 0 === dt.getShaderPrecisionFormat &&
						(dt.getShaderPrecisionFormat = function () {
							return { rangeMin: 1, rangeMax: 1, precision: 1 }
						})
				} catch (se) {
					throw (console.error("THREE.WebGLRenderer: " + se.message), se)
				}
				function Rn() {
					;(Sn = new gxe(dt)),
						(Hn = new mxe(dt, Sn, t)),
						Sn.init(Hn),
						(Gn = new f7(dt, Sn, Hn)),
						(kn = new P1e(dt, Sn, Hn)),
						kn.scissor(ae.copy(Ae).multiplyScalar(ve).floor()),
						kn.viewport(le.copy(Z).multiplyScalar(ve).floor()),
						(Ii = new vxe(dt)),
						(Et = new C1e()),
						(Tt = new O1e(dt, Sn, kn, Et, Hn, Gn, Ii)),
						(Ut = new Axe(y)),
						(Fn = new zve(dt, Hn)),
						(In = new hxe(dt, Sn, Fn, Hn)),
						(ln = new bxe(dt, Fn, Ii, In)),
						(oe = new Cxe(dt, ln, Fn, Ii)),
						(An = new xxe(dt)),
						(It = new pxe(Et)),
						(ne = new x1e(y, Ut, Sn, Hn, In, It)),
						(_t = new N1e(Et)),
						(xt = new S1e(Et)),
						(Be = new D1e(Sn, Hn)),
						(en = new uxe(y, Ut, kn, oe, a)),
						(Bt = new fxe(dt, Sn, Ii, Hn)),
						(Vn = new _xe(dt, Sn, Ii, Hn)),
						(Ii.programs = ne.programs),
						(y.capabilities = Hn),
						(y.extensions = Sn),
						(y.properties = Et),
						(y.renderLists = xt),
						(y.state = kn),
						(y.info = Ii)
				}
				Rn()
				const Pn = new m7(y, dt)
				this.xr = Pn
				const fo = new h7(y, oe, Hn.maxTextureSize)
				function Oa(se) {
					se.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), (C = !0)
				}
				function See() {
					console.log("THREE.WebGLRenderer: Context Restored."), (C = !1), Rn()
				}
				function kee(se) {
					const ut = se.target
					ut.removeEventListener("dispose", kee),
						(function i8e(se) {
							Tee(se), Et.remove(se)
						})(ut)
				}
				function Tee(se) {
					const ut = Et.get(se).program
					void 0 !== ut && ne.releaseProgram(ut)
				}
				;(this.shadowMap = fo),
					(this.getContext = function () {
						return dt
					}),
					(this.getContextAttributes = function () {
						return dt.getContextAttributes()
					}),
					(this.forceContextLoss = function () {
						const se = Sn.get("WEBGL_lose_context")
						se && se.loseContext()
					}),
					(this.forceContextRestore = function () {
						const se = Sn.get("WEBGL_lose_context")
						se && se.restoreContext()
					}),
					(this.getPixelRatio = function () {
						return ve
					}),
					(this.setPixelRatio = function (se) {
						void 0 !== se && ((ve = se), this.setSize(ue, Se, !1))
					}),
					(this.getSize = function (se) {
						return (
							void 0 === se &&
								(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), (se = new lt())),
							se.set(ue, Se)
						)
					}),
					(this.setSize = function (se, ut, tt) {
						Pn.isPresenting
							? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.")
							: ((ue = se),
							  (Se = ut),
							  (n.width = Math.floor(se * ve)),
							  (n.height = Math.floor(ut * ve)),
							  !1 !== tt && ((n.style.width = se + "px"), (n.style.height = ut + "px")),
							  this.setViewport(0, 0, se, ut))
					}),
					(this.getDrawingBufferSize = function (se) {
						return (
							void 0 === se &&
								(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
								(se = new lt())),
							se.set(ue * ve, Se * ve).floor()
						)
					}),
					(this.setDrawingBufferSize = function (se, ut, tt) {
						;(ue = se),
							(Se = ut),
							(ve = tt),
							(n.width = Math.floor(se * tt)),
							(n.height = Math.floor(ut * tt)),
							this.setViewport(0, 0, se, ut)
					}),
					(this.getCurrentViewport = function (se) {
						return (
							void 0 === se &&
								(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
								(se = new lr())),
							se.copy(le)
						)
					}),
					(this.getViewport = function (se) {
						return se.copy(Z)
					}),
					(this.setViewport = function (se, ut, tt, At) {
						se.isVector4 ? Z.set(se.x, se.y, se.z, se.w) : Z.set(se, ut, tt, At),
							kn.viewport(le.copy(Z).multiplyScalar(ve).floor())
					}),
					(this.getScissor = function (se) {
						return se.copy(Ae)
					}),
					(this.setScissor = function (se, ut, tt, At) {
						se.isVector4 ? Ae.set(se.x, se.y, se.z, se.w) : Ae.set(se, ut, tt, At),
							kn.scissor(ae.copy(Ae).multiplyScalar(ve).floor())
					}),
					(this.getScissorTest = function () {
						return Ie
					}),
					(this.setScissorTest = function (se) {
						kn.setScissorTest((Ie = se))
					}),
					(this.setOpaqueSort = function (se) {
						W = se
					}),
					(this.setTransparentSort = function (se) {
						me = se
					}),
					(this.getClearColor = function (se) {
						return (
							void 0 === se &&
								(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), (se = new Lt())),
							se.copy(en.getClearColor())
						)
					}),
					(this.setClearColor = function () {
						en.setClearColor.apply(en, arguments)
					}),
					(this.getClearAlpha = function () {
						return en.getClearAlpha()
					}),
					(this.setClearAlpha = function () {
						en.setClearAlpha.apply(en, arguments)
					}),
					(this.clear = function (se, ut, tt) {
						let At = 0
						;(void 0 === se || se) && (At |= 16384),
							(void 0 === ut || ut) && (At |= 256),
							(void 0 === tt || tt) && (At |= 1024),
							dt.clear(At)
					}),
					(this.clearColor = function () {
						this.clear(!0, !1, !1)
					}),
					(this.clearDepth = function () {
						this.clear(!1, !0, !1)
					}),
					(this.clearStencil = function () {
						this.clear(!1, !1, !0)
					}),
					(this.dispose = function () {
						n.removeEventListener("webglcontextlost", Oa, !1),
							n.removeEventListener("webglcontextrestored", See, !1),
							xt.dispose(),
							Be.dispose(),
							Et.dispose(),
							Ut.dispose(),
							oe.dispose(),
							In.dispose(),
							Pn.dispose(),
							jw.stop()
					}),
					(this.renderBufferImmediate = function (se, ut) {
						In.initAttributes()
						const tt = Et.get(se)
						se.hasPositions && !tt.position && (tt.position = dt.createBuffer()),
							se.hasNormals && !tt.normal && (tt.normal = dt.createBuffer()),
							se.hasUvs && !tt.uv && (tt.uv = dt.createBuffer()),
							se.hasColors && !tt.color && (tt.color = dt.createBuffer())
						const At = ut.getAttributes()
						se.hasPositions &&
							(dt.bindBuffer(34962, tt.position),
							dt.bufferData(34962, se.positionArray, 35048),
							In.enableAttribute(At.position),
							dt.vertexAttribPointer(At.position, 3, 5126, !1, 0, 0)),
							se.hasNormals &&
								(dt.bindBuffer(34962, tt.normal),
								dt.bufferData(34962, se.normalArray, 35048),
								In.enableAttribute(At.normal),
								dt.vertexAttribPointer(At.normal, 3, 5126, !1, 0, 0)),
							se.hasUvs &&
								(dt.bindBuffer(34962, tt.uv),
								dt.bufferData(34962, se.uvArray, 35048),
								In.enableAttribute(At.uv),
								dt.vertexAttribPointer(At.uv, 2, 5126, !1, 0, 0)),
							se.hasColors &&
								(dt.bindBuffer(34962, tt.color),
								dt.bufferData(34962, se.colorArray, 35048),
								In.enableAttribute(At.color),
								dt.vertexAttribPointer(At.color, 3, 5126, !1, 0, 0)),
							In.disableUnusedAttributes(),
							dt.drawArrays(4, 0, se.count),
							(se.count = 0)
					}),
					(this.renderBufferDirect = function (se, ut, tt, At, $t, zi) {
						null === ut && (ut = Kt)
						const Zn = $t.isMesh && $t.matrixWorld.determinant() < 0,
							mi = Dee(se, ut, At, $t)
						kn.setMaterial(At, Zn)
						let vi = tt.index
						const So = tt.attributes.position
						if (null === vi) {
							if (void 0 === So || 0 === So.count) return
						} else if (0 === vi.count) return
						let Ur = 1
						!0 === At.wireframe && ((vi = ln.getWireframeAttribute(tt)), (Ur = 2)),
							(At.morphTargets || At.morphNormals) && An.update($t, tt, At, mi),
							In.setup($t, At, mi, tt, vi)
						let ui,
							ur = Bt
						null !== vi && ((ui = Fn.get(vi)), (ur = Vn), ur.setIndex(ui))
						const Il = null !== vi ? vi.count : So.count,
							Hr = tt.drawRange.start * Ur,
							Ju = tt.drawRange.count * Ur,
							As = null !== zi ? zi.start * Ur : 0,
							Z3 = null !== zi ? zi.count * Ur : 1 / 0,
							Na = Math.max(Hr, As),
							Kw = Math.min(Il, Hr + Ju, As + Z3) - 1,
							$b = Math.max(0, Kw - Na + 1)
						if (0 !== $b) {
							if ($t.isMesh)
								!0 === At.wireframe ? (kn.setLineWidth(At.wireframeLinewidth * Un()), ur.setMode(1)) : ur.setMode(4)
							else if ($t.isLine) {
								let Xw = At.linewidth
								void 0 === Xw && (Xw = 1),
									kn.setLineWidth(Xw * Un()),
									ur.setMode($t.isLineSegments ? 1 : $t.isLineLoop ? 2 : 3)
							} else $t.isPoints ? ur.setMode(0) : $t.isSprite && ur.setMode(4)
							if ($t.isInstancedMesh) ur.renderInstances(Na, $b, $t.count)
							else if (tt.isInstancedBufferGeometry) {
								const Xw = Math.min(tt.instanceCount, tt._maxInstanceCount)
								ur.renderInstances(Na, $b, Xw)
							} else ur.render(Na, $b)
						}
					}),
					(this.compile = function (se, ut) {
						;(h = Be.get(se)),
							h.init(),
							se.traverseVisible(function (At) {
								At.isLight && At.layers.test(ut.layers) && (h.pushLight(At), At.castShadow && h.pushShadow(At))
							}),
							h.setupLights()
						const tt = new WeakMap()
						se.traverse(function (At) {
							const $t = At.material
							if ($t)
								if (Array.isArray($t))
									for (let zi = 0; zi < $t.length; zi++) {
										const Zn = $t[zi]
										!1 === tt.has(Zn) && (Zu(Zn, se, At), tt.set(Zn))
									}
								else !1 === tt.has($t) && (Zu($t, se, At), tt.set($t))
						})
					})
				let q3 = null
				const jw = new Gj()
				function Fee(se, ut, tt, At) {
					if (!1 === se.visible) return
					if (se.layers.test(ut.layers))
						if (se.isGroup) tt = se.renderOrder
						else if (se.isLOD) !0 === se.autoUpdate && se.update(ut)
						else if (se.isLight) h.pushLight(se), se.castShadow && h.pushShadow(se)
						else if (se.isSprite) {
							if (!se.frustumCulled || Pe.intersectsSprite(se)) {
								At && tn.setFromMatrixPosition(se.matrixWorld).applyMatrix4(kt)
								const Zn = oe.update(se),
									mi = se.material
								mi.visible && u.push(se, Zn, mi, tt, tn.z, null)
							}
						} else if (se.isImmediateRenderObject)
							At && tn.setFromMatrixPosition(se.matrixWorld).applyMatrix4(kt), u.push(se, null, se.material, tt, tn.z, null)
						else if (
							(se.isMesh || se.isLine || se.isPoints) &&
							(se.isSkinnedMesh &&
								se.skeleton.frame !== Ii.render.frame &&
								(se.skeleton.update(), (se.skeleton.frame = Ii.render.frame)),
							!se.frustumCulled || Pe.intersectsObject(se))
						) {
							At && tn.setFromMatrixPosition(se.matrixWorld).applyMatrix4(kt)
							const Zn = oe.update(se),
								mi = se.material
							if (Array.isArray(mi)) {
								const vi = Zn.groups
								for (let So = 0, Ur = vi.length; So < Ur; So++) {
									const ui = vi[So],
										ur = mi[ui.materialIndex]
									ur && ur.visible && u.push(se, Zn, ur, tt, tn.z, ui)
								}
							} else mi.visible && u.push(se, Zn, mi, tt, tn.z, null)
						}
					const zi = se.children
					for (let Zn = 0, mi = zi.length; Zn < mi; Zn++) Fee(zi[Zn], ut, tt, At)
				}
				function Bee(se, ut, tt) {
					const At = !0 === ut.isScene ? ut.overrideMaterial : null
					for (let $t = 0, zi = se.length; $t < zi; $t++) {
						const Zn = se[$t],
							mi = Zn.object,
							vi = Zn.geometry,
							So = null === At ? Zn.material : At,
							Ur = Zn.group
						if (tt.isArrayCamera) {
							const ui = tt.cameras
							for (let ur = 0, Il = ui.length; ur < Il; ur++) {
								const Hr = ui[ur]
								mi.layers.test(Hr.layers) &&
									(kn.viewport(le.copy(Hr.viewport)), h.setupLightsView(Hr), Iee(mi, ut, Hr, vi, So, Ur))
							}
						} else Iee(mi, ut, tt, vi, So, Ur)
					}
				}
				function Iee(se, ut, tt, At, $t, zi) {
					if (
						(se.onBeforeRender(y, ut, tt, At, $t, zi),
						se.modelViewMatrix.multiplyMatrices(tt.matrixWorldInverse, se.matrixWorld),
						se.normalMatrix.getNormalMatrix(se.modelViewMatrix),
						se.isImmediateRenderObject)
					) {
						const Zn = Dee(tt, ut, $t, se)
						kn.setMaterial($t),
							In.reset(),
							(function r8e(se, ut) {
								se.render(function (tt) {
									y.renderBufferImmediate(tt, ut)
								})
							})(se, Zn)
					} else y.renderBufferDirect(tt, ut, At, $t, se, zi)
					se.onAfterRender(y, ut, tt, At, $t, zi)
				}
				function Zu(se, ut, tt) {
					!0 !== ut.isScene && (ut = Kt)
					const At = Et.get(se),
						$t = h.state.lights,
						Zn = $t.state.version,
						mi = ne.getParameters(se, $t.state, h.state.shadowsArray, ut, tt),
						vi = ne.getProgramCacheKey(mi)
					let So = At.program,
						Ur = !0
					if (
						((At.environment = se.isMeshStandardMaterial ? ut.environment : null),
						(At.fog = ut.fog),
						(At.envMap = Ut.get(se.envMap || At.environment)),
						void 0 === So)
					)
						se.addEventListener("dispose", kee)
					else if (So.cacheKey !== vi) Tee(se)
					else if (At.lightsStateVersion !== Zn) Ur = !1
					else {
						if (void 0 !== mi.shaderID) return
						Ur = !1
					}
					Ur &&
						((mi.uniforms = ne.getUniforms(se)),
						se.onBeforeCompile(mi, y),
						(So = ne.acquireProgram(mi, vi)),
						(At.program = So),
						(At.uniforms = mi.uniforms),
						(At.outputEncoding = mi.outputEncoding))
					const ui = At.uniforms
					;((!se.isShaderMaterial && !se.isRawShaderMaterial) || !0 === se.clipping) &&
						((At.numClippingPlanes = It.numPlanes),
						(At.numIntersection = It.numIntersection),
						(ui.clippingPlanes = It.uniform)),
						(At.needsLights = (function a8e(se) {
							return (
								se.isMeshLambertMaterial ||
								se.isMeshToonMaterial ||
								se.isMeshPhongMaterial ||
								se.isMeshStandardMaterial ||
								se.isShadowMaterial ||
								(se.isShaderMaterial && !0 === se.lights)
							)
						})(se)),
						(At.lightsStateVersion = Zn),
						At.needsLights &&
							((ui.ambientLightColor.value = $t.state.ambient),
							(ui.lightProbe.value = $t.state.probe),
							(ui.directionalLights.value = $t.state.directional),
							(ui.directionalLightShadows.value = $t.state.directionalShadow),
							(ui.spotLights.value = $t.state.spot),
							(ui.spotLightShadows.value = $t.state.spotShadow),
							(ui.rectAreaLights.value = $t.state.rectArea),
							(ui.ltc_1.value = $t.state.rectAreaLTC1),
							(ui.ltc_2.value = $t.state.rectAreaLTC2),
							(ui.pointLights.value = $t.state.point),
							(ui.pointLightShadows.value = $t.state.pointShadow),
							(ui.hemisphereLights.value = $t.state.hemi),
							(ui.directionalShadowMap.value = $t.state.directionalShadowMap),
							(ui.directionalShadowMatrix.value = $t.state.directionalShadowMatrix),
							(ui.spotShadowMap.value = $t.state.spotShadowMap),
							(ui.spotShadowMatrix.value = $t.state.spotShadowMatrix),
							(ui.pointShadowMap.value = $t.state.pointShadowMap),
							(ui.pointShadowMatrix.value = $t.state.pointShadowMatrix))
					const ur = At.program.getUniforms(),
						Il = af.seqWithValue(ur.seq, ui)
					At.uniformsList = Il
				}
				function Dee(se, ut, tt, At) {
					!0 !== ut.isScene && (ut = Kt), Tt.resetTextureUnits()
					const $t = ut.fog,
						zi = tt.isMeshStandardMaterial ? ut.environment : null,
						Zn = null === M ? y.outputEncoding : M.texture.encoding,
						mi = Ut.get(tt.envMap || zi),
						vi = Et.get(tt),
						So = h.state.lights
					!0 !== nt || (!0 !== pt && se === j) || It.setState(tt, se, se === j && tt.id === N),
						tt.version === vi.__version
							? ((tt.fog && vi.fog !== $t) ||
									vi.environment !== zi ||
									(vi.needsLights && vi.lightsStateVersion !== So.state.version) ||
									(void 0 !== vi.numClippingPlanes &&
										(vi.numClippingPlanes !== It.numPlanes || vi.numIntersection !== It.numIntersection)) ||
									vi.outputEncoding !== Zn ||
									vi.envMap !== mi) &&
							  Zu(tt, ut, At)
							: (Zu(tt, ut, At), (vi.__version = tt.version))
					let Ur = !1,
						ui = !1,
						ur = !1
					const Il = vi.program,
						Hr = Il.getUniforms(),
						Ju = vi.uniforms
					if (
						(kn.useProgram(Il.program) && ((Ur = !0), (ui = !0), (ur = !0)),
						tt.id !== N && ((N = tt.id), (ui = !0)),
						Ur || j !== se)
					) {
						if (
							(Hr.setValue(dt, "projectionMatrix", se.projectionMatrix),
							Hn.logarithmicDepthBuffer && Hr.setValue(dt, "logDepthBufFC", 2 / (Math.log(se.far + 1) / Math.LN2)),
							j !== se && ((j = se), (ui = !0), (ur = !0)),
							tt.isShaderMaterial ||
								tt.isMeshPhongMaterial ||
								tt.isMeshToonMaterial ||
								tt.isMeshStandardMaterial ||
								tt.envMap)
						) {
							const As = Hr.map.cameraPosition
							void 0 !== As && As.setValue(dt, tn.setFromMatrixPosition(se.matrixWorld))
						}
						;(tt.isMeshPhongMaterial ||
							tt.isMeshToonMaterial ||
							tt.isMeshLambertMaterial ||
							tt.isMeshBasicMaterial ||
							tt.isMeshStandardMaterial ||
							tt.isShaderMaterial) &&
							Hr.setValue(dt, "isOrthographic", !0 === se.isOrthographicCamera),
							(tt.isMeshPhongMaterial ||
								tt.isMeshToonMaterial ||
								tt.isMeshLambertMaterial ||
								tt.isMeshBasicMaterial ||
								tt.isMeshStandardMaterial ||
								tt.isShaderMaterial ||
								tt.isShadowMaterial ||
								tt.skinning) &&
								Hr.setValue(dt, "viewMatrix", se.matrixWorldInverse)
					}
					if (tt.skinning) {
						Hr.setOptional(dt, At, "bindMatrix"), Hr.setOptional(dt, At, "bindMatrixInverse")
						const As = At.skeleton
						if (As)
							if (Hn.floatVertexTextures) {
								if (null === As.boneTexture) {
									let Na = Math.sqrt(4 * As.bones.length)
									;(Na = jn.ceilPowerOfTwo(Na)), (Na = Math.max(Na, 4))
									const Kw = new Float32Array(Na * Na * 4)
									Kw.set(As.boneMatrices)
									const $b = new Jg(Kw, Na, Na, ha, Bu)
									;(As.boneMatrices = Kw), (As.boneTexture = $b), (As.boneTextureSize = Na)
								}
								Hr.setValue(dt, "boneTexture", As.boneTexture, Tt), Hr.setValue(dt, "boneTextureSize", As.boneTextureSize)
							} else Hr.setOptional(dt, As, "boneMatrices")
					}
					return (
						(ui || vi.receiveShadow !== At.receiveShadow) &&
							((vi.receiveShadow = At.receiveShadow), Hr.setValue(dt, "receiveShadow", At.receiveShadow)),
						ui &&
							(Hr.setValue(dt, "toneMappingExposure", y.toneMappingExposure),
							vi.needsLights &&
								(function s8e(se, ut) {
									;(se.ambientLightColor.needsUpdate = ut),
										(se.lightProbe.needsUpdate = ut),
										(se.directionalLights.needsUpdate = ut),
										(se.directionalLightShadows.needsUpdate = ut),
										(se.pointLights.needsUpdate = ut),
										(se.pointLightShadows.needsUpdate = ut),
										(se.spotLights.needsUpdate = ut),
										(se.spotLightShadows.needsUpdate = ut),
										(se.rectAreaLights.needsUpdate = ut),
										(se.hemisphereLights.needsUpdate = ut)
								})(Ju, ur),
							$t && tt.fog && _t.refreshFogUniforms(Ju, $t),
							_t.refreshMaterialUniforms(Ju, tt, ve, Se),
							af.upload(dt, vi.uniformsList, Ju, Tt)),
						tt.isShaderMaterial &&
							!0 === tt.uniformsNeedUpdate &&
							(af.upload(dt, vi.uniformsList, Ju, Tt), (tt.uniformsNeedUpdate = !1)),
						tt.isSpriteMaterial && Hr.setValue(dt, "center", At.center),
						Hr.setValue(dt, "modelViewMatrix", At.modelViewMatrix),
						Hr.setValue(dt, "normalMatrix", At.normalMatrix),
						Hr.setValue(dt, "modelMatrix", At.matrixWorld),
						Il
					)
				}
				jw.setAnimationLoop(function o8e(se) {
					Pn.isPresenting || (q3 && q3(se))
				}),
					typeof window < "u" && jw.setContext(window),
					(this.setAnimationLoop = function (se) {
						;(q3 = se), Pn.setAnimationLoop(se), null === se ? jw.stop() : jw.start()
					}),
					(this.render = function (se, ut) {
						let tt, At
						if (
							(void 0 !== arguments[2] &&
								(console.warn(
									"THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
								),
								(tt = arguments[2])),
							void 0 !== arguments[3] &&
								(console.warn(
									"THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
								),
								(At = arguments[3])),
							void 0 !== ut && !0 !== ut.isCamera)
						)
							return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
						if (!0 === C) return
						In.resetDefaultState(),
							(N = -1),
							(j = null),
							!0 === se.autoUpdate && se.updateMatrixWorld(),
							null === ut.parent && ut.updateMatrixWorld(),
							!0 === Pn.enabled && !0 === Pn.isPresenting && (ut = Pn.getCamera(ut)),
							!0 === se.isScene && se.onBeforeRender(y, se, ut, tt || M),
							(h = Be.get(se, _.length)),
							h.init(),
							_.push(h),
							kt.multiplyMatrices(ut.projectionMatrix, ut.matrixWorldInverse),
							Pe.setFromProjectionMatrix(kt),
							(pt = this.localClippingEnabled),
							(nt = It.init(this.clippingPlanes, pt, ut)),
							(u = xt.get(se, f.length)),
							u.init(),
							f.push(u),
							Fee(se, ut, 0, y.sortObjects),
							u.finish(),
							!0 === y.sortObjects && u.sort(W, me),
							!0 === nt && It.beginShadows(),
							fo.render(h.state.shadowsArray, se, ut),
							h.setupLights(),
							h.setupLightsView(ut),
							!0 === nt && It.endShadows(),
							!0 === this.info.autoReset && this.info.reset(),
							void 0 !== tt && this.setRenderTarget(tt),
							en.render(u, se, ut, At)
						const zi = u.opaque,
							Zn = u.transparent
						zi.length > 0 && Bee(zi, se, ut),
							Zn.length > 0 && Bee(Zn, se, ut),
							!0 === se.isScene && se.onAfterRender(y, se, ut),
							null !== M && (Tt.updateRenderTargetMipmap(M), Tt.updateMultisampleRenderTarget(M)),
							kn.buffers.depth.setTest(!0),
							kn.buffers.depth.setMask(!0),
							kn.buffers.color.setMask(!0),
							kn.setPolygonOffset(!1),
							_.pop(),
							(h = _.length > 0 ? _[_.length - 1] : null),
							f.pop(),
							(u = f.length > 0 ? f[f.length - 1] : null)
					}),
					(this.setFramebuffer = function (se) {
						x !== se && null === M && dt.bindFramebuffer(36160, se), (x = se)
					}),
					(this.getActiveCubeFace = function () {
						return w
					}),
					(this.getActiveMipmapLevel = function () {
						return S
					}),
					(this.getRenderTarget = function () {
						return M
					}),
					(this.setRenderTarget = function (se, ut = 0, tt = 0) {
						;(M = se), (w = ut), (S = tt), se && void 0 === Et.get(se).__webglFramebuffer && Tt.setupRenderTarget(se)
						let At = x,
							$t = !1,
							zi = !1
						if (se) {
							const Zn = se.texture
							;(Zn.isDataTexture3D || Zn.isDataTexture2DArray) && (zi = !0)
							const mi = Et.get(se).__webglFramebuffer
							se.isWebGLCubeRenderTarget
								? ((At = mi[ut]), ($t = !0))
								: (At = se.isWebGLMultisampleRenderTarget ? Et.get(se).__webglMultisampledFramebuffer : mi),
								le.copy(se.viewport),
								ae.copy(se.scissor),
								(ce = se.scissorTest)
						} else le.copy(Z).multiplyScalar(ve).floor(), ae.copy(Ae).multiplyScalar(ve).floor(), (ce = Ie)
						if (
							(O !== At && (dt.bindFramebuffer(36160, At), (O = At)),
							kn.viewport(le),
							kn.scissor(ae),
							kn.setScissorTest(ce),
							$t)
						) {
							const Zn = Et.get(se.texture)
							dt.framebufferTexture2D(36160, 36064, 34069 + ut, Zn.__webglTexture, tt)
						} else if (zi) {
							const Zn = Et.get(se.texture)
							dt.framebufferTextureLayer(36160, 36064, Zn.__webglTexture, tt || 0, ut || 0)
						}
					}),
					(this.readRenderTargetPixels = function (se, ut, tt, At, $t, zi, Zn) {
						if (!se || !se.isWebGLRenderTarget)
							return void console.error(
								"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
							)
						let mi = Et.get(se).__webglFramebuffer
						if ((se.isWebGLCubeRenderTarget && void 0 !== Zn && (mi = mi[Zn]), mi)) {
							let vi = !1
							mi !== O && (dt.bindFramebuffer(36160, mi), (vi = !0))
							try {
								const So = se.texture,
									Ur = So.format,
									ui = So.type
								if (Ur !== ha && Gn.convert(Ur) !== dt.getParameter(35739))
									return void console.error(
										"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
									)
								const ur =
									ui === cy &&
									(Sn.has("EXT_color_buffer_half_float") || (Hn.isWebGL2 && Sn.has("EXT_color_buffer_float")))
								if (
									!(
										ui === Pg ||
										Gn.convert(ui) === dt.getParameter(35738) ||
										(ui === Bu && (Hn.isWebGL2 || Sn.has("OES_texture_float") || Sn.has("WEBGL_color_buffer_float"))) ||
										ur
									)
								)
									return void console.error(
										"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
									)
								36053 === dt.checkFramebufferStatus(36160)
									? ut >= 0 &&
									  ut <= se.width - At &&
									  tt >= 0 &&
									  tt <= se.height - $t &&
									  dt.readPixels(ut, tt, At, $t, Gn.convert(Ur), Gn.convert(ui), zi)
									: console.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
									  )
							} finally {
								vi && dt.bindFramebuffer(36160, O)
							}
						}
					}),
					(this.copyFramebufferToTexture = function (se, ut, tt = 0) {
						const At = Math.pow(2, -tt),
							$t = Math.floor(ut.image.width * At),
							zi = Math.floor(ut.image.height * At),
							Zn = Gn.convert(ut.format)
						Tt.setTexture2D(ut, 0), dt.copyTexImage2D(3553, tt, Zn, se.x, se.y, $t, zi, 0), kn.unbindTexture()
					}),
					(this.copyTextureToTexture = function (se, ut, tt, At = 0) {
						const $t = ut.image.width,
							zi = ut.image.height,
							Zn = Gn.convert(tt.format),
							mi = Gn.convert(tt.type)
						Tt.setTexture2D(tt, 0),
							dt.pixelStorei(37440, tt.flipY),
							dt.pixelStorei(37441, tt.premultiplyAlpha),
							dt.pixelStorei(3317, tt.unpackAlignment),
							ut.isDataTexture
								? dt.texSubImage2D(3553, At, se.x, se.y, $t, zi, Zn, mi, ut.image.data)
								: ut.isCompressedTexture
								? dt.compressedTexSubImage2D(
										3553,
										At,
										se.x,
										se.y,
										ut.mipmaps[0].width,
										ut.mipmaps[0].height,
										Zn,
										ut.mipmaps[0].data
								  )
								: dt.texSubImage2D(3553, At, se.x, se.y, Zn, mi, ut.image),
							0 === At && tt.generateMipmaps && dt.generateMipmap(3553),
							kn.unbindTexture()
					}),
					(this.copyTextureToTexture3D = function (se, ut, tt, At, $t = 0) {
						if (y.isWebGL1Renderer)
							return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.")
						const { width: zi, height: Zn, data: mi } = tt.image,
							vi = Gn.convert(At.format),
							So = Gn.convert(At.type)
						let Ur
						if (At.isDataTexture3D) Tt.setTexture3D(At, 0), (Ur = 32879)
						else {
							if (!At.isDataTexture2DArray)
								return void console.warn(
									"THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
								)
							Tt.setTexture2DArray(At, 0), (Ur = 35866)
						}
						dt.pixelStorei(37440, At.flipY),
							dt.pixelStorei(37441, At.premultiplyAlpha),
							dt.pixelStorei(3317, At.unpackAlignment)
						const ui = dt.getParameter(3314),
							ur = dt.getParameter(32878),
							Il = dt.getParameter(3316),
							Hr = dt.getParameter(3315),
							Ju = dt.getParameter(32877)
						dt.pixelStorei(3314, zi),
							dt.pixelStorei(32878, Zn),
							dt.pixelStorei(3316, se.min.x),
							dt.pixelStorei(3315, se.min.y),
							dt.pixelStorei(32877, se.min.z),
							dt.texSubImage3D(
								Ur,
								$t,
								ut.x,
								ut.y,
								ut.z,
								se.max.x - se.min.x + 1,
								se.max.y - se.min.y + 1,
								se.max.z - se.min.z + 1,
								vi,
								So,
								mi
							),
							dt.pixelStorei(3314, ui),
							dt.pixelStorei(32878, ur),
							dt.pixelStorei(3316, Il),
							dt.pixelStorei(3315, Hr),
							dt.pixelStorei(32877, Ju),
							0 === $t && At.generateMipmaps && dt.generateMipmap(Ur),
							kn.unbindTexture()
					}),
					(this.initTexture = function (se) {
						Tt.setTexture2D(se, 0), kn.unbindTexture()
					}),
					(this.resetState = function () {
						kn.reset(), In.reset()
					}),
					typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }))
			}
			;(ps.prototype.isGroup = !0),
				Object.assign(Ty.prototype, {
					constructor: Ty,
					getHandSpace: function () {
						return (
							null === this._hand &&
								((this._hand = new ps()),
								(this._hand.matrixAutoUpdate = !1),
								(this._hand.visible = !1),
								(this._hand.joints = {}),
								(this._hand.inputState = { pinching: !1 })),
							this._hand
						)
					},
					getTargetRaySpace: function () {
						return (
							null === this._targetRay &&
								((this._targetRay = new ps()), (this._targetRay.matrixAutoUpdate = !1), (this._targetRay.visible = !1)),
							this._targetRay
						)
					},
					getGripSpace: function () {
						return (
							null === this._grip && ((this._grip = new ps()), (this._grip.matrixAutoUpdate = !1), (this._grip.visible = !1)),
							this._grip
						)
					},
					dispatchEvent: function (t) {
						return (
							null !== this._targetRay && this._targetRay.dispatchEvent(t),
							null !== this._grip && this._grip.dispatchEvent(t),
							null !== this._hand && this._hand.dispatchEvent(t),
							this
						)
					},
					disconnect: function (t) {
						return (
							this.dispatchEvent({ type: "disconnected", data: t }),
							null !== this._targetRay && (this._targetRay.visible = !1),
							null !== this._grip && (this._grip.visible = !1),
							null !== this._hand && (this._hand.visible = !1),
							this
						)
					},
					update: function (t, n, e) {
						let i = null,
							r = null,
							o = null
						const s = this._targetRay,
							a = this._grip,
							c = this._hand
						if (t && "visible-blurred" !== n.session.visibilityState)
							if (c && t.hand) {
								o = !0
								for (const _ of t.hand.values()) {
									const y = n.getJointPose(_, e)
									if (void 0 === c.joints[_.jointName]) {
										const x = new ps()
										;(x.matrixAutoUpdate = !1), (x.visible = !1), (c.joints[_.jointName] = x), c.add(x)
									}
									const C = c.joints[_.jointName]
									null !== y &&
										(C.matrix.fromArray(y.transform.matrix),
										C.matrix.decompose(C.position, C.rotation, C.scale),
										(C.jointRadius = y.radius)),
										(C.visible = null !== y)
								}
								const u = c.joints["index-finger-tip"].position.distanceTo(c.joints["thumb-tip"].position),
									h = 0.02,
									f = 0.005
								c.inputState.pinching && u > h + f
									? ((c.inputState.pinching = !1),
									  this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this }))
									: !c.inputState.pinching &&
									  u <= h - f &&
									  ((c.inputState.pinching = !0),
									  this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }))
							} else
								null !== s &&
									((i = n.getPose(t.targetRaySpace, e)),
									null !== i &&
										(s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale))),
									null !== a &&
										t.gripSpace &&
										((r = n.getPose(t.gripSpace, e)),
										null !== r &&
											(a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)))
						return (
							null !== s && (s.visible = null !== i),
							null !== a && (a.visible = null !== r),
							null !== c && (c.visible = null !== o),
							this
						)
					}
				}),
				Object.assign(m7.prototype, Iu.prototype)
			class p7 extends dr {}
			p7.prototype.isWebGL1Renderer = !0
			class Fy {
				constructor(n, e) {
					;(this.name = ""), (this.color = new Lt(n)), (this.density = void 0 !== e ? e : 25e-5)
				}
				clone() {
					return new Fy(this.color, this.density)
				}
				toJSON() {
					return { type: "FogExp2", color: this.color.getHex(), density: this.density }
				}
			}
			Fy.prototype.isFogExp2 = !0
			class By {
				constructor(n, e, i) {
					;(this.name = ""), (this.color = new Lt(n)), (this.near = void 0 !== e ? e : 1), (this.far = void 0 !== i ? i : 1e3)
				}
				clone() {
					return new By(this.color, this.near, this.far)
				}
				toJSON() {
					return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far }
				}
			}
			By.prototype.isFog = !0
			class nb extends On {
				constructor() {
					super(),
						(this.type = "Scene"),
						(this.background = null),
						(this.environment = null),
						(this.fog = null),
						(this.overrideMaterial = null),
						(this.autoUpdate = !0),
						typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }))
				}
				copy(n, e) {
					return (
						super.copy(n, e),
						null !== n.background && (this.background = n.background.clone()),
						null !== n.environment && (this.environment = n.environment.clone()),
						null !== n.fog && (this.fog = n.fog.clone()),
						null !== n.overrideMaterial && (this.overrideMaterial = n.overrideMaterial.clone()),
						(this.autoUpdate = n.autoUpdate),
						(this.matrixAutoUpdate = n.matrixAutoUpdate),
						this
					)
				}
				toJSON(n) {
					const e = super.toJSON(n)
					return (
						null !== this.background && (e.object.background = this.background.toJSON(n)),
						null !== this.environment && (e.object.environment = this.environment.toJSON(n)),
						null !== this.fog && (e.object.fog = this.fog.toJSON()),
						e
					)
				}
			}
			function Ra(t, n) {
				;(this.array = t),
					(this.stride = n),
					(this.count = void 0 !== t ? t.length / n : 0),
					(this.usage = fy),
					(this.updateRange = { offset: 0, count: -1 }),
					(this.version = 0),
					(this.uuid = jn.generateUUID())
			}
			;(nb.prototype.isScene = !0),
				Object.defineProperty(Ra.prototype, "needsUpdate", {
					set: function (t) {
						!0 === t && this.version++
					}
				}),
				Object.assign(Ra.prototype, {
					isInterleavedBuffer: !0,
					onUploadCallback: function () {},
					setUsage: function (t) {
						return (this.usage = t), this
					},
					copy: function (t) {
						return (
							(this.array = new t.array.constructor(t.array)),
							(this.count = t.count),
							(this.stride = t.stride),
							(this.usage = t.usage),
							this
						)
					},
					copyAt: function (t, n, e) {
						;(t *= this.stride), (e *= n.stride)
						for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = n.array[e + i]
						return this
					},
					set: function (t, n = 0) {
						return this.array.set(t, n), this
					},
					clone: function (t) {
						void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
							void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = jn.generateUUID()),
							void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
								(t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
						const e = new Ra(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride)
						return e.setUsage(this.usage), e
					},
					onUpload: function (t) {
						return (this.onUploadCallback = t), this
					},
					toJSON: function (t) {
						return (
							void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
							void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = jn.generateUUID()),
							void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
								(t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
							{ uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride }
						)
					}
				})
			const hp = new K()
			function cf(t, n, e, i) {
				;(this.name = ""), (this.data = t), (this.itemSize = n), (this.offset = e), (this.normalized = !0 === i)
			}
			Object.defineProperties(cf.prototype, {
				count: {
					get: function () {
						return this.data.count
					}
				},
				array: {
					get: function () {
						return this.data.array
					}
				},
				needsUpdate: {
					set: function (t) {
						this.data.needsUpdate = t
					}
				}
			}),
				Object.assign(cf.prototype, {
					isInterleavedBufferAttribute: !0,
					applyMatrix4: function (t) {
						for (let n = 0, e = this.data.count; n < e; n++)
							(hp.x = this.getX(n)),
								(hp.y = this.getY(n)),
								(hp.z = this.getZ(n)),
								hp.applyMatrix4(t),
								this.setXYZ(n, hp.x, hp.y, hp.z)
						return this
					},
					setX: function (t, n) {
						return (this.data.array[t * this.data.stride + this.offset] = n), this
					},
					setY: function (t, n) {
						return (this.data.array[t * this.data.stride + this.offset + 1] = n), this
					},
					setZ: function (t, n) {
						return (this.data.array[t * this.data.stride + this.offset + 2] = n), this
					},
					setW: function (t, n) {
						return (this.data.array[t * this.data.stride + this.offset + 3] = n), this
					},
					getX: function (t) {
						return this.data.array[t * this.data.stride + this.offset]
					},
					getY: function (t) {
						return this.data.array[t * this.data.stride + this.offset + 1]
					},
					getZ: function (t) {
						return this.data.array[t * this.data.stride + this.offset + 2]
					},
					getW: function (t) {
						return this.data.array[t * this.data.stride + this.offset + 3]
					},
					setXY: function (t, n, e) {
						return (this.data.array[(t = t * this.data.stride + this.offset) + 0] = n), (this.data.array[t + 1] = e), this
					},
					setXYZ: function (t, n, e, i) {
						return (
							(this.data.array[(t = t * this.data.stride + this.offset) + 0] = n),
							(this.data.array[t + 1] = e),
							(this.data.array[t + 2] = i),
							this
						)
					},
					setXYZW: function (t, n, e, i, r) {
						return (
							(this.data.array[(t = t * this.data.stride + this.offset) + 0] = n),
							(this.data.array[t + 1] = e),
							(this.data.array[t + 2] = i),
							(this.data.array[t + 3] = r),
							this
						)
					},
					clone: function (t) {
						if (void 0 === t) {
							console.log(
								"THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
							)
							const n = []
							for (let e = 0; e < this.count; e++) {
								const i = e * this.data.stride + this.offset
								for (let r = 0; r < this.itemSize; r++) n.push(this.data.array[i + r])
							}
							return new xn(new this.array.constructor(n), this.itemSize, this.normalized)
						}
						return (
							void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
							void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
							new cf(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
						)
					},
					toJSON: function (t) {
						if (void 0 === t) {
							console.log(
								"THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
							)
							const n = []
							for (let e = 0; e < this.count; e++) {
								const i = e * this.data.stride + this.offset
								for (let r = 0; r < this.itemSize; r++) n.push(this.data.array[i + r])
							}
							return { itemSize: this.itemSize, type: this.array.constructor.name, array: n, normalized: this.normalized }
						}
						return (
							void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
							void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
							{
								isInterleavedBufferAttribute: !0,
								itemSize: this.itemSize,
								data: this.data.uuid,
								offset: this.offset,
								normalized: this.normalized
							}
						)
					}
				})
			class Iy extends jr {
				constructor(n) {
					super(),
						(this.type = "SpriteMaterial"),
						(this.color = new Lt(16777215)),
						(this.map = null),
						(this.alphaMap = null),
						(this.rotation = 0),
						(this.sizeAttenuation = !0),
						(this.transparent = !0),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						this.color.copy(n.color),
						(this.map = n.map),
						(this.alphaMap = n.alphaMap),
						(this.rotation = n.rotation),
						(this.sizeAttenuation = n.sizeAttenuation),
						this
					)
				}
			}
			let ib
			Iy.prototype.isSpriteMaterial = !0
			const Dy = new K(),
				rb = new K(),
				ob = new K(),
				sb = new lt(),
				Ly = new lt(),
				A7 = new Cn(),
				WM = new K(),
				Ry = new K(),
				jM = new K(),
				g7 = new lt(),
				jR = new lt(),
				b7 = new lt()
			class ab extends On {
				constructor(n) {
					if ((super(), (this.type = "Sprite"), void 0 === ib)) {
						ib = new vn()
						const i = new Ra(
							new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]),
							5
						)
						ib.setIndex([0, 1, 2, 0, 2, 3]),
							ib.setAttribute("position", new cf(i, 3, 0, !1)),
							ib.setAttribute("uv", new cf(i, 2, 3, !1))
					}
					;(this.geometry = ib), (this.material = void 0 !== n ? n : new Iy()), (this.center = new lt(0.5, 0.5))
				}
				raycast(n, e) {
					null === n.camera &&
						console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
						rb.setFromMatrixScale(this.matrixWorld),
						A7.copy(n.camera.matrixWorld),
						this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse, this.matrixWorld),
						ob.setFromMatrixPosition(this.modelViewMatrix),
						n.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && rb.multiplyScalar(-ob.z)
					const i = this.material.rotation
					let r, o
					0 !== i && ((o = Math.cos(i)), (r = Math.sin(i)))
					const s = this.center
					KM(WM.set(-0.5, -0.5, 0), ob, s, rb, r, o),
						KM(Ry.set(0.5, -0.5, 0), ob, s, rb, r, o),
						KM(jM.set(0.5, 0.5, 0), ob, s, rb, r, o),
						g7.set(0, 0),
						jR.set(1, 0),
						b7.set(1, 1)
					let a = n.ray.intersectTriangle(WM, Ry, jM, !1, Dy)
					if (
						null === a &&
						(KM(Ry.set(-0.5, 0.5, 0), ob, s, rb, r, o),
						jR.set(0, 1),
						(a = n.ray.intersectTriangle(WM, jM, Ry, !1, Dy)),
						null === a)
					)
						return
					const c = n.ray.origin.distanceTo(Dy)
					c < n.near ||
						c > n.far ||
						e.push({
							distance: c,
							point: Dy.clone(),
							uv: Ro.getUV(Dy, WM, Ry, jM, g7, jR, b7, new lt()),
							face: null,
							object: this
						})
				}
				copy(n) {
					return super.copy(n), void 0 !== n.center && this.center.copy(n.center), (this.material = n.material), this
				}
			}
			function KM(t, n, e, i, r, o) {
				sb.subVectors(t, e).addScalar(0.5).multiply(i),
					void 0 !== r ? ((Ly.x = o * sb.x - r * sb.y), (Ly.y = r * sb.x + o * sb.y)) : Ly.copy(sb),
					t.copy(n),
					(t.x += Ly.x),
					(t.y += Ly.y),
					t.applyMatrix4(A7)
			}
			ab.prototype.isSprite = !0
			const XM = new K(),
				_7 = new K()
			class KR extends On {
				constructor() {
					super(),
						(this._currentLevel = 0),
						(this.type = "LOD"),
						Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }),
						(this.autoUpdate = !0)
				}
				copy(n) {
					super.copy(n, !1)
					const e = n.levels
					for (let i = 0, r = e.length; i < r; i++) {
						const o = e[i]
						this.addLevel(o.object.clone(), o.distance)
					}
					return (this.autoUpdate = n.autoUpdate), this
				}
				addLevel(n, e = 0) {
					e = Math.abs(e)
					const i = this.levels
					let r
					for (r = 0; r < i.length && !(e < i[r].distance); r++);
					return i.splice(r, 0, { distance: e, object: n }), this.add(n), this
				}
				getCurrentLevel() {
					return this._currentLevel
				}
				getObjectForDistance(n) {
					const e = this.levels
					if (e.length > 0) {
						let i, r
						for (i = 1, r = e.length; i < r && !(n < e[i].distance); i++);
						return e[i - 1].object
					}
					return null
				}
				raycast(n, e) {
					if (this.levels.length > 0) {
						XM.setFromMatrixPosition(this.matrixWorld)
						const r = n.ray.origin.distanceTo(XM)
						this.getObjectForDistance(r).raycast(n, e)
					}
				}
				update(n) {
					const e = this.levels
					if (e.length > 1) {
						XM.setFromMatrixPosition(n.matrixWorld), _7.setFromMatrixPosition(this.matrixWorld)
						const i = XM.distanceTo(_7) / n.zoom
						let r, o
						for (e[0].object.visible = !0, r = 1, o = e.length; r < o && i >= e[r].distance; r++)
							(e[r - 1].object.visible = !1), (e[r].object.visible = !0)
						for (this._currentLevel = r - 1; r < o; r++) e[r].object.visible = !1
					}
				}
				toJSON(n) {
					const e = super.toJSON(n)
					!1 === this.autoUpdate && (e.object.autoUpdate = !1), (e.object.levels = [])
					const i = this.levels
					for (let r = 0, o = i.length; r < o; r++) {
						const s = i[r]
						e.object.levels.push({ object: s.object.uuid, distance: s.distance })
					}
					return e
				}
			}
			const v7 = new K(),
				y7 = new lr(),
				w7 = new lr(),
				H1e = new K(),
				x7 = new Cn()
			function Py(t, n) {
				Mi.call(this, t, n),
					(this.type = "SkinnedMesh"),
					(this.bindMode = "attached"),
					(this.bindMatrix = new Cn()),
					(this.bindMatrixInverse = new Cn())
			}
			function Oy() {
				On.call(this), (this.type = "Bone")
			}
			;(Py.prototype = Object.assign(Object.create(Mi.prototype), {
				constructor: Py,
				isSkinnedMesh: !0,
				copy: function (t) {
					return (
						Mi.prototype.copy.call(this, t),
						(this.bindMode = t.bindMode),
						this.bindMatrix.copy(t.bindMatrix),
						this.bindMatrixInverse.copy(t.bindMatrixInverse),
						(this.skeleton = t.skeleton),
						this
					)
				},
				bind: function (t, n) {
					;(this.skeleton = t),
						void 0 === n && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (n = this.matrixWorld)),
						this.bindMatrix.copy(n),
						this.bindMatrixInverse.copy(n).invert()
				},
				pose: function () {
					this.skeleton.pose()
				},
				normalizeSkinWeights: function () {
					const t = new lr(),
						n = this.geometry.attributes.skinWeight
					for (let e = 0, i = n.count; e < i; e++) {
						;(t.x = n.getX(e)), (t.y = n.getY(e)), (t.z = n.getZ(e)), (t.w = n.getW(e))
						const r = 1 / t.manhattanLength()
						r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), n.setXYZW(e, t.x, t.y, t.z, t.w)
					}
				},
				updateMatrixWorld: function (t) {
					Mi.prototype.updateMatrixWorld.call(this, t),
						"attached" === this.bindMode
							? this.bindMatrixInverse.copy(this.matrixWorld).invert()
							: "detached" === this.bindMode
							? this.bindMatrixInverse.copy(this.bindMatrix).invert()
							: console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
				},
				boneTransform: function (t, n) {
					const e = this.skeleton,
						i = this.geometry
					y7.fromBufferAttribute(i.attributes.skinIndex, t),
						w7.fromBufferAttribute(i.attributes.skinWeight, t),
						v7.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix),
						n.set(0, 0, 0)
					for (let r = 0; r < 4; r++) {
						const o = w7.getComponent(r)
						if (0 !== o) {
							const s = y7.getComponent(r)
							x7.multiplyMatrices(e.bones[s].matrixWorld, e.boneInverses[s]),
								n.addScaledVector(H1e.copy(v7).applyMatrix4(x7), o)
						}
					}
					return n.applyMatrix4(this.bindMatrixInverse)
				}
			})),
				(Oy.prototype = Object.assign(Object.create(On.prototype), { constructor: Oy, isBone: !0 }))
			const C7 = new Cn(),
				V1e = new Cn()
			class Ny {
				constructor(n = [], e = []) {
					;(this.uuid = jn.generateUUID()),
						(this.bones = n.slice(0)),
						(this.boneInverses = e),
						(this.boneMatrices = null),
						(this.boneTexture = null),
						(this.boneTextureSize = 0),
						(this.frame = -1),
						this.init()
				}
				init() {
					const n = this.bones,
						e = this.boneInverses
					if (((this.boneMatrices = new Float32Array(16 * n.length)), 0 === e.length)) this.calculateInverses()
					else if (n.length !== e.length) {
						console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
							(this.boneInverses = [])
						for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new Cn())
					}
				}
				calculateInverses() {
					this.boneInverses.length = 0
					for (let n = 0, e = this.bones.length; n < e; n++) {
						const i = new Cn()
						this.bones[n] && i.copy(this.bones[n].matrixWorld).invert(), this.boneInverses.push(i)
					}
				}
				pose() {
					for (let n = 0, e = this.bones.length; n < e; n++) {
						const i = this.bones[n]
						i && i.matrixWorld.copy(this.boneInverses[n]).invert()
					}
					for (let n = 0, e = this.bones.length; n < e; n++) {
						const i = this.bones[n]
						i &&
							(i.parent && i.parent.isBone
								? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld))
								: i.matrix.copy(i.matrixWorld),
							i.matrix.decompose(i.position, i.quaternion, i.scale))
					}
				}
				update() {
					const n = this.bones,
						e = this.boneInverses,
						i = this.boneMatrices,
						r = this.boneTexture
					for (let o = 0, s = n.length; o < s; o++)
						C7.multiplyMatrices(n[o] ? n[o].matrixWorld : V1e, e[o]), C7.toArray(i, 16 * o)
					null !== r && (r.needsUpdate = !0)
				}
				clone() {
					return new Ny(this.bones, this.boneInverses)
				}
				getBoneByName(n) {
					for (let e = 0, i = this.bones.length; e < i; e++) {
						const r = this.bones[e]
						if (r.name === n) return r
					}
				}
				dispose() {
					null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null))
				}
				fromJSON(n, e) {
					this.uuid = n.uuid
					for (let i = 0, r = n.bones.length; i < r; i++) {
						const o = n.bones[i]
						let s = e[o]
						void 0 === s && (console.warn("THREE.Skeleton: No bone found with UUID:", o), (s = new Oy())),
							this.bones.push(s),
							this.boneInverses.push(new Cn().fromArray(n.boneInverses[i]))
					}
					return this.init(), this
				}
				toJSON() {
					const n = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }
					n.uuid = this.uuid
					const e = this.bones,
						i = this.boneInverses
					for (let r = 0, o = e.length; r < o; r++) n.bones.push(e[r].uuid), n.boneInverses.push(i[r].toArray())
					return n
				}
			}
			const E7 = new Cn(),
				M7 = new Cn(),
				YM = [],
				Uy = new Mi()
			function qM(t, n, e) {
				Mi.call(this, t, n),
					(this.instanceMatrix = new xn(new Float32Array(16 * e), 16)),
					(this.instanceColor = null),
					(this.count = e),
					(this.frustumCulled = !1)
			}
			qM.prototype = Object.assign(Object.create(Mi.prototype), {
				constructor: qM,
				isInstancedMesh: !0,
				copy: function (t) {
					return (
						Mi.prototype.copy.call(this, t),
						this.instanceMatrix.copy(t.instanceMatrix),
						null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
						(this.count = t.count),
						this
					)
				},
				getColorAt: function (t, n) {
					n.fromArray(this.instanceColor.array, 3 * t)
				},
				getMatrixAt: function (t, n) {
					n.fromArray(this.instanceMatrix.array, 16 * t)
				},
				raycast: function (t, n) {
					const e = this.matrixWorld,
						i = this.count
					if (((Uy.geometry = this.geometry), (Uy.material = this.material), void 0 !== Uy.material))
						for (let r = 0; r < i; r++) {
							this.getMatrixAt(r, E7), M7.multiplyMatrices(e, E7), (Uy.matrixWorld = M7), Uy.raycast(t, YM)
							for (let o = 0, s = YM.length; o < s; o++) {
								const a = YM[o]
								;(a.instanceId = r), (a.object = this), n.push(a)
							}
							YM.length = 0
						}
				},
				setColorAt: function (t, n) {
					null === this.instanceColor && (this.instanceColor = new xn(new Float32Array(3 * this.count), 3)),
						n.toArray(this.instanceColor.array, 3 * t)
				},
				setMatrixAt: function (t, n) {
					n.toArray(this.instanceMatrix.array, 16 * t)
				},
				updateMorphTargets: function () {},
				dispose: function () {
					this.dispatchEvent({ type: "dispose" })
				}
			})
			class Go extends jr {
				constructor(n) {
					super(),
						(this.type = "LineBasicMaterial"),
						(this.color = new Lt(16777215)),
						(this.linewidth = 1),
						(this.linecap = "round"),
						(this.linejoin = "round"),
						(this.morphTargets = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						this.color.copy(n.color),
						(this.linewidth = n.linewidth),
						(this.linecap = n.linecap),
						(this.linejoin = n.linejoin),
						(this.morphTargets = n.morphTargets),
						this
					)
				}
			}
			Go.prototype.isLineBasicMaterial = !0
			const S7 = new K(),
				k7 = new K(),
				T7 = new Cn(),
				XR = new Ru(),
				ZM = new xd()
			function ma(t = new vn(), n = new Go()) {
				On.call(this), (this.type = "Line"), (this.geometry = t), (this.material = n), this.updateMorphTargets()
			}
			ma.prototype = Object.assign(Object.create(On.prototype), {
				constructor: ma,
				isLine: !0,
				copy: function (t) {
					return On.prototype.copy.call(this, t), (this.material = t.material), (this.geometry = t.geometry), this
				},
				computeLineDistances: function () {
					const t = this.geometry
					if (t.isBufferGeometry)
						if (null === t.index) {
							const n = t.attributes.position,
								e = [0]
							for (let i = 1, r = n.count; i < r; i++)
								S7.fromBufferAttribute(n, i - 1),
									k7.fromBufferAttribute(n, i),
									(e[i] = e[i - 1]),
									(e[i] += S7.distanceTo(k7))
							t.setAttribute("lineDistance", new cn(e, 1))
						} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")
					else
						t.isGeometry &&
							console.error(
								"THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
							)
					return this
				},
				raycast: function (t, n) {
					const e = this.geometry,
						i = this.matrixWorld,
						r = t.params.Line.threshold
					if (
						(null === e.boundingSphere && e.computeBoundingSphere(),
						ZM.copy(e.boundingSphere),
						ZM.applyMatrix4(i),
						(ZM.radius += r),
						!1 === t.ray.intersectsSphere(ZM))
					)
						return
					T7.copy(i).invert(), XR.copy(t.ray).applyMatrix4(T7)
					const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
						s = o * o,
						a = new K(),
						c = new K(),
						l = new K(),
						d = new K(),
						u = this.isLineSegments ? 2 : 1
					if (e.isBufferGeometry) {
						const h = e.index,
							_ = e.attributes.position
						if (null !== h) {
							const y = h.array
							for (let C = 0, x = y.length - 1; C < x; C += u) {
								const S = y[C + 1]
								if ((a.fromBufferAttribute(_, y[C]), c.fromBufferAttribute(_, S), XR.distanceSqToSegment(a, c, d, l) > s))
									continue
								d.applyMatrix4(this.matrixWorld)
								const O = t.ray.origin.distanceTo(d)
								O < t.near ||
									O > t.far ||
									n.push({
										distance: O,
										point: l.clone().applyMatrix4(this.matrixWorld),
										index: C,
										face: null,
										faceIndex: null,
										object: this
									})
							}
						} else
							for (let y = 0, C = _.count - 1; y < C; y += u) {
								if ((a.fromBufferAttribute(_, y), c.fromBufferAttribute(_, y + 1), XR.distanceSqToSegment(a, c, d, l) > s))
									continue
								d.applyMatrix4(this.matrixWorld)
								const w = t.ray.origin.distanceTo(d)
								w < t.near ||
									w > t.far ||
									n.push({
										distance: w,
										point: l.clone().applyMatrix4(this.matrixWorld),
										index: y,
										face: null,
										faceIndex: null,
										object: this
									})
							}
					} else
						e.isGeometry &&
							console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				},
				updateMorphTargets: function () {
					const t = this.geometry
					if (t.isBufferGeometry) {
						const n = t.morphAttributes,
							e = Object.keys(n)
						if (e.length > 0) {
							const i = n[e[0]]
							if (void 0 !== i) {
								;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
								for (let r = 0, o = i.length; r < o; r++) {
									const s = i[r].name || String(r)
									this.morphTargetInfluences.push(0), (this.morphTargetDictionary[s] = r)
								}
							}
						}
					} else {
						const n = t.morphTargets
						void 0 !== n &&
							n.length > 0 &&
							console.error(
								"THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
							)
					}
				}
			})
			const F7 = new K(),
				B7 = new K()
			function pa(t, n) {
				ma.call(this, t, n), (this.type = "LineSegments")
			}
			pa.prototype = Object.assign(Object.create(ma.prototype), {
				constructor: pa,
				isLineSegments: !0,
				computeLineDistances: function () {
					const t = this.geometry
					if (t.isBufferGeometry)
						if (null === t.index) {
							const n = t.attributes.position,
								e = []
							for (let i = 0, r = n.count; i < r; i += 2)
								F7.fromBufferAttribute(n, i),
									B7.fromBufferAttribute(n, i + 1),
									(e[i] = 0 === i ? 0 : e[i - 1]),
									(e[i + 1] = e[i] + F7.distanceTo(B7))
							t.setAttribute("lineDistance", new cn(e, 1))
						} else
							console.warn(
								"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
							)
					else
						t.isGeometry &&
							console.error(
								"THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
							)
					return this
				}
			})
			class YR extends ma {
				constructor(n, e) {
					super(n, e), (this.type = "LineLoop")
				}
			}
			YR.prototype.isLineLoop = !0
			class fp extends jr {
				constructor(n) {
					super(),
						(this.type = "PointsMaterial"),
						(this.color = new Lt(16777215)),
						(this.map = null),
						(this.alphaMap = null),
						(this.size = 1),
						(this.sizeAttenuation = !0),
						(this.morphTargets = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						this.color.copy(n.color),
						(this.map = n.map),
						(this.alphaMap = n.alphaMap),
						(this.size = n.size),
						(this.sizeAttenuation = n.sizeAttenuation),
						(this.morphTargets = n.morphTargets),
						this
					)
				}
			}
			fp.prototype.isPointsMaterial = !0
			const I7 = new Cn(),
				qR = new Ru(),
				JM = new xd(),
				eS = new K()
			function cb(t = new vn(), n = new fp()) {
				On.call(this), (this.type = "Points"), (this.geometry = t), (this.material = n), this.updateMorphTargets()
			}
			function D7(t, n, e, i, r, o, s) {
				const a = qR.distanceSqToPoint(t)
				if (a < e) {
					const c = new K()
					qR.closestPointToPoint(t, c), c.applyMatrix4(i)
					const l = r.ray.origin.distanceTo(c)
					if (l < r.near || l > r.far) return
					o.push({ distance: l, distanceToRay: Math.sqrt(a), point: c, index: n, face: null, object: s })
				}
			}
			cb.prototype = Object.assign(Object.create(On.prototype), {
				constructor: cb,
				isPoints: !0,
				copy: function (t) {
					return On.prototype.copy.call(this, t), (this.material = t.material), (this.geometry = t.geometry), this
				},
				raycast: function (t, n) {
					const e = this.geometry,
						i = this.matrixWorld,
						r = t.params.Points.threshold
					if (
						(null === e.boundingSphere && e.computeBoundingSphere(),
						JM.copy(e.boundingSphere),
						JM.applyMatrix4(i),
						(JM.radius += r),
						!1 === t.ray.intersectsSphere(JM))
					)
						return
					I7.copy(i).invert(), qR.copy(t.ray).applyMatrix4(I7)
					const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
						s = o * o
					if (e.isBufferGeometry) {
						const a = e.index,
							l = e.attributes.position
						if (null !== a) {
							const d = a.array
							for (let u = 0, h = d.length; u < h; u++) {
								const f = d[u]
								eS.fromBufferAttribute(l, f), D7(eS, f, s, i, t, n, this)
							}
						} else for (let d = 0, u = l.count; d < u; d++) eS.fromBufferAttribute(l, d), D7(eS, d, s, i, t, n, this)
					} else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				},
				updateMorphTargets: function () {
					const t = this.geometry
					if (t.isBufferGeometry) {
						const n = t.morphAttributes,
							e = Object.keys(n)
						if (e.length > 0) {
							const i = n[e[0]]
							if (void 0 !== i) {
								;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
								for (let r = 0, o = i.length; r < o; r++) {
									const s = i[r].name || String(r)
									this.morphTargetInfluences.push(0), (this.morphTargetDictionary[s] = r)
								}
							}
						}
					} else {
						const n = t.morphTargets
						void 0 !== n &&
							n.length > 0 &&
							console.error(
								"THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
							)
					}
				}
			})
			class L7 extends zo {
				constructor(n, e, i, r, o, s, a, c, l) {
					super(n, e, i, r, o, s, a, c, l),
						(this.format = void 0 !== a ? a : Xh),
						(this.minFilter = void 0 !== s ? s : xo),
						(this.magFilter = void 0 !== o ? o : xo),
						(this.generateMipmaps = !1)
					const d = this
					"requestVideoFrameCallback" in n &&
						n.requestVideoFrameCallback(function u() {
							;(d.needsUpdate = !0), n.requestVideoFrameCallback(u)
						})
				}
				clone() {
					return new this.constructor(this.image).copy(this)
				}
				update() {
					const n = this.image
					"requestVideoFrameCallback" in n == 0 && n.readyState >= n.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
				}
			}
			L7.prototype.isVideoTexture = !0
			class ZR extends zo {
				constructor(n, e, i, r, o, s, a, c, l, d, u, h) {
					super(null, s, a, c, l, d, r, o, u, h),
						(this.image = { width: e, height: i }),
						(this.mipmaps = n),
						(this.flipY = !1),
						(this.generateMipmaps = !1)
				}
			}
			ZR.prototype.isCompressedTexture = !0
			class JR extends zo {
				constructor(n, e, i, r, o, s, a, c, l) {
					super(n, e, i, r, o, s, a, c, l), (this.needsUpdate = !0)
				}
			}
			JR.prototype.isCanvasTexture = !0
			class R7 extends zo {
				constructor(n, e, i, r, o, s, a, c, l, d) {
					if ((d = void 0 !== d ? d : tp) !== tp && d !== Ng)
						throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat")
					void 0 === i && d === tp && (i = sy),
						void 0 === i && d === Ng && (i = Og),
						super(null, r, o, s, a, c, d, i, l),
						(this.image = { width: n, height: e }),
						(this.magFilter = void 0 !== a ? a : ts),
						(this.minFilter = void 0 !== c ? c : ts),
						(this.flipY = !1),
						(this.generateMipmaps = !1)
				}
			}
			R7.prototype.isDepthTexture = !0
			class tS extends vn {
				constructor(n = 1, e = 8, i = 0, r = 2 * Math.PI) {
					super(),
						(this.type = "CircleGeometry"),
						(this.parameters = { radius: n, segments: e, thetaStart: i, thetaLength: r }),
						(e = Math.max(3, e))
					const o = [],
						s = [],
						a = [],
						c = [],
						l = new K(),
						d = new lt()
					s.push(0, 0, 0), a.push(0, 0, 1), c.push(0.5, 0.5)
					for (let u = 0, h = 3; u <= e; u++, h += 3) {
						const f = i + (u / e) * r
						;(l.x = n * Math.cos(f)),
							(l.y = n * Math.sin(f)),
							s.push(l.x, l.y, l.z),
							a.push(0, 0, 1),
							(d.x = (s[h] / n + 1) / 2),
							(d.y = (s[h + 1] / n + 1) / 2),
							c.push(d.x, d.y)
					}
					for (let u = 1; u <= e; u++) o.push(u, u + 1, 0)
					this.setIndex(o),
						this.setAttribute("position", new cn(s, 3)),
						this.setAttribute("normal", new cn(a, 3)),
						this.setAttribute("uv", new cn(c, 2))
				}
			}
			class lb extends vn {
				constructor(n = 1, e = 1, i = 1, r = 8, o = 1, s = !1, a = 0, c = 2 * Math.PI) {
					super(),
						(this.type = "CylinderGeometry"),
						(this.parameters = {
							radiusTop: n,
							radiusBottom: e,
							height: i,
							radialSegments: r,
							heightSegments: o,
							openEnded: s,
							thetaStart: a,
							thetaLength: c
						})
					const l = this
					;(r = Math.floor(r)), (o = Math.floor(o))
					const d = [],
						u = [],
						h = [],
						f = []
					let _ = 0
					const y = [],
						C = i / 2
					let x = 0
					function S(M) {
						const O = _,
							N = new lt(),
							j = new K()
						let le = 0
						const ae = !0 === M ? n : e,
							ce = !0 === M ? 1 : -1
						for (let Se = 1; Se <= r; Se++) u.push(0, C * ce, 0), h.push(0, ce, 0), f.push(0.5, 0.5), _++
						const ue = _
						for (let Se = 0; Se <= r; Se++) {
							const W = (Se / r) * c + a,
								me = Math.cos(W),
								Z = Math.sin(W)
							;(j.x = ae * Z),
								(j.y = C * ce),
								(j.z = ae * me),
								u.push(j.x, j.y, j.z),
								h.push(0, ce, 0),
								(N.x = 0.5 * me + 0.5),
								(N.y = 0.5 * Z * ce + 0.5),
								f.push(N.x, N.y),
								_++
						}
						for (let Se = 0; Se < r; Se++) {
							const ve = O + Se,
								W = ue + Se
							!0 === M ? d.push(W, W + 1, ve) : d.push(W + 1, W, ve), (le += 3)
						}
						l.addGroup(x, le, !0 === M ? 1 : 2), (x += le)
					}
					;(function w() {
						const M = new K(),
							O = new K()
						let N = 0
						const j = (e - n) / i
						for (let le = 0; le <= o; le++) {
							const ae = [],
								ce = le / o,
								ue = ce * (e - n) + n
							for (let Se = 0; Se <= r; Se++) {
								const ve = Se / r,
									W = ve * c + a,
									me = Math.sin(W),
									Z = Math.cos(W)
								;(O.x = ue * me),
									(O.y = -ce * i + C),
									(O.z = ue * Z),
									u.push(O.x, O.y, O.z),
									M.set(me, j, Z).normalize(),
									h.push(M.x, M.y, M.z),
									f.push(ve, 1 - ce),
									ae.push(_++)
							}
							y.push(ae)
						}
						for (let le = 0; le < r; le++)
							for (let ae = 0; ae < o; ae++) {
								const ue = y[ae + 1][le],
									Se = y[ae + 1][le + 1],
									ve = y[ae][le + 1]
								d.push(y[ae][le], ue, ve), d.push(ue, Se, ve), (N += 6)
							}
						l.addGroup(x, N, 0), (x += N)
					})(),
						!1 === s && (n > 0 && S(!0), e > 0 && S(!1)),
						this.setIndex(d),
						this.setAttribute("position", new cn(u, 3)),
						this.setAttribute("normal", new cn(h, 3)),
						this.setAttribute("uv", new cn(f, 2))
				}
			}
			class nS extends lb {
				constructor(n = 1, e = 1, i = 8, r = 1, o = !1, s = 0, a = 2 * Math.PI) {
					super(0, n, e, i, r, o, s, a),
						(this.type = "ConeGeometry"),
						(this.parameters = {
							radius: n,
							height: e,
							radialSegments: i,
							heightSegments: r,
							openEnded: o,
							thetaStart: s,
							thetaLength: a
						})
				}
			}
			class lf extends vn {
				constructor(n, e, i = 1, r = 0) {
					super(), (this.type = "PolyhedronGeometry"), (this.parameters = { vertices: n, indices: e, radius: i, detail: r })
					const o = [],
						s = []
					function c(w, S, M, O) {
						const N = O + 1,
							j = []
						for (let le = 0; le <= N; le++) {
							j[le] = []
							const ae = w.clone().lerp(M, le / N),
								ce = S.clone().lerp(M, le / N),
								ue = N - le
							for (let Se = 0; Se <= ue; Se++) j[le][Se] = 0 === Se && le === N ? ae : ae.clone().lerp(ce, Se / ue)
						}
						for (let le = 0; le < N; le++)
							for (let ae = 0; ae < 2 * (N - le) - 1; ae++) {
								const ce = Math.floor(ae / 2)
								ae % 2 == 0
									? (h(j[le][ce + 1]), h(j[le + 1][ce]), h(j[le][ce]))
									: (h(j[le][ce + 1]), h(j[le + 1][ce + 1]), h(j[le + 1][ce]))
							}
					}
					function h(w) {
						o.push(w.x, w.y, w.z)
					}
					function f(w, S) {
						const M = 3 * w
						;(S.x = n[M + 0]), (S.y = n[M + 1]), (S.z = n[M + 2])
					}
					function y(w, S, M, O) {
						O < 0 && 1 === w.x && (s[S] = w.x - 1), 0 === M.x && 0 === M.z && (s[S] = O / 2 / Math.PI + 0.5)
					}
					function C(w) {
						return Math.atan2(w.z, -w.x)
					}
					function x(w) {
						return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z))
					}
					;(function a(w) {
						const S = new K(),
							M = new K(),
							O = new K()
						for (let N = 0; N < e.length; N += 3) f(e[N + 0], S), f(e[N + 1], M), f(e[N + 2], O), c(S, M, O, w)
					})(r),
						(function l(w) {
							const S = new K()
							for (let M = 0; M < o.length; M += 3)
								(S.x = o[M + 0]),
									(S.y = o[M + 1]),
									(S.z = o[M + 2]),
									S.normalize().multiplyScalar(w),
									(o[M + 0] = S.x),
									(o[M + 1] = S.y),
									(o[M + 2] = S.z)
						})(i),
						(function d() {
							const w = new K()
							for (let S = 0; S < o.length; S += 3) {
								;(w.x = o[S + 0]), (w.y = o[S + 1]), (w.z = o[S + 2])
								const M = C(w) / 2 / Math.PI + 0.5,
									O = x(w) / Math.PI + 0.5
								s.push(M, 1 - O)
							}
							;(function _() {
								const w = new K(),
									S = new K(),
									M = new K(),
									O = new K(),
									N = new lt(),
									j = new lt(),
									le = new lt()
								for (let ae = 0, ce = 0; ae < o.length; ae += 9, ce += 6) {
									w.set(o[ae + 0], o[ae + 1], o[ae + 2]),
										S.set(o[ae + 3], o[ae + 4], o[ae + 5]),
										M.set(o[ae + 6], o[ae + 7], o[ae + 8]),
										N.set(s[ce + 0], s[ce + 1]),
										j.set(s[ce + 2], s[ce + 3]),
										le.set(s[ce + 4], s[ce + 5]),
										O.copy(w).add(S).add(M).divideScalar(3)
									const ue = C(O)
									y(N, ce + 0, w, ue), y(j, ce + 2, S, ue), y(le, ce + 4, M, ue)
								}
							})(),
								(function u() {
									for (let w = 0; w < s.length; w += 6) {
										const S = s[w + 0],
											M = s[w + 2],
											O = s[w + 4],
											N = Math.max(S, M, O),
											j = Math.min(S, M, O)
										N > 0.9 &&
											j < 0.1 &&
											(S < 0.2 && (s[w + 0] += 1), M < 0.2 && (s[w + 2] += 1), O < 0.2 && (s[w + 4] += 1))
									}
								})()
						})(),
						this.setAttribute("position", new cn(o, 3)),
						this.setAttribute("normal", new cn(o.slice(), 3)),
						this.setAttribute("uv", new cn(s, 2)),
						0 === r ? this.computeVertexNormals() : this.normalizeNormals()
				}
			}
			class iS extends lf {
				constructor(n = 1, e = 0) {
					const i = (1 + Math.sqrt(5)) / 2,
						r = 1 / i
					super(
						[
							-1,
							-1,
							-1,
							-1,
							-1,
							1,
							-1,
							1,
							-1,
							-1,
							1,
							1,
							1,
							-1,
							-1,
							1,
							-1,
							1,
							1,
							1,
							-1,
							1,
							1,
							1,
							0,
							-r,
							-i,
							0,
							-r,
							i,
							0,
							r,
							-i,
							0,
							r,
							i,
							-r,
							-i,
							0,
							-r,
							i,
							0,
							r,
							-i,
							0,
							r,
							i,
							0,
							-i,
							0,
							-r,
							i,
							0,
							-r,
							-i,
							0,
							r,
							i,
							0,
							r
						],
						[
							3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16,
							2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1,
							9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19,
							4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9
						],
						n,
						e
					),
						(this.type = "DodecahedronGeometry"),
						(this.parameters = { radius: n, detail: e })
				}
			}
			const rS = new K(),
				oS = new K(),
				eP = new K(),
				sS = new Ro()
			class tP extends vn {
				constructor(n, e) {
					if (
						(super(),
						(this.type = "EdgesGeometry"),
						(this.parameters = { thresholdAngle: e }),
						(e = void 0 !== e ? e : 1),
						!0 === n.isGeometry)
					)
						return void console.error(
							"THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
						)
					const r = Math.pow(10, 4),
						o = Math.cos(jn.DEG2RAD * e),
						s = n.getIndex(),
						a = n.getAttribute("position"),
						c = s ? s.count : a.count,
						l = [0, 0, 0],
						d = ["a", "b", "c"],
						u = new Array(3),
						h = {},
						f = []
					for (let _ = 0; _ < c; _ += 3) {
						s
							? ((l[0] = s.getX(_)), (l[1] = s.getX(_ + 1)), (l[2] = s.getX(_ + 2)))
							: ((l[0] = _), (l[1] = _ + 1), (l[2] = _ + 2))
						const { a: y, b: C, c: x } = sS
						if (
							(y.fromBufferAttribute(a, l[0]),
							C.fromBufferAttribute(a, l[1]),
							x.fromBufferAttribute(a, l[2]),
							sS.getNormal(eP),
							(u[0] = `${Math.round(y.x * r)},${Math.round(y.y * r)},${Math.round(y.z * r)}`),
							(u[1] = `${Math.round(C.x * r)},${Math.round(C.y * r)},${Math.round(C.z * r)}`),
							(u[2] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`),
							u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
						)
							for (let w = 0; w < 3; w++) {
								const S = (w + 1) % 3,
									M = u[w],
									O = u[S],
									N = sS[d[w]],
									j = sS[d[S]],
									le = `${M}_${O}`,
									ae = `${O}_${M}`
								ae in h && h[ae]
									? (eP.dot(h[ae].normal) <= o && (f.push(N.x, N.y, N.z), f.push(j.x, j.y, j.z)), (h[ae] = null))
									: le in h || (h[le] = { index0: l[w], index1: l[S], normal: eP.clone() })
							}
					}
					for (const _ in h)
						if (h[_]) {
							const { index0: y, index1: C } = h[_]
							rS.fromBufferAttribute(a, y), oS.fromBufferAttribute(a, C), f.push(rS.x, rS.y, rS.z), f.push(oS.x, oS.y, oS.z)
						}
					this.setAttribute("position", new cn(f, 3))
				}
			}
			function P7(t, n, e, i, r) {
				let o, s
				if (
					r ===
					(function rCe(t, n, e, i) {
						let r = 0
						for (let o = n, s = e - i; o < e; o += i) (r += (t[s] - t[o]) * (t[o + 1] + t[s + 1])), (s = o)
						return r
					})(t, n, e, i) >
						0
				)
					for (o = n; o < e; o += i) s = U7(o, t[o], t[o + 1], s)
				else for (o = e - i; o >= n; o -= i) s = U7(o, t[o], t[o + 1], s)
				return s && aS(s, s.next) && (Qy(s), (s = s.next)), s
			}
			function df(t, n) {
				if (!t) return t
				n || (n = t)
				let i,
					e = t
				do {
					if (((i = !1), e.steiner || (!aS(e, e.next) && 0 !== ho(e.prev, e, e.next)))) e = e.next
					else {
						if ((Qy(e), (e = n = e.prev), e === e.next)) break
						i = !0
					}
				} while (i || e !== n)
				return n
			}
			function Hy(t, n, e, i, r, o, s) {
				if (!t) return
				!s &&
					o &&
					(function Z1e(t, n, e, i) {
						let r = t
						do {
							null === r.z && (r.z = nP(r.x, r.y, n, e, i)), (r.prevZ = r.prev), (r.nextZ = r.next), (r = r.next)
						} while (r !== t)
						;(r.prevZ.nextZ = null),
							(r.prevZ = null),
							(function J1e(t) {
								let n,
									e,
									i,
									r,
									o,
									s,
									a,
									c,
									l = 1
								do {
									for (e = t, t = null, o = null, s = 0; e; ) {
										for (s++, i = e, a = 0, n = 0; n < l && (a++, (i = i.nextZ), i); n++);
										for (c = l; a > 0 || (c > 0 && i); )
											0 !== a && (0 === c || !i || e.z <= i.z)
												? ((r = e), (e = e.nextZ), a--)
												: ((r = i), (i = i.nextZ), c--),
												o ? (o.nextZ = r) : (t = r),
												(r.prevZ = o),
												(o = r)
										e = i
									}
									;(o.nextZ = null), (l *= 2)
								} while (s > 1)
							})(r)
					})(t, i, r, o)
				let c,
					l,
					a = t
				for (; t.prev !== t.next; )
					if (((c = t.prev), (l = t.next), o ? G1e(t, i, r, o) : z1e(t)))
						n.push(c.i / e), n.push(t.i / e), n.push(l.i / e), Qy(t), (t = l.next), (a = l.next)
					else if ((t = l) === a) {
						s
							? 1 === s
								? Hy((t = $1e(df(t), n, e)), n, e, i, r, o, 2)
								: 2 === s && W1e(t, n, e, i, r, o)
							: Hy(df(t), n, e, i, r, o, 1)
						break
					}
			}
			function z1e(t) {
				const n = t.prev,
					e = t,
					i = t.next
				if (ho(n, e, i) >= 0) return !1
				let r = t.next.next
				for (; r !== t.prev; ) {
					if (db(n.x, n.y, e.x, e.y, i.x, i.y, r.x, r.y) && ho(r.prev, r, r.next) >= 0) return !1
					r = r.next
				}
				return !0
			}
			function G1e(t, n, e, i) {
				const r = t.prev,
					o = t,
					s = t.next
				if (ho(r, o, s) >= 0) return !1
				const l = r.x > o.x ? (r.x > s.x ? r.x : s.x) : o.x > s.x ? o.x : s.x,
					d = r.y > o.y ? (r.y > s.y ? r.y : s.y) : o.y > s.y ? o.y : s.y,
					u = nP(
						r.x < o.x ? (r.x < s.x ? r.x : s.x) : o.x < s.x ? o.x : s.x,
						r.y < o.y ? (r.y < s.y ? r.y : s.y) : o.y < s.y ? o.y : s.y,
						n,
						e,
						i
					),
					h = nP(l, d, n, e, i)
				let f = t.prevZ,
					_ = t.nextZ
				for (; f && f.z >= u && _ && _.z <= h; ) {
					if (
						(f !== t.prev && f !== t.next && db(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && ho(f.prev, f, f.next) >= 0) ||
						((f = f.prevZ),
						_ !== t.prev && _ !== t.next && db(r.x, r.y, o.x, o.y, s.x, s.y, _.x, _.y) && ho(_.prev, _, _.next) >= 0)
					)
						return !1
					_ = _.nextZ
				}
				for (; f && f.z >= u; ) {
					if (f !== t.prev && f !== t.next && db(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && ho(f.prev, f, f.next) >= 0) return !1
					f = f.prevZ
				}
				for (; _ && _.z <= h; ) {
					if (_ !== t.prev && _ !== t.next && db(r.x, r.y, o.x, o.y, s.x, s.y, _.x, _.y) && ho(_.prev, _, _.next) >= 0) return !1
					_ = _.nextZ
				}
				return !0
			}
			function $1e(t, n, e) {
				let i = t
				do {
					const r = i.prev,
						o = i.next.next
					!aS(r, o) &&
						O7(r, i, i.next, o) &&
						Vy(r, o) &&
						Vy(o, r) &&
						(n.push(r.i / e), n.push(i.i / e), n.push(o.i / e), Qy(i), Qy(i.next), (i = t = o)),
						(i = i.next)
				} while (i !== t)
				return df(i)
			}
			function W1e(t, n, e, i, r, o) {
				let s = t
				do {
					let a = s.next.next
					for (; a !== s.prev; ) {
						if (s.i !== a.i && tCe(s, a)) {
							let c = N7(s, a)
							return (s = df(s, s.next)), (c = df(c, c.next)), Hy(s, n, e, i, r, o), void Hy(c, n, e, i, r, o)
						}
						a = a.next
					}
					s = s.next
				} while (s !== t)
			}
			function K1e(t, n) {
				return t.x - n.x
			}
			function X1e(t, n) {
				if (
					((n = (function Y1e(t, n) {
						let e = n
						const i = t.x,
							r = t.y
						let s,
							o = -1 / 0
						do {
							if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
								const h = e.x + ((r - e.y) * (e.next.x - e.x)) / (e.next.y - e.y)
								if (h <= i && h > o) {
									if (((o = h), h === i)) {
										if (r === e.y) return e
										if (r === e.next.y) return e.next
									}
									s = e.x < e.next.x ? e : e.next
								}
							}
							e = e.next
						} while (e !== n)
						if (!s) return null
						if (i === o) return s
						const a = s,
							c = s.x,
							l = s.y
						let u,
							d = 1 / 0
						e = s
						do {
							i >= e.x &&
								e.x >= c &&
								i !== e.x &&
								db(r < l ? i : o, r, c, l, r < l ? o : i, r, e.x, e.y) &&
								((u = Math.abs(r - e.y) / (i - e.x)),
								Vy(e, t) && (u < d || (u === d && (e.x > s.x || (e.x === s.x && q1e(s, e))))) && ((s = e), (d = u))),
								(e = e.next)
						} while (e !== a)
						return s
					})(t, n)),
					n)
				) {
					const e = N7(n, t)
					df(n, n.next), df(e, e.next)
				}
			}
			function q1e(t, n) {
				return ho(t.prev, t, n.prev) < 0 && ho(n.next, t, t.next) < 0
			}
			function nP(t, n, e, i, r) {
				return (
					(t =
						1431655765 &
						((t =
							858993459 &
							((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - e) * r) | (t << 8))) | (t << 4))) | (t << 2))) |
							(t << 1))) |
					((n =
						1431655765 &
						((n =
							858993459 &
							((n = 252645135 & ((n = 16711935 & ((n = 32767 * (n - i) * r) | (n << 8))) | (n << 4))) | (n << 2))) |
							(n << 1))) <<
						1)
				)
			}
			function eCe(t) {
				let n = t,
					e = t
				do {
					;(n.x < e.x || (n.x === e.x && n.y < e.y)) && (e = n), (n = n.next)
				} while (n !== t)
				return e
			}
			function db(t, n, e, i, r, o, s, a) {
				return (
					(r - s) * (n - a) - (t - s) * (o - a) >= 0 &&
					(t - s) * (i - a) - (e - s) * (n - a) >= 0 &&
					(e - s) * (o - a) - (r - s) * (i - a) >= 0
				)
			}
			function tCe(t, n) {
				return (
					t.next.i !== n.i &&
					t.prev.i !== n.i &&
					!(function nCe(t, n) {
						let e = t
						do {
							if (e.i !== t.i && e.next.i !== t.i && e.i !== n.i && e.next.i !== n.i && O7(e, e.next, t, n)) return !0
							e = e.next
						} while (e !== t)
						return !1
					})(t, n) &&
					((Vy(t, n) &&
						Vy(n, t) &&
						(function iCe(t, n) {
							let e = t,
								i = !1
							const r = (t.x + n.x) / 2,
								o = (t.y + n.y) / 2
							do {
								e.y > o != e.next.y > o &&
									e.next.y !== e.y &&
									r < ((e.next.x - e.x) * (o - e.y)) / (e.next.y - e.y) + e.x &&
									(i = !i),
									(e = e.next)
							} while (e !== t)
							return i
						})(t, n) &&
						(ho(t.prev, t, n.prev) || ho(t, n.prev, n))) ||
						(aS(t, n) && ho(t.prev, t, t.next) > 0 && ho(n.prev, n, n.next) > 0))
				)
			}
			function ho(t, n, e) {
				return (n.y - t.y) * (e.x - n.x) - (n.x - t.x) * (e.y - n.y)
			}
			function aS(t, n) {
				return t.x === n.x && t.y === n.y
			}
			function O7(t, n, e, i) {
				const r = lS(ho(t, n, e)),
					o = lS(ho(t, n, i)),
					s = lS(ho(e, i, t)),
					a = lS(ho(e, i, n))
				return !!(
					(r !== o && s !== a) ||
					(0 === r && cS(t, e, n)) ||
					(0 === o && cS(t, i, n)) ||
					(0 === s && cS(e, t, i)) ||
					(0 === a && cS(e, n, i))
				)
			}
			function cS(t, n, e) {
				return n.x <= Math.max(t.x, e.x) && n.x >= Math.min(t.x, e.x) && n.y <= Math.max(t.y, e.y) && n.y >= Math.min(t.y, e.y)
			}
			function lS(t) {
				return t > 0 ? 1 : t < 0 ? -1 : 0
			}
			function Vy(t, n) {
				return ho(t.prev, t, t.next) < 0
					? ho(t, n, t.next) >= 0 && ho(t, t.prev, n) >= 0
					: ho(t, n, t.prev) < 0 || ho(t, t.next, n) < 0
			}
			function N7(t, n) {
				const e = new iP(t.i, t.x, t.y),
					i = new iP(n.i, n.x, n.y),
					r = t.next,
					o = n.prev
				return (t.next = n), (n.prev = t), (e.next = r), (r.prev = e), (i.next = e), (e.prev = i), (o.next = i), (i.prev = o), i
			}
			function U7(t, n, e, i) {
				const r = new iP(t, n, e)
				return i ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r)) : ((r.prev = r), (r.next = r)), r
			}
			function Qy(t) {
				;(t.next.prev = t.prev), (t.prev.next = t.next), t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
			}
			function iP(t, n, e) {
				;(this.i = t),
					(this.x = n),
					(this.y = e),
					(this.prev = null),
					(this.next = null),
					(this.z = null),
					(this.prevZ = null),
					(this.nextZ = null),
					(this.steiner = !1)
			}
			const Uu = {
				area: function (t) {
					const n = t.length
					let e = 0
					for (let i = n - 1, r = 0; r < n; i = r++) e += t[i].x * t[r].y - t[r].x * t[i].y
					return 0.5 * e
				},
				isClockWise: function (t) {
					return Uu.area(t) < 0
				},
				triangulateShape: function (t, n) {
					const e = [],
						i = [],
						r = []
					H7(t), V7(e, t)
					let o = t.length
					n.forEach(H7)
					for (let a = 0; a < n.length; a++) i.push(o), (o += n[a].length), V7(e, n[a])
					const s = (function (t, n, e) {
						e = e || 2
						const i = n && n.length,
							r = i ? n[0] * e : t.length
						let o = P7(t, 0, r, e, !0)
						const s = []
						if (!o || o.next === o.prev) return s
						let a, c, l, d, u, h, f
						if (
							(i &&
								(o = (function j1e(t, n, e, i) {
									const r = []
									let o, s, a, c, l
									for (o = 0, s = n.length; o < s; o++)
										(a = n[o] * i),
											(c = o < s - 1 ? n[o + 1] * i : t.length),
											(l = P7(t, a, c, i, !1)),
											l === l.next && (l.steiner = !0),
											r.push(eCe(l))
									for (r.sort(K1e), o = 0; o < r.length; o++) X1e(r[o], e), (e = df(e, e.next))
									return e
								})(t, n, o, e)),
							t.length > 80 * e)
						) {
							;(a = l = t[0]), (c = d = t[1])
							for (let _ = e; _ < r; _ += e)
								(u = t[_]), (h = t[_ + 1]), u < a && (a = u), h < c && (c = h), u > l && (l = u), h > d && (d = h)
							;(f = Math.max(l - a, d - c)), (f = 0 !== f ? 1 / f : 0)
						}
						return Hy(o, s, e, a, c, f), s
					})(e, i)
					for (let a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3))
					return r
				}
			}
			function H7(t) {
				const n = t.length
				n > 2 && t[n - 1].equals(t[0]) && t.pop()
			}
			function V7(t, n) {
				for (let e = 0; e < n.length; e++) t.push(n[e].x), t.push(n[e].y)
			}
			class Hu extends vn {
				constructor(n, e) {
					super(),
						(this.type = "ExtrudeGeometry"),
						(this.parameters = { shapes: n, options: e }),
						(n = Array.isArray(n) ? n : [n])
					const i = this,
						r = [],
						o = []
					for (let a = 0, c = n.length; a < c; a++) s(n[a])
					function s(a) {
						const c = [],
							l = void 0 !== e.curveSegments ? e.curveSegments : 12,
							d = void 0 !== e.steps ? e.steps : 1
						let u = void 0 !== e.depth ? e.depth : 100,
							h = void 0 === e.bevelEnabled || e.bevelEnabled,
							f = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
							_ = void 0 !== e.bevelSize ? e.bevelSize : f - 2,
							y = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
							C = void 0 !== e.bevelSegments ? e.bevelSegments : 3
						const x = e.extrudePath,
							w = void 0 !== e.UVGenerator ? e.UVGenerator : oCe
						void 0 !== e.amount &&
							(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), (u = e.amount))
						let S,
							O,
							N,
							j,
							le,
							M = !1
						x &&
							((S = x.getSpacedPoints(d)),
							(M = !0),
							(h = !1),
							(O = x.computeFrenetFrames(d, !1)),
							(N = new K()),
							(j = new K()),
							(le = new K())),
							h || ((C = 0), (f = 0), (_ = 0), (y = 0))
						const ae = a.extractPoints(l)
						let ce = ae.shape
						const ue = ae.holes
						if (!Uu.isClockWise(ce)) {
							ce = ce.reverse()
							for (let Et = 0, Tt = ue.length; Et < Tt; Et++) {
								const Ut = ue[Et]
								Uu.isClockWise(Ut) && (ue[Et] = Ut.reverse())
							}
						}
						const ve = Uu.triangulateShape(ce, ue),
							W = ce
						for (let Et = 0, Tt = ue.length; Et < Tt; Et++) ce = ce.concat(ue[Et])
						function me(Et, Tt, Ut) {
							return Tt || console.error("THREE.ExtrudeGeometry: vec does not exist"), Tt.clone().multiplyScalar(Ut).add(Et)
						}
						const Z = ce.length,
							Ae = ve.length
						function Ie(Et, Tt, Ut) {
							let Fn, ln, oe
							const ne = Et.x - Tt.x,
								_t = Et.y - Tt.y,
								xt = Ut.x - Et.x,
								Be = Ut.y - Et.y,
								It = ne * ne + _t * _t
							if (Math.abs(ne * Be - _t * xt) > Number.EPSILON) {
								const An = Math.sqrt(It),
									Bt = Math.sqrt(xt * xt + Be * Be),
									Vn = Tt.x - _t / An,
									Gn = Tt.y + ne / An,
									Pn = ((Ut.x - Be / Bt - Vn) * Be - (Ut.y + xt / Bt - Gn) * xt) / (ne * Be - _t * xt)
								;(Fn = Vn + ne * Pn - Et.x), (ln = Gn + _t * Pn - Et.y)
								const fo = Fn * Fn + ln * ln
								if (fo <= 2) return new lt(Fn, ln)
								oe = Math.sqrt(fo / 2)
							} else {
								let An = !1
								ne > Number.EPSILON
									? xt > Number.EPSILON && (An = !0)
									: ne < -Number.EPSILON
									? xt < -Number.EPSILON && (An = !0)
									: Math.sign(_t) === Math.sign(Be) && (An = !0),
									An ? ((Fn = -_t), (ln = ne), (oe = Math.sqrt(It))) : ((Fn = ne), (ln = _t), (oe = Math.sqrt(It / 2)))
							}
							return new lt(Fn / oe, ln / oe)
						}
						const Pe = []
						for (let Et = 0, Tt = W.length, Ut = Tt - 1, Fn = Et + 1; Et < Tt; Et++, Ut++, Fn++)
							Ut === Tt && (Ut = 0), Fn === Tt && (Fn = 0), (Pe[Et] = Ie(W[Et], W[Ut], W[Fn]))
						const nt = []
						let pt,
							kt = Pe.concat()
						for (let Et = 0, Tt = ue.length; Et < Tt; Et++) {
							const Ut = ue[Et]
							pt = []
							for (let Fn = 0, ln = Ut.length, oe = ln - 1, ne = Fn + 1; Fn < ln; Fn++, oe++, ne++)
								oe === ln && (oe = 0), ne === ln && (ne = 0), (pt[Fn] = Ie(Ut[Fn], Ut[oe], Ut[ne]))
							nt.push(pt), (kt = kt.concat(pt))
						}
						for (let Et = 0; Et < C; Et++) {
							const Tt = Et / C,
								Ut = f * Math.cos((Tt * Math.PI) / 2),
								Fn = _ * Math.sin((Tt * Math.PI) / 2) + y
							for (let ln = 0, oe = W.length; ln < oe; ln++) {
								const ne = me(W[ln], Pe[ln], Fn)
								nn(ne.x, ne.y, -Ut)
							}
							for (let ln = 0, oe = ue.length; ln < oe; ln++) {
								const ne = ue[ln]
								pt = nt[ln]
								for (let _t = 0, xt = ne.length; _t < xt; _t++) {
									const Be = me(ne[_t], pt[_t], Fn)
									nn(Be.x, Be.y, -Ut)
								}
							}
						}
						const tn = _ + y
						for (let Et = 0; Et < Z; Et++) {
							const Tt = h ? me(ce[Et], kt[Et], tn) : ce[Et]
							M
								? (j.copy(O.normals[0]).multiplyScalar(Tt.x),
								  N.copy(O.binormals[0]).multiplyScalar(Tt.y),
								  le.copy(S[0]).add(j).add(N),
								  nn(le.x, le.y, le.z))
								: nn(Tt.x, Tt.y, 0)
						}
						for (let Et = 1; Et <= d; Et++)
							for (let Tt = 0; Tt < Z; Tt++) {
								const Ut = h ? me(ce[Tt], kt[Tt], tn) : ce[Tt]
								M
									? (j.copy(O.normals[Et]).multiplyScalar(Ut.x),
									  N.copy(O.binormals[Et]).multiplyScalar(Ut.y),
									  le.copy(S[Et]).add(j).add(N),
									  nn(le.x, le.y, le.z))
									: nn(Ut.x, Ut.y, (u / d) * Et)
							}
						for (let Et = C - 1; Et >= 0; Et--) {
							const Tt = Et / C,
								Ut = f * Math.cos((Tt * Math.PI) / 2),
								Fn = _ * Math.sin((Tt * Math.PI) / 2) + y
							for (let ln = 0, oe = W.length; ln < oe; ln++) {
								const ne = me(W[ln], Pe[ln], Fn)
								nn(ne.x, ne.y, u + Ut)
							}
							for (let ln = 0, oe = ue.length; ln < oe; ln++) {
								const ne = ue[ln]
								pt = nt[ln]
								for (let _t = 0, xt = ne.length; _t < xt; _t++) {
									const Be = me(ne[_t], pt[_t], Fn)
									M ? nn(Be.x, Be.y + S[d - 1].y, S[d - 1].x + Ut) : nn(Be.x, Be.y, u + Ut)
								}
							}
						}
						function dt(Et, Tt) {
							let Ut = Et.length
							for (; --Ut >= 0; ) {
								const Fn = Ut
								let ln = Ut - 1
								ln < 0 && (ln = Et.length - 1)
								for (let oe = 0, ne = d + 2 * C; oe < ne; oe++) {
									const _t = Z * oe,
										xt = Z * (oe + 1)
									Hn(Tt + Fn + _t, Tt + ln + _t, Tt + ln + xt, Tt + Fn + xt)
								}
							}
						}
						function nn(Et, Tt, Ut) {
							c.push(Et), c.push(Tt), c.push(Ut)
						}
						function Sn(Et, Tt, Ut) {
							kn(Et), kn(Tt), kn(Ut)
							const Fn = r.length / 3,
								ln = w.generateTopUV(i, r, Fn - 3, Fn - 2, Fn - 1)
							Ii(ln[0]), Ii(ln[1]), Ii(ln[2])
						}
						function Hn(Et, Tt, Ut, Fn) {
							kn(Et), kn(Tt), kn(Fn), kn(Tt), kn(Ut), kn(Fn)
							const ln = r.length / 3,
								oe = w.generateSideWallUV(i, r, ln - 6, ln - 3, ln - 2, ln - 1)
							Ii(oe[0]), Ii(oe[1]), Ii(oe[3]), Ii(oe[1]), Ii(oe[2]), Ii(oe[3])
						}
						function kn(Et) {
							r.push(c[3 * Et + 0]), r.push(c[3 * Et + 1]), r.push(c[3 * Et + 2])
						}
						function Ii(Et) {
							o.push(Et.x), o.push(Et.y)
						}
						;(function Kt() {
							const Et = r.length / 3
							if (h) {
								let Tt = 0,
									Ut = Z * Tt
								for (let Fn = 0; Fn < Ae; Fn++) {
									const ln = ve[Fn]
									Sn(ln[2] + Ut, ln[1] + Ut, ln[0] + Ut)
								}
								;(Tt = d + 2 * C), (Ut = Z * Tt)
								for (let Fn = 0; Fn < Ae; Fn++) {
									const ln = ve[Fn]
									Sn(ln[0] + Ut, ln[1] + Ut, ln[2] + Ut)
								}
							} else {
								for (let Tt = 0; Tt < Ae; Tt++) {
									const Ut = ve[Tt]
									Sn(Ut[2], Ut[1], Ut[0])
								}
								for (let Tt = 0; Tt < Ae; Tt++) {
									const Ut = ve[Tt]
									Sn(Ut[0] + Z * d, Ut[1] + Z * d, Ut[2] + Z * d)
								}
							}
							i.addGroup(Et, r.length / 3 - Et, 0)
						})(),
							(function Un() {
								const Et = r.length / 3
								let Tt = 0
								dt(W, Tt), (Tt += W.length)
								for (let Ut = 0, Fn = ue.length; Ut < Fn; Ut++) {
									const ln = ue[Ut]
									dt(ln, Tt), (Tt += ln.length)
								}
								i.addGroup(Et, r.length / 3 - Et, 1)
							})()
					}
					this.setAttribute("position", new cn(r, 3)), this.setAttribute("uv", new cn(o, 2)), this.computeVertexNormals()
				}
				toJSON() {
					const n = vn.prototype.toJSON.call(this)
					return (function sCe(t, n, e) {
						if (((e.shapes = []), Array.isArray(t))) for (let i = 0, r = t.length; i < r; i++) e.shapes.push(t[i].uuid)
						else e.shapes.push(t.uuid)
						return void 0 !== n.extrudePath && (e.options.extrudePath = n.extrudePath.toJSON()), e
					})(this.parameters.shapes, this.parameters.options, n)
				}
			}
			const oCe = {
				generateTopUV: function (t, n, e, i, r) {
					const a = n[3 * i],
						c = n[3 * i + 1],
						l = n[3 * r],
						d = n[3 * r + 1]
					return [new lt(n[3 * e], n[3 * e + 1]), new lt(a, c), new lt(l, d)]
				},
				generateSideWallUV: function (t, n, e, i, r, o) {
					const s = n[3 * e],
						a = n[3 * e + 1],
						c = n[3 * e + 2],
						l = n[3 * i],
						d = n[3 * i + 1],
						u = n[3 * i + 2],
						h = n[3 * r],
						f = n[3 * r + 1],
						_ = n[3 * r + 2],
						y = n[3 * o],
						C = n[3 * o + 1],
						x = n[3 * o + 2]
					return Math.abs(a - d) < 0.01
						? [new lt(s, 1 - c), new lt(l, 1 - u), new lt(h, 1 - _), new lt(y, 1 - x)]
						: [new lt(a, 1 - c), new lt(d, 1 - u), new lt(f, 1 - _), new lt(C, 1 - x)]
				}
			}
			class dS extends lf {
				constructor(n = 1, e = 0) {
					const i = (1 + Math.sqrt(5)) / 2
					super(
						[
							-1,
							i,
							0,
							1,
							i,
							0,
							-1,
							-i,
							0,
							1,
							-i,
							0,
							0,
							-1,
							i,
							0,
							1,
							i,
							0,
							-1,
							-i,
							0,
							1,
							-i,
							i,
							0,
							-1,
							i,
							0,
							1,
							-i,
							0,
							-1,
							-i,
							0,
							1
						],
						[
							0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4,
							2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
						],
						n,
						e
					),
						(this.type = "IcosahedronGeometry"),
						(this.parameters = { radius: n, detail: e })
				}
			}
			class uS extends vn {
				constructor(n, e = 12, i = 0, r = 2 * Math.PI) {
					super(),
						(this.type = "LatheGeometry"),
						(this.parameters = { points: n, segments: e, phiStart: i, phiLength: r }),
						(e = Math.floor(e)),
						(r = jn.clamp(r, 0, 2 * Math.PI))
					const o = [],
						s = [],
						a = [],
						c = 1 / e,
						l = new K(),
						d = new lt()
					for (let u = 0; u <= e; u++) {
						const h = i + u * c * r,
							f = Math.sin(h),
							_ = Math.cos(h)
						for (let y = 0; y <= n.length - 1; y++)
							(l.x = n[y].x * f),
								(l.y = n[y].y),
								(l.z = n[y].x * _),
								s.push(l.x, l.y, l.z),
								(d.x = u / e),
								(d.y = y / (n.length - 1)),
								a.push(d.x, d.y)
					}
					for (let u = 0; u < e; u++)
						for (let h = 0; h < n.length - 1; h++) {
							const f = h + u * n.length,
								y = f + n.length,
								C = f + n.length + 1,
								x = f + 1
							o.push(f, y, x), o.push(y, C, x)
						}
					if (
						(this.setIndex(o),
						this.setAttribute("position", new cn(s, 3)),
						this.setAttribute("uv", new cn(a, 2)),
						this.computeVertexNormals(),
						r === 2 * Math.PI)
					) {
						const u = this.attributes.normal.array,
							h = new K(),
							f = new K(),
							_ = new K(),
							y = e * n.length * 3
						for (let C = 0, x = 0; C < n.length; C++, x += 3)
							(h.x = u[x + 0]),
								(h.y = u[x + 1]),
								(h.z = u[x + 2]),
								(f.x = u[y + x + 0]),
								(f.y = u[y + x + 1]),
								(f.z = u[y + x + 2]),
								_.addVectors(h, f).normalize(),
								(u[x + 0] = u[y + x + 0] = _.x),
								(u[x + 1] = u[y + x + 1] = _.y),
								(u[x + 2] = u[y + x + 2] = _.z)
					}
				}
			}
			class zy extends lf {
				constructor(n = 1, e = 0) {
					super(
						[1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
						[0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
						n,
						e
					),
						(this.type = "OctahedronGeometry"),
						(this.parameters = { radius: n, detail: e })
				}
			}
			function mp(t, n, e) {
				vn.call(this), (this.type = "ParametricGeometry"), (this.parameters = { func: t, slices: n, stacks: e })
				const i = [],
					r = [],
					o = [],
					s = [],
					a = 1e-5,
					c = new K(),
					l = new K(),
					d = new K(),
					u = new K(),
					h = new K()
				t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.")
				const f = n + 1
				for (let _ = 0; _ <= e; _++) {
					const y = _ / e
					for (let C = 0; C <= n; C++) {
						const x = C / n
						t(x, y, l),
							r.push(l.x, l.y, l.z),
							x - a >= 0 ? (t(x - a, y, d), u.subVectors(l, d)) : (t(x + a, y, d), u.subVectors(d, l)),
							y - a >= 0 ? (t(x, y - a, d), h.subVectors(l, d)) : (t(x, y + a, d), h.subVectors(d, l)),
							c.crossVectors(u, h).normalize(),
							o.push(c.x, c.y, c.z),
							s.push(x, y)
					}
				}
				for (let _ = 0; _ < e; _++)
					for (let y = 0; y < n; y++) {
						const x = _ * f + y + 1,
							w = (_ + 1) * f + y + 1,
							S = (_ + 1) * f + y
						i.push(_ * f + y, x, S), i.push(x, w, S)
					}
				this.setIndex(i),
					this.setAttribute("position", new cn(r, 3)),
					this.setAttribute("normal", new cn(o, 3)),
					this.setAttribute("uv", new cn(s, 2))
			}
			;(mp.prototype = Object.create(vn.prototype)).constructor = mp
			class hS extends vn {
				constructor(n = 0.5, e = 1, i = 8, r = 1, o = 0, s = 2 * Math.PI) {
					super(),
						(this.type = "RingGeometry"),
						(this.parameters = {
							innerRadius: n,
							outerRadius: e,
							thetaSegments: i,
							phiSegments: r,
							thetaStart: o,
							thetaLength: s
						}),
						(i = Math.max(3, i))
					const a = [],
						c = [],
						l = [],
						d = []
					let u = n
					const h = (e - n) / (r = Math.max(1, r)),
						f = new K(),
						_ = new lt()
					for (let y = 0; y <= r; y++) {
						for (let C = 0; C <= i; C++) {
							const x = o + (C / i) * s
							;(f.x = u * Math.cos(x)),
								(f.y = u * Math.sin(x)),
								c.push(f.x, f.y, f.z),
								l.push(0, 0, 1),
								(_.x = (f.x / e + 1) / 2),
								(_.y = (f.y / e + 1) / 2),
								d.push(_.x, _.y)
						}
						u += h
					}
					for (let y = 0; y < r; y++) {
						const C = y * (i + 1)
						for (let x = 0; x < i; x++) {
							const w = x + C,
								M = w + i + 1,
								O = w + i + 2,
								N = w + 1
							a.push(w, M, N), a.push(M, O, N)
						}
					}
					this.setIndex(a),
						this.setAttribute("position", new cn(c, 3)),
						this.setAttribute("normal", new cn(l, 3)),
						this.setAttribute("uv", new cn(d, 2))
				}
			}
			class Gy extends vn {
				constructor(n, e = 12) {
					super(), (this.type = "ShapeGeometry"), (this.parameters = { shapes: n, curveSegments: e })
					const i = [],
						r = [],
						o = [],
						s = []
					let a = 0,
						c = 0
					if (!1 === Array.isArray(n)) l(n)
					else for (let d = 0; d < n.length; d++) l(n[d]), this.addGroup(a, c, d), (a += c), (c = 0)
					function l(d) {
						const u = r.length / 3,
							h = d.extractPoints(e)
						let f = h.shape
						const _ = h.holes
						!1 === Uu.isClockWise(f) && (f = f.reverse())
						for (let C = 0, x = _.length; C < x; C++) {
							const w = _[C]
							!0 === Uu.isClockWise(w) && (_[C] = w.reverse())
						}
						const y = Uu.triangulateShape(f, _)
						for (let C = 0, x = _.length; C < x; C++) f = f.concat(_[C])
						for (let C = 0, x = f.length; C < x; C++) {
							const w = f[C]
							r.push(w.x, w.y, 0), o.push(0, 0, 1), s.push(w.x, w.y)
						}
						for (let C = 0, x = y.length; C < x; C++) {
							const w = y[C]
							i.push(w[0] + u, w[1] + u, w[2] + u), (c += 3)
						}
					}
					this.setIndex(i),
						this.setAttribute("position", new cn(r, 3)),
						this.setAttribute("normal", new cn(o, 3)),
						this.setAttribute("uv", new cn(s, 2))
				}
				toJSON() {
					const n = vn.prototype.toJSON.call(this)
					return (function aCe(t, n) {
						if (((n.shapes = []), Array.isArray(t))) for (let e = 0, i = t.length; e < i; e++) n.shapes.push(t[e].uuid)
						else n.shapes.push(t.uuid)
						return n
					})(this.parameters.shapes, n)
				}
			}
			class $y extends vn {
				constructor(n = 1, e = 8, i = 6, r = 0, o = 2 * Math.PI, s = 0, a = Math.PI) {
					super(),
						(this.type = "SphereGeometry"),
						(this.parameters = {
							radius: n,
							widthSegments: e,
							heightSegments: i,
							phiStart: r,
							phiLength: o,
							thetaStart: s,
							thetaLength: a
						}),
						(e = Math.max(3, Math.floor(e))),
						(i = Math.max(2, Math.floor(i)))
					const c = Math.min(s + a, Math.PI)
					let l = 0
					const d = [],
						u = new K(),
						h = new K(),
						f = [],
						_ = [],
						y = [],
						C = []
					for (let x = 0; x <= i; x++) {
						const w = [],
							S = x / i
						let M = 0
						0 == x && 0 == s ? (M = 0.5 / e) : x == i && c == Math.PI && (M = -0.5 / e)
						for (let O = 0; O <= e; O++) {
							const N = O / e
							;(u.x = -n * Math.cos(r + N * o) * Math.sin(s + S * a)),
								(u.y = n * Math.cos(s + S * a)),
								(u.z = n * Math.sin(r + N * o) * Math.sin(s + S * a)),
								_.push(u.x, u.y, u.z),
								h.copy(u).normalize(),
								y.push(h.x, h.y, h.z),
								C.push(N + M, 1 - S),
								w.push(l++)
						}
						d.push(w)
					}
					for (let x = 0; x < i; x++)
						for (let w = 0; w < e; w++) {
							const M = d[x][w],
								O = d[x + 1][w],
								N = d[x + 1][w + 1]
							;(0 !== x || s > 0) && f.push(d[x][w + 1], M, N), (x !== i - 1 || c < Math.PI) && f.push(M, O, N)
						}
					this.setIndex(f),
						this.setAttribute("position", new cn(_, 3)),
						this.setAttribute("normal", new cn(y, 3)),
						this.setAttribute("uv", new cn(C, 2))
				}
			}
			class fS extends lf {
				constructor(n = 1, e = 0) {
					super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], n, e),
						(this.type = "TetrahedronGeometry"),
						(this.parameters = { radius: n, detail: e })
				}
			}
			class mS extends Hu {
				constructor(n, e = {}) {
					const i = e.font
					if (!i || !i.isFont)
						return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new vn()
					const r = i.generateShapes(n, e.size)
					;(e.depth = void 0 !== e.height ? e.height : 50),
						void 0 === e.bevelThickness && (e.bevelThickness = 10),
						void 0 === e.bevelSize && (e.bevelSize = 8),
						void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
						super(r, e),
						(this.type = "TextGeometry")
				}
			}
			class pS extends vn {
				constructor(n = 1, e = 0.4, i = 8, r = 6, o = 2 * Math.PI) {
					super(),
						(this.type = "TorusGeometry"),
						(this.parameters = { radius: n, tube: e, radialSegments: i, tubularSegments: r, arc: o }),
						(i = Math.floor(i)),
						(r = Math.floor(r))
					const s = [],
						a = [],
						c = [],
						l = [],
						d = new K(),
						u = new K(),
						h = new K()
					for (let f = 0; f <= i; f++)
						for (let _ = 0; _ <= r; _++) {
							const y = (_ / r) * o,
								C = (f / i) * Math.PI * 2
							;(u.x = (n + e * Math.cos(C)) * Math.cos(y)),
								(u.y = (n + e * Math.cos(C)) * Math.sin(y)),
								(u.z = e * Math.sin(C)),
								a.push(u.x, u.y, u.z),
								(d.x = n * Math.cos(y)),
								(d.y = n * Math.sin(y)),
								h.subVectors(u, d).normalize(),
								c.push(h.x, h.y, h.z),
								l.push(_ / r),
								l.push(f / i)
						}
					for (let f = 1; f <= i; f++)
						for (let _ = 1; _ <= r; _++) {
							const C = (r + 1) * (f - 1) + _ - 1,
								x = (r + 1) * (f - 1) + _,
								w = (r + 1) * f + _
							s.push((r + 1) * f + _ - 1, C, w), s.push(C, x, w)
						}
					this.setIndex(s),
						this.setAttribute("position", new cn(a, 3)),
						this.setAttribute("normal", new cn(c, 3)),
						this.setAttribute("uv", new cn(l, 2))
				}
			}
			class AS extends vn {
				constructor(n = 1, e = 0.4, i = 64, r = 8, o = 2, s = 3) {
					super(),
						(this.type = "TorusKnotGeometry"),
						(this.parameters = { radius: n, tube: e, tubularSegments: i, radialSegments: r, p: o, q: s }),
						(i = Math.floor(i)),
						(r = Math.floor(r))
					const a = [],
						c = [],
						l = [],
						d = [],
						u = new K(),
						h = new K(),
						f = new K(),
						_ = new K(),
						y = new K(),
						C = new K(),
						x = new K()
					for (let S = 0; S <= i; ++S) {
						const M = (S / i) * o * Math.PI * 2
						w(M, o, s, n, f),
							w(M + 0.01, o, s, n, _),
							C.subVectors(_, f),
							x.addVectors(_, f),
							y.crossVectors(C, x),
							x.crossVectors(y, C),
							y.normalize(),
							x.normalize()
						for (let O = 0; O <= r; ++O) {
							const N = (O / r) * Math.PI * 2,
								j = -e * Math.cos(N),
								le = e * Math.sin(N)
							;(u.x = f.x + (j * x.x + le * y.x)),
								(u.y = f.y + (j * x.y + le * y.y)),
								(u.z = f.z + (j * x.z + le * y.z)),
								c.push(u.x, u.y, u.z),
								h.subVectors(u, f).normalize(),
								l.push(h.x, h.y, h.z),
								d.push(S / i),
								d.push(O / r)
						}
					}
					for (let S = 1; S <= i; S++)
						for (let M = 1; M <= r; M++) {
							const N = (r + 1) * S + (M - 1),
								j = (r + 1) * S + M,
								le = (r + 1) * (S - 1) + M
							a.push((r + 1) * (S - 1) + (M - 1), N, le), a.push(N, j, le)
						}
					function w(S, M, O, N, j) {
						const le = Math.cos(S),
							ae = Math.sin(S),
							ce = (O / M) * S,
							ue = Math.cos(ce)
						;(j.x = N * (2 + ue) * 0.5 * le), (j.y = N * (2 + ue) * ae * 0.5), (j.z = N * Math.sin(ce) * 0.5)
					}
					this.setIndex(a),
						this.setAttribute("position", new cn(c, 3)),
						this.setAttribute("normal", new cn(l, 3)),
						this.setAttribute("uv", new cn(d, 2))
				}
			}
			class gS extends vn {
				constructor(n, e = 64, i = 1, r = 8, o = !1) {
					super(),
						(this.type = "TubeGeometry"),
						(this.parameters = { path: n, tubularSegments: e, radius: i, radialSegments: r, closed: o })
					const s = n.computeFrenetFrames(e, o)
					;(this.tangents = s.tangents), (this.normals = s.normals), (this.binormals = s.binormals)
					const a = new K(),
						c = new K(),
						l = new lt()
					let d = new K()
					const u = [],
						h = [],
						f = [],
						_ = []
					function C(S) {
						d = n.getPointAt(S / e, d)
						const M = s.normals[S],
							O = s.binormals[S]
						for (let N = 0; N <= r; N++) {
							const j = (N / r) * Math.PI * 2,
								le = Math.sin(j),
								ae = -Math.cos(j)
							;(c.x = ae * M.x + le * O.x),
								(c.y = ae * M.y + le * O.y),
								(c.z = ae * M.z + le * O.z),
								c.normalize(),
								h.push(c.x, c.y, c.z),
								(a.x = d.x + i * c.x),
								(a.y = d.y + i * c.y),
								(a.z = d.z + i * c.z),
								u.push(a.x, a.y, a.z)
						}
					}
					;(function y() {
						for (let S = 0; S < e; S++) C(S)
						C(!1 === o ? e : 0),
							(function w() {
								for (let S = 0; S <= e; S++) for (let M = 0; M <= r; M++) (l.x = S / e), (l.y = M / r), f.push(l.x, l.y)
							})(),
							(function x() {
								for (let S = 1; S <= e; S++)
									for (let M = 1; M <= r; M++) {
										const N = (r + 1) * S + (M - 1),
											j = (r + 1) * S + M,
											le = (r + 1) * (S - 1) + M
										_.push((r + 1) * (S - 1) + (M - 1), N, le), _.push(N, j, le)
									}
							})()
					})(),
						this.setIndex(_),
						this.setAttribute("position", new cn(u, 3)),
						this.setAttribute("normal", new cn(h, 3)),
						this.setAttribute("uv", new cn(f, 2))
				}
				toJSON() {
					const n = vn.prototype.toJSON.call(this)
					return (n.path = this.parameters.path.toJSON()), n
				}
			}
			class rP extends vn {
				constructor(n) {
					if ((super(), (this.type = "WireframeGeometry"), !0 === n.isGeometry))
						return void console.error(
							"THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
						)
					const e = [],
						i = [0, 0],
						r = {},
						o = new K()
					if (null !== n.index) {
						const s = n.attributes.position,
							a = n.index
						let c = n.groups
						0 === c.length && (c = [{ start: 0, count: a.count, materialIndex: 0 }])
						for (let l = 0, d = c.length; l < d; ++l) {
							const u = c[l],
								h = u.start
							for (let _ = h, y = h + u.count; _ < y; _ += 3)
								for (let C = 0; C < 3; C++) {
									const x = a.getX(_ + C),
										w = a.getX(_ + ((C + 1) % 3))
									;(i[0] = Math.min(x, w)), (i[1] = Math.max(x, w))
									const S = i[0] + "," + i[1]
									void 0 === r[S] && (r[S] = { index1: i[0], index2: i[1] })
								}
						}
						for (const l in r) {
							const d = r[l]
							o.fromBufferAttribute(s, d.index1),
								e.push(o.x, o.y, o.z),
								o.fromBufferAttribute(s, d.index2),
								e.push(o.x, o.y, o.z)
						}
					} else {
						const s = n.attributes.position
						for (let a = 0, c = s.count / 3; a < c; a++)
							for (let l = 0; l < 3; l++)
								o.fromBufferAttribute(s, 3 * a + l),
									e.push(o.x, o.y, o.z),
									o.fromBufferAttribute(s, 3 * a + ((l + 1) % 3)),
									e.push(o.x, o.y, o.z)
					}
					this.setAttribute("position", new cn(e, 3))
				}
			}
			var Aa = Object.freeze({
				__proto__: null,
				BoxGeometry: _l,
				BoxBufferGeometry: _l,
				CircleGeometry: tS,
				CircleBufferGeometry: tS,
				ConeGeometry: nS,
				ConeBufferGeometry: nS,
				CylinderGeometry: lb,
				CylinderBufferGeometry: lb,
				DodecahedronGeometry: iS,
				DodecahedronBufferGeometry: iS,
				EdgesGeometry: tP,
				ExtrudeGeometry: Hu,
				ExtrudeBufferGeometry: Hu,
				IcosahedronGeometry: dS,
				IcosahedronBufferGeometry: dS,
				LatheGeometry: uS,
				LatheBufferGeometry: uS,
				OctahedronGeometry: zy,
				OctahedronBufferGeometry: zy,
				ParametricGeometry: mp,
				ParametricBufferGeometry: mp,
				PlaneGeometry: sf,
				PlaneBufferGeometry: sf,
				PolyhedronGeometry: lf,
				PolyhedronBufferGeometry: lf,
				RingGeometry: hS,
				RingBufferGeometry: hS,
				ShapeGeometry: Gy,
				ShapeBufferGeometry: Gy,
				SphereGeometry: $y,
				SphereBufferGeometry: $y,
				TetrahedronGeometry: fS,
				TetrahedronBufferGeometry: fS,
				TextGeometry: mS,
				TextBufferGeometry: mS,
				TorusGeometry: pS,
				TorusBufferGeometry: pS,
				TorusKnotGeometry: AS,
				TorusKnotBufferGeometry: AS,
				TubeGeometry: gS,
				TubeBufferGeometry: gS,
				WireframeGeometry: rP
			})
			class oP extends jr {
				constructor(n) {
					super(), (this.type = "ShadowMaterial"), (this.color = new Lt(0)), (this.transparent = !0), this.setValues(n)
				}
				copy(n) {
					return super.copy(n), this.color.copy(n.color), this
				}
			}
			oP.prototype.isShadowMaterial = !0
			class ub extends Ds {
				constructor(n) {
					super(n), (this.type = "RawShaderMaterial")
				}
			}
			function Md(t) {
				jr.call(this),
					(this.defines = { STANDARD: "" }),
					(this.type = "MeshStandardMaterial"),
					(this.color = new Lt(16777215)),
					(this.roughness = 1),
					(this.metalness = 0),
					(this.map = null),
					(this.lightMap = null),
					(this.lightMapIntensity = 1),
					(this.aoMap = null),
					(this.aoMapIntensity = 1),
					(this.emissive = new Lt(0)),
					(this.emissiveIntensity = 1),
					(this.emissiveMap = null),
					(this.bumpMap = null),
					(this.bumpScale = 1),
					(this.normalMap = null),
					(this.normalMapType = rp),
					(this.normalScale = new lt(1, 1)),
					(this.displacementMap = null),
					(this.displacementScale = 1),
					(this.displacementBias = 0),
					(this.roughnessMap = null),
					(this.metalnessMap = null),
					(this.alphaMap = null),
					(this.envMap = null),
					(this.envMapIntensity = 1),
					(this.refractionRatio = 0.98),
					(this.wireframe = !1),
					(this.wireframeLinewidth = 1),
					(this.wireframeLinecap = "round"),
					(this.wireframeLinejoin = "round"),
					(this.skinning = !1),
					(this.morphTargets = !1),
					(this.morphNormals = !1),
					(this.flatShading = !1),
					(this.vertexTangents = !1),
					this.setValues(t)
			}
			function uf(t) {
				Md.call(this),
					(this.defines = { STANDARD: "", PHYSICAL: "" }),
					(this.type = "MeshPhysicalMaterial"),
					(this.clearcoat = 0),
					(this.clearcoatMap = null),
					(this.clearcoatRoughness = 0),
					(this.clearcoatRoughnessMap = null),
					(this.clearcoatNormalScale = new lt(1, 1)),
					(this.clearcoatNormalMap = null),
					(this.reflectivity = 0.5),
					Object.defineProperty(this, "ior", {
						get: function () {
							return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
						},
						set: function (n) {
							this.reflectivity = jn.clamp((2.5 * (n - 1)) / (n + 1), 0, 1)
						}
					}),
					(this.sheen = null),
					(this.transmission = 0),
					(this.transmissionMap = null),
					this.setValues(t)
			}
			;(ub.prototype.isRawShaderMaterial = !0),
				((Md.prototype = Object.create(jr.prototype)).constructor = Md),
				(Md.prototype.isMeshStandardMaterial = !0),
				(Md.prototype.copy = function (t) {
					return (
						jr.prototype.copy.call(this, t),
						(this.defines = { STANDARD: "" }),
						this.color.copy(t.color),
						(this.roughness = t.roughness),
						(this.metalness = t.metalness),
						(this.map = t.map),
						(this.lightMap = t.lightMap),
						(this.lightMapIntensity = t.lightMapIntensity),
						(this.aoMap = t.aoMap),
						(this.aoMapIntensity = t.aoMapIntensity),
						this.emissive.copy(t.emissive),
						(this.emissiveMap = t.emissiveMap),
						(this.emissiveIntensity = t.emissiveIntensity),
						(this.bumpMap = t.bumpMap),
						(this.bumpScale = t.bumpScale),
						(this.normalMap = t.normalMap),
						(this.normalMapType = t.normalMapType),
						this.normalScale.copy(t.normalScale),
						(this.displacementMap = t.displacementMap),
						(this.displacementScale = t.displacementScale),
						(this.displacementBias = t.displacementBias),
						(this.roughnessMap = t.roughnessMap),
						(this.metalnessMap = t.metalnessMap),
						(this.alphaMap = t.alphaMap),
						(this.envMap = t.envMap),
						(this.envMapIntensity = t.envMapIntensity),
						(this.refractionRatio = t.refractionRatio),
						(this.wireframe = t.wireframe),
						(this.wireframeLinewidth = t.wireframeLinewidth),
						(this.wireframeLinecap = t.wireframeLinecap),
						(this.wireframeLinejoin = t.wireframeLinejoin),
						(this.skinning = t.skinning),
						(this.morphTargets = t.morphTargets),
						(this.morphNormals = t.morphNormals),
						(this.flatShading = t.flatShading),
						(this.vertexTangents = t.vertexTangents),
						this
					)
				}),
				((uf.prototype = Object.create(Md.prototype)).constructor = uf),
				(uf.prototype.isMeshPhysicalMaterial = !0),
				(uf.prototype.copy = function (t) {
					return (
						Md.prototype.copy.call(this, t),
						(this.defines = { STANDARD: "", PHYSICAL: "" }),
						(this.clearcoat = t.clearcoat),
						(this.clearcoatMap = t.clearcoatMap),
						(this.clearcoatRoughness = t.clearcoatRoughness),
						(this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
						(this.clearcoatNormalMap = t.clearcoatNormalMap),
						this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
						(this.reflectivity = t.reflectivity),
						(this.sheen = t.sheen ? (this.sheen || new Lt()).copy(t.sheen) : null),
						(this.transmission = t.transmission),
						(this.transmissionMap = t.transmissionMap),
						this
					)
				})
			class bS extends jr {
				constructor(n) {
					super(),
						(this.type = "MeshPhongMaterial"),
						(this.color = new Lt(16777215)),
						(this.specular = new Lt(1118481)),
						(this.shininess = 30),
						(this.map = null),
						(this.lightMap = null),
						(this.lightMapIntensity = 1),
						(this.aoMap = null),
						(this.aoMapIntensity = 1),
						(this.emissive = new Lt(0)),
						(this.emissiveIntensity = 1),
						(this.emissiveMap = null),
						(this.bumpMap = null),
						(this.bumpScale = 1),
						(this.normalMap = null),
						(this.normalMapType = rp),
						(this.normalScale = new lt(1, 1)),
						(this.displacementMap = null),
						(this.displacementScale = 1),
						(this.displacementBias = 0),
						(this.specularMap = null),
						(this.alphaMap = null),
						(this.envMap = null),
						(this.combine = ty),
						(this.reflectivity = 1),
						(this.refractionRatio = 0.98),
						(this.wireframe = !1),
						(this.wireframeLinewidth = 1),
						(this.wireframeLinecap = "round"),
						(this.wireframeLinejoin = "round"),
						(this.skinning = !1),
						(this.morphTargets = !1),
						(this.morphNormals = !1),
						(this.flatShading = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						this.color.copy(n.color),
						this.specular.copy(n.specular),
						(this.shininess = n.shininess),
						(this.map = n.map),
						(this.lightMap = n.lightMap),
						(this.lightMapIntensity = n.lightMapIntensity),
						(this.aoMap = n.aoMap),
						(this.aoMapIntensity = n.aoMapIntensity),
						this.emissive.copy(n.emissive),
						(this.emissiveMap = n.emissiveMap),
						(this.emissiveIntensity = n.emissiveIntensity),
						(this.bumpMap = n.bumpMap),
						(this.bumpScale = n.bumpScale),
						(this.normalMap = n.normalMap),
						(this.normalMapType = n.normalMapType),
						this.normalScale.copy(n.normalScale),
						(this.displacementMap = n.displacementMap),
						(this.displacementScale = n.displacementScale),
						(this.displacementBias = n.displacementBias),
						(this.specularMap = n.specularMap),
						(this.alphaMap = n.alphaMap),
						(this.envMap = n.envMap),
						(this.combine = n.combine),
						(this.reflectivity = n.reflectivity),
						(this.refractionRatio = n.refractionRatio),
						(this.wireframe = n.wireframe),
						(this.wireframeLinewidth = n.wireframeLinewidth),
						(this.wireframeLinecap = n.wireframeLinecap),
						(this.wireframeLinejoin = n.wireframeLinejoin),
						(this.skinning = n.skinning),
						(this.morphTargets = n.morphTargets),
						(this.morphNormals = n.morphNormals),
						(this.flatShading = n.flatShading),
						this
					)
				}
			}
			bS.prototype.isMeshPhongMaterial = !0
			class sP extends jr {
				constructor(n) {
					super(),
						(this.defines = { TOON: "" }),
						(this.type = "MeshToonMaterial"),
						(this.color = new Lt(16777215)),
						(this.map = null),
						(this.gradientMap = null),
						(this.lightMap = null),
						(this.lightMapIntensity = 1),
						(this.aoMap = null),
						(this.aoMapIntensity = 1),
						(this.emissive = new Lt(0)),
						(this.emissiveIntensity = 1),
						(this.emissiveMap = null),
						(this.bumpMap = null),
						(this.bumpScale = 1),
						(this.normalMap = null),
						(this.normalMapType = rp),
						(this.normalScale = new lt(1, 1)),
						(this.displacementMap = null),
						(this.displacementScale = 1),
						(this.displacementBias = 0),
						(this.alphaMap = null),
						(this.wireframe = !1),
						(this.wireframeLinewidth = 1),
						(this.wireframeLinecap = "round"),
						(this.wireframeLinejoin = "round"),
						(this.skinning = !1),
						(this.morphTargets = !1),
						(this.morphNormals = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						this.color.copy(n.color),
						(this.map = n.map),
						(this.gradientMap = n.gradientMap),
						(this.lightMap = n.lightMap),
						(this.lightMapIntensity = n.lightMapIntensity),
						(this.aoMap = n.aoMap),
						(this.aoMapIntensity = n.aoMapIntensity),
						this.emissive.copy(n.emissive),
						(this.emissiveMap = n.emissiveMap),
						(this.emissiveIntensity = n.emissiveIntensity),
						(this.bumpMap = n.bumpMap),
						(this.bumpScale = n.bumpScale),
						(this.normalMap = n.normalMap),
						(this.normalMapType = n.normalMapType),
						this.normalScale.copy(n.normalScale),
						(this.displacementMap = n.displacementMap),
						(this.displacementScale = n.displacementScale),
						(this.displacementBias = n.displacementBias),
						(this.alphaMap = n.alphaMap),
						(this.wireframe = n.wireframe),
						(this.wireframeLinewidth = n.wireframeLinewidth),
						(this.wireframeLinecap = n.wireframeLinecap),
						(this.wireframeLinejoin = n.wireframeLinejoin),
						(this.skinning = n.skinning),
						(this.morphTargets = n.morphTargets),
						(this.morphNormals = n.morphNormals),
						this
					)
				}
			}
			sP.prototype.isMeshToonMaterial = !0
			class _S extends jr {
				constructor(n) {
					super(),
						(this.type = "MeshNormalMaterial"),
						(this.bumpMap = null),
						(this.bumpScale = 1),
						(this.normalMap = null),
						(this.normalMapType = rp),
						(this.normalScale = new lt(1, 1)),
						(this.displacementMap = null),
						(this.displacementScale = 1),
						(this.displacementBias = 0),
						(this.wireframe = !1),
						(this.wireframeLinewidth = 1),
						(this.fog = !1),
						(this.skinning = !1),
						(this.morphTargets = !1),
						(this.morphNormals = !1),
						(this.flatShading = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						(this.bumpMap = n.bumpMap),
						(this.bumpScale = n.bumpScale),
						(this.normalMap = n.normalMap),
						(this.normalMapType = n.normalMapType),
						this.normalScale.copy(n.normalScale),
						(this.displacementMap = n.displacementMap),
						(this.displacementScale = n.displacementScale),
						(this.displacementBias = n.displacementBias),
						(this.wireframe = n.wireframe),
						(this.wireframeLinewidth = n.wireframeLinewidth),
						(this.skinning = n.skinning),
						(this.morphTargets = n.morphTargets),
						(this.morphNormals = n.morphNormals),
						(this.flatShading = n.flatShading),
						this
					)
				}
			}
			_S.prototype.isMeshNormalMaterial = !0
			class hb extends jr {
				constructor(n) {
					super(),
						(this.type = "MeshLambertMaterial"),
						(this.color = new Lt(16777215)),
						(this.map = null),
						(this.lightMap = null),
						(this.lightMapIntensity = 1),
						(this.aoMap = null),
						(this.aoMapIntensity = 1),
						(this.emissive = new Lt(0)),
						(this.emissiveIntensity = 1),
						(this.emissiveMap = null),
						(this.specularMap = null),
						(this.alphaMap = null),
						(this.envMap = null),
						(this.combine = ty),
						(this.reflectivity = 1),
						(this.refractionRatio = 0.98),
						(this.wireframe = !1),
						(this.wireframeLinewidth = 1),
						(this.wireframeLinecap = "round"),
						(this.wireframeLinejoin = "round"),
						(this.skinning = !1),
						(this.morphTargets = !1),
						(this.morphNormals = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						this.color.copy(n.color),
						(this.map = n.map),
						(this.lightMap = n.lightMap),
						(this.lightMapIntensity = n.lightMapIntensity),
						(this.aoMap = n.aoMap),
						(this.aoMapIntensity = n.aoMapIntensity),
						this.emissive.copy(n.emissive),
						(this.emissiveMap = n.emissiveMap),
						(this.emissiveIntensity = n.emissiveIntensity),
						(this.specularMap = n.specularMap),
						(this.alphaMap = n.alphaMap),
						(this.envMap = n.envMap),
						(this.combine = n.combine),
						(this.reflectivity = n.reflectivity),
						(this.refractionRatio = n.refractionRatio),
						(this.wireframe = n.wireframe),
						(this.wireframeLinewidth = n.wireframeLinewidth),
						(this.wireframeLinecap = n.wireframeLinecap),
						(this.wireframeLinejoin = n.wireframeLinejoin),
						(this.skinning = n.skinning),
						(this.morphTargets = n.morphTargets),
						(this.morphNormals = n.morphNormals),
						this
					)
				}
			}
			hb.prototype.isMeshLambertMaterial = !0
			class aP extends jr {
				constructor(n) {
					super(),
						(this.defines = { MATCAP: "" }),
						(this.type = "MeshMatcapMaterial"),
						(this.color = new Lt(16777215)),
						(this.matcap = null),
						(this.map = null),
						(this.bumpMap = null),
						(this.bumpScale = 1),
						(this.normalMap = null),
						(this.normalMapType = rp),
						(this.normalScale = new lt(1, 1)),
						(this.displacementMap = null),
						(this.displacementScale = 1),
						(this.displacementBias = 0),
						(this.alphaMap = null),
						(this.skinning = !1),
						(this.morphTargets = !1),
						(this.morphNormals = !1),
						(this.flatShading = !1),
						this.setValues(n)
				}
				copy(n) {
					return (
						super.copy(n),
						(this.defines = { MATCAP: "" }),
						this.color.copy(n.color),
						(this.matcap = n.matcap),
						(this.map = n.map),
						(this.bumpMap = n.bumpMap),
						(this.bumpScale = n.bumpScale),
						(this.normalMap = n.normalMap),
						(this.normalMapType = n.normalMapType),
						this.normalScale.copy(n.normalScale),
						(this.displacementMap = n.displacementMap),
						(this.displacementScale = n.displacementScale),
						(this.displacementBias = n.displacementBias),
						(this.alphaMap = n.alphaMap),
						(this.skinning = n.skinning),
						(this.morphTargets = n.morphTargets),
						(this.morphNormals = n.morphNormals),
						(this.flatShading = n.flatShading),
						this
					)
				}
			}
			aP.prototype.isMeshMatcapMaterial = !0
			class cP extends Go {
				constructor(n) {
					super(),
						(this.type = "LineDashedMaterial"),
						(this.scale = 1),
						(this.dashSize = 3),
						(this.gapSize = 1),
						this.setValues(n)
				}
				copy(n) {
					return super.copy(n), (this.scale = n.scale), (this.dashSize = n.dashSize), (this.gapSize = n.gapSize), this
				}
			}
			cP.prototype.isLineDashedMaterial = !0
			var cCe = Object.freeze({
				__proto__: null,
				ShadowMaterial: oP,
				SpriteMaterial: Iy,
				RawShaderMaterial: ub,
				ShaderMaterial: Ds,
				PointsMaterial: fp,
				MeshPhysicalMaterial: uf,
				MeshStandardMaterial: Md,
				MeshPhongMaterial: bS,
				MeshToonMaterial: sP,
				MeshNormalMaterial: _S,
				MeshLambertMaterial: hb,
				MeshDepthMaterial: zM,
				MeshDistanceMaterial: GM,
				MeshBasicMaterial: Cd,
				MeshMatcapMaterial: aP,
				LineDashedMaterial: cP,
				LineBasicMaterial: Go,
				Material: jr
			})
			const Kr = {
				arraySlice: function (t, n, e) {
					return Kr.isTypedArray(t) ? new t.constructor(t.subarray(n, void 0 !== e ? e : t.length)) : t.slice(n, e)
				},
				convertArray: function (t, n, e) {
					return !t || (!e && t.constructor === n)
						? t
						: "number" == typeof n.BYTES_PER_ELEMENT
						? new n(t)
						: Array.prototype.slice.call(t)
				},
				isTypedArray: function (t) {
					return ArrayBuffer.isView(t) && !(t instanceof DataView)
				},
				getKeyframeOrder: function (t) {
					const e = t.length,
						i = new Array(e)
					for (let r = 0; r !== e; ++r) i[r] = r
					return (
						i.sort(function n(r, o) {
							return t[r] - t[o]
						}),
						i
					)
				},
				sortedArray: function (t, n, e) {
					const i = t.length,
						r = new t.constructor(i)
					for (let o = 0, s = 0; s !== i; ++o) {
						const a = e[o] * n
						for (let c = 0; c !== n; ++c) r[s++] = t[a + c]
					}
					return r
				},
				flattenJSON: function (t, n, e, i) {
					let r = 1,
						o = t[0]
					for (; void 0 !== o && void 0 === o[i]; ) o = t[r++]
					if (void 0 === o) return
					let s = o[i]
					if (void 0 !== s)
						if (Array.isArray(s))
							do {
								;(s = o[i]), void 0 !== s && (n.push(o.time), e.push.apply(e, s)), (o = t[r++])
							} while (void 0 !== o)
						else if (void 0 !== s.toArray)
							do {
								;(s = o[i]), void 0 !== s && (n.push(o.time), s.toArray(e, e.length)), (o = t[r++])
							} while (void 0 !== o)
						else
							do {
								;(s = o[i]), void 0 !== s && (n.push(o.time), e.push(s)), (o = t[r++])
							} while (void 0 !== o)
				},
				subclip: function (t, n, e, i, r = 30) {
					const o = t.clone()
					o.name = n
					const s = []
					for (let c = 0; c < o.tracks.length; ++c) {
						const l = o.tracks[c],
							d = l.getValueSize(),
							u = [],
							h = []
						for (let f = 0; f < l.times.length; ++f) {
							const _ = l.times[f] * r
							if (!(_ < e || _ >= i)) {
								u.push(l.times[f])
								for (let y = 0; y < d; ++y) h.push(l.values[f * d + y])
							}
						}
						0 !== u.length &&
							((l.times = Kr.convertArray(u, l.times.constructor)),
							(l.values = Kr.convertArray(h, l.values.constructor)),
							s.push(l))
					}
					o.tracks = s
					let a = 1 / 0
					for (let c = 0; c < o.tracks.length; ++c) a > o.tracks[c].times[0] && (a = o.tracks[c].times[0])
					for (let c = 0; c < o.tracks.length; ++c) o.tracks[c].shift(-1 * a)
					return o.resetDuration(), o
				},
				makeClipAdditive: function (t, n = 0, e = t, i = 30) {
					i <= 0 && (i = 30)
					const r = e.tracks.length,
						o = n / i
					for (let s = 0; s < r; ++s) {
						const a = e.tracks[s],
							c = a.ValueTypeName
						if ("bool" === c || "string" === c) continue
						const l = t.tracks.find(function (x) {
							return x.name === a.name && x.ValueTypeName === c
						})
						if (void 0 === l) continue
						let d = 0
						const u = a.getValueSize()
						a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = u / 3)
						let h = 0
						const f = l.getValueSize()
						l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = f / 3)
						const _ = a.times.length - 1
						let y
						if (o <= a.times[0]) y = Kr.arraySlice(a.values, d, u - d)
						else if (o >= a.times[_]) {
							const x = _ * u + d
							y = Kr.arraySlice(a.values, x, x + u - d)
						} else {
							const x = a.createInterpolant(),
								w = d,
								S = u - d
							x.evaluate(o), (y = Kr.arraySlice(x.resultBuffer, w, S))
						}
						"quaternion" === c && new fs().fromArray(y).normalize().conjugate().toArray(y)
						const C = l.times.length
						for (let x = 0; x < C; ++x) {
							const w = x * f + h
							if ("quaternion" === c) fs.multiplyQuaternionsFlat(l.values, w, y, 0, l.values, w)
							else {
								const S = f - 2 * h
								for (let M = 0; M < S; ++M) l.values[w + M] -= y[M]
							}
						}
					}
					return (t.blendMode = AR), t
				}
			}
			function ac(t, n, e, i) {
				;(this.parameterPositions = t),
					(this._cachedIndex = 0),
					(this.resultBuffer = void 0 !== i ? i : new n.constructor(e)),
					(this.sampleValues = n),
					(this.valueSize = e)
			}
			function vS(t, n, e, i) {
				ac.call(this, t, n, e, i),
					(this._weightPrev = -0),
					(this._offsetPrev = -0),
					(this._weightNext = -0),
					(this._offsetNext = -0)
			}
			function Wy(t, n, e, i) {
				ac.call(this, t, n, e, i)
			}
			function yS(t, n, e, i) {
				ac.call(this, t, n, e, i)
			}
			Object.assign(ac.prototype, {
				evaluate: function (t) {
					const n = this.parameterPositions
					let e = this._cachedIndex,
						i = n[e],
						r = n[e - 1]
					e: {
						t: {
							let o
							n: {
								i: if (!(t < i)) {
									for (let s = e + 2; ; ) {
										if (void 0 === i) {
											if (t < r) break i
											return (e = n.length), (this._cachedIndex = e), this.afterEnd_(e - 1, t, r)
										}
										if (e === s) break
										if (((r = i), (i = n[++e]), t < i)) break t
									}
									o = n.length
									break n
								}
								if (t >= r) break e
								{
									const s = n[1]
									t < s && ((e = 2), (r = s))
									for (let a = e - 2; ; ) {
										if (void 0 === r) return (this._cachedIndex = 0), this.beforeStart_(0, t, i)
										if (e === a) break
										if (((i = r), (r = n[--e - 1]), t >= r)) break t
									}
									;(o = e), (e = 0)
								}
							}
							for (; e < o; ) {
								const s = (e + o) >>> 1
								t < n[s] ? (o = s) : (e = s + 1)
							}
							if (((i = n[e]), (r = n[e - 1]), void 0 === r)) return (this._cachedIndex = 0), this.beforeStart_(0, t, i)
							if (void 0 === i) return (e = n.length), (this._cachedIndex = e), this.afterEnd_(e - 1, r, t)
						}
						;(this._cachedIndex = e), this.intervalChanged_(e, r, i)
					}
					return this.interpolate_(e, r, t, i)
				},
				settings: null,
				DefaultSettings_: {},
				getSettings_: function () {
					return this.settings || this.DefaultSettings_
				},
				copySampleValue_: function (t) {
					const n = this.resultBuffer,
						e = this.sampleValues,
						i = this.valueSize,
						r = t * i
					for (let o = 0; o !== i; ++o) n[o] = e[r + o]
					return n
				},
				interpolate_: function () {
					throw new Error("call to abstract method")
				},
				intervalChanged_: function () {}
			}),
				Object.assign(ac.prototype, { beforeStart_: ac.prototype.copySampleValue_, afterEnd_: ac.prototype.copySampleValue_ }),
				(vS.prototype = Object.assign(Object.create(ac.prototype), {
					constructor: vS,
					DefaultSettings_: { endingStart: np, endingEnd: np },
					intervalChanged_: function (t, n, e) {
						const i = this.parameterPositions
						let r = t - 2,
							o = t + 1,
							s = i[r],
							a = i[o]
						if (void 0 === s)
							switch (this.getSettings_().endingStart) {
								case ip:
									;(r = t), (s = 2 * n - e)
									break
								case uy:
									;(r = i.length - 2), (s = n + i[r] - i[r + 1])
									break
								default:
									;(r = t), (s = e)
							}
						if (void 0 === a)
							switch (this.getSettings_().endingEnd) {
								case ip:
									;(o = t), (a = 2 * e - n)
									break
								case uy:
									;(o = 1), (a = e + i[1] - i[0])
									break
								default:
									;(o = t - 1), (a = n)
							}
						const c = 0.5 * (e - n),
							l = this.valueSize
						;(this._weightPrev = c / (n - s)),
							(this._weightNext = c / (a - e)),
							(this._offsetPrev = r * l),
							(this._offsetNext = o * l)
					},
					interpolate_: function (t, n, e, i) {
						const r = this.resultBuffer,
							o = this.sampleValues,
							s = this.valueSize,
							a = t * s,
							c = a - s,
							l = this._offsetPrev,
							d = this._offsetNext,
							u = this._weightPrev,
							h = this._weightNext,
							f = (e - n) / (i - n),
							_ = f * f,
							y = _ * f,
							C = -u * y + 2 * u * _ - u * f,
							x = (1 + u) * y + (-1.5 - 2 * u) * _ + (-0.5 + u) * f + 1,
							w = (-1 - h) * y + (1.5 + h) * _ + 0.5 * f,
							S = h * y - h * _
						for (let M = 0; M !== s; ++M) r[M] = C * o[l + M] + x * o[c + M] + w * o[a + M] + S * o[d + M]
						return r
					}
				})),
				(Wy.prototype = Object.assign(Object.create(ac.prototype), {
					constructor: Wy,
					interpolate_: function (t, n, e, i) {
						const r = this.resultBuffer,
							o = this.sampleValues,
							s = this.valueSize,
							a = t * s,
							c = a - s,
							l = (e - n) / (i - n),
							d = 1 - l
						for (let u = 0; u !== s; ++u) r[u] = o[c + u] * d + o[a + u] * l
						return r
					}
				})),
				(yS.prototype = Object.assign(Object.create(ac.prototype), {
					constructor: yS,
					interpolate_: function (t) {
						return this.copySampleValue_(t - 1)
					}
				}))
			class yl {
				constructor(n, e, i, r) {
					if (void 0 === n) throw new Error("THREE.KeyframeTrack: track name is undefined")
					if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + n)
					;(this.name = n),
						(this.times = Kr.convertArray(e, this.TimeBufferType)),
						(this.values = Kr.convertArray(i, this.ValueBufferType)),
						this.setInterpolation(r || this.DefaultInterpolation)
				}
				static toJSON(n) {
					const e = n.constructor
					let i
					if (e.toJSON !== this.toJSON) i = e.toJSON(n)
					else {
						i = { name: n.name, times: Kr.convertArray(n.times, Array), values: Kr.convertArray(n.values, Array) }
						const r = n.getInterpolation()
						r !== n.DefaultInterpolation && (i.interpolation = r)
					}
					return (i.type = n.ValueTypeName), i
				}
				InterpolantFactoryMethodDiscrete(n) {
					return new yS(this.times, this.values, this.getValueSize(), n)
				}
				InterpolantFactoryMethodLinear(n) {
					return new Wy(this.times, this.values, this.getValueSize(), n)
				}
				InterpolantFactoryMethodSmooth(n) {
					return new vS(this.times, this.values, this.getValueSize(), n)
				}
				setInterpolation(n) {
					let e
					switch (n) {
						case ly:
							e = this.InterpolantFactoryMethodDiscrete
							break
						case dy:
							e = this.InterpolantFactoryMethodLinear
							break
						case gM:
							e = this.InterpolantFactoryMethodSmooth
					}
					if (void 0 === e) {
						const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name
						if (void 0 === this.createInterpolant) {
							if (n === this.DefaultInterpolation) throw new Error(i)
							this.setInterpolation(this.DefaultInterpolation)
						}
						return console.warn("THREE.KeyframeTrack:", i), this
					}
					return (this.createInterpolant = e), this
				}
				getInterpolation() {
					switch (this.createInterpolant) {
						case this.InterpolantFactoryMethodDiscrete:
							return ly
						case this.InterpolantFactoryMethodLinear:
							return dy
						case this.InterpolantFactoryMethodSmooth:
							return gM
					}
				}
				getValueSize() {
					return this.values.length / this.times.length
				}
				shift(n) {
					if (0 !== n) {
						const e = this.times
						for (let i = 0, r = e.length; i !== r; ++i) e[i] += n
					}
					return this
				}
				scale(n) {
					if (1 !== n) {
						const e = this.times
						for (let i = 0, r = e.length; i !== r; ++i) e[i] *= n
					}
					return this
				}
				trim(n, e) {
					const i = this.times,
						r = i.length
					let o = 0,
						s = r - 1
					for (; o !== r && i[o] < n; ) ++o
					for (; -1 !== s && i[s] > e; ) --s
					if ((++s, 0 !== o || s !== r)) {
						o >= s && ((s = Math.max(s, 1)), (o = s - 1))
						const a = this.getValueSize()
						;(this.times = Kr.arraySlice(i, o, s)), (this.values = Kr.arraySlice(this.values, o * a, s * a))
					}
					return this
				}
				validate() {
					let n = !0
					const e = this.getValueSize()
					e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), (n = !1))
					const i = this.times,
						r = this.values,
						o = i.length
					0 === o && (console.error("THREE.KeyframeTrack: Track is empty.", this), (n = !1))
					let s = null
					for (let a = 0; a !== o; a++) {
						const c = i[a]
						if ("number" == typeof c && isNaN(c)) {
							console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, c), (n = !1)
							break
						}
						if (null !== s && s > c) {
							console.error("THREE.KeyframeTrack: Out of order keys.", this, a, c, s), (n = !1)
							break
						}
						s = c
					}
					if (void 0 !== r && Kr.isTypedArray(r))
						for (let a = 0, c = r.length; a !== c; ++a) {
							const l = r[a]
							if (isNaN(l)) {
								console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), (n = !1)
								break
							}
						}
					return n
				}
				optimize() {
					const n = Kr.arraySlice(this.times),
						e = Kr.arraySlice(this.values),
						i = this.getValueSize(),
						r = this.getInterpolation() === gM,
						o = n.length - 1
					let s = 1
					for (let a = 1; a < o; ++a) {
						let c = !1
						const l = n[a]
						if (l !== n[a + 1] && (1 !== a || l !== n[0]))
							if (r) c = !0
							else {
								const u = a * i,
									h = u - i,
									f = u + i
								for (let _ = 0; _ !== i; ++_) {
									const y = e[u + _]
									if (y !== e[h + _] || y !== e[f + _]) {
										c = !0
										break
									}
								}
							}
						if (c) {
							if (a !== s) {
								n[s] = n[a]
								const u = a * i,
									h = s * i
								for (let f = 0; f !== i; ++f) e[h + f] = e[u + f]
							}
							++s
						}
					}
					if (o > 0) {
						n[s] = n[o]
						for (let a = o * i, c = s * i, l = 0; l !== i; ++l) e[c + l] = e[a + l]
						++s
					}
					return (
						s !== n.length
							? ((this.times = Kr.arraySlice(n, 0, s)), (this.values = Kr.arraySlice(e, 0, s * i)))
							: ((this.times = n), (this.values = e)),
						this
					)
				}
				clone() {
					const n = Kr.arraySlice(this.times, 0),
						e = Kr.arraySlice(this.values, 0),
						r = new (0, this.constructor)(this.name, n, e)
					return (r.createInterpolant = this.createInterpolant), r
				}
			}
			;(yl.prototype.TimeBufferType = Float32Array),
				(yl.prototype.ValueBufferType = Float32Array),
				(yl.prototype.DefaultInterpolation = dy)
			class pp extends yl {}
			;(pp.prototype.ValueTypeName = "bool"),
				(pp.prototype.ValueBufferType = Array),
				(pp.prototype.DefaultInterpolation = ly),
				(pp.prototype.InterpolantFactoryMethodLinear = void 0),
				(pp.prototype.InterpolantFactoryMethodSmooth = void 0)
			class lP extends yl {}
			lP.prototype.ValueTypeName = "color"
			class jy extends yl {}
			function wS(t, n, e, i) {
				ac.call(this, t, n, e, i)
			}
			;(jy.prototype.ValueTypeName = "number"),
				(wS.prototype = Object.assign(Object.create(ac.prototype), {
					constructor: wS,
					interpolate_: function (t, n, e, i) {
						const r = this.resultBuffer,
							o = this.sampleValues,
							s = this.valueSize,
							a = (e - n) / (i - n)
						let c = t * s
						for (let l = c + s; c !== l; c += 4) fs.slerpFlat(r, 0, o, c - s, o, c, a)
						return r
					}
				}))
			class fb extends yl {
				InterpolantFactoryMethodLinear(n) {
					return new wS(this.times, this.values, this.getValueSize(), n)
				}
			}
			;(fb.prototype.ValueTypeName = "quaternion"),
				(fb.prototype.DefaultInterpolation = dy),
				(fb.prototype.InterpolantFactoryMethodSmooth = void 0)
			class Ap extends yl {}
			;(Ap.prototype.ValueTypeName = "string"),
				(Ap.prototype.ValueBufferType = Array),
				(Ap.prototype.DefaultInterpolation = ly),
				(Ap.prototype.InterpolantFactoryMethodLinear = void 0),
				(Ap.prototype.InterpolantFactoryMethodSmooth = void 0)
			class Ky extends yl {}
			Ky.prototype.ValueTypeName = "vector"
			class Xy {
				constructor(n, e = -1, i, r = bM) {
					;(this.name = n),
						(this.tracks = i),
						(this.duration = e),
						(this.blendMode = r),
						(this.uuid = jn.generateUUID()),
						this.duration < 0 && this.resetDuration()
				}
				static parse(n) {
					const e = [],
						i = n.tracks,
						r = 1 / (n.fps || 1)
					for (let s = 0, a = i.length; s !== a; ++s) e.push(dCe(i[s]).scale(r))
					const o = new this(n.name, n.duration, e, n.blendMode)
					return (o.uuid = n.uuid), o
				}
				static toJSON(n) {
					const e = [],
						i = n.tracks,
						r = { name: n.name, duration: n.duration, tracks: e, uuid: n.uuid, blendMode: n.blendMode }
					for (let o = 0, s = i.length; o !== s; ++o) e.push(yl.toJSON(i[o]))
					return r
				}
				static CreateFromMorphTargetSequence(n, e, i, r) {
					const o = e.length,
						s = []
					for (let a = 0; a < o; a++) {
						let c = [],
							l = []
						c.push((a + o - 1) % o, a, (a + 1) % o), l.push(0, 1, 0)
						const d = Kr.getKeyframeOrder(c)
						;(c = Kr.sortedArray(c, 1, d)),
							(l = Kr.sortedArray(l, 1, d)),
							!r && 0 === c[0] && (c.push(o), l.push(l[0])),
							s.push(new jy(".morphTargetInfluences[" + e[a].name + "]", c, l).scale(1 / i))
					}
					return new this(n, -1, s)
				}
				static findByName(n, e) {
					let i = n
					Array.isArray(n) || (i = (n.geometry && n.geometry.animations) || n.animations)
					for (let r = 0; r < i.length; r++) if (i[r].name === e) return i[r]
					return null
				}
				static CreateClipsFromMorphTargetSequences(n, e, i) {
					const r = {},
						o = /^([\w-]*?)([\d]+)$/
					for (let a = 0, c = n.length; a < c; a++) {
						const l = n[a],
							d = l.name.match(o)
						if (d && d.length > 1) {
							const u = d[1]
							let h = r[u]
							h || (r[u] = h = []), h.push(l)
						}
					}
					const s = []
					for (const a in r) s.push(this.CreateFromMorphTargetSequence(a, r[a], e, i))
					return s
				}
				static parseAnimation(n, e) {
					if (!n) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null
					const i = function (u, h, f, _, y) {
							if (0 !== f.length) {
								const C = [],
									x = []
								Kr.flattenJSON(f, C, x, _), 0 !== C.length && y.push(new u(h, C, x))
							}
						},
						r = [],
						o = n.name || "default",
						s = n.fps || 30,
						a = n.blendMode
					let c = n.length || -1
					const l = n.hierarchy || []
					for (let u = 0; u < l.length; u++) {
						const h = l[u].keys
						if (h && 0 !== h.length)
							if (h[0].morphTargets) {
								const f = {}
								let _
								for (_ = 0; _ < h.length; _++)
									if (h[_].morphTargets) for (let y = 0; y < h[_].morphTargets.length; y++) f[h[_].morphTargets[y]] = -1
								for (const y in f) {
									const C = [],
										x = []
									for (let w = 0; w !== h[_].morphTargets.length; ++w) {
										const S = h[_]
										C.push(S.time), x.push(S.morphTarget === y ? 1 : 0)
									}
									r.push(new jy(".morphTargetInfluence[" + y + "]", C, x))
								}
								c = f.length * (s || 1)
							} else {
								const f = ".bones[" + e[u].name + "]"
								i(Ky, f + ".position", h, "pos", r), i(fb, f + ".quaternion", h, "rot", r), i(Ky, f + ".scale", h, "scl", r)
							}
					}
					return 0 === r.length ? null : new this(o, c, r, a)
				}
				resetDuration() {
					let e = 0
					for (let i = 0, r = this.tracks.length; i !== r; ++i) {
						const o = this.tracks[i]
						e = Math.max(e, o.times[o.times.length - 1])
					}
					return (this.duration = e), this
				}
				trim() {
					for (let n = 0; n < this.tracks.length; n++) this.tracks[n].trim(0, this.duration)
					return this
				}
				validate() {
					let n = !0
					for (let e = 0; e < this.tracks.length; e++) n = n && this.tracks[e].validate()
					return n
				}
				optimize() {
					for (let n = 0; n < this.tracks.length; n++) this.tracks[n].optimize()
					return this
				}
				clone() {
					const n = []
					for (let e = 0; e < this.tracks.length; e++) n.push(this.tracks[e].clone())
					return new this.constructor(this.name, this.duration, n, this.blendMode)
				}
				toJSON() {
					return this.constructor.toJSON(this)
				}
			}
			function dCe(t) {
				if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse")
				const n = (function lCe(t) {
					switch (t.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return jy
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return Ky
						case "color":
							return lP
						case "quaternion":
							return fb
						case "bool":
						case "boolean":
							return pp
						case "string":
							return Ap
					}
					throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
				})(t.type)
				if (void 0 === t.times) {
					const e = [],
						i = []
					Kr.flattenJSON(t.keys, e, i, "value"), (t.times = e), (t.values = i)
				}
				return void 0 !== n.parse ? n.parse(t) : new n(t.name, t.times, t.values, t.interpolation)
			}
			const gp = {
				enabled: !1,
				files: {},
				add: function (t, n) {
					!1 !== this.enabled && (this.files[t] = n)
				},
				get: function (t) {
					if (!1 !== this.enabled) return this.files[t]
				},
				remove: function (t) {
					delete this.files[t]
				},
				clear: function () {
					this.files = {}
				}
			}
			function dP(t, n, e) {
				const i = this
				let a,
					r = !1,
					o = 0,
					s = 0
				const c = []
				;(this.onStart = void 0),
					(this.onLoad = t),
					(this.onProgress = n),
					(this.onError = e),
					(this.itemStart = function (l) {
						s++, !1 === r && void 0 !== i.onStart && i.onStart(l, o, s), (r = !0)
					}),
					(this.itemEnd = function (l) {
						o++, void 0 !== i.onProgress && i.onProgress(l, o, s), o === s && ((r = !1), void 0 !== i.onLoad && i.onLoad())
					}),
					(this.itemError = function (l) {
						void 0 !== i.onError && i.onError(l)
					}),
					(this.resolveURL = function (l) {
						return a ? a(l) : l
					}),
					(this.setURLModifier = function (l) {
						return (a = l), this
					}),
					(this.addHandler = function (l, d) {
						return c.push(l, d), this
					}),
					(this.removeHandler = function (l) {
						const d = c.indexOf(l)
						return -1 !== d && c.splice(d, 2), this
					}),
					(this.getHandler = function (l) {
						for (let d = 0, u = c.length; d < u; d += 2) {
							const h = c[d],
								f = c[d + 1]
							if ((h.global && (h.lastIndex = 0), h.test(l))) return f
						}
						return null
					})
			}
			const Q7 = new dP()
			function Eo(t) {
				;(this.manager = void 0 !== t ? t : Q7),
					(this.crossOrigin = "anonymous"),
					(this.withCredentials = !1),
					(this.path = ""),
					(this.resourcePath = ""),
					(this.requestHeader = {})
			}
			Object.assign(Eo.prototype, {
				load: function () {},
				loadAsync: function (t, n) {
					const e = this
					return new Promise(function (i, r) {
						e.load(t, i, n, r)
					})
				},
				parse: function () {},
				setCrossOrigin: function (t) {
					return (this.crossOrigin = t), this
				},
				setWithCredentials: function (t) {
					return (this.withCredentials = t), this
				},
				setPath: function (t) {
					return (this.path = t), this
				},
				setResourcePath: function (t) {
					return (this.resourcePath = t), this
				},
				setRequestHeader: function (t) {
					return (this.requestHeader = t), this
				}
			})
			const wl = {}
			function Hc(t) {
				Eo.call(this, t)
			}
			Hc.prototype = Object.assign(Object.create(Eo.prototype), {
				constructor: Hc,
				load: function (t, n, e, i) {
					void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
					const r = this,
						o = gp.get(t)
					if (void 0 !== o)
						return (
							r.manager.itemStart(t),
							setTimeout(function () {
								n && n(o), r.manager.itemEnd(t)
							}, 0),
							o
						)
					if (void 0 !== wl[t]) return void wl[t].push({ onLoad: n, onProgress: e, onError: i })
					const a = t.match(/^data:(.*?)(;base64)?,(.*)$/)
					let c
					if (a) {
						const l = a[1],
							d = !!a[2]
						let u = a[3]
						;(u = decodeURIComponent(u)), d && (u = atob(u))
						try {
							let h
							const f = (this.responseType || "").toLowerCase()
							switch (f) {
								case "arraybuffer":
								case "blob":
									const _ = new Uint8Array(u.length)
									for (let C = 0; C < u.length; C++) _[C] = u.charCodeAt(C)
									h = "blob" === f ? new Blob([_.buffer], { type: l }) : _.buffer
									break
								case "document":
									h = new DOMParser().parseFromString(u, l)
									break
								case "json":
									h = JSON.parse(u)
									break
								default:
									h = u
							}
							setTimeout(function () {
								n && n(h), r.manager.itemEnd(t)
							}, 0)
						} catch (h) {
							setTimeout(function () {
								i && i(h), r.manager.itemError(t), r.manager.itemEnd(t)
							}, 0)
						}
					} else {
						;(wl[t] = []),
							wl[t].push({ onLoad: n, onProgress: e, onError: i }),
							(c = new XMLHttpRequest()),
							c.open("GET", t, !0),
							c.addEventListener(
								"load",
								function (l) {
									const d = this.response,
										u = wl[t]
									if ((delete wl[t], 200 === this.status || 0 === this.status)) {
										0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), gp.add(t, d)
										for (let h = 0, f = u.length; h < f; h++) {
											const _ = u[h]
											_.onLoad && _.onLoad(d)
										}
										r.manager.itemEnd(t)
									} else {
										for (let h = 0, f = u.length; h < f; h++) {
											const _ = u[h]
											_.onError && _.onError(l)
										}
										r.manager.itemError(t), r.manager.itemEnd(t)
									}
								},
								!1
							),
							c.addEventListener(
								"progress",
								function (l) {
									const d = wl[t]
									for (let u = 0, h = d.length; u < h; u++) {
										const f = d[u]
										f.onProgress && f.onProgress(l)
									}
								},
								!1
							),
							c.addEventListener(
								"error",
								function (l) {
									const d = wl[t]
									delete wl[t]
									for (let u = 0, h = d.length; u < h; u++) {
										const f = d[u]
										f.onError && f.onError(l)
									}
									r.manager.itemError(t), r.manager.itemEnd(t)
								},
								!1
							),
							c.addEventListener(
								"abort",
								function (l) {
									const d = wl[t]
									delete wl[t]
									for (let u = 0, h = d.length; u < h; u++) {
										const f = d[u]
										f.onError && f.onError(l)
									}
									r.manager.itemError(t), r.manager.itemEnd(t)
								},
								!1
							),
							void 0 !== this.responseType && (c.responseType = this.responseType),
							void 0 !== this.withCredentials && (c.withCredentials = this.withCredentials),
							c.overrideMimeType && c.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain")
						for (const l in this.requestHeader) c.setRequestHeader(l, this.requestHeader[l])
						c.send(null)
					}
					return r.manager.itemStart(t), c
				},
				setResponseType: function (t) {
					return (this.responseType = t), this
				},
				setMimeType: function (t) {
					return (this.mimeType = t), this
				}
			})
			class uCe extends Eo {
				constructor(n) {
					super(n)
				}
				load(n, e, i, r) {
					const o = this,
						s = new Hc(this.manager)
					s.setPath(this.path),
						s.setRequestHeader(this.requestHeader),
						s.setWithCredentials(this.withCredentials),
						s.load(
							n,
							function (a) {
								try {
									e(o.parse(JSON.parse(a)))
								} catch (c) {
									r ? r(c) : console.error(c), o.manager.itemError(n)
								}
							},
							i,
							r
						)
				}
				parse(n) {
					const e = []
					for (let i = 0; i < n.length; i++) {
						const r = Xy.parse(n[i])
						e.push(r)
					}
					return e
				}
			}
			function uP(t) {
				Eo.call(this, t)
			}
			uP.prototype = Object.assign(Object.create(Eo.prototype), {
				constructor: uP,
				load: function (t, n, e, i) {
					const r = this,
						o = [],
						s = new ZR(),
						a = new Hc(this.manager)
					a.setPath(this.path),
						a.setResponseType("arraybuffer"),
						a.setRequestHeader(this.requestHeader),
						a.setWithCredentials(r.withCredentials)
					let c = 0
					function l(d) {
						a.load(
							t[d],
							function (u) {
								const h = r.parse(u, !0)
								;(o[d] = { width: h.width, height: h.height, format: h.format, mipmaps: h.mipmaps }),
									(c += 1),
									6 === c &&
										(1 === h.mipmapCount && (s.minFilter = xo),
										(s.image = o),
										(s.format = h.format),
										(s.needsUpdate = !0),
										n && n(s))
							},
							e,
							i
						)
					}
					if (Array.isArray(t)) for (let d = 0, u = t.length; d < u; ++d) l(d)
					else
						a.load(
							t,
							function (d) {
								const u = r.parse(d, !0)
								if (u.isCubemap) {
									const h = u.mipmaps.length / u.mipmapCount
									for (let f = 0; f < h; f++) {
										o[f] = { mipmaps: [] }
										for (let _ = 0; _ < u.mipmapCount; _++)
											o[f].mipmaps.push(u.mipmaps[f * u.mipmapCount + _]),
												(o[f].format = u.format),
												(o[f].width = u.width),
												(o[f].height = u.height)
									}
									s.image = o
								} else (s.image.width = u.width), (s.image.height = u.height), (s.mipmaps = u.mipmaps)
								1 === u.mipmapCount && (s.minFilter = xo), (s.format = u.format), (s.needsUpdate = !0), n && n(s)
							},
							e,
							i
						)
					return s
				}
			})
			class xS extends Eo {
				constructor(n) {
					super(n)
				}
				load(n, e, i, r) {
					void 0 !== this.path && (n = this.path + n), (n = this.manager.resolveURL(n))
					const o = this,
						s = gp.get(n)
					if (void 0 !== s)
						return (
							o.manager.itemStart(n),
							setTimeout(function () {
								e && e(s), o.manager.itemEnd(n)
							}, 0),
							s
						)
					const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img")
					function c() {
						a.removeEventListener("load", c, !1),
							a.removeEventListener("error", l, !1),
							gp.add(n, this),
							e && e(this),
							o.manager.itemEnd(n)
					}
					function l(d) {
						a.removeEventListener("load", c, !1),
							a.removeEventListener("error", l, !1),
							r && r(d),
							o.manager.itemError(n),
							o.manager.itemEnd(n)
					}
					return (
						a.addEventListener("load", c, !1),
						a.addEventListener("error", l, !1),
						"data:" !== n.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
						o.manager.itemStart(n),
						(a.src = n),
						a
					)
				}
			}
			class z7 extends Eo {
				constructor(n) {
					super(n)
				}
				load(n, e, i, r) {
					const o = new Zg(),
						s = new xS(this.manager)
					s.setCrossOrigin(this.crossOrigin), s.setPath(this.path)
					let a = 0
					function c(l) {
						s.load(
							n[l],
							function (d) {
								;(o.images[l] = d), a++, 6 === a && ((o.needsUpdate = !0), e && e(o))
							},
							void 0,
							r
						)
					}
					for (let l = 0; l < n.length; ++l) c(l)
					return o
				}
			}
			function CS(t) {
				Eo.call(this, t)
			}
			function ES(t) {
				Eo.call(this, t)
			}
			function ga() {
				;(this.type = "Curve"), (this.arcLengthDivisions = 200)
			}
			;(CS.prototype = Object.assign(Object.create(Eo.prototype), {
				constructor: CS,
				load: function (t, n, e, i) {
					const r = this,
						o = new Jg(),
						s = new Hc(this.manager)
					return (
						s.setResponseType("arraybuffer"),
						s.setRequestHeader(this.requestHeader),
						s.setPath(this.path),
						s.setWithCredentials(r.withCredentials),
						s.load(
							t,
							function (a) {
								const c = r.parse(a)
								c &&
									(void 0 !== c.image
										? (o.image = c.image)
										: void 0 !== c.data &&
										  ((o.image.width = c.width), (o.image.height = c.height), (o.image.data = c.data)),
									(o.wrapS = void 0 !== c.wrapS ? c.wrapS : ua),
									(o.wrapT = void 0 !== c.wrapT ? c.wrapT : ua),
									(o.magFilter = void 0 !== c.magFilter ? c.magFilter : xo),
									(o.minFilter = void 0 !== c.minFilter ? c.minFilter : xo),
									(o.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1),
									void 0 !== c.encoding && (o.encoding = c.encoding),
									void 0 !== c.flipY && (o.flipY = c.flipY),
									void 0 !== c.format && (o.format = c.format),
									void 0 !== c.type && (o.type = c.type),
									void 0 !== c.mipmaps && ((o.mipmaps = c.mipmaps), (o.minFilter = Rg)),
									1 === c.mipmapCount && (o.minFilter = xo),
									(o.needsUpdate = !0),
									n && n(o, c))
							},
							e,
							i
						),
						o
					)
				}
			})),
				(ES.prototype = Object.assign(Object.create(Eo.prototype), {
					constructor: ES,
					load: function (t, n, e, i) {
						const r = new zo(),
							o = new xS(this.manager)
						return (
							o.setCrossOrigin(this.crossOrigin),
							o.setPath(this.path),
							o.load(
								t,
								function (s) {
									r.image = s
									const a = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/)
									;(r.format = a ? Xh : ha), (r.needsUpdate = !0), void 0 !== n && n(r)
								},
								e,
								i
							),
							r
						)
					}
				})),
				Object.assign(ga.prototype, {
					getPoint: function () {
						return console.warn("THREE.Curve: .getPoint() not implemented."), null
					},
					getPointAt: function (t, n) {
						const e = this.getUtoTmapping(t)
						return this.getPoint(e, n)
					},
					getPoints: function (t = 5) {
						const n = []
						for (let e = 0; e <= t; e++) n.push(this.getPoint(e / t))
						return n
					},
					getSpacedPoints: function (t = 5) {
						const n = []
						for (let e = 0; e <= t; e++) n.push(this.getPointAt(e / t))
						return n
					},
					getLength: function () {
						const t = this.getLengths()
						return t[t.length - 1]
					},
					getLengths: function (t) {
						if (
							(void 0 === t && (t = this.arcLengthDivisions),
							this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
						)
							return this.cacheArcLengths
						this.needsUpdate = !1
						const n = []
						let e,
							i = this.getPoint(0),
							r = 0
						n.push(0)
						for (let o = 1; o <= t; o++) (e = this.getPoint(o / t)), (r += e.distanceTo(i)), n.push(r), (i = e)
						return (this.cacheArcLengths = n), n
					},
					updateArcLengths: function () {
						;(this.needsUpdate = !0), this.getLengths()
					},
					getUtoTmapping: function (t, n) {
						const e = this.getLengths()
						let i = 0
						const r = e.length
						let o
						o = n || t * e[r - 1]
						let c,
							s = 0,
							a = r - 1
						for (; s <= a; )
							if (((i = Math.floor(s + (a - s) / 2)), (c = e[i] - o), c < 0)) s = i + 1
							else {
								if (!(c > 0)) {
									a = i
									break
								}
								a = i - 1
							}
						if (((i = a), e[i] === o)) return i / (r - 1)
						const l = e[i]
						return (i + (o - l) / (e[i + 1] - l)) / (r - 1)
					},
					getTangent: function (t, n) {
						let i = t - 1e-4,
							r = t + 1e-4
						i < 0 && (i = 0), r > 1 && (r = 1)
						const o = this.getPoint(i),
							s = this.getPoint(r),
							a = n || (o.isVector2 ? new lt() : new K())
						return a.copy(s).sub(o).normalize(), a
					},
					getTangentAt: function (t, n) {
						const e = this.getUtoTmapping(t)
						return this.getTangent(e, n)
					},
					computeFrenetFrames: function (t, n) {
						const e = new K(),
							i = [],
							r = [],
							o = [],
							s = new K(),
							a = new Cn()
						for (let h = 0; h <= t; h++) (i[h] = this.getTangentAt(h / t, new K())), i[h].normalize()
						;(r[0] = new K()), (o[0] = new K())
						let c = Number.MAX_VALUE
						const l = Math.abs(i[0].x),
							d = Math.abs(i[0].y),
							u = Math.abs(i[0].z)
						l <= c && ((c = l), e.set(1, 0, 0)),
							d <= c && ((c = d), e.set(0, 1, 0)),
							u <= c && e.set(0, 0, 1),
							s.crossVectors(i[0], e).normalize(),
							r[0].crossVectors(i[0], s),
							o[0].crossVectors(i[0], r[0])
						for (let h = 1; h <= t; h++) {
							if (
								((r[h] = r[h - 1].clone()),
								(o[h] = o[h - 1].clone()),
								s.crossVectors(i[h - 1], i[h]),
								s.length() > Number.EPSILON)
							) {
								s.normalize()
								const f = Math.acos(jn.clamp(i[h - 1].dot(i[h]), -1, 1))
								r[h].applyMatrix4(a.makeRotationAxis(s, f))
							}
							o[h].crossVectors(i[h], r[h])
						}
						if (!0 === n) {
							let h = Math.acos(jn.clamp(r[0].dot(r[t]), -1, 1))
							;(h /= t), i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (h = -h)
							for (let f = 1; f <= t; f++) r[f].applyMatrix4(a.makeRotationAxis(i[f], h * f)), o[f].crossVectors(i[f], r[f])
						}
						return { tangents: i, normals: r, binormals: o }
					},
					clone: function () {
						return new this.constructor().copy(this)
					},
					copy: function (t) {
						return (this.arcLengthDivisions = t.arcLengthDivisions), this
					},
					toJSON: function () {
						const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }
						return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
					},
					fromJSON: function (t) {
						return (this.arcLengthDivisions = t.arcLengthDivisions), this
					}
				})
			class Yy extends ga {
				constructor(n = 0, e = 0, i = 1, r = 1, o = 0, s = 2 * Math.PI, a = !1, c = 0) {
					super(),
						(this.type = "EllipseCurve"),
						(this.aX = n),
						(this.aY = e),
						(this.xRadius = i),
						(this.yRadius = r),
						(this.aStartAngle = o),
						(this.aEndAngle = s),
						(this.aClockwise = a),
						(this.aRotation = c)
				}
				getPoint(n, e) {
					const i = e || new lt(),
						r = 2 * Math.PI
					let o = this.aEndAngle - this.aStartAngle
					const s = Math.abs(o) < Number.EPSILON
					for (; o < 0; ) o += r
					for (; o > r; ) o -= r
					o < Number.EPSILON && (o = s ? 0 : r), !0 === this.aClockwise && !s && (o === r ? (o = -r) : (o -= r))
					const a = this.aStartAngle + n * o
					let c = this.aX + this.xRadius * Math.cos(a),
						l = this.aY + this.yRadius * Math.sin(a)
					if (0 !== this.aRotation) {
						const d = Math.cos(this.aRotation),
							u = Math.sin(this.aRotation),
							h = c - this.aX,
							f = l - this.aY
						;(c = h * d - f * u + this.aX), (l = h * u + f * d + this.aY)
					}
					return i.set(c, l)
				}
				copy(n) {
					return (
						super.copy(n),
						(this.aX = n.aX),
						(this.aY = n.aY),
						(this.xRadius = n.xRadius),
						(this.yRadius = n.yRadius),
						(this.aStartAngle = n.aStartAngle),
						(this.aEndAngle = n.aEndAngle),
						(this.aClockwise = n.aClockwise),
						(this.aRotation = n.aRotation),
						this
					)
				}
				toJSON() {
					const n = super.toJSON()
					return (
						(n.aX = this.aX),
						(n.aY = this.aY),
						(n.xRadius = this.xRadius),
						(n.yRadius = this.yRadius),
						(n.aStartAngle = this.aStartAngle),
						(n.aEndAngle = this.aEndAngle),
						(n.aClockwise = this.aClockwise),
						(n.aRotation = this.aRotation),
						n
					)
				}
				fromJSON(n) {
					return (
						super.fromJSON(n),
						(this.aX = n.aX),
						(this.aY = n.aY),
						(this.xRadius = n.xRadius),
						(this.yRadius = n.yRadius),
						(this.aStartAngle = n.aStartAngle),
						(this.aEndAngle = n.aEndAngle),
						(this.aClockwise = n.aClockwise),
						(this.aRotation = n.aRotation),
						this
					)
				}
			}
			Yy.prototype.isEllipseCurve = !0
			class hP extends Yy {
				constructor(n, e, i, r, o, s) {
					super(n, e, i, i, r, o, s), (this.type = "ArcCurve")
				}
			}
			function fP() {
				let t = 0,
					n = 0,
					e = 0,
					i = 0
				function r(o, s, a, c) {
					;(t = o), (n = a), (e = -3 * o + 3 * s - 2 * a - c), (i = 2 * o - 2 * s + a + c)
				}
				return {
					initCatmullRom: function (o, s, a, c, l) {
						r(s, a, l * (a - o), l * (c - s))
					},
					initNonuniformCatmullRom: function (o, s, a, c, l, d, u) {
						let h = (s - o) / l - (a - o) / (l + d) + (a - s) / d,
							f = (a - s) / d - (c - s) / (d + u) + (c - a) / u
						;(h *= d), (f *= d), r(s, a, h, f)
					},
					calc: function (o) {
						const s = o * o
						return t + n * o + e * s + i * (s * o)
					}
				}
			}
			hP.prototype.isArcCurve = !0
			const MS = new K(),
				mP = new fP(),
				pP = new fP(),
				AP = new fP()
			class gP extends ga {
				constructor(n = [], e = !1, i = "centripetal", r = 0.5) {
					super(),
						(this.type = "CatmullRomCurve3"),
						(this.points = n),
						(this.closed = e),
						(this.curveType = i),
						(this.tension = r)
				}
				getPoint(n, e = new K()) {
					const i = e,
						r = this.points,
						o = r.length,
						s = (o - (this.closed ? 0 : 1)) * n
					let l,
						d,
						a = Math.floor(s),
						c = s - a
					this.closed
						? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / o) + 1) * o)
						: 0 === c && a === o - 1 && ((a = o - 2), (c = 1)),
						this.closed || a > 0 ? (l = r[(a - 1) % o]) : (MS.subVectors(r[0], r[1]).add(r[0]), (l = MS))
					const u = r[a % o],
						h = r[(a + 1) % o]
					if (
						(this.closed || a + 2 < o ? (d = r[(a + 2) % o]) : (MS.subVectors(r[o - 1], r[o - 2]).add(r[o - 1]), (d = MS)),
						"centripetal" === this.curveType || "chordal" === this.curveType)
					) {
						const f = "chordal" === this.curveType ? 0.5 : 0.25
						let _ = Math.pow(l.distanceToSquared(u), f),
							y = Math.pow(u.distanceToSquared(h), f),
							C = Math.pow(h.distanceToSquared(d), f)
						y < 1e-4 && (y = 1),
							_ < 1e-4 && (_ = y),
							C < 1e-4 && (C = y),
							mP.initNonuniformCatmullRom(l.x, u.x, h.x, d.x, _, y, C),
							pP.initNonuniformCatmullRom(l.y, u.y, h.y, d.y, _, y, C),
							AP.initNonuniformCatmullRom(l.z, u.z, h.z, d.z, _, y, C)
					} else
						"catmullrom" === this.curveType &&
							(mP.initCatmullRom(l.x, u.x, h.x, d.x, this.tension),
							pP.initCatmullRom(l.y, u.y, h.y, d.y, this.tension),
							AP.initCatmullRom(l.z, u.z, h.z, d.z, this.tension))
					return i.set(mP.calc(c), pP.calc(c), AP.calc(c)), i
				}
				copy(n) {
					super.copy(n), (this.points = [])
					for (let e = 0, i = n.points.length; e < i; e++) this.points.push(n.points[e].clone())
					return (this.closed = n.closed), (this.curveType = n.curveType), (this.tension = n.tension), this
				}
				toJSON() {
					const n = super.toJSON()
					n.points = []
					for (let e = 0, i = this.points.length; e < i; e++) n.points.push(this.points[e].toArray())
					return (n.closed = this.closed), (n.curveType = this.curveType), (n.tension = this.tension), n
				}
				fromJSON(n) {
					super.fromJSON(n), (this.points = [])
					for (let e = 0, i = n.points.length; e < i; e++) {
						const r = n.points[e]
						this.points.push(new K().fromArray(r))
					}
					return (this.closed = n.closed), (this.curveType = n.curveType), (this.tension = n.tension), this
				}
			}
			function G7(t, n, e, i, r) {
				const o = 0.5 * (i - n),
					s = 0.5 * (r - e),
					a = t * t
				return (2 * e - 2 * i + o + s) * (t * a) + (-3 * e + 3 * i - 2 * o - s) * a + o * t + e
			}
			function qy(t, n, e, i) {
				return (
					(function hCe(t, n) {
						const e = 1 - t
						return e * e * n
					})(t, n) +
					(function fCe(t, n) {
						return 2 * (1 - t) * t * n
					})(t, e) +
					(function mCe(t, n) {
						return t * t * n
					})(t, i)
				)
			}
			function Zy(t, n, e, i, r) {
				return (
					(function pCe(t, n) {
						const e = 1 - t
						return e * e * e * n
					})(t, n) +
					(function ACe(t, n) {
						const e = 1 - t
						return 3 * e * e * t * n
					})(t, e) +
					(function gCe(t, n) {
						return 3 * (1 - t) * t * t * n
					})(t, i) +
					(function bCe(t, n) {
						return t * t * t * n
					})(t, r)
				)
			}
			gP.prototype.isCatmullRomCurve3 = !0
			class SS extends ga {
				constructor(n = new lt(), e = new lt(), i = new lt(), r = new lt()) {
					super(), (this.type = "CubicBezierCurve"), (this.v0 = n), (this.v1 = e), (this.v2 = i), (this.v3 = r)
				}
				getPoint(n, e = new lt()) {
					const i = e,
						r = this.v0,
						o = this.v1,
						s = this.v2,
						a = this.v3
					return i.set(Zy(n, r.x, o.x, s.x, a.x), Zy(n, r.y, o.y, s.y, a.y)), i
				}
				copy(n) {
					return super.copy(n), this.v0.copy(n.v0), this.v1.copy(n.v1), this.v2.copy(n.v2), this.v3.copy(n.v3), this
				}
				toJSON() {
					const n = super.toJSON()
					return (n.v0 = this.v0.toArray()), (n.v1 = this.v1.toArray()), (n.v2 = this.v2.toArray()), (n.v3 = this.v3.toArray()), n
				}
				fromJSON(n) {
					return (
						super.fromJSON(n),
						this.v0.fromArray(n.v0),
						this.v1.fromArray(n.v1),
						this.v2.fromArray(n.v2),
						this.v3.fromArray(n.v3),
						this
					)
				}
			}
			SS.prototype.isCubicBezierCurve = !0
			class kS extends ga {
				constructor(n = new K(), e = new K(), i = new K(), r = new K()) {
					super(), (this.type = "CubicBezierCurve3"), (this.v0 = n), (this.v1 = e), (this.v2 = i), (this.v3 = r)
				}
				getPoint(n, e = new K()) {
					const i = e,
						r = this.v0,
						o = this.v1,
						s = this.v2,
						a = this.v3
					return i.set(Zy(n, r.x, o.x, s.x, a.x), Zy(n, r.y, o.y, s.y, a.y), Zy(n, r.z, o.z, s.z, a.z)), i
				}
				copy(n) {
					return super.copy(n), this.v0.copy(n.v0), this.v1.copy(n.v1), this.v2.copy(n.v2), this.v3.copy(n.v3), this
				}
				toJSON() {
					const n = super.toJSON()
					return (n.v0 = this.v0.toArray()), (n.v1 = this.v1.toArray()), (n.v2 = this.v2.toArray()), (n.v3 = this.v3.toArray()), n
				}
				fromJSON(n) {
					return (
						super.fromJSON(n),
						this.v0.fromArray(n.v0),
						this.v1.fromArray(n.v1),
						this.v2.fromArray(n.v2),
						this.v3.fromArray(n.v3),
						this
					)
				}
			}
			kS.prototype.isCubicBezierCurve3 = !0
			class Jy extends ga {
				constructor(n = new lt(), e = new lt()) {
					super(), (this.type = "LineCurve"), (this.v1 = n), (this.v2 = e)
				}
				getPoint(n, e = new lt()) {
					const i = e
					return 1 === n ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(n).add(this.v1)), i
				}
				getPointAt(n, e) {
					return this.getPoint(n, e)
				}
				getTangent(n, e) {
					const i = e || new lt()
					return i.copy(this.v2).sub(this.v1).normalize(), i
				}
				copy(n) {
					return super.copy(n), this.v1.copy(n.v1), this.v2.copy(n.v2), this
				}
				toJSON() {
					const n = super.toJSON()
					return (n.v1 = this.v1.toArray()), (n.v2 = this.v2.toArray()), n
				}
				fromJSON(n) {
					return super.fromJSON(n), this.v1.fromArray(n.v1), this.v2.fromArray(n.v2), this
				}
			}
			Jy.prototype.isLineCurve = !0
			class $7 extends ga {
				constructor(n = new K(), e = new K()) {
					super(), (this.type = "LineCurve3"), (this.isLineCurve3 = !0), (this.v1 = n), (this.v2 = e)
				}
				getPoint(n, e = new K()) {
					const i = e
					return 1 === n ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(n).add(this.v1)), i
				}
				getPointAt(n, e) {
					return this.getPoint(n, e)
				}
				copy(n) {
					return super.copy(n), this.v1.copy(n.v1), this.v2.copy(n.v2), this
				}
				toJSON() {
					const n = super.toJSON()
					return (n.v1 = this.v1.toArray()), (n.v2 = this.v2.toArray()), n
				}
				fromJSON(n) {
					return super.fromJSON(n), this.v1.fromArray(n.v1), this.v2.fromArray(n.v2), this
				}
			}
			class TS extends ga {
				constructor(n = new lt(), e = new lt(), i = new lt()) {
					super(), (this.type = "QuadraticBezierCurve"), (this.v0 = n), (this.v1 = e), (this.v2 = i)
				}
				getPoint(n, e = new lt()) {
					const i = e,
						r = this.v0,
						o = this.v1,
						s = this.v2
					return i.set(qy(n, r.x, o.x, s.x), qy(n, r.y, o.y, s.y)), i
				}
				copy(n) {
					return super.copy(n), this.v0.copy(n.v0), this.v1.copy(n.v1), this.v2.copy(n.v2), this
				}
				toJSON() {
					const n = super.toJSON()
					return (n.v0 = this.v0.toArray()), (n.v1 = this.v1.toArray()), (n.v2 = this.v2.toArray()), n
				}
				fromJSON(n) {
					return super.fromJSON(n), this.v0.fromArray(n.v0), this.v1.fromArray(n.v1), this.v2.fromArray(n.v2), this
				}
			}
			TS.prototype.isQuadraticBezierCurve = !0
			class bP extends ga {
				constructor(n = new K(), e = new K(), i = new K()) {
					super(), (this.type = "QuadraticBezierCurve3"), (this.v0 = n), (this.v1 = e), (this.v2 = i)
				}
				getPoint(n, e = new K()) {
					const i = e,
						r = this.v0,
						o = this.v1,
						s = this.v2
					return i.set(qy(n, r.x, o.x, s.x), qy(n, r.y, o.y, s.y), qy(n, r.z, o.z, s.z)), i
				}
				copy(n) {
					return super.copy(n), this.v0.copy(n.v0), this.v1.copy(n.v1), this.v2.copy(n.v2), this
				}
				toJSON() {
					const n = super.toJSON()
					return (n.v0 = this.v0.toArray()), (n.v1 = this.v1.toArray()), (n.v2 = this.v2.toArray()), n
				}
				fromJSON(n) {
					return super.fromJSON(n), this.v0.fromArray(n.v0), this.v1.fromArray(n.v1), this.v2.fromArray(n.v2), this
				}
			}
			bP.prototype.isQuadraticBezierCurve3 = !0
			class FS extends ga {
				constructor(n = []) {
					super(), (this.type = "SplineCurve"), (this.points = n)
				}
				getPoint(n, e = new lt()) {
					const i = e,
						r = this.points,
						o = (r.length - 1) * n,
						s = Math.floor(o),
						a = o - s,
						c = r[0 === s ? s : s - 1],
						l = r[s],
						d = r[s > r.length - 2 ? r.length - 1 : s + 1],
						u = r[s > r.length - 3 ? r.length - 1 : s + 2]
					return i.set(G7(a, c.x, l.x, d.x, u.x), G7(a, c.y, l.y, d.y, u.y)), i
				}
				copy(n) {
					super.copy(n), (this.points = [])
					for (let e = 0, i = n.points.length; e < i; e++) this.points.push(n.points[e].clone())
					return this
				}
				toJSON() {
					const n = super.toJSON()
					n.points = []
					for (let e = 0, i = this.points.length; e < i; e++) n.points.push(this.points[e].toArray())
					return n
				}
				fromJSON(n) {
					super.fromJSON(n), (this.points = [])
					for (let e = 0, i = n.points.length; e < i; e++) {
						const r = n.points[e]
						this.points.push(new lt().fromArray(r))
					}
					return this
				}
			}
			FS.prototype.isSplineCurve = !0
			var _P = Object.freeze({
				__proto__: null,
				ArcCurve: hP,
				CatmullRomCurve3: gP,
				CubicBezierCurve: SS,
				CubicBezierCurve3: kS,
				EllipseCurve: Yy,
				LineCurve: Jy,
				LineCurve3: $7,
				QuadraticBezierCurve: TS,
				QuadraticBezierCurve3: bP,
				SplineCurve: FS
			})
			class W7 extends ga {
				constructor() {
					super(), (this.type = "CurvePath"), (this.curves = []), (this.autoClose = !1)
				}
				add(n) {
					this.curves.push(n)
				}
				closePath() {
					const n = this.curves[0].getPoint(0),
						e = this.curves[this.curves.length - 1].getPoint(1)
					n.equals(e) || this.curves.push(new Jy(e, n))
				}
				getPoint(n) {
					const e = n * this.getLength(),
						i = this.getCurveLengths()
					let r = 0
					for (; r < i.length; ) {
						if (i[r] >= e) {
							const o = i[r] - e,
								s = this.curves[r],
								a = s.getLength()
							return s.getPointAt(0 === a ? 0 : 1 - o / a)
						}
						r++
					}
					return null
				}
				getLength() {
					const n = this.getCurveLengths()
					return n[n.length - 1]
				}
				updateArcLengths() {
					;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
				}
				getCurveLengths() {
					if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths
					const n = []
					let e = 0
					for (let i = 0, r = this.curves.length; i < r; i++) (e += this.curves[i].getLength()), n.push(e)
					return (this.cacheLengths = n), n
				}
				getSpacedPoints(n = 40) {
					const e = []
					for (let i = 0; i <= n; i++) e.push(this.getPoint(i / n))
					return this.autoClose && e.push(e[0]), e
				}
				getPoints(n = 12) {
					const e = []
					let i
					for (let r = 0, o = this.curves; r < o.length; r++) {
						const s = o[r],
							c = s.getPoints(
								s && s.isEllipseCurve
									? 2 * n
									: s && (s.isLineCurve || s.isLineCurve3)
									? 1
									: s && s.isSplineCurve
									? n * s.points.length
									: n
							)
						for (let l = 0; l < c.length; l++) {
							const d = c[l]
							;(i && i.equals(d)) || (e.push(d), (i = d))
						}
					}
					return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
				}
				copy(n) {
					super.copy(n), (this.curves = [])
					for (let e = 0, i = n.curves.length; e < i; e++) this.curves.push(n.curves[e].clone())
					return (this.autoClose = n.autoClose), this
				}
				toJSON() {
					const n = super.toJSON()
					;(n.autoClose = this.autoClose), (n.curves = [])
					for (let e = 0, i = this.curves.length; e < i; e++) n.curves.push(this.curves[e].toJSON())
					return n
				}
				fromJSON(n) {
					super.fromJSON(n), (this.autoClose = n.autoClose), (this.curves = [])
					for (let e = 0, i = n.curves.length; e < i; e++) {
						const r = n.curves[e]
						this.curves.push(new _P[r.type]().fromJSON(r))
					}
					return this
				}
			}
			class ew extends W7 {
				constructor(n) {
					super(), (this.type = "Path"), (this.currentPoint = new lt()), n && this.setFromPoints(n)
				}
				setFromPoints(n) {
					this.moveTo(n[0].x, n[0].y)
					for (let e = 1, i = n.length; e < i; e++) this.lineTo(n[e].x, n[e].y)
					return this
				}
				moveTo(n, e) {
					return this.currentPoint.set(n, e), this
				}
				lineTo(n, e) {
					const i = new Jy(this.currentPoint.clone(), new lt(n, e))
					return this.curves.push(i), this.currentPoint.set(n, e), this
				}
				quadraticCurveTo(n, e, i, r) {
					const o = new TS(this.currentPoint.clone(), new lt(n, e), new lt(i, r))
					return this.curves.push(o), this.currentPoint.set(i, r), this
				}
				bezierCurveTo(n, e, i, r, o, s) {
					const a = new SS(this.currentPoint.clone(), new lt(n, e), new lt(i, r), new lt(o, s))
					return this.curves.push(a), this.currentPoint.set(o, s), this
				}
				splineThru(n) {
					const e = [this.currentPoint.clone()].concat(n),
						i = new FS(e)
					return this.curves.push(i), this.currentPoint.copy(n[n.length - 1]), this
				}
				arc(n, e, i, r, o, s) {
					return this.absarc(n + this.currentPoint.x, e + this.currentPoint.y, i, r, o, s), this
				}
				absarc(n, e, i, r, o, s) {
					return this.absellipse(n, e, i, i, r, o, s), this
				}
				ellipse(n, e, i, r, o, s, a, c) {
					return this.absellipse(n + this.currentPoint.x, e + this.currentPoint.y, i, r, o, s, a, c), this
				}
				absellipse(n, e, i, r, o, s, a, c) {
					const l = new Yy(n, e, i, r, o, s, a, c)
					if (this.curves.length > 0) {
						const u = l.getPoint(0)
						u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
					}
					this.curves.push(l)
					const d = l.getPoint(1)
					return this.currentPoint.copy(d), this
				}
				copy(n) {
					return super.copy(n), this.currentPoint.copy(n.currentPoint), this
				}
				toJSON() {
					const n = super.toJSON()
					return (n.currentPoint = this.currentPoint.toArray()), n
				}
				fromJSON(n) {
					return super.fromJSON(n), this.currentPoint.fromArray(n.currentPoint), this
				}
			}
			class hf extends ew {
				constructor(n) {
					super(n), (this.uuid = jn.generateUUID()), (this.type = "Shape"), (this.holes = [])
				}
				getPointsHoles(n) {
					const e = []
					for (let i = 0, r = this.holes.length; i < r; i++) e[i] = this.holes[i].getPoints(n)
					return e
				}
				extractPoints(n) {
					return { shape: this.getPoints(n), holes: this.getPointsHoles(n) }
				}
				copy(n) {
					super.copy(n), (this.holes = [])
					for (let e = 0, i = n.holes.length; e < i; e++) this.holes.push(n.holes[e].clone())
					return this
				}
				toJSON() {
					const n = super.toJSON()
					;(n.uuid = this.uuid), (n.holes = [])
					for (let e = 0, i = this.holes.length; e < i; e++) n.holes.push(this.holes[e].toJSON())
					return n
				}
				fromJSON(n) {
					super.fromJSON(n), (this.uuid = n.uuid), (this.holes = [])
					for (let e = 0, i = n.holes.length; e < i; e++) {
						const r = n.holes[e]
						this.holes.push(new ew().fromJSON(r))
					}
					return this
				}
			}
			class xl extends On {
				constructor(n, e = 1) {
					super(), (this.type = "Light"), (this.color = new Lt(n)), (this.intensity = e)
				}
				copy(n) {
					return super.copy(n), this.color.copy(n.color), (this.intensity = n.intensity), this
				}
				toJSON(n) {
					const e = super.toJSON(n)
					return (
						(e.object.color = this.color.getHex()),
						(e.object.intensity = this.intensity),
						void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
						void 0 !== this.distance && (e.object.distance = this.distance),
						void 0 !== this.angle && (e.object.angle = this.angle),
						void 0 !== this.decay && (e.object.decay = this.decay),
						void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
						void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
						e
					)
				}
			}
			xl.prototype.isLight = !0
			class vP extends xl {
				constructor(n, e, i) {
					super(n, i),
						(this.type = "HemisphereLight"),
						this.position.copy(On.DefaultUp),
						this.updateMatrix(),
						(this.groundColor = new Lt(e))
				}
				copy(n) {
					return xl.prototype.copy.call(this, n), this.groundColor.copy(n.groundColor), this
				}
			}
			vP.prototype.isHemisphereLight = !0
			const j7 = new Cn(),
				K7 = new K(),
				X7 = new K()
			class yP {
				constructor(n) {
					;(this.camera = n),
						(this.bias = 0),
						(this.normalBias = 0),
						(this.radius = 1),
						(this.mapSize = new lt(512, 512)),
						(this.map = null),
						(this.mapPass = null),
						(this.matrix = new Cn()),
						(this.autoUpdate = !0),
						(this.needsUpdate = !1),
						(this._frustum = new My()),
						(this._frameExtents = new lt(1, 1)),
						(this._viewportCount = 1),
						(this._viewports = [new lr(0, 0, 1, 1)])
				}
				getViewportCount() {
					return this._viewportCount
				}
				getFrustum() {
					return this._frustum
				}
				updateMatrices(n) {
					const e = this.camera,
						i = this.matrix
					K7.setFromMatrixPosition(n.matrixWorld),
						e.position.copy(K7),
						X7.setFromMatrixPosition(n.target.matrixWorld),
						e.lookAt(X7),
						e.updateMatrixWorld(),
						j7.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
						this._frustum.setFromProjectionMatrix(j7),
						i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
						i.multiply(e.projectionMatrix),
						i.multiply(e.matrixWorldInverse)
				}
				getViewport(n) {
					return this._viewports[n]
				}
				getFrameExtents() {
					return this._frameExtents
				}
				copy(n) {
					return (
						(this.camera = n.camera.clone()), (this.bias = n.bias), (this.radius = n.radius), this.mapSize.copy(n.mapSize), this
					)
				}
				clone() {
					return new this.constructor().copy(this)
				}
				toJSON() {
					const n = {}
					return (
						0 !== this.bias && (n.bias = this.bias),
						0 !== this.normalBias && (n.normalBias = this.normalBias),
						1 !== this.radius && (n.radius = this.radius),
						(512 !== this.mapSize.x || 512 !== this.mapSize.y) && (n.mapSize = this.mapSize.toArray()),
						(n.camera = this.camera.toJSON(!1).object),
						delete n.camera.matrix,
						n
					)
				}
			}
			class Y7 extends yP {
				constructor() {
					super(new Co(50, 1, 0.5, 500)), (this.focus = 1)
				}
				updateMatrices(n) {
					const e = this.camera,
						i = 2 * jn.RAD2DEG * n.angle * this.focus,
						r = this.mapSize.width / this.mapSize.height,
						o = n.distance || e.far
					;(i !== e.fov || r !== e.aspect || o !== e.far) &&
						((e.fov = i), (e.aspect = r), (e.far = o), e.updateProjectionMatrix()),
						super.updateMatrices(n)
				}
			}
			Y7.prototype.isSpotLightShadow = !0
			class wP extends xl {
				constructor(n, e, i = 0, r = Math.PI / 3, o = 0, s = 1) {
					super(n, e),
						(this.type = "SpotLight"),
						this.position.copy(On.DefaultUp),
						this.updateMatrix(),
						(this.target = new On()),
						(this.distance = i),
						(this.angle = r),
						(this.penumbra = o),
						(this.decay = s),
						(this.shadow = new Y7())
				}
				get power() {
					return this.intensity * Math.PI
				}
				set power(n) {
					this.intensity = n / Math.PI
				}
				copy(n) {
					return (
						super.copy(n),
						(this.distance = n.distance),
						(this.angle = n.angle),
						(this.penumbra = n.penumbra),
						(this.decay = n.decay),
						(this.target = n.target.clone()),
						(this.shadow = n.shadow.clone()),
						this
					)
				}
			}
			wP.prototype.isSpotLight = !0
			const q7 = new Cn(),
				tw = new K(),
				xP = new K()
			class Z7 extends yP {
				constructor() {
					super(new Co(90, 1, 0.5, 500)),
						(this._frameExtents = new lt(4, 2)),
						(this._viewportCount = 6),
						(this._viewports = [
							new lr(2, 1, 1, 1),
							new lr(0, 1, 1, 1),
							new lr(3, 1, 1, 1),
							new lr(1, 1, 1, 1),
							new lr(3, 0, 1, 1),
							new lr(1, 0, 1, 1)
						]),
						(this._cubeDirections = [
							new K(1, 0, 0),
							new K(-1, 0, 0),
							new K(0, 0, 1),
							new K(0, 0, -1),
							new K(0, 1, 0),
							new K(0, -1, 0)
						]),
						(this._cubeUps = [new K(0, 1, 0), new K(0, 1, 0), new K(0, 1, 0), new K(0, 1, 0), new K(0, 0, 1), new K(0, 0, -1)])
				}
				updateMatrices(n, e = 0) {
					const i = this.camera,
						r = this.matrix
					tw.setFromMatrixPosition(n.matrixWorld),
						i.position.copy(tw),
						xP.copy(i.position),
						xP.add(this._cubeDirections[e]),
						i.up.copy(this._cubeUps[e]),
						i.lookAt(xP),
						i.updateMatrixWorld(),
						r.makeTranslation(-tw.x, -tw.y, -tw.z),
						q7.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
						this._frustum.setFromProjectionMatrix(q7)
				}
			}
			Z7.prototype.isPointLightShadow = !0
			class CP extends xl {
				constructor(n, e, i = 0, r = 1) {
					super(n, e), (this.type = "PointLight"), (this.distance = i), (this.decay = r), (this.shadow = new Z7())
				}
				get power() {
					return 4 * this.intensity * Math.PI
				}
				set power(n) {
					this.intensity = n / (4 * Math.PI)
				}
				copy(n) {
					return super.copy(n), (this.distance = n.distance), (this.decay = n.decay), (this.shadow = n.shadow.clone()), this
				}
			}
			CP.prototype.isPointLight = !0
			class bp extends rf {
				constructor(n = -1, e = 1, i = 1, r = -1, o = 0.1, s = 2e3) {
					super(),
						(this.type = "OrthographicCamera"),
						(this.zoom = 1),
						(this.view = null),
						(this.left = n),
						(this.right = e),
						(this.top = i),
						(this.bottom = r),
						(this.near = o),
						(this.far = s),
						this.updateProjectionMatrix()
				}
				copy(n, e) {
					return (
						super.copy(n, e),
						(this.left = n.left),
						(this.right = n.right),
						(this.top = n.top),
						(this.bottom = n.bottom),
						(this.near = n.near),
						(this.far = n.far),
						(this.zoom = n.zoom),
						(this.view = null === n.view ? null : Object.assign({}, n.view)),
						this
					)
				}
				setViewOffset(n, e, i, r, o, s) {
					null === this.view &&
						(this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
						(this.view.enabled = !0),
						(this.view.fullWidth = n),
						(this.view.fullHeight = e),
						(this.view.offsetX = i),
						(this.view.offsetY = r),
						(this.view.width = o),
						(this.view.height = s),
						this.updateProjectionMatrix()
				}
				clearViewOffset() {
					null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
				}
				updateProjectionMatrix() {
					const n = (this.right - this.left) / (2 * this.zoom),
						e = (this.top - this.bottom) / (2 * this.zoom),
						i = (this.right + this.left) / 2,
						r = (this.top + this.bottom) / 2
					let o = i - n,
						s = i + n,
						a = r + e,
						c = r - e
					if (null !== this.view && this.view.enabled) {
						const l = (this.right - this.left) / this.view.fullWidth / this.zoom,
							d = (this.top - this.bottom) / this.view.fullHeight / this.zoom
						;(o += l * this.view.offsetX),
							(s = o + l * this.view.width),
							(a -= d * this.view.offsetY),
							(c = a - d * this.view.height)
					}
					this.projectionMatrix.makeOrthographic(o, s, a, c, this.near, this.far),
						this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
				}
				toJSON(n) {
					const e = On.prototype.toJSON.call(this, n)
					return (
						(e.object.zoom = this.zoom),
						(e.object.left = this.left),
						(e.object.right = this.right),
						(e.object.top = this.top),
						(e.object.bottom = this.bottom),
						(e.object.near = this.near),
						(e.object.far = this.far),
						null !== this.view && (e.object.view = Object.assign({}, this.view)),
						e
					)
				}
			}
			bp.prototype.isOrthographicCamera = !0
			class J7 extends yP {
				constructor() {
					super(new bp(-5, 5, 5, -5, 0.5, 500))
				}
			}
			J7.prototype.isDirectionalLightShadow = !0
			class _p extends xl {
				constructor(n, e) {
					super(n, e),
						(this.type = "DirectionalLight"),
						this.position.copy(On.DefaultUp),
						this.updateMatrix(),
						(this.target = new On()),
						(this.shadow = new J7())
				}
				copy(n) {
					return super.copy(n), (this.target = n.target.clone()), (this.shadow = n.shadow.clone()), this
				}
			}
			_p.prototype.isDirectionalLight = !0
			class nw extends xl {
				constructor(n, e) {
					super(n, e), (this.type = "AmbientLight")
				}
			}
			nw.prototype.isAmbientLight = !0
			class EP extends xl {
				constructor(n, e, i = 10, r = 10) {
					super(n, e), (this.type = "RectAreaLight"), (this.width = i), (this.height = r)
				}
				copy(n) {
					return super.copy(n), (this.width = n.width), (this.height = n.height), this
				}
				toJSON(n) {
					const e = super.toJSON(n)
					return (e.object.width = this.width), (e.object.height = this.height), e
				}
			}
			EP.prototype.isRectAreaLight = !0
			class MP {
				constructor() {
					this.coefficients = []
					for (let n = 0; n < 9; n++) this.coefficients.push(new K())
				}
				set(n) {
					for (let e = 0; e < 9; e++) this.coefficients[e].copy(n[e])
					return this
				}
				zero() {
					for (let n = 0; n < 9; n++) this.coefficients[n].set(0, 0, 0)
					return this
				}
				getAt(n, e) {
					const i = n.x,
						r = n.y,
						o = n.z,
						s = this.coefficients
					return (
						e.copy(s[0]).multiplyScalar(0.282095),
						e.addScaledVector(s[1], 0.488603 * r),
						e.addScaledVector(s[2], 0.488603 * o),
						e.addScaledVector(s[3], 0.488603 * i),
						e.addScaledVector(s[4], i * r * 1.092548),
						e.addScaledVector(s[5], r * o * 1.092548),
						e.addScaledVector(s[6], 0.315392 * (3 * o * o - 1)),
						e.addScaledVector(s[7], i * o * 1.092548),
						e.addScaledVector(s[8], 0.546274 * (i * i - r * r)),
						e
					)
				}
				getIrradianceAt(n, e) {
					const i = n.x,
						r = n.y,
						o = n.z,
						s = this.coefficients
					return (
						e.copy(s[0]).multiplyScalar(0.886227),
						e.addScaledVector(s[1], 1.023328 * r),
						e.addScaledVector(s[2], 1.023328 * o),
						e.addScaledVector(s[3], 1.023328 * i),
						e.addScaledVector(s[4], 0.858086 * i * r),
						e.addScaledVector(s[5], 0.858086 * r * o),
						e.addScaledVector(s[6], 0.743125 * o * o - 0.247708),
						e.addScaledVector(s[7], 0.858086 * i * o),
						e.addScaledVector(s[8], 0.429043 * (i * i - r * r)),
						e
					)
				}
				add(n) {
					for (let e = 0; e < 9; e++) this.coefficients[e].add(n.coefficients[e])
					return this
				}
				addScaledSH(n, e) {
					for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(n.coefficients[i], e)
					return this
				}
				scale(n) {
					for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(n)
					return this
				}
				lerp(n, e) {
					for (let i = 0; i < 9; i++) this.coefficients[i].lerp(n.coefficients[i], e)
					return this
				}
				equals(n) {
					for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(n.coefficients[e])) return !1
					return !0
				}
				copy(n) {
					return this.set(n.coefficients)
				}
				clone() {
					return new this.constructor().copy(this)
				}
				fromArray(n, e = 0) {
					const i = this.coefficients
					for (let r = 0; r < 9; r++) i[r].fromArray(n, e + 3 * r)
					return this
				}
				toArray(n = [], e = 0) {
					const i = this.coefficients
					for (let r = 0; r < 9; r++) i[r].toArray(n, e + 3 * r)
					return n
				}
				static getBasisAt(n, e) {
					const i = n.x,
						r = n.y,
						o = n.z
					;(e[0] = 0.282095),
						(e[1] = 0.488603 * r),
						(e[2] = 0.488603 * o),
						(e[3] = 0.488603 * i),
						(e[4] = 1.092548 * i * r),
						(e[5] = 1.092548 * r * o),
						(e[6] = 0.315392 * (3 * o * o - 1)),
						(e[7] = 1.092548 * i * o),
						(e[8] = 0.546274 * (i * i - r * r))
				}
			}
			MP.prototype.isSphericalHarmonics3 = !0
			class iw extends xl {
				constructor(n = new MP(), e = 1) {
					super(void 0, e), (this.sh = n)
				}
				copy(n) {
					return super.copy(n), this.sh.copy(n.sh), this
				}
				fromJSON(n) {
					return (this.intensity = n.intensity), this.sh.fromArray(n.sh), this
				}
				toJSON(n) {
					const e = super.toJSON(n)
					return (e.object.sh = this.sh.toArray()), e
				}
			}
			iw.prototype.isLightProbe = !0
			class eK extends Eo {
				constructor(n) {
					super(n), (this.textures = {})
				}
				load(n, e, i, r) {
					const o = this,
						s = new Hc(o.manager)
					s.setPath(o.path),
						s.setRequestHeader(o.requestHeader),
						s.setWithCredentials(o.withCredentials),
						s.load(
							n,
							function (a) {
								try {
									e(o.parse(JSON.parse(a)))
								} catch (c) {
									r ? r(c) : console.error(c), o.manager.itemError(n)
								}
							},
							i,
							r
						)
				}
				parse(n) {
					const e = this.textures
					function i(o) {
						return void 0 === e[o] && console.warn("THREE.MaterialLoader: Undefined texture", o), e[o]
					}
					const r = new cCe[n.type]()
					if (
						(void 0 !== n.uuid && (r.uuid = n.uuid),
						void 0 !== n.name && (r.name = n.name),
						void 0 !== n.color && void 0 !== r.color && r.color.setHex(n.color),
						void 0 !== n.roughness && (r.roughness = n.roughness),
						void 0 !== n.metalness && (r.metalness = n.metalness),
						void 0 !== n.sheen && (r.sheen = new Lt().setHex(n.sheen)),
						void 0 !== n.emissive && void 0 !== r.emissive && r.emissive.setHex(n.emissive),
						void 0 !== n.specular && void 0 !== r.specular && r.specular.setHex(n.specular),
						void 0 !== n.shininess && (r.shininess = n.shininess),
						void 0 !== n.clearcoat && (r.clearcoat = n.clearcoat),
						void 0 !== n.clearcoatRoughness && (r.clearcoatRoughness = n.clearcoatRoughness),
						void 0 !== n.fog && (r.fog = n.fog),
						void 0 !== n.flatShading && (r.flatShading = n.flatShading),
						void 0 !== n.blending && (r.blending = n.blending),
						void 0 !== n.combine && (r.combine = n.combine),
						void 0 !== n.side && (r.side = n.side),
						void 0 !== n.opacity && (r.opacity = n.opacity),
						void 0 !== n.transparent && (r.transparent = n.transparent),
						void 0 !== n.alphaTest && (r.alphaTest = n.alphaTest),
						void 0 !== n.depthTest && (r.depthTest = n.depthTest),
						void 0 !== n.depthWrite && (r.depthWrite = n.depthWrite),
						void 0 !== n.colorWrite && (r.colorWrite = n.colorWrite),
						void 0 !== n.stencilWrite && (r.stencilWrite = n.stencilWrite),
						void 0 !== n.stencilWriteMask && (r.stencilWriteMask = n.stencilWriteMask),
						void 0 !== n.stencilFunc && (r.stencilFunc = n.stencilFunc),
						void 0 !== n.stencilRef && (r.stencilRef = n.stencilRef),
						void 0 !== n.stencilFuncMask && (r.stencilFuncMask = n.stencilFuncMask),
						void 0 !== n.stencilFail && (r.stencilFail = n.stencilFail),
						void 0 !== n.stencilZFail && (r.stencilZFail = n.stencilZFail),
						void 0 !== n.stencilZPass && (r.stencilZPass = n.stencilZPass),
						void 0 !== n.wireframe && (r.wireframe = n.wireframe),
						void 0 !== n.wireframeLinewidth && (r.wireframeLinewidth = n.wireframeLinewidth),
						void 0 !== n.wireframeLinecap && (r.wireframeLinecap = n.wireframeLinecap),
						void 0 !== n.wireframeLinejoin && (r.wireframeLinejoin = n.wireframeLinejoin),
						void 0 !== n.rotation && (r.rotation = n.rotation),
						1 !== n.linewidth && (r.linewidth = n.linewidth),
						void 0 !== n.dashSize && (r.dashSize = n.dashSize),
						void 0 !== n.gapSize && (r.gapSize = n.gapSize),
						void 0 !== n.scale && (r.scale = n.scale),
						void 0 !== n.polygonOffset && (r.polygonOffset = n.polygonOffset),
						void 0 !== n.polygonOffsetFactor && (r.polygonOffsetFactor = n.polygonOffsetFactor),
						void 0 !== n.polygonOffsetUnits && (r.polygonOffsetUnits = n.polygonOffsetUnits),
						void 0 !== n.skinning && (r.skinning = n.skinning),
						void 0 !== n.morphTargets && (r.morphTargets = n.morphTargets),
						void 0 !== n.morphNormals && (r.morphNormals = n.morphNormals),
						void 0 !== n.dithering && (r.dithering = n.dithering),
						void 0 !== n.vertexTangents && (r.vertexTangents = n.vertexTangents),
						void 0 !== n.visible && (r.visible = n.visible),
						void 0 !== n.toneMapped && (r.toneMapped = n.toneMapped),
						void 0 !== n.userData && (r.userData = n.userData),
						void 0 !== n.vertexColors &&
							(r.vertexColors = "number" == typeof n.vertexColors ? n.vertexColors > 0 : n.vertexColors),
						void 0 !== n.uniforms)
					)
						for (const o in n.uniforms) {
							const s = n.uniforms[o]
							switch (((r.uniforms[o] = {}), s.type)) {
								case "t":
									r.uniforms[o].value = i(s.value)
									break
								case "c":
									r.uniforms[o].value = new Lt().setHex(s.value)
									break
								case "v2":
									r.uniforms[o].value = new lt().fromArray(s.value)
									break
								case "v3":
									r.uniforms[o].value = new K().fromArray(s.value)
									break
								case "v4":
									r.uniforms[o].value = new lr().fromArray(s.value)
									break
								case "m3":
									r.uniforms[o].value = new ns().fromArray(s.value)
									break
								case "m4":
									r.uniforms[o].value = new Cn().fromArray(s.value)
									break
								default:
									r.uniforms[o].value = s.value
							}
						}
					if (
						(void 0 !== n.defines && (r.defines = n.defines),
						void 0 !== n.vertexShader && (r.vertexShader = n.vertexShader),
						void 0 !== n.fragmentShader && (r.fragmentShader = n.fragmentShader),
						void 0 !== n.extensions)
					)
						for (const o in n.extensions) r.extensions[o] = n.extensions[o]
					if (
						(void 0 !== n.shading && (r.flatShading = 1 === n.shading),
						void 0 !== n.size && (r.size = n.size),
						void 0 !== n.sizeAttenuation && (r.sizeAttenuation = n.sizeAttenuation),
						void 0 !== n.map && (r.map = i(n.map)),
						void 0 !== n.matcap && (r.matcap = i(n.matcap)),
						void 0 !== n.alphaMap && (r.alphaMap = i(n.alphaMap)),
						void 0 !== n.bumpMap && (r.bumpMap = i(n.bumpMap)),
						void 0 !== n.bumpScale && (r.bumpScale = n.bumpScale),
						void 0 !== n.normalMap && (r.normalMap = i(n.normalMap)),
						void 0 !== n.normalMapType && (r.normalMapType = n.normalMapType),
						void 0 !== n.normalScale)
					) {
						let o = n.normalScale
						!1 === Array.isArray(o) && (o = [o, o]), (r.normalScale = new lt().fromArray(o))
					}
					return (
						void 0 !== n.displacementMap && (r.displacementMap = i(n.displacementMap)),
						void 0 !== n.displacementScale && (r.displacementScale = n.displacementScale),
						void 0 !== n.displacementBias && (r.displacementBias = n.displacementBias),
						void 0 !== n.roughnessMap && (r.roughnessMap = i(n.roughnessMap)),
						void 0 !== n.metalnessMap && (r.metalnessMap = i(n.metalnessMap)),
						void 0 !== n.emissiveMap && (r.emissiveMap = i(n.emissiveMap)),
						void 0 !== n.emissiveIntensity && (r.emissiveIntensity = n.emissiveIntensity),
						void 0 !== n.specularMap && (r.specularMap = i(n.specularMap)),
						void 0 !== n.envMap && (r.envMap = i(n.envMap)),
						void 0 !== n.envMapIntensity && (r.envMapIntensity = n.envMapIntensity),
						void 0 !== n.reflectivity && (r.reflectivity = n.reflectivity),
						void 0 !== n.refractionRatio && (r.refractionRatio = n.refractionRatio),
						void 0 !== n.lightMap && (r.lightMap = i(n.lightMap)),
						void 0 !== n.lightMapIntensity && (r.lightMapIntensity = n.lightMapIntensity),
						void 0 !== n.aoMap && (r.aoMap = i(n.aoMap)),
						void 0 !== n.aoMapIntensity && (r.aoMapIntensity = n.aoMapIntensity),
						void 0 !== n.gradientMap && (r.gradientMap = i(n.gradientMap)),
						void 0 !== n.clearcoatMap && (r.clearcoatMap = i(n.clearcoatMap)),
						void 0 !== n.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = i(n.clearcoatRoughnessMap)),
						void 0 !== n.clearcoatNormalMap && (r.clearcoatNormalMap = i(n.clearcoatNormalMap)),
						void 0 !== n.clearcoatNormalScale && (r.clearcoatNormalScale = new lt().fromArray(n.clearcoatNormalScale)),
						void 0 !== n.transmission && (r.transmission = n.transmission),
						void 0 !== n.transmissionMap && (r.transmissionMap = i(n.transmissionMap)),
						r
					)
				}
				setTextures(n) {
					return (this.textures = n), this
				}
			}
			const SP = {
				decodeText: function (t) {
					if (typeof TextDecoder < "u") return new TextDecoder().decode(t)
					let n = ""
					for (let e = 0, i = t.length; e < i; e++) n += String.fromCharCode(t[e])
					try {
						return decodeURIComponent(escape(n))
					} catch {
						return n
					}
				},
				extractUrlBase: function (t) {
					const n = t.lastIndexOf("/")
					return -1 === n ? "./" : t.substr(0, n + 1)
				}
			}
			function rw() {
				vn.call(this), (this.type = "InstancedBufferGeometry"), (this.instanceCount = 1 / 0)
			}
			function BS(t, n, e, i) {
				"number" == typeof e &&
					((i = e),
					(e = !1),
					console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
					xn.call(this, t, n, e),
					(this.meshPerAttribute = i || 1)
			}
			;(rw.prototype = Object.assign(Object.create(vn.prototype), {
				constructor: rw,
				isInstancedBufferGeometry: !0,
				copy: function (t) {
					return vn.prototype.copy.call(this, t), (this.instanceCount = t.instanceCount), this
				},
				clone: function () {
					return new this.constructor().copy(this)
				},
				toJSON: function () {
					const t = vn.prototype.toJSON.call(this)
					return (t.instanceCount = this.instanceCount), (t.isInstancedBufferGeometry = !0), t
				}
			})),
				(BS.prototype = Object.assign(Object.create(xn.prototype), {
					constructor: BS,
					isInstancedBufferAttribute: !0,
					copy: function (t) {
						return xn.prototype.copy.call(this, t), (this.meshPerAttribute = t.meshPerAttribute), this
					},
					toJSON: function () {
						const t = xn.prototype.toJSON.call(this)
						return (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t
					}
				}))
			class tK extends Eo {
				constructor(n) {
					super(n)
				}
				load(n, e, i, r) {
					const o = this,
						s = new Hc(o.manager)
					s.setPath(o.path),
						s.setRequestHeader(o.requestHeader),
						s.setWithCredentials(o.withCredentials),
						s.load(
							n,
							function (a) {
								try {
									e(o.parse(JSON.parse(a)))
								} catch (c) {
									r ? r(c) : console.error(c), o.manager.itemError(n)
								}
							},
							i,
							r
						)
				}
				parse(n) {
					const e = {},
						i = {}
					function r(f, _) {
						if (void 0 !== e[_]) return e[_]
						const C = f.interleavedBuffers[_],
							x = (function o(f, _) {
								if (void 0 !== i[_]) return i[_]
								const x = new Uint32Array(f.arrayBuffers[_]).buffer
								return (i[_] = x), x
							})(f, C.buffer),
							S = new Ra(Cy(C.type, x), C.stride)
						return (S.uuid = C.uuid), (e[_] = S), S
					}
					const s = n.isInstancedBufferGeometry ? new rw() : new vn(),
						a = n.data.index
					if (void 0 !== a) {
						const f = Cy(a.type, a.array)
						s.setIndex(new xn(f, 1))
					}
					const c = n.data.attributes
					for (const f in c) {
						const _ = c[f]
						let y
						if (_.isInterleavedBufferAttribute) y = new cf(r(n.data, _.data), _.itemSize, _.offset, _.normalized)
						else {
							const C = Cy(_.type, _.array)
							y = new (_.isInstancedBufferAttribute ? BS : xn)(C, _.itemSize, _.normalized)
						}
						void 0 !== _.name && (y.name = _.name), s.setAttribute(f, y)
					}
					const l = n.data.morphAttributes
					if (l)
						for (const f in l) {
							const _ = l[f],
								y = []
							for (let C = 0, x = _.length; C < x; C++) {
								const w = _[C]
								let S
								;(S = w.isInterleavedBufferAttribute
									? new cf(r(n.data, w.data), w.itemSize, w.offset, w.normalized)
									: new xn(Cy(w.type, w.array), w.itemSize, w.normalized)),
									void 0 !== w.name && (S.name = w.name),
									y.push(S)
							}
							s.morphAttributes[f] = y
						}
					n.data.morphTargetsRelative && (s.morphTargetsRelative = !0)
					const u = n.data.groups || n.data.drawcalls || n.data.offsets
					if (void 0 !== u)
						for (let f = 0, _ = u.length; f !== _; ++f) {
							const y = u[f]
							s.addGroup(y.start, y.count, y.materialIndex)
						}
					const h = n.data.boundingSphere
					if (void 0 !== h) {
						const f = new K()
						void 0 !== h.center && f.fromArray(h.center), (s.boundingSphere = new xd(f, h.radius))
					}
					return n.name && (s.name = n.name), n.userData && (s.userData = n.userData), s
				}
			}
			class _Ce extends Eo {
				constructor(n) {
					super(n)
				}
				load(n, e, i, r) {
					const o = this,
						s = "" === this.path ? SP.extractUrlBase(n) : this.path
					this.resourcePath = this.resourcePath || s
					const a = new Hc(this.manager)
					a.setPath(this.path),
						a.setRequestHeader(this.requestHeader),
						a.setWithCredentials(this.withCredentials),
						a.load(
							n,
							function (c) {
								let l = null
								try {
									l = JSON.parse(c)
								} catch (u) {
									return void 0 !== r && r(u), void console.error("THREE:ObjectLoader: Can't parse " + n + ".", u.message)
								}
								const d = l.metadata
								void 0 !== d && void 0 !== d.type && "geometry" !== d.type.toLowerCase()
									? o.parse(l, e)
									: console.error("THREE.ObjectLoader: Can't load " + n)
							},
							i,
							r
						)
				}
				parse(n, e) {
					const i = this.parseAnimations(n.animations),
						r = this.parseShapes(n.shapes),
						o = this.parseGeometries(n.geometries, r),
						s = this.parseImages(n.images, function () {
							void 0 !== e && e(l)
						}),
						a = this.parseTextures(n.textures, s),
						c = this.parseMaterials(n.materials, a),
						l = this.parseObject(n.object, o, c, i),
						d = this.parseSkeletons(n.skeletons, l)
					if ((this.bindSkeletons(l, d), void 0 !== e)) {
						let u = !1
						for (const h in s)
							if (s[h] instanceof HTMLImageElement) {
								u = !0
								break
							}
						!1 === u && e(l)
					}
					return l
				}
				parseShapes(n) {
					const e = {}
					if (void 0 !== n)
						for (let i = 0, r = n.length; i < r; i++) {
							const o = new hf().fromJSON(n[i])
							e[o.uuid] = o
						}
					return e
				}
				parseSkeletons(n, e) {
					const i = {},
						r = {}
					if (
						(e.traverse(function (o) {
							o.isBone && (r[o.uuid] = o)
						}),
						void 0 !== n)
					)
						for (let o = 0, s = n.length; o < s; o++) {
							const a = new Ny().fromJSON(n[o], r)
							i[a.uuid] = a
						}
					return i
				}
				parseGeometries(n, e) {
					const i = {}
					let r
					if (void 0 !== n) {
						const o = new tK()
						for (let s = 0, a = n.length; s < a; s++) {
							let c
							const l = n[s]
							switch (l.type) {
								case "PlaneGeometry":
								case "PlaneBufferGeometry":
									c = new Aa[l.type](l.width, l.height, l.widthSegments, l.heightSegments)
									break
								case "BoxGeometry":
								case "BoxBufferGeometry":
									c = new Aa[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments)
									break
								case "CircleGeometry":
								case "CircleBufferGeometry":
									c = new Aa[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength)
									break
								case "CylinderGeometry":
								case "CylinderBufferGeometry":
									c = new Aa[l.type](
										l.radiusTop,
										l.radiusBottom,
										l.height,
										l.radialSegments,
										l.heightSegments,
										l.openEnded,
										l.thetaStart,
										l.thetaLength
									)
									break
								case "ConeGeometry":
								case "ConeBufferGeometry":
									c = new Aa[l.type](
										l.radius,
										l.height,
										l.radialSegments,
										l.heightSegments,
										l.openEnded,
										l.thetaStart,
										l.thetaLength
									)
									break
								case "SphereGeometry":
								case "SphereBufferGeometry":
									c = new Aa[l.type](
										l.radius,
										l.widthSegments,
										l.heightSegments,
										l.phiStart,
										l.phiLength,
										l.thetaStart,
										l.thetaLength
									)
									break
								case "DodecahedronGeometry":
								case "DodecahedronBufferGeometry":
								case "IcosahedronGeometry":
								case "IcosahedronBufferGeometry":
								case "OctahedronGeometry":
								case "OctahedronBufferGeometry":
								case "TetrahedronGeometry":
								case "TetrahedronBufferGeometry":
									c = new Aa[l.type](l.radius, l.detail)
									break
								case "RingGeometry":
								case "RingBufferGeometry":
									c = new Aa[l.type](
										l.innerRadius,
										l.outerRadius,
										l.thetaSegments,
										l.phiSegments,
										l.thetaStart,
										l.thetaLength
									)
									break
								case "TorusGeometry":
								case "TorusBufferGeometry":
									c = new Aa[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc)
									break
								case "TorusKnotGeometry":
								case "TorusKnotBufferGeometry":
									c = new Aa[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q)
									break
								case "TubeGeometry":
								case "TubeBufferGeometry":
									c = new Aa[l.type](
										new _P[l.path.type]().fromJSON(l.path),
										l.tubularSegments,
										l.radius,
										l.radialSegments,
										l.closed
									)
									break
								case "LatheGeometry":
								case "LatheBufferGeometry":
									c = new Aa[l.type](l.points, l.segments, l.phiStart, l.phiLength)
									break
								case "PolyhedronGeometry":
								case "PolyhedronBufferGeometry":
									c = new Aa[l.type](l.vertices, l.indices, l.radius, l.details)
									break
								case "ShapeGeometry":
								case "ShapeBufferGeometry":
									r = []
									for (let u = 0, h = l.shapes.length; u < h; u++) r.push(e[l.shapes[u]])
									c = new Aa[l.type](r, l.curveSegments)
									break
								case "ExtrudeGeometry":
								case "ExtrudeBufferGeometry":
									r = []
									for (let u = 0, h = l.shapes.length; u < h; u++) r.push(e[l.shapes[u]])
									const d = l.options.extrudePath
									void 0 !== d && (l.options.extrudePath = new _P[d.type]().fromJSON(d)),
										(c = new Aa[l.type](r, l.options))
									break
								case "BufferGeometry":
								case "InstancedBufferGeometry":
									c = o.parse(l)
									break
								case "Geometry":
									console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.')
									break
								default:
									console.warn('THREE.ObjectLoader: Unsupported geometry type "' + l.type + '"')
									continue
							}
							;(c.uuid = l.uuid),
								void 0 !== l.name && (c.name = l.name),
								!0 === c.isBufferGeometry && void 0 !== l.userData && (c.userData = l.userData),
								(i[l.uuid] = c)
						}
					}
					return i
				}
				parseMaterials(n, e) {
					const i = {},
						r = {}
					if (void 0 !== n) {
						const o = new eK()
						o.setTextures(e)
						for (let s = 0, a = n.length; s < a; s++) {
							const c = n[s]
							if ("MultiMaterial" === c.type) {
								const l = []
								for (let d = 0; d < c.materials.length; d++) {
									const u = c.materials[d]
									void 0 === i[u.uuid] && (i[u.uuid] = o.parse(u)), l.push(i[u.uuid])
								}
								r[c.uuid] = l
							} else void 0 === i[c.uuid] && (i[c.uuid] = o.parse(c)), (r[c.uuid] = i[c.uuid])
						}
					}
					return r
				}
				parseAnimations(n) {
					const e = {}
					if (void 0 !== n)
						for (let i = 0; i < n.length; i++) {
							const o = Xy.parse(n[i])
							e[o.uuid] = o
						}
					return e
				}
				parseImages(n, e) {
					const i = this,
						r = {}
					let o
					function a(c) {
						if ("string" == typeof c) {
							const l = c
							return (function s(c) {
								return (
									i.manager.itemStart(c),
									o.load(
										c,
										function () {
											i.manager.itemEnd(c)
										},
										void 0,
										function () {
											i.manager.itemError(c), i.manager.itemEnd(c)
										}
									)
								)
							})(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : i.resourcePath + l)
						}
						return c.data ? { data: Cy(c.type, c.data), width: c.width, height: c.height } : null
					}
					if (void 0 !== n && n.length > 0) {
						const c = new dP(e)
						;(o = new xS(c)), o.setCrossOrigin(this.crossOrigin)
						for (let l = 0, d = n.length; l < d; l++) {
							const u = n[l],
								h = u.url
							if (Array.isArray(h)) {
								r[u.uuid] = []
								for (let f = 0, _ = h.length; f < _; f++) {
									const C = a(h[f])
									null !== C &&
										(C instanceof HTMLImageElement
											? r[u.uuid].push(C)
											: r[u.uuid].push(new Jg(C.data, C.width, C.height)))
								}
							} else {
								const f = a(u.url)
								null !== f && (r[u.uuid] = f)
							}
						}
					}
					return r
				}
				parseTextures(n, e) {
					function i(o, s) {
						return "number" == typeof o
							? o
							: (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), s[o])
					}
					const r = {}
					if (void 0 !== n)
						for (let o = 0, s = n.length; o < s; o++) {
							const a = n[o]
							let c
							void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
								void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image)
							const l = e[a.image]
							Array.isArray(l)
								? ((c = new Zg(l)), 6 === l.length && (c.needsUpdate = !0))
								: ((c = l && l.data ? new Jg(l.data, l.width, l.height) : new zo(l)), l && (c.needsUpdate = !0)),
								(c.uuid = a.uuid),
								void 0 !== a.name && (c.name = a.name),
								void 0 !== a.mapping && (c.mapping = i(a.mapping, vCe)),
								void 0 !== a.offset && c.offset.fromArray(a.offset),
								void 0 !== a.repeat && c.repeat.fromArray(a.repeat),
								void 0 !== a.center && c.center.fromArray(a.center),
								void 0 !== a.rotation && (c.rotation = a.rotation),
								void 0 !== a.wrap && ((c.wrapS = i(a.wrap[0], nK)), (c.wrapT = i(a.wrap[1], nK))),
								void 0 !== a.format && (c.format = a.format),
								void 0 !== a.type && (c.type = a.type),
								void 0 !== a.encoding && (c.encoding = a.encoding),
								void 0 !== a.minFilter && (c.minFilter = i(a.minFilter, iK)),
								void 0 !== a.magFilter && (c.magFilter = i(a.magFilter, iK)),
								void 0 !== a.anisotropy && (c.anisotropy = a.anisotropy),
								void 0 !== a.flipY && (c.flipY = a.flipY),
								void 0 !== a.premultiplyAlpha && (c.premultiplyAlpha = a.premultiplyAlpha),
								void 0 !== a.unpackAlignment && (c.unpackAlignment = a.unpackAlignment),
								(r[a.uuid] = c)
						}
					return r
				}
				parseObject(n, e, i, r) {
					let o, c, l
					function s(d) {
						return void 0 === e[d] && console.warn("THREE.ObjectLoader: Undefined geometry", d), e[d]
					}
					function a(d) {
						if (void 0 !== d) {
							if (Array.isArray(d)) {
								const u = []
								for (let h = 0, f = d.length; h < f; h++) {
									const _ = d[h]
									void 0 === i[_] && console.warn("THREE.ObjectLoader: Undefined material", _), u.push(i[_])
								}
								return u
							}
							return void 0 === i[d] && console.warn("THREE.ObjectLoader: Undefined material", d), i[d]
						}
					}
					switch (n.type) {
						case "Scene":
							;(o = new nb()),
								void 0 !== n.background && Number.isInteger(n.background) && (o.background = new Lt(n.background)),
								void 0 !== n.fog &&
									("Fog" === n.fog.type
										? (o.fog = new By(n.fog.color, n.fog.near, n.fog.far))
										: "FogExp2" === n.fog.type && (o.fog = new Fy(n.fog.color, n.fog.density)))
							break
						case "PerspectiveCamera":
							;(o = new Co(n.fov, n.aspect, n.near, n.far)),
								void 0 !== n.focus && (o.focus = n.focus),
								void 0 !== n.zoom && (o.zoom = n.zoom),
								void 0 !== n.filmGauge && (o.filmGauge = n.filmGauge),
								void 0 !== n.filmOffset && (o.filmOffset = n.filmOffset),
								void 0 !== n.view && (o.view = Object.assign({}, n.view))
							break
						case "OrthographicCamera":
							;(o = new bp(n.left, n.right, n.top, n.bottom, n.near, n.far)),
								void 0 !== n.zoom && (o.zoom = n.zoom),
								void 0 !== n.view && (o.view = Object.assign({}, n.view))
							break
						case "AmbientLight":
							o = new nw(n.color, n.intensity)
							break
						case "DirectionalLight":
							o = new _p(n.color, n.intensity)
							break
						case "PointLight":
							o = new CP(n.color, n.intensity, n.distance, n.decay)
							break
						case "RectAreaLight":
							o = new EP(n.color, n.intensity, n.width, n.height)
							break
						case "SpotLight":
							o = new wP(n.color, n.intensity, n.distance, n.angle, n.penumbra, n.decay)
							break
						case "HemisphereLight":
							o = new vP(n.color, n.groundColor, n.intensity)
							break
						case "LightProbe":
							o = new iw().fromJSON(n)
							break
						case "SkinnedMesh":
							;(c = s(n.geometry)),
								(l = a(n.material)),
								(o = new Py(c, l)),
								void 0 !== n.bindMode && (o.bindMode = n.bindMode),
								void 0 !== n.bindMatrix && o.bindMatrix.fromArray(n.bindMatrix),
								void 0 !== n.skeleton && (o.skeleton = n.skeleton)
							break
						case "Mesh":
							;(c = s(n.geometry)), (l = a(n.material)), (o = new Mi(c, l))
							break
						case "InstancedMesh":
							;(c = s(n.geometry)), (l = a(n.material))
							const u = n.instanceMatrix
							;(o = new qM(c, l, n.count)), (o.instanceMatrix = new xn(new Float32Array(u.array), 16))
							break
						case "LOD":
							o = new KR()
							break
						case "Line":
							o = new ma(s(n.geometry), a(n.material))
							break
						case "LineLoop":
							o = new YR(s(n.geometry), a(n.material))
							break
						case "LineSegments":
							o = new pa(s(n.geometry), a(n.material))
							break
						case "PointCloud":
						case "Points":
							o = new cb(s(n.geometry), a(n.material))
							break
						case "Sprite":
							o = new ab(a(n.material))
							break
						case "Group":
							o = new ps()
							break
						case "Bone":
							o = new Oy()
							break
						default:
							o = new On()
					}
					if (
						((o.uuid = n.uuid),
						void 0 !== n.name && (o.name = n.name),
						void 0 !== n.matrix
							? (o.matrix.fromArray(n.matrix),
							  void 0 !== n.matrixAutoUpdate && (o.matrixAutoUpdate = n.matrixAutoUpdate),
							  o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale))
							: (void 0 !== n.position && o.position.fromArray(n.position),
							  void 0 !== n.rotation && o.rotation.fromArray(n.rotation),
							  void 0 !== n.quaternion && o.quaternion.fromArray(n.quaternion),
							  void 0 !== n.scale && o.scale.fromArray(n.scale)),
						void 0 !== n.castShadow && (o.castShadow = n.castShadow),
						void 0 !== n.receiveShadow && (o.receiveShadow = n.receiveShadow),
						n.shadow &&
							(void 0 !== n.shadow.bias && (o.shadow.bias = n.shadow.bias),
							void 0 !== n.shadow.normalBias && (o.shadow.normalBias = n.shadow.normalBias),
							void 0 !== n.shadow.radius && (o.shadow.radius = n.shadow.radius),
							void 0 !== n.shadow.mapSize && o.shadow.mapSize.fromArray(n.shadow.mapSize),
							void 0 !== n.shadow.camera && (o.shadow.camera = this.parseObject(n.shadow.camera))),
						void 0 !== n.visible && (o.visible = n.visible),
						void 0 !== n.frustumCulled && (o.frustumCulled = n.frustumCulled),
						void 0 !== n.renderOrder && (o.renderOrder = n.renderOrder),
						void 0 !== n.userData && (o.userData = n.userData),
						void 0 !== n.layers && (o.layers.mask = n.layers),
						void 0 !== n.children)
					) {
						const d = n.children
						for (let u = 0; u < d.length; u++) o.add(this.parseObject(d[u], e, i, r))
					}
					if (void 0 !== n.animations) {
						const d = n.animations
						for (let u = 0; u < d.length; u++) o.animations.push(r[d[u]])
					}
					if ("LOD" === n.type) {
						void 0 !== n.autoUpdate && (o.autoUpdate = n.autoUpdate)
						const d = n.levels
						for (let u = 0; u < d.length; u++) {
							const h = d[u],
								f = o.getObjectByProperty("uuid", h.object)
							void 0 !== f && o.addLevel(f, h.distance)
						}
					}
					return o
				}
				bindSkeletons(n, e) {
					0 !== Object.keys(e).length &&
						n.traverse(function (i) {
							if (!0 === i.isSkinnedMesh && void 0 !== i.skeleton) {
								const r = e[i.skeleton]
								void 0 === r
									? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton)
									: i.bind(r, i.bindMatrix)
							}
						})
				}
				setTexturePath(n) {
					return (
						console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),
						this.setResourcePath(n)
					)
				}
			}
			const vCe = {
					UVMapping: hM,
					CubeReflectionMapping: ny,
					CubeRefractionMapping: iy,
					EquirectangularReflectionMapping: fM,
					EquirectangularRefractionMapping: mM,
					CubeUVReflectionMapping: Lg,
					CubeUVRefractionMapping: ry
				},
				nK = { RepeatWrapping: ep, ClampToEdgeWrapping: ua, MirroredRepeatWrapping: oy },
				iK = {
					NearestFilter: ts,
					NearestMipmapNearestFilter: pM,
					NearestMipmapLinearFilter: AM,
					LinearFilter: xo,
					LinearMipmapNearestFilter: oR,
					LinearMipmapLinearFilter: Rg
				}
			function kP(t) {
				typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
					typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
					Eo.call(this, t),
					(this.options = { premultiplyAlpha: "none" })
			}
			kP.prototype = Object.assign(Object.create(Eo.prototype), {
				constructor: kP,
				isImageBitmapLoader: !0,
				setOptions: function (n) {
					return (this.options = n), this
				},
				load: function (t, n, e, i) {
					void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
					const r = this,
						o = gp.get(t)
					if (void 0 !== o)
						return (
							r.manager.itemStart(t),
							setTimeout(function () {
								n && n(o), r.manager.itemEnd(t)
							}, 0),
							o
						)
					const s = {}
					;(s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include"),
						(s.headers = this.requestHeader),
						fetch(t, s)
							.then(function (a) {
								return a.blob()
							})
							.then(function (a) {
								return createImageBitmap(a, Object.assign(r.options, { colorSpaceConversion: "none" }))
							})
							.then(function (a) {
								gp.add(t, a), n && n(a), r.manager.itemEnd(t)
							})
							.catch(function (a) {
								i && i(a), r.manager.itemError(t), r.manager.itemEnd(t)
							}),
						r.manager.itemStart(t)
				}
			})
			class rK {
				constructor() {
					;(this.type = "ShapePath"), (this.color = new Lt()), (this.subPaths = []), (this.currentPath = null)
				}
				moveTo(n, e) {
					return (this.currentPath = new ew()), this.subPaths.push(this.currentPath), this.currentPath.moveTo(n, e), this
				}
				lineTo(n, e) {
					return this.currentPath.lineTo(n, e), this
				}
				quadraticCurveTo(n, e, i, r) {
					return this.currentPath.quadraticCurveTo(n, e, i, r), this
				}
				bezierCurveTo(n, e, i, r, o, s) {
					return this.currentPath.bezierCurveTo(n, e, i, r, o, s), this
				}
				splineThru(n) {
					return this.currentPath.splineThru(n), this
				}
				toShapes(n, e) {
					function i(w) {
						const S = []
						for (let M = 0, O = w.length; M < O; M++) {
							const N = w[M],
								j = new hf()
							;(j.curves = N.curves), S.push(j)
						}
						return S
					}
					function r(w, S) {
						const M = S.length
						let O = !1
						for (let N = M - 1, j = 0; j < M; N = j++) {
							let le = S[N],
								ae = S[j],
								ce = ae.x - le.x,
								ue = ae.y - le.y
							if (Math.abs(ue) > Number.EPSILON) {
								if ((ue < 0 && ((le = S[j]), (ce = -ce), (ae = S[N]), (ue = -ue)), w.y < le.y || w.y > ae.y)) continue
								if (w.y === le.y) {
									if (w.x === le.x) return !0
								} else {
									const Se = ue * (w.x - le.x) - ce * (w.y - le.y)
									if (0 === Se) return !0
									if (Se < 0) continue
									O = !O
								}
							} else {
								if (w.y !== le.y) continue
								if ((ae.x <= w.x && w.x <= le.x) || (le.x <= w.x && w.x <= ae.x)) return !0
							}
						}
						return O
					}
					const o = Uu.isClockWise,
						s = this.subPaths
					if (0 === s.length) return []
					if (!0 === e) return i(s)
					let a, c, l
					const d = []
					if (1 === s.length) return (c = s[0]), (l = new hf()), (l.curves = c.curves), d.push(l), d
					let u = !o(s[0].getPoints())
					u = n ? !u : u
					const h = [],
						f = []
					let C,
						x,
						_ = [],
						y = 0
					;(f[y] = void 0), (_[y] = [])
					for (let w = 0, S = s.length; w < S; w++)
						(c = s[w]),
							(C = c.getPoints()),
							(a = o(C)),
							(a = n ? !a : a),
							a
								? (!u && f[y] && y++, (f[y] = { s: new hf(), p: C }), (f[y].s.curves = c.curves), u && y++, (_[y] = []))
								: _[y].push({ h: c, p: C[0] })
					if (!f[0]) return i(s)
					if (f.length > 1) {
						let w = !1
						const S = []
						for (let M = 0, O = f.length; M < O; M++) h[M] = []
						for (let M = 0, O = f.length; M < O; M++) {
							const N = _[M]
							for (let j = 0; j < N.length; j++) {
								const le = N[j]
								let ae = !0
								for (let ce = 0; ce < f.length; ce++)
									r(le.p, f[ce].p) &&
										(M !== ce && S.push({ froms: M, tos: ce, hole: j }), ae ? ((ae = !1), h[ce].push(le)) : (w = !0))
								ae && h[M].push(le)
							}
						}
						S.length > 0 && (w || (_ = h))
					}
					for (let w = 0, S = f.length; w < S; w++) {
						;(l = f[w].s), d.push(l), (x = _[w])
						for (let M = 0, O = x.length; M < O; M++) l.holes.push(x[M].h)
					}
					return d
				}
			}
			class TP {
				constructor(n) {
					;(this.type = "Font"), (this.data = n)
				}
				generateShapes(n, e = 100) {
					const i = [],
						r = (function yCe(t, n, e) {
							const i = Array.from(t),
								r = n / e.resolution,
								o = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * r,
								s = []
							let a = 0,
								c = 0
							for (let l = 0; l < i.length; l++) {
								const d = i[l]
								if ("\n" === d) (a = 0), (c -= o)
								else {
									const u = wCe(d, r, a, c, e)
									;(a += u.offsetX), s.push(u.path)
								}
							}
							return s
						})(n, e, this.data)
					for (let o = 0, s = r.length; o < s; o++) Array.prototype.push.apply(i, r[o].toShapes())
					return i
				}
			}
			function wCe(t, n, e, i, r) {
				const o = r.glyphs[t] || r.glyphs["?"]
				if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".")
				const s = new rK()
				let a, c, l, d, u, h, f, _
				if (o.o) {
					const y = o._cachedOutline || (o._cachedOutline = o.o.split(" "))
					for (let C = 0, x = y.length; C < x; )
						switch (y[C++]) {
							case "m":
								;(a = y[C++] * n + e), (c = y[C++] * n + i), s.moveTo(a, c)
								break
							case "l":
								;(a = y[C++] * n + e), (c = y[C++] * n + i), s.lineTo(a, c)
								break
							case "q":
								;(l = y[C++] * n + e),
									(d = y[C++] * n + i),
									(u = y[C++] * n + e),
									(h = y[C++] * n + i),
									s.quadraticCurveTo(u, h, l, d)
								break
							case "b":
								;(l = y[C++] * n + e),
									(d = y[C++] * n + i),
									(u = y[C++] * n + e),
									(h = y[C++] * n + i),
									(f = y[C++] * n + e),
									(_ = y[C++] * n + i),
									s.bezierCurveTo(u, h, f, _, l, d)
						}
				}
				return { offsetX: o.ha * n, path: s }
			}
			TP.prototype.isFont = !0
			class xCe extends Eo {
				constructor(n) {
					super(n)
				}
				load(n, e, i, r) {
					const o = this,
						s = new Hc(this.manager)
					s.setPath(this.path),
						s.setRequestHeader(this.requestHeader),
						s.setWithCredentials(o.withCredentials),
						s.load(
							n,
							function (a) {
								let c
								try {
									c = JSON.parse(a)
								} catch {
									console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
										(c = JSON.parse(a.substring(65, a.length - 2)))
								}
								const l = o.parse(c)
								e && e(l)
							},
							i,
							r
						)
				}
				parse(n) {
					return new TP(n)
				}
			}
			let IS
			const FP = {
				getContext: function () {
					return void 0 === IS && (IS = new (window.AudioContext || window.webkitAudioContext)()), IS
				},
				setContext: function (t) {
					IS = t
				}
			}
			class oK extends Eo {
				constructor(n) {
					super(n)
				}
				load(n, e, i, r) {
					const o = this,
						s = new Hc(this.manager)
					s.setResponseType("arraybuffer"),
						s.setPath(this.path),
						s.setRequestHeader(this.requestHeader),
						s.setWithCredentials(this.withCredentials),
						s.load(
							n,
							function (a) {
								try {
									const c = a.slice(0)
									FP.getContext().decodeAudioData(c, function (d) {
										e(d)
									})
								} catch (c) {
									r ? r(c) : console.error(c), o.manager.itemError(n)
								}
							},
							i,
							r
						)
				}
			}
			class sK extends iw {
				constructor(n, e, i = 1) {
					super(void 0, i)
					const r = new Lt().set(n),
						o = new Lt().set(e),
						s = new K(r.r, r.g, r.b),
						a = new K(o.r, o.g, o.b),
						c = Math.sqrt(Math.PI),
						l = c * Math.sqrt(0.75)
					this.sh.coefficients[0].copy(s).add(a).multiplyScalar(c), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
				}
			}
			sK.prototype.isHemisphereLightProbe = !0
			class aK extends iw {
				constructor(n, e = 1) {
					super(void 0, e)
					const i = new Lt().set(n)
					this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
				}
			}
			aK.prototype.isAmbientLightProbe = !0
			const cK = new Cn(),
				lK = new Cn()
			class CCe {
				constructor() {
					;(this.type = "StereoCamera"),
						(this.aspect = 1),
						(this.eyeSep = 0.064),
						(this.cameraL = new Co()),
						this.cameraL.layers.enable(1),
						(this.cameraL.matrixAutoUpdate = !1),
						(this.cameraR = new Co()),
						this.cameraR.layers.enable(2),
						(this.cameraR.matrixAutoUpdate = !1),
						(this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null })
				}
				update(n) {
					const e = this._cache
					if (
						e.focus !== n.focus ||
						e.fov !== n.fov ||
						e.aspect !== n.aspect * this.aspect ||
						e.near !== n.near ||
						e.far !== n.far ||
						e.zoom !== n.zoom ||
						e.eyeSep !== this.eyeSep
					) {
						;(e.focus = n.focus),
							(e.fov = n.fov),
							(e.aspect = n.aspect * this.aspect),
							(e.near = n.near),
							(e.far = n.far),
							(e.zoom = n.zoom),
							(e.eyeSep = this.eyeSep)
						const r = n.projectionMatrix.clone(),
							o = e.eyeSep / 2,
							s = (o * e.near) / e.focus,
							a = (e.near * Math.tan(jn.DEG2RAD * e.fov * 0.5)) / e.zoom
						let c, l
						;(lK.elements[12] = -o),
							(cK.elements[12] = o),
							(c = -a * e.aspect + s),
							(l = a * e.aspect + s),
							(r.elements[0] = (2 * e.near) / (l - c)),
							(r.elements[8] = (l + c) / (l - c)),
							this.cameraL.projectionMatrix.copy(r),
							(c = -a * e.aspect - s),
							(l = a * e.aspect - s),
							(r.elements[0] = (2 * e.near) / (l - c)),
							(r.elements[8] = (l + c) / (l - c)),
							this.cameraR.projectionMatrix.copy(r)
					}
					this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(lK), this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(cK)
				}
			}
			class BP {
				constructor(n) {
					;(this.autoStart = void 0 === n || n),
						(this.startTime = 0),
						(this.oldTime = 0),
						(this.elapsedTime = 0),
						(this.running = !1)
				}
				start() {
					;(this.startTime = dK()), (this.oldTime = this.startTime), (this.elapsedTime = 0), (this.running = !0)
				}
				stop() {
					this.getElapsedTime(), (this.running = !1), (this.autoStart = !1)
				}
				getElapsedTime() {
					return this.getDelta(), this.elapsedTime
				}
				getDelta() {
					let n = 0
					if (this.autoStart && !this.running) return this.start(), 0
					if (this.running) {
						const e = dK()
						;(n = (e - this.oldTime) / 1e3), (this.oldTime = e), (this.elapsedTime += n)
					}
					return n
				}
			}
			function dK() {
				return (typeof performance > "u" ? Date : performance).now()
			}
			const vp = new K(),
				uK = new fs(),
				ECe = new K(),
				yp = new K()
			class MCe extends On {
				constructor() {
					super(),
						(this.type = "AudioListener"),
						(this.context = FP.getContext()),
						(this.gain = this.context.createGain()),
						this.gain.connect(this.context.destination),
						(this.filter = null),
						(this.timeDelta = 0),
						(this._clock = new BP())
				}
				getInput() {
					return this.gain
				}
				removeFilter() {
					return (
						null !== this.filter &&
							(this.gain.disconnect(this.filter),
							this.filter.disconnect(this.context.destination),
							this.gain.connect(this.context.destination),
							(this.filter = null)),
						this
					)
				}
				getFilter() {
					return this.filter
				}
				setFilter(n) {
					return (
						null !== this.filter
							? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination))
							: this.gain.disconnect(this.context.destination),
						(this.filter = n),
						this.gain.connect(this.filter),
						this.filter.connect(this.context.destination),
						this
					)
				}
				getMasterVolume() {
					return this.gain.gain.value
				}
				setMasterVolume(n) {
					return this.gain.gain.setTargetAtTime(n, this.context.currentTime, 0.01), this
				}
				updateMatrixWorld(n) {
					super.updateMatrixWorld(n)
					const e = this.context.listener,
						i = this.up
					if (
						((this.timeDelta = this._clock.getDelta()),
						this.matrixWorld.decompose(vp, uK, ECe),
						yp.set(0, 0, -1).applyQuaternion(uK),
						e.positionX)
					) {
						const r = this.context.currentTime + this.timeDelta
						e.positionX.linearRampToValueAtTime(vp.x, r),
							e.positionY.linearRampToValueAtTime(vp.y, r),
							e.positionZ.linearRampToValueAtTime(vp.z, r),
							e.forwardX.linearRampToValueAtTime(yp.x, r),
							e.forwardY.linearRampToValueAtTime(yp.y, r),
							e.forwardZ.linearRampToValueAtTime(yp.z, r),
							e.upX.linearRampToValueAtTime(i.x, r),
							e.upY.linearRampToValueAtTime(i.y, r),
							e.upZ.linearRampToValueAtTime(i.z, r)
					} else e.setPosition(vp.x, vp.y, vp.z), e.setOrientation(yp.x, yp.y, yp.z, i.x, i.y, i.z)
				}
			}
			class IP extends On {
				constructor(n) {
					super(),
						(this.type = "Audio"),
						(this.listener = n),
						(this.context = n.context),
						(this.gain = this.context.createGain()),
						this.gain.connect(n.getInput()),
						(this.autoplay = !1),
						(this.buffer = null),
						(this.detune = 0),
						(this.loop = !1),
						(this.loopStart = 0),
						(this.loopEnd = 0),
						(this.offset = 0),
						(this.duration = void 0),
						(this.playbackRate = 1),
						(this.isPlaying = !1),
						(this.hasPlaybackControl = !0),
						(this.source = null),
						(this.sourceType = "empty"),
						(this._startedAt = 0),
						(this._progress = 0),
						(this._connected = !1),
						(this.filters = [])
				}
				getOutput() {
					return this.gain
				}
				setNodeSource(n) {
					return (this.hasPlaybackControl = !1), (this.sourceType = "audioNode"), (this.source = n), this.connect(), this
				}
				setMediaElementSource(n) {
					return (
						(this.hasPlaybackControl = !1),
						(this.sourceType = "mediaNode"),
						(this.source = this.context.createMediaElementSource(n)),
						this.connect(),
						this
					)
				}
				setMediaStreamSource(n) {
					return (
						(this.hasPlaybackControl = !1),
						(this.sourceType = "mediaStreamNode"),
						(this.source = this.context.createMediaStreamSource(n)),
						this.connect(),
						this
					)
				}
				setBuffer(n) {
					return (this.buffer = n), (this.sourceType = "buffer"), this.autoplay && this.play(), this
				}
				play(n = 0) {
					if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.")
					if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.")
					this._startedAt = this.context.currentTime + n
					const e = this.context.createBufferSource()
					return (
						(e.buffer = this.buffer),
						(e.loop = this.loop),
						(e.loopStart = this.loopStart),
						(e.loopEnd = this.loopEnd),
						(e.onended = this.onEnded.bind(this)),
						e.start(this._startedAt, this._progress + this.offset, this.duration),
						(this.isPlaying = !0),
						(this.source = e),
						this.setDetune(this.detune),
						this.setPlaybackRate(this.playbackRate),
						this.connect()
					)
				}
				pause() {
					if (!1 !== this.hasPlaybackControl)
						return (
							!0 === this.isPlaying &&
								((this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
								!0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
								this.source.stop(),
								(this.source.onended = null),
								(this.isPlaying = !1)),
							this
						)
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				stop() {
					if (!1 !== this.hasPlaybackControl)
						return (this._progress = 0), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1), this
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				connect() {
					if (this.filters.length > 0) {
						this.source.connect(this.filters[0])
						for (let n = 1, e = this.filters.length; n < e; n++) this.filters[n - 1].connect(this.filters[n])
						this.filters[this.filters.length - 1].connect(this.getOutput())
					} else this.source.connect(this.getOutput())
					return (this._connected = !0), this
				}
				disconnect() {
					if (this.filters.length > 0) {
						this.source.disconnect(this.filters[0])
						for (let n = 1, e = this.filters.length; n < e; n++) this.filters[n - 1].disconnect(this.filters[n])
						this.filters[this.filters.length - 1].disconnect(this.getOutput())
					} else this.source.disconnect(this.getOutput())
					return (this._connected = !1), this
				}
				getFilters() {
					return this.filters
				}
				setFilters(n) {
					return (
						n || (n = []),
						!0 === this._connected
							? (this.disconnect(), (this.filters = n.slice()), this.connect())
							: (this.filters = n.slice()),
						this
					)
				}
				setDetune(n) {
					if (((this.detune = n), void 0 !== this.source.detune))
						return (
							!0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this
						)
				}
				getDetune() {
					return this.detune
				}
				getFilter() {
					return this.getFilters()[0]
				}
				setFilter(n) {
					return this.setFilters(n ? [n] : [])
				}
				setPlaybackRate(n) {
					if (!1 !== this.hasPlaybackControl)
						return (
							(this.playbackRate = n),
							!0 === this.isPlaying &&
								this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01),
							this
						)
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				getPlaybackRate() {
					return this.playbackRate
				}
				onEnded() {
					this.isPlaying = !1
				}
				getLoop() {
					return !1 === this.hasPlaybackControl
						? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
						: this.loop
				}
				setLoop(n) {
					if (!1 !== this.hasPlaybackControl)
						return (this.loop = n), !0 === this.isPlaying && (this.source.loop = this.loop), this
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				setLoopStart(n) {
					return (this.loopStart = n), this
				}
				setLoopEnd(n) {
					return (this.loopEnd = n), this
				}
				getVolume() {
					return this.gain.gain.value
				}
				setVolume(n) {
					return this.gain.gain.setTargetAtTime(n, this.context.currentTime, 0.01), this
				}
			}
			const wp = new K(),
				hK = new fs(),
				SCe = new K(),
				xp = new K()
			class kCe extends IP {
				constructor(n) {
					super(n),
						(this.panner = this.context.createPanner()),
						(this.panner.panningModel = "HRTF"),
						this.panner.connect(this.gain)
				}
				getOutput() {
					return this.panner
				}
				getRefDistance() {
					return this.panner.refDistance
				}
				setRefDistance(n) {
					return (this.panner.refDistance = n), this
				}
				getRolloffFactor() {
					return this.panner.rolloffFactor
				}
				setRolloffFactor(n) {
					return (this.panner.rolloffFactor = n), this
				}
				getDistanceModel() {
					return this.panner.distanceModel
				}
				setDistanceModel(n) {
					return (this.panner.distanceModel = n), this
				}
				getMaxDistance() {
					return this.panner.maxDistance
				}
				setMaxDistance(n) {
					return (this.panner.maxDistance = n), this
				}
				setDirectionalCone(n, e, i) {
					return (this.panner.coneInnerAngle = n), (this.panner.coneOuterAngle = e), (this.panner.coneOuterGain = i), this
				}
				updateMatrixWorld(n) {
					if ((super.updateMatrixWorld(n), !0 === this.hasPlaybackControl && !1 === this.isPlaying)) return
					this.matrixWorld.decompose(wp, hK, SCe), xp.set(0, 0, 1).applyQuaternion(hK)
					const e = this.panner
					if (e.positionX) {
						const i = this.context.currentTime + this.listener.timeDelta
						e.positionX.linearRampToValueAtTime(wp.x, i),
							e.positionY.linearRampToValueAtTime(wp.y, i),
							e.positionZ.linearRampToValueAtTime(wp.z, i),
							e.orientationX.linearRampToValueAtTime(xp.x, i),
							e.orientationY.linearRampToValueAtTime(xp.y, i),
							e.orientationZ.linearRampToValueAtTime(xp.z, i)
					} else e.setPosition(wp.x, wp.y, wp.z), e.setOrientation(xp.x, xp.y, xp.z)
				}
			}
			class fK {
				constructor(n, e = 2048) {
					;(this.analyser = n.context.createAnalyser()),
						(this.analyser.fftSize = e),
						(this.data = new Uint8Array(this.analyser.frequencyBinCount)),
						n.getOutput().connect(this.analyser)
				}
				getFrequencyData() {
					return this.analyser.getByteFrequencyData(this.data), this.data
				}
				getAverageFrequency() {
					let n = 0
					const e = this.getFrequencyData()
					for (let i = 0; i < e.length; i++) n += e[i]
					return n / e.length
				}
			}
			class mK {
				constructor(n, e, i) {
					let r, o, s
					switch (((this.binding = n), (this.valueSize = i), e)) {
						case "quaternion":
							;(r = this._slerp),
								(o = this._slerpAdditive),
								(s = this._setAdditiveIdentityQuaternion),
								(this.buffer = new Float64Array(6 * i)),
								(this._workIndex = 5)
							break
						case "string":
						case "bool":
							;(r = this._select), (o = this._select), (s = this._setAdditiveIdentityOther), (this.buffer = new Array(5 * i))
							break
						default:
							;(r = this._lerp),
								(o = this._lerpAdditive),
								(s = this._setAdditiveIdentityNumeric),
								(this.buffer = new Float64Array(5 * i))
					}
					;(this._mixBufferRegion = r),
						(this._mixBufferRegionAdditive = o),
						(this._setIdentity = s),
						(this._origIndex = 3),
						(this._addIndex = 4),
						(this.cumulativeWeight = 0),
						(this.cumulativeWeightAdditive = 0),
						(this.useCount = 0),
						(this.referenceCount = 0)
				}
				accumulate(n, e) {
					const i = this.buffer,
						r = this.valueSize,
						o = n * r + r
					let s = this.cumulativeWeight
					if (0 === s) {
						for (let a = 0; a !== r; ++a) i[o + a] = i[a]
						s = e
					} else (s += e), this._mixBufferRegion(i, o, 0, e / s, r)
					this.cumulativeWeight = s
				}
				accumulateAdditive(n) {
					const e = this.buffer,
						i = this.valueSize,
						r = i * this._addIndex
					0 === this.cumulativeWeightAdditive && this._setIdentity(),
						this._mixBufferRegionAdditive(e, r, 0, n, i),
						(this.cumulativeWeightAdditive += n)
				}
				apply(n) {
					const e = this.valueSize,
						i = this.buffer,
						r = n * e + e,
						o = this.cumulativeWeight,
						s = this.cumulativeWeightAdditive,
						a = this.binding
					;(this.cumulativeWeight = 0),
						(this.cumulativeWeightAdditive = 0),
						o < 1 && this._mixBufferRegion(i, r, e * this._origIndex, 1 - o, e),
						s > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * e, 1, e)
					for (let c = e, l = e + e; c !== l; ++c)
						if (i[c] !== i[c + e]) {
							a.setValue(i, r)
							break
						}
				}
				saveOriginalState() {
					const e = this.buffer,
						i = this.valueSize,
						r = i * this._origIndex
					this.binding.getValue(e, r)
					for (let o = i, s = r; o !== s; ++o) e[o] = e[r + (o % i)]
					this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0)
				}
				restoreOriginalState() {
					this.binding.setValue(this.buffer, 3 * this.valueSize)
				}
				_setAdditiveIdentityNumeric() {
					const n = this._addIndex * this.valueSize,
						e = n + this.valueSize
					for (let i = n; i < e; i++) this.buffer[i] = 0
				}
				_setAdditiveIdentityQuaternion() {
					this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1)
				}
				_setAdditiveIdentityOther() {
					const n = this._origIndex * this.valueSize,
						e = this._addIndex * this.valueSize
					for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[n + i]
				}
				_select(n, e, i, r, o) {
					if (r >= 0.5) for (let s = 0; s !== o; ++s) n[e + s] = n[i + s]
				}
				_slerp(n, e, i, r) {
					fs.slerpFlat(n, e, n, e, n, i, r)
				}
				_slerpAdditive(n, e, i, r, o) {
					const s = this._workIndex * o
					fs.multiplyQuaternionsFlat(n, s, n, e, n, i), fs.slerpFlat(n, e, n, e, n, s, r)
				}
				_lerp(n, e, i, r, o) {
					const s = 1 - r
					for (let a = 0; a !== o; ++a) {
						const c = e + a
						n[c] = n[c] * s + n[i + a] * r
					}
				}
				_lerpAdditive(n, e, i, r, o) {
					for (let s = 0; s !== o; ++s) {
						const a = e + s
						n[a] = n[a] + n[i + s] * r
					}
				}
			}
			const DP = "\\[\\]\\.:\\/",
				TCe = new RegExp("[" + DP + "]", "g"),
				LP = "[^" + DP + "]",
				FCe = "[^" + DP.replace("\\.", "") + "]",
				BCe = /((?:WC+[\/:])*)/.source.replace("WC", LP),
				ICe = /(WCOD+)?/.source.replace("WCOD", FCe),
				DCe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", LP),
				LCe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", LP),
				RCe = new RegExp("^" + BCe + ICe + DCe + LCe + "$"),
				PCe = ["material", "materials", "bones"]
			function pK(t, n, e) {
				const i = e || Gs.parseTrackName(n)
				;(this._targetGroup = t), (this._bindings = t.subscribe_(n, i))
			}
			function Gs(t, n, e) {
				;(this.path = n),
					(this.parsedPath = e || Gs.parseTrackName(n)),
					(this.node = Gs.findNode(t, this.parsedPath.nodeName) || t),
					(this.rootNode = t)
			}
			Object.assign(pK.prototype, {
				getValue: function (t, n) {
					this.bind()
					const i = this._bindings[this._targetGroup.nCachedObjects_]
					void 0 !== i && i.getValue(t, n)
				},
				setValue: function (t, n) {
					const e = this._bindings
					for (let i = this._targetGroup.nCachedObjects_, r = e.length; i !== r; ++i) e[i].setValue(t, n)
				},
				bind: function () {
					const t = this._bindings
					for (let n = this._targetGroup.nCachedObjects_, e = t.length; n !== e; ++n) t[n].bind()
				},
				unbind: function () {
					const t = this._bindings
					for (let n = this._targetGroup.nCachedObjects_, e = t.length; n !== e; ++n) t[n].unbind()
				}
			}),
				Object.assign(Gs, {
					Composite: pK,
					create: function (t, n, e) {
						return t && t.isAnimationObjectGroup ? new Gs.Composite(t, n, e) : new Gs(t, n, e)
					},
					sanitizeNodeName: function (t) {
						return t.replace(/\s/g, "_").replace(TCe, "")
					},
					parseTrackName: function (t) {
						const n = RCe.exec(t)
						if (!n) throw new Error("PropertyBinding: Cannot parse trackName: " + t)
						const e = { nodeName: n[2], objectName: n[3], objectIndex: n[4], propertyName: n[5], propertyIndex: n[6] },
							i = e.nodeName && e.nodeName.lastIndexOf(".")
						if (void 0 !== i && -1 !== i) {
							const r = e.nodeName.substring(i + 1)
							;-1 !== PCe.indexOf(r) && ((e.nodeName = e.nodeName.substring(0, i)), (e.objectName = r))
						}
						if (null === e.propertyName || 0 === e.propertyName.length)
							throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t)
						return e
					},
					findNode: function (t, n) {
						if (!n || "" === n || "." === n || -1 === n || n === t.name || n === t.uuid) return t
						if (t.skeleton) {
							const e = t.skeleton.getBoneByName(n)
							if (void 0 !== e) return e
						}
						if (t.children) {
							const e = function (r) {
									for (let o = 0; o < r.length; o++) {
										const s = r[o]
										if (s.name === n || s.uuid === n) return s
										const a = e(s.children)
										if (a) return a
									}
									return null
								},
								i = e(t.children)
							if (i) return i
						}
						return null
					}
				}),
				Object.assign(Gs.prototype, {
					_getValue_unavailable: function () {},
					_setValue_unavailable: function () {},
					BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 },
					Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
					GetterByBindingType: [
						function (n, e) {
							n[e] = this.node[this.propertyName]
						},
						function (n, e) {
							const i = this.resolvedProperty
							for (let r = 0, o = i.length; r !== o; ++r) n[e++] = i[r]
						},
						function (n, e) {
							n[e] = this.resolvedProperty[this.propertyIndex]
						},
						function (n, e) {
							this.resolvedProperty.toArray(n, e)
						}
					],
					SetterByBindingTypeAndVersioning: [
						[
							function (n, e) {
								this.targetObject[this.propertyName] = n[e]
							},
							function (n, e) {
								;(this.targetObject[this.propertyName] = n[e]), (this.targetObject.needsUpdate = !0)
							},
							function (n, e) {
								;(this.targetObject[this.propertyName] = n[e]), (this.targetObject.matrixWorldNeedsUpdate = !0)
							}
						],
						[
							function (n, e) {
								const i = this.resolvedProperty
								for (let r = 0, o = i.length; r !== o; ++r) i[r] = n[e++]
							},
							function (n, e) {
								const i = this.resolvedProperty
								for (let r = 0, o = i.length; r !== o; ++r) i[r] = n[e++]
								this.targetObject.needsUpdate = !0
							},
							function (n, e) {
								const i = this.resolvedProperty
								for (let r = 0, o = i.length; r !== o; ++r) i[r] = n[e++]
								this.targetObject.matrixWorldNeedsUpdate = !0
							}
						],
						[
							function (n, e) {
								this.resolvedProperty[this.propertyIndex] = n[e]
							},
							function (n, e) {
								;(this.resolvedProperty[this.propertyIndex] = n[e]), (this.targetObject.needsUpdate = !0)
							},
							function (n, e) {
								;(this.resolvedProperty[this.propertyIndex] = n[e]), (this.targetObject.matrixWorldNeedsUpdate = !0)
							}
						],
						[
							function (n, e) {
								this.resolvedProperty.fromArray(n, e)
							},
							function (n, e) {
								this.resolvedProperty.fromArray(n, e), (this.targetObject.needsUpdate = !0)
							},
							function (n, e) {
								this.resolvedProperty.fromArray(n, e), (this.targetObject.matrixWorldNeedsUpdate = !0)
							}
						]
					],
					getValue: function (n, e) {
						this.bind(), this.getValue(n, e)
					},
					setValue: function (n, e) {
						this.bind(), this.setValue(n, e)
					},
					bind: function () {
						let t = this.node
						const n = this.parsedPath,
							e = n.objectName,
							i = n.propertyName
						let r = n.propertyIndex
						if (
							(t || ((t = Gs.findNode(this.rootNode, n.nodeName) || this.rootNode), (this.node = t)),
							(this.getValue = this._getValue_unavailable),
							(this.setValue = this._setValue_unavailable),
							!t)
						)
							return void console.error(
								"THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."
							)
						if (e) {
							let c = n.objectIndex
							switch (e) {
								case "materials":
									if (!t.material)
										return void console.error(
											"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
											this
										)
									if (!t.material.materials)
										return void console.error(
											"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
											this
										)
									t = t.material.materials
									break
								case "bones":
									if (!t.skeleton)
										return void console.error(
											"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
											this
										)
									t = t.skeleton.bones
									for (let l = 0; l < t.length; l++)
										if (t[l].name === c) {
											c = l
											break
										}
									break
								default:
									if (void 0 === t[e])
										return void console.error(
											"THREE.PropertyBinding: Can not bind to objectName of node undefined.",
											this
										)
									t = t[e]
							}
							if (void 0 !== c) {
								if (void 0 === t[c])
									return void console.error(
										"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
										this,
										t
									)
								t = t[c]
							}
						}
						const o = t[i]
						if (void 0 === o)
							return void console.error(
								"THREE.PropertyBinding: Trying to update property for track: " +
									n.nodeName +
									"." +
									i +
									" but it wasn't found.",
								t
							)
						let s = this.Versioning.None
						;(this.targetObject = t),
							void 0 !== t.needsUpdate
								? (s = this.Versioning.NeedsUpdate)
								: void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate)
						let a = this.BindingType.Direct
						if (void 0 !== r) {
							if ("morphTargetInfluences" === i) {
								if (!t.geometry)
									return void console.error(
										"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
										this
									)
								if (!t.geometry.isBufferGeometry)
									return void console.error(
										"THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
										this
									)
								if (!t.geometry.morphAttributes)
									return void console.error(
										"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
										this
									)
								void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
							}
							;(a = this.BindingType.ArrayElement), (this.resolvedProperty = o), (this.propertyIndex = r)
						} else
							void 0 !== o.fromArray && void 0 !== o.toArray
								? ((a = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
								: Array.isArray(o)
								? ((a = this.BindingType.EntireArray), (this.resolvedProperty = o))
								: (this.propertyName = i)
						;(this.getValue = this.GetterByBindingType[a]), (this.setValue = this.SetterByBindingTypeAndVersioning[a][s])
					},
					unbind: function () {
						;(this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound)
					}
				}),
				Object.assign(Gs.prototype, { _getValue_unbound: Gs.prototype.getValue, _setValue_unbound: Gs.prototype.setValue })
			class AK {
				constructor() {
					;(this.uuid = jn.generateUUID()), (this._objects = Array.prototype.slice.call(arguments)), (this.nCachedObjects_ = 0)
					const n = {}
					this._indicesByUUID = n
					for (let i = 0, r = arguments.length; i !== r; ++i) n[arguments[i].uuid] = i
					;(this._paths = []), (this._parsedPaths = []), (this._bindings = []), (this._bindingsIndicesByPath = {})
					const e = this
					this.stats = {
						objects: {
							get total() {
								return e._objects.length
							},
							get inUse() {
								return this.total - e.nCachedObjects_
							}
						},
						get bindingsPerObject() {
							return e._bindings.length
						}
					}
				}
				add() {
					const n = this._objects,
						e = this._indicesByUUID,
						i = this._paths,
						r = this._parsedPaths,
						o = this._bindings,
						s = o.length
					let a,
						c = n.length,
						l = this.nCachedObjects_
					for (let d = 0, u = arguments.length; d !== u; ++d) {
						const h = arguments[d],
							f = h.uuid
						let _ = e[f]
						if (void 0 === _) {
							;(_ = c++), (e[f] = _), n.push(h)
							for (let y = 0, C = s; y !== C; ++y) o[y].push(new Gs(h, i[y], r[y]))
						} else if (_ < l) {
							a = n[_]
							const y = --l,
								C = n[y]
							;(e[C.uuid] = _), (n[_] = C), (e[f] = y), (n[y] = h)
							for (let x = 0, w = s; x !== w; ++x) {
								const S = o[x]
								let O = S[_]
								;(S[_] = S[y]), void 0 === O && (O = new Gs(h, i[x], r[x])), (S[y] = O)
							}
						} else
							n[_] !== a &&
								console.error(
									"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
								)
					}
					this.nCachedObjects_ = l
				}
				remove() {
					const n = this._objects,
						e = this._indicesByUUID,
						i = this._bindings,
						r = i.length
					let o = this.nCachedObjects_
					for (let s = 0, a = arguments.length; s !== a; ++s) {
						const c = arguments[s],
							l = c.uuid,
							d = e[l]
						if (void 0 !== d && d >= o) {
							const u = o++,
								h = n[u]
							;(e[h.uuid] = d), (n[d] = h), (e[l] = u), (n[u] = c)
							for (let f = 0, _ = r; f !== _; ++f) {
								const y = i[f],
									x = y[d]
								;(y[d] = y[u]), (y[u] = x)
							}
						}
					}
					this.nCachedObjects_ = o
				}
				uncache() {
					const n = this._objects,
						e = this._indicesByUUID,
						i = this._bindings,
						r = i.length
					let o = this.nCachedObjects_,
						s = n.length
					for (let a = 0, c = arguments.length; a !== c; ++a) {
						const d = arguments[a].uuid,
							u = e[d]
						if (void 0 !== u)
							if ((delete e[d], u < o)) {
								const h = --o,
									f = n[h],
									_ = --s,
									y = n[_]
								;(e[f.uuid] = u), (n[u] = f), (e[y.uuid] = h), (n[h] = y), n.pop()
								for (let C = 0, x = r; C !== x; ++C) {
									const w = i[C],
										M = w[_]
									;(w[u] = w[h]), (w[h] = M), w.pop()
								}
							} else {
								const h = --s,
									f = n[h]
								h > 0 && (e[f.uuid] = u), (n[u] = f), n.pop()
								for (let _ = 0, y = r; _ !== y; ++_) {
									const C = i[_]
									;(C[u] = C[h]), C.pop()
								}
							}
					}
					this.nCachedObjects_ = o
				}
				subscribe_(n, e) {
					const i = this._bindingsIndicesByPath
					let r = i[n]
					const o = this._bindings
					if (void 0 !== r) return o[r]
					const s = this._paths,
						a = this._parsedPaths,
						c = this._objects,
						d = this.nCachedObjects_,
						u = new Array(c.length)
					;(r = o.length), (i[n] = r), s.push(n), a.push(e), o.push(u)
					for (let h = d, f = c.length; h !== f; ++h) u[h] = new Gs(c[h], n, e)
					return u
				}
				unsubscribe_(n) {
					const e = this._bindingsIndicesByPath,
						i = e[n]
					if (void 0 !== i) {
						const r = this._paths,
							o = this._parsedPaths,
							s = this._bindings,
							a = s.length - 1,
							c = s[a]
						;(e[n[a]] = i), (s[i] = c), s.pop(), (o[i] = o[a]), o.pop(), (r[i] = r[a]), r.pop()
					}
				}
			}
			AK.prototype.isAnimationObjectGroup = !0
			class OCe {
				constructor(n, e, i = null, r = e.blendMode) {
					;(this._mixer = n), (this._clip = e), (this._localRoot = i), (this.blendMode = r)
					const o = e.tracks,
						s = o.length,
						a = new Array(s),
						c = { endingStart: np, endingEnd: np }
					for (let l = 0; l !== s; ++l) {
						const d = o[l].createInterpolant(null)
						;(a[l] = d), (d.settings = c)
					}
					;(this._interpolantSettings = c),
						(this._interpolants = a),
						(this._propertyBindings = new Array(s)),
						(this._cacheIndex = null),
						(this._byClipCacheIndex = null),
						(this._timeScaleInterpolant = null),
						(this._weightInterpolant = null),
						(this.loop = xj),
						(this._loopCount = -1),
						(this._startTime = null),
						(this.time = 0),
						(this.timeScale = 1),
						(this._effectiveTimeScale = 1),
						(this.weight = 1),
						(this._effectiveWeight = 1),
						(this.repetitions = 1 / 0),
						(this.paused = !1),
						(this.enabled = !0),
						(this.clampWhenFinished = !1),
						(this.zeroSlopeAtStart = !0),
						(this.zeroSlopeAtEnd = !0)
				}
				play() {
					return this._mixer._activateAction(this), this
				}
				stop() {
					return this._mixer._deactivateAction(this), this.reset()
				}
				reset() {
					return (
						(this.paused = !1),
						(this.enabled = !0),
						(this.time = 0),
						(this._loopCount = -1),
						(this._startTime = null),
						this.stopFading().stopWarping()
					)
				}
				isRunning() {
					return (
						this.enabled &&
						!this.paused &&
						0 !== this.timeScale &&
						null === this._startTime &&
						this._mixer._isActiveAction(this)
					)
				}
				isScheduled() {
					return this._mixer._isActiveAction(this)
				}
				startAt(n) {
					return (this._startTime = n), this
				}
				setLoop(n, e) {
					return (this.loop = n), (this.repetitions = e), this
				}
				setEffectiveWeight(n) {
					return (this.weight = n), (this._effectiveWeight = this.enabled ? n : 0), this.stopFading()
				}
				getEffectiveWeight() {
					return this._effectiveWeight
				}
				fadeIn(n) {
					return this._scheduleFading(n, 0, 1)
				}
				fadeOut(n) {
					return this._scheduleFading(n, 1, 0)
				}
				crossFadeFrom(n, e, i) {
					if ((n.fadeOut(e), this.fadeIn(e), i)) {
						const r = this._clip.duration,
							o = n._clip.duration,
							a = r / o
						n.warp(1, o / r, e), this.warp(a, 1, e)
					}
					return this
				}
				crossFadeTo(n, e, i) {
					return n.crossFadeFrom(this, e, i)
				}
				stopFading() {
					const n = this._weightInterpolant
					return null !== n && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(n)), this
				}
				setEffectiveTimeScale(n) {
					return (this.timeScale = n), (this._effectiveTimeScale = this.paused ? 0 : n), this.stopWarping()
				}
				getEffectiveTimeScale() {
					return this._effectiveTimeScale
				}
				setDuration(n) {
					return (this.timeScale = this._clip.duration / n), this.stopWarping()
				}
				syncWith(n) {
					return (this.time = n.time), (this.timeScale = n.timeScale), this.stopWarping()
				}
				halt(n) {
					return this.warp(this._effectiveTimeScale, 0, n)
				}
				warp(n, e, i) {
					const r = this._mixer,
						o = r.time,
						s = this.timeScale
					let a = this._timeScaleInterpolant
					null === a && ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a))
					const c = a.parameterPositions,
						l = a.sampleValues
					return (c[0] = o), (c[1] = o + i), (l[0] = n / s), (l[1] = e / s), this
				}
				stopWarping() {
					const n = this._timeScaleInterpolant
					return null !== n && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(n)), this
				}
				getMixer() {
					return this._mixer
				}
				getClip() {
					return this._clip
				}
				getRoot() {
					return this._localRoot || this._mixer._root
				}
				_update(n, e, i, r) {
					if (!this.enabled) return void this._updateWeight(n)
					const o = this._startTime
					if (null !== o) {
						const c = (n - o) * i
						if (c < 0 || 0 === i) return
						;(this._startTime = null), (e = i * c)
					}
					e *= this._updateTimeScale(n)
					const s = this._updateTime(e),
						a = this._updateWeight(n)
					if (a > 0) {
						const c = this._interpolants,
							l = this._propertyBindings
						if (this.blendMode === AR) for (let d = 0, u = c.length; d !== u; ++d) c[d].evaluate(s), l[d].accumulateAdditive(a)
						else for (let d = 0, u = c.length; d !== u; ++d) c[d].evaluate(s), l[d].accumulate(r, a)
					}
				}
				_updateWeight(n) {
					let e = 0
					if (this.enabled) {
						e = this.weight
						const i = this._weightInterpolant
						if (null !== i) {
							const r = i.evaluate(n)[0]
							;(e *= r), n > i.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
						}
					}
					return (this._effectiveWeight = e), e
				}
				_updateTimeScale(n) {
					let e = 0
					if (!this.paused) {
						e = this.timeScale
						const i = this._timeScaleInterpolant
						null !== i &&
							((e *= i.evaluate(n)[0]),
							n > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e)))
					}
					return (this._effectiveTimeScale = e), e
				}
				_updateTime(n) {
					const e = this._clip.duration,
						i = this.loop
					let r = this.time + n,
						o = this._loopCount
					const s = i === Cj
					if (0 === n) return -1 === o ? r : s && 1 == (1 & o) ? e - r : r
					if (i === wj) {
						;-1 === o && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
						e: {
							if (r >= e) r = e
							else {
								if (!(r < 0)) {
									this.time = r
									break e
								}
								r = 0
							}
							this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
								(this.time = r),
								this._mixer.dispatchEvent({ type: "finished", action: this, direction: n < 0 ? -1 : 1 })
						}
					} else {
						if (
							(-1 === o &&
								(n >= 0
									? ((o = 0), this._setEndings(!0, 0 === this.repetitions, s))
									: this._setEndings(0 === this.repetitions, !0, s)),
							r >= e || r < 0)
						) {
							const a = Math.floor(r / e)
							;(r -= e * a), (o += Math.abs(a))
							const c = this.repetitions - o
							if (c <= 0)
								this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
									(r = n > 0 ? e : 0),
									(this.time = r),
									this._mixer.dispatchEvent({ type: "finished", action: this, direction: n > 0 ? 1 : -1 })
							else {
								if (1 === c) {
									const l = n < 0
									this._setEndings(l, !l, s)
								} else this._setEndings(!1, !1, s)
								;(this._loopCount = o),
									(this.time = r),
									this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a })
							}
						} else this.time = r
						if (s && 1 == (1 & o)) return e - r
					}
					return r
				}
				_setEndings(n, e, i) {
					const r = this._interpolantSettings
					i
						? ((r.endingStart = ip), (r.endingEnd = ip))
						: ((r.endingStart = n ? (this.zeroSlopeAtStart ? ip : np) : uy),
						  (r.endingEnd = e ? (this.zeroSlopeAtEnd ? ip : np) : uy))
				}
				_scheduleFading(n, e, i) {
					const r = this._mixer,
						o = r.time
					let s = this._weightInterpolant
					null === s && ((s = r._lendControlInterpolant()), (this._weightInterpolant = s))
					const a = s.parameterPositions,
						c = s.sampleValues
					return (a[0] = o), (c[0] = e), (a[1] = o + n), (c[1] = i), this
				}
			}
			class gK extends Iu {
				constructor(n) {
					super(), (this._root = n), this._initMemoryManager(), (this._accuIndex = 0), (this.time = 0), (this.timeScale = 1)
				}
				_bindAction(n, e) {
					const i = n._localRoot || this._root,
						r = n._clip.tracks,
						o = r.length,
						s = n._propertyBindings,
						a = n._interpolants,
						c = i.uuid,
						l = this._bindingsByRootAndName
					let d = l[c]
					void 0 === d && ((d = {}), (l[c] = d))
					for (let u = 0; u !== o; ++u) {
						const h = r[u],
							f = h.name
						let _ = d[f]
						if (void 0 !== _) s[u] = _
						else {
							if (((_ = s[u]), void 0 !== _)) {
								null === _._cacheIndex && (++_.referenceCount, this._addInactiveBinding(_, c, f))
								continue
							}
							;(_ = new mK(
								Gs.create(i, f, e && e._propertyBindings[u].binding.parsedPath),
								h.ValueTypeName,
								h.getValueSize()
							)),
								++_.referenceCount,
								this._addInactiveBinding(_, c, f),
								(s[u] = _)
						}
						a[u].resultBuffer = _.buffer
					}
				}
				_activateAction(n) {
					if (!this._isActiveAction(n)) {
						if (null === n._cacheIndex) {
							const i = (n._localRoot || this._root).uuid,
								r = n._clip.uuid,
								o = this._actionsByClip[r]
							this._bindAction(n, o && o.knownActions[0]), this._addInactiveAction(n, r, i)
						}
						const e = n._propertyBindings
						for (let i = 0, r = e.length; i !== r; ++i) {
							const o = e[i]
							0 == o.useCount++ && (this._lendBinding(o), o.saveOriginalState())
						}
						this._lendAction(n)
					}
				}
				_deactivateAction(n) {
					if (this._isActiveAction(n)) {
						const e = n._propertyBindings
						for (let i = 0, r = e.length; i !== r; ++i) {
							const o = e[i]
							0 == --o.useCount && (o.restoreOriginalState(), this._takeBackBinding(o))
						}
						this._takeBackAction(n)
					}
				}
				_initMemoryManager() {
					;(this._actions = []),
						(this._nActiveActions = 0),
						(this._actionsByClip = {}),
						(this._bindings = []),
						(this._nActiveBindings = 0),
						(this._bindingsByRootAndName = {}),
						(this._controlInterpolants = []),
						(this._nActiveControlInterpolants = 0)
					const n = this
					this.stats = {
						actions: {
							get total() {
								return n._actions.length
							},
							get inUse() {
								return n._nActiveActions
							}
						},
						bindings: {
							get total() {
								return n._bindings.length
							},
							get inUse() {
								return n._nActiveBindings
							}
						},
						controlInterpolants: {
							get total() {
								return n._controlInterpolants.length
							},
							get inUse() {
								return n._nActiveControlInterpolants
							}
						}
					}
				}
				_isActiveAction(n) {
					const e = n._cacheIndex
					return null !== e && e < this._nActiveActions
				}
				_addInactiveAction(n, e, i) {
					const r = this._actions,
						o = this._actionsByClip
					let s = o[e]
					if (void 0 === s) (s = { knownActions: [n], actionByRoot: {} }), (n._byClipCacheIndex = 0), (o[e] = s)
					else {
						const a = s.knownActions
						;(n._byClipCacheIndex = a.length), a.push(n)
					}
					;(n._cacheIndex = r.length), r.push(n), (s.actionByRoot[i] = n)
				}
				_removeInactiveAction(n) {
					const e = this._actions,
						i = e[e.length - 1],
						r = n._cacheIndex
					;(i._cacheIndex = r), (e[r] = i), e.pop(), (n._cacheIndex = null)
					const o = n._clip.uuid,
						s = this._actionsByClip,
						a = s[o],
						c = a.knownActions,
						l = c[c.length - 1],
						d = n._byClipCacheIndex
					;(l._byClipCacheIndex = d),
						(c[d] = l),
						c.pop(),
						(n._byClipCacheIndex = null),
						delete a.actionByRoot[(n._localRoot || this._root).uuid],
						0 === c.length && delete s[o],
						this._removeInactiveBindingsForAction(n)
				}
				_removeInactiveBindingsForAction(n) {
					const e = n._propertyBindings
					for (let i = 0, r = e.length; i !== r; ++i) {
						const o = e[i]
						0 == --o.referenceCount && this._removeInactiveBinding(o)
					}
				}
				_lendAction(n) {
					const e = this._actions,
						i = n._cacheIndex,
						r = this._nActiveActions++,
						o = e[r]
					;(n._cacheIndex = r), (e[r] = n), (o._cacheIndex = i), (e[i] = o)
				}
				_takeBackAction(n) {
					const e = this._actions,
						i = n._cacheIndex,
						r = --this._nActiveActions,
						o = e[r]
					;(n._cacheIndex = r), (e[r] = n), (o._cacheIndex = i), (e[i] = o)
				}
				_addInactiveBinding(n, e, i) {
					const r = this._bindingsByRootAndName,
						o = this._bindings
					let s = r[e]
					void 0 === s && ((s = {}), (r[e] = s)), (s[i] = n), (n._cacheIndex = o.length), o.push(n)
				}
				_removeInactiveBinding(n) {
					const e = this._bindings,
						i = n.binding,
						r = i.rootNode.uuid,
						o = i.path,
						s = this._bindingsByRootAndName,
						a = s[r],
						c = e[e.length - 1],
						l = n._cacheIndex
					;(c._cacheIndex = l), (e[l] = c), e.pop(), delete a[o], 0 === Object.keys(a).length && delete s[r]
				}
				_lendBinding(n) {
					const e = this._bindings,
						i = n._cacheIndex,
						r = this._nActiveBindings++,
						o = e[r]
					;(n._cacheIndex = r), (e[r] = n), (o._cacheIndex = i), (e[i] = o)
				}
				_takeBackBinding(n) {
					const e = this._bindings,
						i = n._cacheIndex,
						r = --this._nActiveBindings,
						o = e[r]
					;(n._cacheIndex = r), (e[r] = n), (o._cacheIndex = i), (e[i] = o)
				}
				_lendControlInterpolant() {
					const n = this._controlInterpolants,
						e = this._nActiveControlInterpolants++
					let i = n[e]
					return (
						void 0 === i &&
							((i = new Wy(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)),
							(i.__cacheIndex = e),
							(n[e] = i)),
						i
					)
				}
				_takeBackControlInterpolant(n) {
					const e = this._controlInterpolants,
						i = n.__cacheIndex,
						r = --this._nActiveControlInterpolants,
						o = e[r]
					;(n.__cacheIndex = r), (e[r] = n), (o.__cacheIndex = i), (e[i] = o)
				}
				clipAction(n, e, i) {
					const r = e || this._root,
						o = r.uuid
					let s = "string" == typeof n ? Xy.findByName(r, n) : n
					const a = null !== s ? s.uuid : n,
						c = this._actionsByClip[a]
					let l = null
					if ((void 0 === i && (i = null !== s ? s.blendMode : bM), void 0 !== c)) {
						const u = c.actionByRoot[o]
						if (void 0 !== u && u.blendMode === i) return u
						;(l = c.knownActions[0]), null === s && (s = l._clip)
					}
					if (null === s) return null
					const d = new OCe(this, s, e, i)
					return this._bindAction(d, l), this._addInactiveAction(d, a, o), d
				}
				existingAction(n, e) {
					const i = e || this._root,
						r = i.uuid,
						o = "string" == typeof n ? Xy.findByName(i, n) : n,
						a = this._actionsByClip[o ? o.uuid : n]
					return (void 0 !== a && a.actionByRoot[r]) || null
				}
				stopAllAction() {
					const n = this._actions
					for (let i = this._nActiveActions - 1; i >= 0; --i) n[i].stop()
					return this
				}
				update(n) {
					const e = this._actions,
						i = this._nActiveActions,
						r = (this.time += n *= this.timeScale),
						o = Math.sign(n),
						s = (this._accuIndex ^= 1)
					for (let l = 0; l !== i; ++l) e[l]._update(r, n, o, s)
					const a = this._bindings,
						c = this._nActiveBindings
					for (let l = 0; l !== c; ++l) a[l].apply(s)
					return this
				}
				setTime(n) {
					this.time = 0
					for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0
					return this.update(n)
				}
				getRoot() {
					return this._root
				}
				uncacheClip(n) {
					const e = this._actions,
						i = n.uuid,
						r = this._actionsByClip,
						o = r[i]
					if (void 0 !== o) {
						const s = o.knownActions
						for (let a = 0, c = s.length; a !== c; ++a) {
							const l = s[a]
							this._deactivateAction(l)
							const d = l._cacheIndex,
								u = e[e.length - 1]
							;(l._cacheIndex = null),
								(l._byClipCacheIndex = null),
								(u._cacheIndex = d),
								(e[d] = u),
								e.pop(),
								this._removeInactiveBindingsForAction(l)
						}
						delete r[i]
					}
				}
				uncacheRoot(n) {
					const e = n.uuid,
						i = this._actionsByClip
					for (const s in i) {
						const c = i[s].actionByRoot[e]
						void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
					}
					const o = this._bindingsByRootAndName[e]
					if (void 0 !== o)
						for (const s in o) {
							const a = o[s]
							a.restoreOriginalState(), this._removeInactiveBinding(a)
						}
				}
				uncacheAction(n, e) {
					const i = this.existingAction(n, e)
					null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
				}
			}
			gK.prototype._controlInterpolantsResultBuffer = new Float32Array(1)
			class DS {
				constructor(n) {
					"string" == typeof n && (console.warn("THREE.Uniform: Type parameter is no longer needed."), (n = arguments[1])),
						(this.value = n)
				}
				clone() {
					return new DS(void 0 === this.value.clone ? this.value : this.value.clone())
				}
			}
			function RP(t, n, e) {
				Ra.call(this, t, n), (this.meshPerAttribute = e || 1)
			}
			function PP(t, n, e, i, r) {
				;(this.buffer = t), (this.type = n), (this.itemSize = e), (this.elementSize = i), (this.count = r), (this.version = 0)
			}
			function ow(t, n, e = 0, i = 1 / 0) {
				;(this.ray = new Ru(t, n)),
					(this.near = e),
					(this.far = i),
					(this.camera = null),
					(this.layers = new kR()),
					(this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }),
					Object.defineProperties(this.params, {
						PointCloud: {
							get: function () {
								return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
							}
						}
					})
			}
			function bK(t, n) {
				return t.distance - n.distance
			}
			function OP(t, n, e, i) {
				if ((t.layers.test(n.layers) && t.raycast(n, e), !0 === i)) {
					const r = t.children
					for (let o = 0, s = r.length; o < s; o++) OP(r[o], n, e, !0)
				}
			}
			;(RP.prototype = Object.assign(Object.create(Ra.prototype), {
				constructor: RP,
				isInstancedInterleavedBuffer: !0,
				copy: function (t) {
					return Ra.prototype.copy.call(this, t), (this.meshPerAttribute = t.meshPerAttribute), this
				},
				clone: function (t) {
					const n = Ra.prototype.clone.call(this, t)
					return (n.meshPerAttribute = this.meshPerAttribute), n
				},
				toJSON: function (t) {
					const n = Ra.prototype.toJSON.call(this, t)
					return (n.isInstancedInterleavedBuffer = !0), (n.meshPerAttribute = this.meshPerAttribute), n
				}
			})),
				Object.defineProperty(PP.prototype, "needsUpdate", {
					set: function (t) {
						!0 === t && this.version++
					}
				}),
				Object.assign(PP.prototype, {
					isGLBufferAttribute: !0,
					setBuffer: function (t) {
						return (this.buffer = t), this
					},
					setType: function (t, n) {
						return (this.type = t), (this.elementSize = n), this
					},
					setItemSize: function (t) {
						return (this.itemSize = t), this
					},
					setCount: function (t) {
						return (this.count = t), this
					}
				}),
				Object.assign(ow.prototype, {
					set: function (t, n) {
						this.ray.set(t, n)
					},
					setFromCamera: function (t, n) {
						n && n.isPerspectiveCamera
							? (this.ray.origin.setFromMatrixPosition(n.matrixWorld),
							  this.ray.direction.set(t.x, t.y, 0.5).unproject(n).sub(this.ray.origin).normalize(),
							  (this.camera = n))
							: n && n.isOrthographicCamera
							? (this.ray.origin.set(t.x, t.y, (n.near + n.far) / (n.near - n.far)).unproject(n),
							  this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld),
							  (this.camera = n))
							: console.error("THREE.Raycaster: Unsupported camera type: " + n.type)
					},
					intersectObject: function (t, n = !1, e = []) {
						return OP(t, this, e, n), e.sort(bK), e
					},
					intersectObjects: function (t, n = !1, e = []) {
						for (let i = 0, r = t.length; i < r; i++) OP(t[i], this, e, n)
						return e.sort(bK), e
					}
				})
			class NCe {
				constructor(n = 1, e = 0, i = 0) {
					return (this.radius = n), (this.phi = e), (this.theta = i), this
				}
				set(n, e, i) {
					return (this.radius = n), (this.phi = e), (this.theta = i), this
				}
				copy(n) {
					return (this.radius = n.radius), (this.phi = n.phi), (this.theta = n.theta), this
				}
				makeSafe() {
					return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
				}
				setFromVector3(n) {
					return this.setFromCartesianCoords(n.x, n.y, n.z)
				}
				setFromCartesianCoords(n, e, i) {
					return (
						(this.radius = Math.sqrt(n * n + e * e + i * i)),
						0 === this.radius
							? ((this.theta = 0), (this.phi = 0))
							: ((this.theta = Math.atan2(n, i)), (this.phi = Math.acos(jn.clamp(e / this.radius, -1, 1)))),
						this
					)
				}
				clone() {
					return new this.constructor().copy(this)
				}
			}
			class UCe {
				constructor(n = 1, e = 0, i = 0) {
					return (this.radius = n), (this.theta = e), (this.y = i), this
				}
				set(n, e, i) {
					return (this.radius = n), (this.theta = e), (this.y = i), this
				}
				copy(n) {
					return (this.radius = n.radius), (this.theta = n.theta), (this.y = n.y), this
				}
				setFromVector3(n) {
					return this.setFromCartesianCoords(n.x, n.y, n.z)
				}
				setFromCartesianCoords(n, e, i) {
					return (this.radius = Math.sqrt(n * n + i * i)), (this.theta = Math.atan2(n, i)), (this.y = e), this
				}
				clone() {
					return new this.constructor().copy(this)
				}
			}
			const _K = new lt()
			class mb {
				constructor(n = new lt(1 / 0, 1 / 0), e = new lt(-1 / 0, -1 / 0)) {
					;(this.min = n), (this.max = e)
				}
				set(n, e) {
					return this.min.copy(n), this.max.copy(e), this
				}
				setFromPoints(n) {
					this.makeEmpty()
					for (let e = 0, i = n.length; e < i; e++) this.expandByPoint(n[e])
					return this
				}
				setFromCenterAndSize(n, e) {
					const i = _K.copy(e).multiplyScalar(0.5)
					return this.min.copy(n).sub(i), this.max.copy(n).add(i), this
				}
				clone() {
					return new this.constructor().copy(this)
				}
				copy(n) {
					return this.min.copy(n.min), this.max.copy(n.max), this
				}
				makeEmpty() {
					return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this
				}
				isEmpty() {
					return this.max.x < this.min.x || this.max.y < this.min.y
				}
				getCenter(n) {
					return (
						void 0 === n && (console.warn("THREE.Box2: .getCenter() target is now required"), (n = new lt())),
						this.isEmpty() ? n.set(0, 0) : n.addVectors(this.min, this.max).multiplyScalar(0.5)
					)
				}
				getSize(n) {
					return (
						void 0 === n && (console.warn("THREE.Box2: .getSize() target is now required"), (n = new lt())),
						this.isEmpty() ? n.set(0, 0) : n.subVectors(this.max, this.min)
					)
				}
				expandByPoint(n) {
					return this.min.min(n), this.max.max(n), this
				}
				expandByVector(n) {
					return this.min.sub(n), this.max.add(n), this
				}
				expandByScalar(n) {
					return this.min.addScalar(-n), this.max.addScalar(n), this
				}
				containsPoint(n) {
					return !(n.x < this.min.x || n.x > this.max.x || n.y < this.min.y || n.y > this.max.y)
				}
				containsBox(n) {
					return this.min.x <= n.min.x && n.max.x <= this.max.x && this.min.y <= n.min.y && n.max.y <= this.max.y
				}
				getParameter(n, e) {
					return (
						void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), (e = new lt())),
						e.set((n.x - this.min.x) / (this.max.x - this.min.x), (n.y - this.min.y) / (this.max.y - this.min.y))
					)
				}
				intersectsBox(n) {
					return !(n.max.x < this.min.x || n.min.x > this.max.x || n.max.y < this.min.y || n.min.y > this.max.y)
				}
				clampPoint(n, e) {
					return (
						void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), (e = new lt())),
						e.copy(n).clamp(this.min, this.max)
					)
				}
				distanceToPoint(n) {
					return _K.copy(n).clamp(this.min, this.max).sub(n).length()
				}
				intersect(n) {
					return this.min.max(n.min), this.max.min(n.max), this
				}
				union(n) {
					return this.min.min(n.min), this.max.max(n.max), this
				}
				translate(n) {
					return this.min.add(n), this.max.add(n), this
				}
				equals(n) {
					return n.min.equals(this.min) && n.max.equals(this.max)
				}
			}
			mb.prototype.isBox2 = !0
			const vK = new K(),
				LS = new K()
			class yK {
				constructor(n = new K(), e = new K()) {
					;(this.start = n), (this.end = e)
				}
				set(n, e) {
					return this.start.copy(n), this.end.copy(e), this
				}
				copy(n) {
					return this.start.copy(n.start), this.end.copy(n.end), this
				}
				getCenter(n) {
					return (
						void 0 === n && (console.warn("THREE.Line3: .getCenter() target is now required"), (n = new K())),
						n.addVectors(this.start, this.end).multiplyScalar(0.5)
					)
				}
				delta(n) {
					return (
						void 0 === n && (console.warn("THREE.Line3: .delta() target is now required"), (n = new K())),
						n.subVectors(this.end, this.start)
					)
				}
				distanceSq() {
					return this.start.distanceToSquared(this.end)
				}
				distance() {
					return this.start.distanceTo(this.end)
				}
				at(n, e) {
					return (
						void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), (e = new K())),
						this.delta(e).multiplyScalar(n).add(this.start)
					)
				}
				closestPointToPointParameter(n, e) {
					vK.subVectors(n, this.start), LS.subVectors(this.end, this.start)
					const i = LS.dot(LS)
					let o = LS.dot(vK) / i
					return e && (o = jn.clamp(o, 0, 1)), o
				}
				closestPointToPoint(n, e, i) {
					const r = this.closestPointToPointParameter(n, e)
					return (
						void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), (i = new K())),
						this.delta(i).multiplyScalar(r).add(this.start)
					)
				}
				applyMatrix4(n) {
					return this.start.applyMatrix4(n), this.end.applyMatrix4(n), this
				}
				equals(n) {
					return n.start.equals(this.start) && n.end.equals(this.end)
				}
				clone() {
					return new this.constructor().copy(this)
				}
			}
			function sw(t) {
				On.call(this),
					(this.material = t),
					(this.render = function () {}),
					(this.hasPositions = !1),
					(this.hasNormals = !1),
					(this.hasColors = !1),
					(this.hasUvs = !1),
					(this.positionArray = null),
					(this.normalArray = null),
					(this.colorArray = null),
					(this.uvArray = null),
					(this.count = 0)
			}
			;((sw.prototype = Object.create(On.prototype)).constructor = sw), (sw.prototype.isImmediateRenderObject = !0)
			const wK = new K()
			class HCe extends On {
				constructor(n, e) {
					super(),
						(this.light = n),
						this.light.updateMatrixWorld(),
						(this.matrix = n.matrixWorld),
						(this.matrixAutoUpdate = !1),
						(this.color = e)
					const i = new vn(),
						r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]
					for (let s = 0, a = 1, c = 32; s < c; s++, a++) {
						const l = (s / c) * Math.PI * 2,
							d = (a / c) * Math.PI * 2
						r.push(Math.cos(l), Math.sin(l), 1, Math.cos(d), Math.sin(d), 1)
					}
					i.setAttribute("position", new cn(r, 3))
					const o = new Go({ fog: !1, toneMapped: !1 })
					;(this.cone = new pa(i, o)), this.add(this.cone), this.update()
				}
				dispose() {
					this.cone.geometry.dispose(), this.cone.material.dispose()
				}
				update() {
					this.light.updateMatrixWorld()
					const n = this.light.distance ? this.light.distance : 1e3,
						e = n * Math.tan(this.light.angle)
					this.cone.scale.set(e, e, n),
						wK.setFromMatrixPosition(this.light.target.matrixWorld),
						this.cone.lookAt(wK),
						void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
				}
			}
			const ff = new K(),
				RS = new Cn(),
				NP = new Cn()
			class xK extends pa {
				constructor(n) {
					const e = CK(n),
						i = new vn(),
						r = [],
						o = [],
						s = new Lt(0, 0, 1),
						a = new Lt(0, 1, 0)
					for (let l = 0; l < e.length; l++) {
						const d = e[l]
						d.parent && d.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), o.push(s.r, s.g, s.b), o.push(a.r, a.g, a.b))
					}
					i.setAttribute("position", new cn(r, 3)),
						i.setAttribute("color", new cn(o, 3)),
						super(i, new Go({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })),
						(this.type = "SkeletonHelper"),
						(this.isSkeletonHelper = !0),
						(this.root = n),
						(this.bones = e),
						(this.matrix = n.matrixWorld),
						(this.matrixAutoUpdate = !1)
				}
				updateMatrixWorld(n) {
					const e = this.bones,
						i = this.geometry,
						r = i.getAttribute("position")
					NP.copy(this.root.matrixWorld).invert()
					for (let o = 0, s = 0; o < e.length; o++) {
						const a = e[o]
						a.parent &&
							a.parent.isBone &&
							(RS.multiplyMatrices(NP, a.matrixWorld),
							ff.setFromMatrixPosition(RS),
							r.setXYZ(s, ff.x, ff.y, ff.z),
							RS.multiplyMatrices(NP, a.parent.matrixWorld),
							ff.setFromMatrixPosition(RS),
							r.setXYZ(s + 1, ff.x, ff.y, ff.z),
							(s += 2))
					}
					;(i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(n)
				}
			}
			function CK(t) {
				const n = []
				t && t.isBone && n.push(t)
				for (let e = 0; e < t.children.length; e++) n.push.apply(n, CK(t.children[e]))
				return n
			}
			class VCe extends Mi {
				constructor(n, e, i) {
					super(new $y(e, 4, 2), new Cd({ wireframe: !0, fog: !1, toneMapped: !1 })),
						(this.light = n),
						this.light.updateMatrixWorld(),
						(this.color = i),
						(this.type = "PointLightHelper"),
						(this.matrix = this.light.matrixWorld),
						(this.matrixAutoUpdate = !1),
						this.update()
				}
				dispose() {
					this.geometry.dispose(), this.material.dispose()
				}
				update() {
					void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
				}
			}
			const QCe = new K(),
				EK = new Lt(),
				MK = new Lt()
			class zCe extends On {
				constructor(n, e, i) {
					super(),
						(this.light = n),
						this.light.updateMatrixWorld(),
						(this.matrix = n.matrixWorld),
						(this.matrixAutoUpdate = !1),
						(this.color = i)
					const r = new zy(e)
					r.rotateY(0.5 * Math.PI),
						(this.material = new Cd({ wireframe: !0, fog: !1, toneMapped: !1 })),
						void 0 === this.color && (this.material.vertexColors = !0)
					const o = r.getAttribute("position"),
						s = new Float32Array(3 * o.count)
					r.setAttribute("color", new xn(s, 3)), this.add(new Mi(r, this.material)), this.update()
				}
				dispose() {
					this.children[0].geometry.dispose(), this.children[0].material.dispose()
				}
				update() {
					const n = this.children[0]
					if (void 0 !== this.color) this.material.color.set(this.color)
					else {
						const e = n.geometry.getAttribute("color")
						EK.copy(this.light.color), MK.copy(this.light.groundColor)
						for (let i = 0, r = e.count; i < r; i++) {
							const o = i < r / 2 ? EK : MK
							e.setXYZ(i, o.r, o.g, o.b)
						}
						e.needsUpdate = !0
					}
					n.lookAt(QCe.setFromMatrixPosition(this.light.matrixWorld).negate())
				}
			}
			class SK extends pa {
				constructor(n = 10, e = 10, i = 4473924, r = 8947848) {
					;(i = new Lt(i)), (r = new Lt(r))
					const o = e / 2,
						s = n / e,
						a = n / 2,
						c = [],
						l = []
					for (let h = 0, f = 0, _ = -a; h <= e; h++, _ += s) {
						c.push(-a, 0, _, a, 0, _), c.push(_, 0, -a, _, 0, a)
						const y = h === o ? i : r
						y.toArray(l, f), (f += 3), y.toArray(l, f), (f += 3), y.toArray(l, f), (f += 3), y.toArray(l, f), (f += 3)
					}
					const d = new vn()
					d.setAttribute("position", new cn(c, 3)),
						d.setAttribute("color", new cn(l, 3)),
						super(d, new Go({ vertexColors: !0, toneMapped: !1 })),
						(this.type = "GridHelper")
				}
			}
			class GCe extends pa {
				constructor(n = 10, e = 16, i = 8, r = 64, o = 4473924, s = 8947848) {
					;(o = new Lt(o)), (s = new Lt(s))
					const a = [],
						c = []
					for (let u = 0; u <= e; u++) {
						const h = (u / e) * (2 * Math.PI),
							f = Math.sin(h) * n,
							_ = Math.cos(h) * n
						a.push(0, 0, 0), a.push(f, 0, _)
						const y = 1 & u ? o : s
						c.push(y.r, y.g, y.b), c.push(y.r, y.g, y.b)
					}
					for (let u = 0; u <= i; u++) {
						const h = 1 & u ? o : s,
							f = n - (n / i) * u
						for (let _ = 0; _ < r; _++) {
							let y = (_ / r) * (2 * Math.PI),
								C = Math.sin(y) * f,
								x = Math.cos(y) * f
							a.push(C, 0, x),
								c.push(h.r, h.g, h.b),
								(y = ((_ + 1) / r) * (2 * Math.PI)),
								(C = Math.sin(y) * f),
								(x = Math.cos(y) * f),
								a.push(C, 0, x),
								c.push(h.r, h.g, h.b)
						}
					}
					const l = new vn()
					l.setAttribute("position", new cn(a, 3)),
						l.setAttribute("color", new cn(c, 3)),
						super(l, new Go({ vertexColors: !0, toneMapped: !1 })),
						(this.type = "PolarGridHelper")
				}
			}
			const kK = new K(),
				PS = new K(),
				TK = new K()
			class $Ce extends On {
				constructor(n, e, i) {
					super(),
						(this.light = n),
						this.light.updateMatrixWorld(),
						(this.matrix = n.matrixWorld),
						(this.matrixAutoUpdate = !1),
						(this.color = i),
						void 0 === e && (e = 1)
					let r = new vn()
					r.setAttribute("position", new cn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3))
					const o = new Go({ fog: !1, toneMapped: !1 })
					;(this.lightPlane = new ma(r, o)),
						this.add(this.lightPlane),
						(r = new vn()),
						r.setAttribute("position", new cn([0, 0, 0, 0, 0, 1], 3)),
						(this.targetLine = new ma(r, o)),
						this.add(this.targetLine),
						this.update()
				}
				dispose() {
					this.lightPlane.geometry.dispose(),
						this.lightPlane.material.dispose(),
						this.targetLine.geometry.dispose(),
						this.targetLine.material.dispose()
				}
				update() {
					kK.setFromMatrixPosition(this.light.matrixWorld),
						PS.setFromMatrixPosition(this.light.target.matrixWorld),
						TK.subVectors(PS, kK),
						this.lightPlane.lookAt(PS),
						void 0 !== this.color
							? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color))
							: (this.lightPlane.material.color.copy(this.light.color),
							  this.targetLine.material.color.copy(this.light.color)),
						this.targetLine.lookAt(PS),
						(this.targetLine.scale.z = TK.length())
				}
			}
			const OS = new K(),
				Mo = new rf()
			class WCe extends pa {
				constructor(n) {
					const e = new vn(),
						i = new Go({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
						r = [],
						o = [],
						s = {},
						a = new Lt(16755200),
						c = new Lt(16711680),
						l = new Lt(43775),
						d = new Lt(16777215),
						u = new Lt(3355443)
					function h(_, y, C) {
						f(_, C), f(y, C)
					}
					function f(_, y) {
						r.push(0, 0, 0), o.push(y.r, y.g, y.b), void 0 === s[_] && (s[_] = []), s[_].push(r.length / 3 - 1)
					}
					h("n1", "n2", a),
						h("n2", "n4", a),
						h("n4", "n3", a),
						h("n3", "n1", a),
						h("f1", "f2", a),
						h("f2", "f4", a),
						h("f4", "f3", a),
						h("f3", "f1", a),
						h("n1", "f1", a),
						h("n2", "f2", a),
						h("n3", "f3", a),
						h("n4", "f4", a),
						h("p", "n1", c),
						h("p", "n2", c),
						h("p", "n3", c),
						h("p", "n4", c),
						h("u1", "u2", l),
						h("u2", "u3", l),
						h("u3", "u1", l),
						h("c", "t", d),
						h("p", "c", u),
						h("cn1", "cn2", u),
						h("cn3", "cn4", u),
						h("cf1", "cf2", u),
						h("cf3", "cf4", u),
						e.setAttribute("position", new cn(r, 3)),
						e.setAttribute("color", new cn(o, 3)),
						super(e, i),
						(this.type = "CameraHelper"),
						(this.camera = n),
						this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
						(this.matrix = n.matrixWorld),
						(this.matrixAutoUpdate = !1),
						(this.pointMap = s),
						this.update()
				}
				update() {
					const n = this.geometry,
						e = this.pointMap
					Mo.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
						Po("c", e, n, Mo, 0, 0, -1),
						Po("t", e, n, Mo, 0, 0, 1),
						Po("n1", e, n, Mo, -1, -1, -1),
						Po("n2", e, n, Mo, 1, -1, -1),
						Po("n3", e, n, Mo, -1, 1, -1),
						Po("n4", e, n, Mo, 1, 1, -1),
						Po("f1", e, n, Mo, -1, -1, 1),
						Po("f2", e, n, Mo, 1, -1, 1),
						Po("f3", e, n, Mo, -1, 1, 1),
						Po("f4", e, n, Mo, 1, 1, 1),
						Po("u1", e, n, Mo, 0.7, 1.1, -1),
						Po("u2", e, n, Mo, -0.7, 1.1, -1),
						Po("u3", e, n, Mo, 0, 2, -1),
						Po("cf1", e, n, Mo, -1, 0, 1),
						Po("cf2", e, n, Mo, 1, 0, 1),
						Po("cf3", e, n, Mo, 0, -1, 1),
						Po("cf4", e, n, Mo, 0, 1, 1),
						Po("cn1", e, n, Mo, -1, 0, -1),
						Po("cn2", e, n, Mo, 1, 0, -1),
						Po("cn3", e, n, Mo, 0, -1, -1),
						Po("cn4", e, n, Mo, 0, 1, -1),
						(n.getAttribute("position").needsUpdate = !0)
				}
			}
			function Po(t, n, e, i, r, o, s) {
				OS.set(r, o, s).unproject(i)
				const a = n[t]
				if (void 0 !== a) {
					const c = e.getAttribute("position")
					for (let l = 0, d = a.length; l < d; l++) c.setXYZ(a[l], OS.x, OS.y, OS.z)
				}
			}
			const NS = new is()
			class UP extends pa {
				constructor(n, e = 16776960) {
					const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
						r = new Float32Array(24),
						o = new vn()
					o.setIndex(new xn(i, 1)),
						o.setAttribute("position", new xn(r, 3)),
						super(o, new Go({ color: e, toneMapped: !1 })),
						(this.object = n),
						(this.type = "BoxHelper"),
						(this.matrixAutoUpdate = !1),
						this.update()
				}
				update(n) {
					if (
						(void 0 !== n && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
						void 0 !== this.object && NS.setFromObject(this.object),
						NS.isEmpty())
					)
						return
					const e = NS.min,
						i = NS.max,
						r = this.geometry.attributes.position,
						o = r.array
					;(o[0] = i.x),
						(o[1] = i.y),
						(o[2] = i.z),
						(o[3] = e.x),
						(o[4] = i.y),
						(o[5] = i.z),
						(o[6] = e.x),
						(o[7] = e.y),
						(o[8] = i.z),
						(o[9] = i.x),
						(o[10] = e.y),
						(o[11] = i.z),
						(o[12] = i.x),
						(o[13] = i.y),
						(o[14] = e.z),
						(o[15] = e.x),
						(o[16] = i.y),
						(o[17] = e.z),
						(o[18] = e.x),
						(o[19] = e.y),
						(o[20] = e.z),
						(o[21] = i.x),
						(o[22] = e.y),
						(o[23] = e.z),
						(r.needsUpdate = !0),
						this.geometry.computeBoundingSphere()
				}
				setFromObject(n) {
					return (this.object = n), this.update(), this
				}
				copy(n) {
					return pa.prototype.copy.call(this, n), (this.object = n.object), this
				}
			}
			class jCe extends pa {
				constructor(n, e = 16776960) {
					const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
						o = new vn()
					o.setIndex(new xn(i, 1)),
						o.setAttribute(
							"position",
							new cn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)
						),
						super(o, new Go({ color: e, toneMapped: !1 })),
						(this.box = n),
						(this.type = "Box3Helper"),
						this.geometry.computeBoundingSphere()
				}
				updateMatrixWorld(n) {
					const e = this.box
					e.isEmpty() ||
						(e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(n))
				}
			}
			class KCe extends ma {
				constructor(n, e = 1, i = 16776960) {
					const r = i,
						s = new vn()
					s.setAttribute(
						"position",
						new cn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)
					),
						s.computeBoundingSphere(),
						super(s, new Go({ color: r, toneMapped: !1 })),
						(this.type = "PlaneHelper"),
						(this.plane = n),
						(this.size = e)
					const c = new vn()
					c.setAttribute("position", new cn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)),
						c.computeBoundingSphere(),
						this.add(new Mi(c, new Cd({ color: r, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })))
				}
				updateMatrixWorld(n) {
					let e = -this.plane.constant
					Math.abs(e) < 1e-8 && (e = 1e-8),
						this.scale.set(0.5 * this.size, 0.5 * this.size, e),
						(this.children[0].material.side = e < 0 ? Lo : Ig),
						this.lookAt(this.plane.normal),
						super.updateMatrixWorld(n)
				}
			}
			const FK = new K()
			let US, HP
			class BK extends On {
				constructor(n = new K(0, 0, 1), e = new K(0, 0, 0), i = 1, r = 16776960, o = 0.2 * i, s = 0.2 * o) {
					super(),
						(this.type = "ArrowHelper"),
						void 0 === US &&
							((US = new vn()),
							US.setAttribute("position", new cn([0, 0, 0, 0, 1, 0], 3)),
							(HP = new lb(0, 0.5, 1, 5, 1)),
							HP.translate(0, -0.5, 0)),
						this.position.copy(e),
						(this.line = new ma(US, new Go({ color: r, toneMapped: !1 }))),
						(this.line.matrixAutoUpdate = !1),
						this.add(this.line),
						(this.cone = new Mi(HP, new Cd({ color: r, toneMapped: !1 }))),
						(this.cone.matrixAutoUpdate = !1),
						this.add(this.cone),
						this.setDirection(n),
						this.setLength(i, o, s)
				}
				setDirection(n) {
					if (n.y > 0.99999) this.quaternion.set(0, 0, 0, 1)
					else if (n.y < -0.99999) this.quaternion.set(1, 0, 0, 0)
					else {
						FK.set(n.z, 0, -n.x).normalize()
						const e = Math.acos(n.y)
						this.quaternion.setFromAxisAngle(FK, e)
					}
				}
				setLength(n, e = 0.2 * n, i = 0.2 * e) {
					this.line.scale.set(1, Math.max(1e-4, n - e), 1),
						this.line.updateMatrix(),
						this.cone.scale.set(i, e, i),
						(this.cone.position.y = n),
						this.cone.updateMatrix()
				}
				setColor(n) {
					this.line.material.color.set(n), this.cone.material.color.set(n)
				}
				copy(n) {
					return super.copy(n, !1), this.line.copy(n.line), this.cone.copy(n.cone), this
				}
			}
			class VP extends pa {
				constructor(n = 1) {
					const e = [0, 0, 0, n, 0, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, 0, n],
						r = new vn()
					r.setAttribute("position", new cn(e, 3)),
						r.setAttribute("color", new cn([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)),
						super(r, new Go({ vertexColors: !0, toneMapped: !1 })),
						(this.type = "AxesHelper")
				}
			}
			const IK = new Float32Array(1),
				XCe = new Int32Array(IK.buffer),
				YCe = {
					toHalfFloat: function (t) {
						IK[0] = t
						const n = XCe[0]
						let e = (n >> 16) & 32768,
							i = (n >> 12) & 2047
						const r = (n >> 23) & 255
						return r < 103
							? e
							: r > 142
							? ((e |= 31744), (e |= (255 == r ? 0 : 1) && 8388607 & n), e)
							: r < 113
							? ((i |= 2048), (e |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)), e)
							: ((e |= ((r - 112) << 10) | (i >> 1)), (e += 1 & i), e)
					}
				},
				Sd = Math.pow(2, 8),
				DK = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
				LK = 5 + DK.length,
				kd = { [fa]: 0, [hy]: 1, [vM]: 2, [gR]: 3, [bR]: 4, [_R]: 5, [_M]: 6 },
				Cp = new Cd({ side: Lo, depthWrite: !1, depthTest: !1 }),
				qCe = new Mi(new _l(), Cp),
				QP = new bp(),
				{ _lodPlanes: aw, _sizeLods: RK, _sigmas: HS } = eEe(),
				PK = new Lt()
			let zP = null
			const Ep = (1 + Math.sqrt(5)) / 2,
				gb = 1 / Ep,
				OK = [
					new K(1, 1, 1),
					new K(-1, 1, 1),
					new K(1, 1, -1),
					new K(-1, 1, -1),
					new K(0, Ep, gb),
					new K(0, Ep, -gb),
					new K(gb, 0, Ep),
					new K(-gb, 0, Ep),
					new K(Ep, gb, 0),
					new K(-Ep, gb, 0)
				]
			function NK(t) {
				const n = Math.max(t.r, t.g, t.b),
					e = Math.min(Math.max(Math.ceil(Math.log2(n)), -128), 127)
				return t.multiplyScalar(Math.pow(2, -e)), (e + 128) / 255
			}
			class ZCe {
				constructor(n) {
					;(this._renderer = n),
						(this._pingPongRenderTarget = null),
						(this._blurMaterial = (function tEe(t) {
							const n = new Float32Array(t),
								e = new K(0, 1, 0)
							return new ub({
								name: "SphericalGaussianBlur",
								defines: { n: t },
								uniforms: {
									envMap: { value: null },
									samples: { value: 1 },
									weights: { value: n },
									latitudinal: { value: !1 },
									dTheta: { value: 0 },
									mipInt: { value: 0 },
									poleAxis: { value: e },
									inputEncoding: { value: kd[fa] },
									outputEncoding: { value: kd[fa] }
								},
								vertexShader:
									"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
								fragmentShader:
									"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
								blending: Fu,
								depthTest: !1,
								depthWrite: !1
							})
						})(20)),
						(this._equirectShader = null),
						(this._cubemapShader = null),
						this._compileMaterial(this._blurMaterial)
				}
				fromScene(n, e = 0, i = 0.1, r = 100) {
					zP = this._renderer.getRenderTarget()
					const o = this._allocateTargets()
					return this._sceneToCubeUV(n, i, r, o), e > 0 && this._blur(o, 0, 0, e), this._applyPMREM(o), this._cleanup(o), o
				}
				fromEquirectangular(n) {
					return this._fromTexture(n)
				}
				fromCubemap(n) {
					return this._fromTexture(n)
				}
				compileCubemapShader() {
					null === this._cubemapShader && ((this._cubemapShader = VK()), this._compileMaterial(this._cubemapShader))
				}
				compileEquirectangularShader() {
					null === this._equirectShader && ((this._equirectShader = HK()), this._compileMaterial(this._equirectShader))
				}
				dispose() {
					this._blurMaterial.dispose(),
						null !== this._cubemapShader && this._cubemapShader.dispose(),
						null !== this._equirectShader && this._equirectShader.dispose()
					for (let n = 0; n < aw.length; n++) aw[n].dispose()
				}
				_cleanup(n) {
					this._pingPongRenderTarget.dispose(),
						this._renderer.setRenderTarget(zP),
						(n.scissorTest = !1),
						VS(n, 0, 0, n.width, n.height)
				}
				_fromTexture(n) {
					zP = this._renderer.getRenderTarget()
					const e = this._allocateTargets(n)
					return this._textureToCubeUV(n, e), this._applyPMREM(e), this._cleanup(e), e
				}
				_allocateTargets(n) {
					const e = {
							magFilter: ts,
							minFilter: ts,
							generateMipmaps: !1,
							type: Pg,
							format: UW,
							encoding:
								((t = n),
								void 0 === t || t.type !== Pg || (t.encoding !== fa && t.encoding !== hy && t.encoding !== _M)
									? vM
									: n.encoding),
							depthBuffer: !1
						},
						i = UK(e)
					var t
					return (i.depthBuffer = !n), (this._pingPongRenderTarget = UK(e)), i
				}
				_compileMaterial(n) {
					const e = new Mi(aw[0], n)
					this._renderer.compile(e, QP)
				}
				_sceneToCubeUV(n, e, i, r) {
					const a = new Co(90, 1, e, i),
						c = [1, -1, 1, 1, 1, 1],
						l = [1, 1, 1, -1, -1, -1],
						d = this._renderer,
						u = d.autoClear,
						h = d.outputEncoding,
						f = d.toneMapping
					d.getClearColor(PK), (d.toneMapping = Jm), (d.outputEncoding = fa), (d.autoClear = !1)
					let _ = !1
					const y = n.background
					if (y) {
						if (y.isColor) {
							Cp.color.copy(y).convertSRGBToLinear(), (n.background = null)
							const C = NK(Cp.color)
							;(Cp.opacity = C), (_ = !0)
						}
					} else {
						Cp.color.copy(PK).convertSRGBToLinear()
						const C = NK(Cp.color)
						;(Cp.opacity = C), (_ = !0)
					}
					for (let C = 0; C < 6; C++) {
						const x = C % 3
						0 == x
							? (a.up.set(0, c[C], 0), a.lookAt(l[C], 0, 0))
							: 1 == x
							? (a.up.set(0, 0, c[C]), a.lookAt(0, l[C], 0))
							: (a.up.set(0, c[C], 0), a.lookAt(0, 0, l[C])),
							VS(r, x * Sd, C > 2 ? Sd : 0, Sd, Sd),
							d.setRenderTarget(r),
							_ && d.render(qCe, a),
							d.render(n, a)
					}
					;(d.toneMapping = f), (d.outputEncoding = h), (d.autoClear = u)
				}
				_textureToCubeUV(n, e) {
					const i = this._renderer
					n.isCubeTexture
						? null == this._cubemapShader && (this._cubemapShader = VK())
						: null == this._equirectShader && (this._equirectShader = HK())
					const r = n.isCubeTexture ? this._cubemapShader : this._equirectShader,
						o = new Mi(aw[0], r),
						s = r.uniforms
					;(s.envMap.value = n),
						n.isCubeTexture || s.texelSize.value.set(1 / n.image.width, 1 / n.image.height),
						(s.inputEncoding.value = kd[n.encoding]),
						(s.outputEncoding.value = kd[e.texture.encoding]),
						VS(e, 0, 0, 3 * Sd, 2 * Sd),
						i.setRenderTarget(e),
						i.render(o, QP)
				}
				_applyPMREM(n) {
					const e = this._renderer,
						i = e.autoClear
					e.autoClear = !1
					for (let r = 1; r < LK; r++) {
						const o = Math.sqrt(HS[r] * HS[r] - HS[r - 1] * HS[r - 1])
						this._blur(n, r - 1, r, o, OK[(r - 1) % OK.length])
					}
					e.autoClear = i
				}
				_blur(n, e, i, r, o) {
					const s = this._pingPongRenderTarget
					this._halfBlur(n, s, e, i, r, "latitudinal", o), this._halfBlur(s, n, i, i, r, "longitudinal", o)
				}
				_halfBlur(n, e, i, r, o, s, a) {
					const c = this._renderer,
						l = this._blurMaterial
					"latitudinal" !== s &&
						"longitudinal" !== s &&
						console.error("blur direction must be either latitudinal or longitudinal!")
					const u = new Mi(aw[r], l),
						h = l.uniforms,
						f = RK[i] - 1,
						_ = isFinite(o) ? Math.PI / (2 * f) : (2 * Math.PI) / 39,
						y = o / _,
						C = isFinite(o) ? 1 + Math.floor(3 * y) : 20
					C > 20 &&
						console.warn(
							`sigmaRadians, ${o}, is too large and will clip, as it requested ${C} samples when the maximum is set to 20`
						)
					const x = []
					let w = 0
					for (let N = 0; N < 20; ++N) {
						const j = N / y,
							le = Math.exp((-j * j) / 2)
						x.push(le), 0 == N ? (w += le) : N < C && (w += 2 * le)
					}
					for (let N = 0; N < x.length; N++) x[N] = x[N] / w
					;(h.envMap.value = n.texture),
						(h.samples.value = C),
						(h.weights.value = x),
						(h.latitudinal.value = "latitudinal" === s),
						a && (h.poleAxis.value = a),
						(h.dTheta.value = _),
						(h.mipInt.value = 8 - i),
						(h.inputEncoding.value = kd[n.texture.encoding]),
						(h.outputEncoding.value = kd[n.texture.encoding])
					const S = RK[r]
					VS(e, 3 * Math.max(0, Sd - 2 * S), (0 === r ? 0 : 2 * Sd) + 2 * S * (r > 4 ? r - 8 + 4 : 0), 3 * S, 2 * S),
						c.setRenderTarget(e),
						c.render(u, QP)
				}
			}
			function eEe() {
				const t = [],
					n = [],
					e = []
				let i = 8
				for (let r = 0; r < LK; r++) {
					const o = Math.pow(2, i)
					n.push(o)
					let s = 1 / o
					r > 4 ? (s = DK[r - 8 + 4 - 1]) : 0 == r && (s = 0), e.push(s)
					const a = 1 / (o - 1),
						c = -a / 2,
						l = 1 + a / 2,
						d = [c, c, l, c, l, l, c, c, l, l, c, l],
						u = 6,
						h = 6,
						f = 3,
						_ = 2,
						y = 1,
						C = new Float32Array(f * h * u),
						x = new Float32Array(_ * h * u),
						w = new Float32Array(y * h * u)
					for (let M = 0; M < u; M++) {
						const O = ((M % 3) * 2) / 3 - 1,
							N = M > 2 ? 0 : -1
						C.set([O, N, 0, O + 2 / 3, N, 0, O + 2 / 3, N + 1, 0, O, N, 0, O + 2 / 3, N + 1, 0, O, N + 1, 0], f * h * M),
							x.set(d, _ * h * M),
							w.set([M, M, M, M, M, M], y * h * M)
					}
					const S = new vn()
					S.setAttribute("position", new xn(C, f)),
						S.setAttribute("uv", new xn(x, _)),
						S.setAttribute("faceIndex", new xn(w, y)),
						t.push(S),
						i > 4 && i--
				}
				return { _lodPlanes: t, _sizeLods: n, _sigmas: e }
			}
			function UK(t) {
				const n = new ml(3 * Sd, 3 * Sd, t)
				return (n.texture.mapping = Lg), (n.texture.name = "PMREM.cubeUv"), (n.scissorTest = !0), n
			}
			function VS(t, n, e, i, r) {
				t.viewport.set(n, e, i, r), t.scissor.set(n, e, i, r)
			}
			function HK() {
				const t = new lt(1, 1)
				return new ub({
					name: "EquirectangularToCubeUV",
					uniforms: {
						envMap: { value: null },
						texelSize: { value: t },
						inputEncoding: { value: kd[fa] },
						outputEncoding: { value: kd[fa] }
					},
					vertexShader:
						"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
					fragmentShader:
						"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
					blending: Fu,
					depthTest: !1,
					depthWrite: !1
				})
			}
			function VK() {
				return new ub({
					name: "CubemapToCubeUV",
					uniforms: { envMap: { value: null }, inputEncoding: { value: kd[fa] }, outputEncoding: { value: kd[fa] } },
					vertexShader:
						"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
					fragmentShader:
						"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
					blending: Fu,
					depthTest: !1,
					depthWrite: !1
				})
			}
			const nEe = 0,
				iEe = 1,
				rEe = 0,
				oEe = 1,
				sEe = 2
			function aEe(t) {
				return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
			}
			function cEe(t = []) {
				return (
					console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
					(t.isMultiMaterial = !0),
					(t.materials = t),
					(t.clone = function () {
						return t.slice()
					}),
					t
				)
			}
			function lEe(t, n) {
				return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new cb(t, n)
			}
			function dEe(t) {
				return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new ab(t)
			}
			function uEe(t, n) {
				return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new cb(t, n)
			}
			function hEe(t) {
				return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new fp(t)
			}
			function fEe(t) {
				return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new fp(t)
			}
			function mEe(t) {
				return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new fp(t)
			}
			function pEe(t, n, e) {
				return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new K(t, n, e)
			}
			function AEe(t, n) {
				return (
					console.warn(
						"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
					),
					new xn(t, n).setUsage(op)
				)
			}
			function gEe(t, n) {
				return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new gy(t, n)
			}
			function bEe(t, n) {
				return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new by(t, n)
			}
			function _Ee(t, n) {
				return (
					console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
					new _y(t, n)
				)
			}
			function vEe(t, n) {
				return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new vy(t, n)
			}
			function yEe(t, n) {
				return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new dp(t, n)
			}
			function wEe(t, n) {
				return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new yy(t, n)
			}
			function xEe(t, n) {
				return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new up(t, n)
			}
			function CEe(t, n) {
				return (
					console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new cn(t, n)
				)
			}
			function EEe(t, n) {
				return (
					console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new xy(t, n)
				)
			}
			function MEe(t) {
				return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new VP(t)
			}
			function SEe(t, n) {
				return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new UP(t, n)
			}
			function kEe(t, n) {
				return (
					console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
					new pa(new tP(t.geometry), new Go({ color: void 0 !== n ? n : 16777215 }))
				)
			}
			function TEe(t, n) {
				return (
					console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
					new pa(new rP(t.geometry), new Go({ color: void 0 !== n ? n : 16777215 }))
				)
			}
			function FEe(t) {
				return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Hc(t)
			}
			function BEe(t) {
				return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new CS(t)
			}
			function IEe(t, n, e) {
				return (
					console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),
					new VM(t, e)
				)
			}
			function DEe() {
				console.error("THREE.CanvasRenderer has been removed")
			}
			function LEe() {
				console.error("THREE.JSONLoader has been removed.")
			}
			;(ga.create = function (t, n) {
				return (
					console.log("THREE.Curve.create() has been deprecated"),
					(t.prototype = Object.create(ga.prototype)),
					(t.prototype.constructor = t),
					(t.prototype.getPoint = n),
					t
				)
			}),
				(ew.prototype.fromPoints = function (t) {
					return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
				}),
				(SK.prototype.setColors = function () {
					console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
				}),
				(xK.prototype.update = function () {
					console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
				}),
				(Eo.prototype.extractUrlBase = function (t) {
					return (
						console.warn(
							"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
						),
						SP.extractUrlBase(t)
					)
				}),
				(Eo.Handlers = {
					add: function () {
						console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
					},
					get: function () {
						console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
					}
				}),
				(mb.prototype.center = function (t) {
					return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
				}),
				(mb.prototype.empty = function () {
					return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
				}),
				(mb.prototype.isIntersectionBox = function (t) {
					return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
				}),
				(mb.prototype.size = function (t) {
					return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
				}),
				(is.prototype.center = function (t) {
					return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
				}),
				(is.prototype.empty = function () {
					return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
				}),
				(is.prototype.isIntersectionBox = function (t) {
					return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
				}),
				(is.prototype.isIntersectionSphere = function (t) {
					return (
						console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
						this.intersectsSphere(t)
					)
				}),
				(is.prototype.size = function (t) {
					return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
				}),
				(xd.prototype.empty = function () {
					return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
				}),
				(My.prototype.setFromMatrix = function (t) {
					return (
						console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
						this.setFromProjectionMatrix(t)
					)
				}),
				(yK.prototype.center = function (t) {
					return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
				}),
				(jn.random16 = function () {
					return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
				}),
				(jn.nearestPowerOfTwo = function (t) {
					return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), jn.floorPowerOfTwo(t)
				}),
				(jn.nextPowerOfTwo = function (t) {
					return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), jn.ceilPowerOfTwo(t)
				}),
				(ns.prototype.flattenToArrayOffset = function (t, n) {
					return (
						console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
						this.toArray(t, n)
					)
				}),
				(ns.prototype.multiplyVector3 = function (t) {
					return (
						console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
						t.applyMatrix3(this)
					)
				}),
				(ns.prototype.multiplyVector3Array = function () {
					console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
				}),
				(ns.prototype.applyToBufferAttribute = function (t) {
					return (
						console.warn(
							"THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
						),
						t.applyMatrix3(this)
					)
				}),
				(ns.prototype.applyToVector3Array = function () {
					console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
				}),
				(ns.prototype.getInverse = function (t) {
					return (
						console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
						this.copy(t).invert()
					)
				}),
				(Cn.prototype.extractPosition = function (t) {
					return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
				}),
				(Cn.prototype.flattenToArrayOffset = function (t, n) {
					return (
						console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
						this.toArray(t, n)
					)
				}),
				(Cn.prototype.getPosition = function () {
					return (
						console.warn(
							"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
						),
						new K().setFromMatrixColumn(this, 3)
					)
				}),
				(Cn.prototype.setRotationFromQuaternion = function (t) {
					return (
						console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
						this.makeRotationFromQuaternion(t)
					)
				}),
				(Cn.prototype.multiplyToArray = function () {
					console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
				}),
				(Cn.prototype.multiplyVector3 = function (t) {
					return (
						console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
						t.applyMatrix4(this)
					)
				}),
				(Cn.prototype.multiplyVector4 = function (t) {
					return (
						console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
						t.applyMatrix4(this)
					)
				}),
				(Cn.prototype.multiplyVector3Array = function () {
					console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
				}),
				(Cn.prototype.rotateAxis = function (t) {
					console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
						t.transformDirection(this)
				}),
				(Cn.prototype.crossVector = function (t) {
					return (
						console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
						t.applyMatrix4(this)
					)
				}),
				(Cn.prototype.translate = function () {
					console.error("THREE.Matrix4: .translate() has been removed.")
				}),
				(Cn.prototype.rotateX = function () {
					console.error("THREE.Matrix4: .rotateX() has been removed.")
				}),
				(Cn.prototype.rotateY = function () {
					console.error("THREE.Matrix4: .rotateY() has been removed.")
				}),
				(Cn.prototype.rotateZ = function () {
					console.error("THREE.Matrix4: .rotateZ() has been removed.")
				}),
				(Cn.prototype.rotateByAxis = function () {
					console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
				}),
				(Cn.prototype.applyToBufferAttribute = function (t) {
					return (
						console.warn(
							"THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
						),
						t.applyMatrix4(this)
					)
				}),
				(Cn.prototype.applyToVector3Array = function () {
					console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
				}),
				(Cn.prototype.makeFrustum = function (t, n, e, i, r, o) {
					return (
						console.warn(
							"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
						),
						this.makePerspective(t, n, i, e, r, o)
					)
				}),
				(Cn.prototype.getInverse = function (t) {
					return (
						console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
						this.copy(t).invert()
					)
				}),
				(Al.prototype.isIntersectionLine = function (t) {
					return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
				}),
				(fs.prototype.multiplyVector3 = function (t) {
					return (
						console.warn(
							"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
						),
						t.applyQuaternion(this)
					)
				}),
				(fs.prototype.inverse = function () {
					return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
				}),
				(Ru.prototype.isIntersectionBox = function (t) {
					return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
				}),
				(Ru.prototype.isIntersectionPlane = function (t) {
					return (
						console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
					)
				}),
				(Ru.prototype.isIntersectionSphere = function (t) {
					return (
						console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
						this.intersectsSphere(t)
					)
				}),
				(Ro.prototype.area = function () {
					return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
				}),
				(Ro.prototype.barycoordFromPoint = function (t, n) {
					return (
						console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, n)
					)
				}),
				(Ro.prototype.midpoint = function (t) {
					return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
				}),
				(Ro.prototypenormal = function (t) {
					return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
				}),
				(Ro.prototype.plane = function (t) {
					return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
				}),
				(Ro.barycoordFromPoint = function (t, n, e, i, r) {
					return (
						console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
						Ro.getBarycoord(t, n, e, i, r)
					)
				}),
				(Ro.normal = function (t, n, e, i) {
					return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ro.getNormal(t, n, e, i)
				}),
				(hf.prototype.extractAllPoints = function (t) {
					return (
						console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
						this.extractPoints(t)
					)
				}),
				(hf.prototype.extrude = function (t) {
					return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Hu(this, t)
				}),
				(hf.prototype.makeGeometry = function (t) {
					return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Gy(this, t)
				}),
				(lt.prototype.fromAttribute = function (t, n, e) {
					return (
						console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
						this.fromBufferAttribute(t, n, e)
					)
				}),
				(lt.prototype.distanceToManhattan = function (t) {
					return (
						console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
						this.manhattanDistanceTo(t)
					)
				}),
				(lt.prototype.lengthManhattan = function () {
					return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
				}),
				(K.prototype.setEulerFromRotationMatrix = function () {
					console.error(
						"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
					)
				}),
				(K.prototype.setEulerFromQuaternion = function () {
					console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
				}),
				(K.prototype.getPositionFromMatrix = function (t) {
					return (
						console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
						this.setFromMatrixPosition(t)
					)
				}),
				(K.prototype.getScaleFromMatrix = function (t) {
					return (
						console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
						this.setFromMatrixScale(t)
					)
				}),
				(K.prototype.getColumnFromMatrix = function (t, n) {
					return (
						console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
						this.setFromMatrixColumn(n, t)
					)
				}),
				(K.prototype.applyProjection = function (t) {
					return (
						console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
						this.applyMatrix4(t)
					)
				}),
				(K.prototype.fromAttribute = function (t, n, e) {
					return (
						console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
						this.fromBufferAttribute(t, n, e)
					)
				}),
				(K.prototype.distanceToManhattan = function (t) {
					return (
						console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
						this.manhattanDistanceTo(t)
					)
				}),
				(K.prototype.lengthManhattan = function () {
					return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
				}),
				(lr.prototype.fromAttribute = function (t, n, e) {
					return (
						console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
						this.fromBufferAttribute(t, n, e)
					)
				}),
				(lr.prototype.lengthManhattan = function () {
					return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
				}),
				(On.prototype.getChildByName = function (t) {
					return (
						console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
					)
				}),
				(On.prototype.renderDepth = function () {
					console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
				}),
				(On.prototype.translate = function (t, n) {
					return (
						console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
						this.translateOnAxis(n, t)
					)
				}),
				(On.prototype.getWorldRotation = function () {
					console.error(
						"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
					)
				}),
				(On.prototype.applyMatrix = function (t) {
					return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
				}),
				Object.defineProperties(On.prototype, {
					eulerOrder: {
						get: function () {
							return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
						},
						set: function (t) {
							console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), (this.rotation.order = t)
						}
					},
					useQuaternion: {
						get: function () {
							console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
						},
						set: function () {
							console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
						}
					}
				}),
				(Mi.prototype.setDrawMode = function () {
					console.error(
						"THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
					)
				}),
				Object.defineProperties(Mi.prototype, {
					drawMode: {
						get: function () {
							return (
								console.error(
									"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
								),
								Ej
							)
						},
						set: function () {
							console.error(
								"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
							)
						}
					}
				}),
				Object.defineProperties(KR.prototype, {
					objects: {
						get: function () {
							return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
						}
					}
				}),
				Object.defineProperty(Ny.prototype, "useVertexTexture", {
					get: function () {
						console.warn("THREE.Skeleton: useVertexTexture has been removed.")
					},
					set: function () {
						console.warn("THREE.Skeleton: useVertexTexture has been removed.")
					}
				}),
				(Py.prototype.initBones = function () {
					console.error("THREE.SkinnedMesh: initBones() has been removed.")
				}),
				Object.defineProperty(ga.prototype, "__arcLengthDivisions", {
					get: function () {
						return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
					},
					set: function (t) {
						console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), (this.arcLengthDivisions = t)
					}
				}),
				(Co.prototype.setLens = function (t, n) {
					console.warn(
						"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
					),
						void 0 !== n && (this.filmGauge = n),
						this.setFocalLength(t)
				}),
				Object.defineProperties(xl.prototype, {
					onlyShadow: {
						set: function () {
							console.warn("THREE.Light: .onlyShadow has been removed.")
						}
					},
					shadowCameraFov: {
						set: function (t) {
							console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), (this.shadow.camera.fov = t)
						}
					},
					shadowCameraLeft: {
						set: function (t) {
							console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), (this.shadow.camera.left = t)
						}
					},
					shadowCameraRight: {
						set: function (t) {
							console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), (this.shadow.camera.right = t)
						}
					},
					shadowCameraTop: {
						set: function (t) {
							console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), (this.shadow.camera.top = t)
						}
					},
					shadowCameraBottom: {
						set: function (t) {
							console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), (this.shadow.camera.bottom = t)
						}
					},
					shadowCameraNear: {
						set: function (t) {
							console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), (this.shadow.camera.near = t)
						}
					},
					shadowCameraFar: {
						set: function (t) {
							console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), (this.shadow.camera.far = t)
						}
					},
					shadowCameraVisible: {
						set: function () {
							console.warn(
								"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
							)
						}
					},
					shadowBias: {
						set: function (t) {
							console.warn("THREE.Light: .shadowBias is now .shadow.bias."), (this.shadow.bias = t)
						}
					},
					shadowDarkness: {
						set: function () {
							console.warn("THREE.Light: .shadowDarkness has been removed.")
						}
					},
					shadowMapWidth: {
						set: function (t) {
							console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), (this.shadow.mapSize.width = t)
						}
					},
					shadowMapHeight: {
						set: function (t) {
							console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), (this.shadow.mapSize.height = t)
						}
					}
				}),
				Object.defineProperties(xn.prototype, {
					length: {
						get: function () {
							return (
								console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
							)
						}
					},
					dynamic: {
						get: function () {
							return (
								console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === op
							)
						},
						set: function () {
							console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(op)
						}
					}
				}),
				(xn.prototype.setDynamic = function (t) {
					return (
						console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
						this.setUsage(!0 === t ? op : fy),
						this
					)
				}),
				(xn.prototype.copyIndicesArray = function () {
					console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
				}),
				(xn.prototype.setArray = function () {
					console.error(
						"THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
					)
				}),
				(vn.prototype.addIndex = function (t) {
					console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
				}),
				(vn.prototype.addAttribute = function (t, n) {
					return (
						console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
						(n && n.isBufferAttribute) || (n && n.isInterleavedBufferAttribute)
							? "index" === t
								? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
								  this.setIndex(n),
								  this)
								: this.setAttribute(t, n)
							: (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
							  this.setAttribute(t, new xn(arguments[1], arguments[2])))
					)
				}),
				(vn.prototype.addDrawCall = function (t, n, e) {
					void 0 !== e && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
						console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
						this.addGroup(t, n)
				}),
				(vn.prototype.clearDrawCalls = function () {
					console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
				}),
				(vn.prototype.computeOffsets = function () {
					console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
				}),
				(vn.prototype.removeAttribute = function (t) {
					return (
						console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
						this.deleteAttribute(t)
					)
				}),
				(vn.prototype.applyMatrix = function (t) {
					return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
				}),
				Object.defineProperties(vn.prototype, {
					drawcalls: {
						get: function () {
							return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
						}
					},
					offsets: {
						get: function () {
							return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
						}
					}
				}),
				Object.defineProperties(rw.prototype, {
					maxInstancedCount: {
						get: function () {
							return (
								console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
								this.instanceCount
							)
						},
						set: function (t) {
							console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
								(this.instanceCount = t)
						}
					}
				}),
				Object.defineProperties(ow.prototype, {
					linePrecision: {
						get: function () {
							return (
								console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
								this.params.Line.threshold
							)
						},
						set: function (t) {
							console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
								(this.params.Line.threshold = t)
						}
					}
				}),
				Object.defineProperties(Ra.prototype, {
					dynamic: {
						get: function () {
							return (
								console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === op
							)
						},
						set: function (t) {
							console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t)
						}
					}
				}),
				(Ra.prototype.setDynamic = function (t) {
					return (
						console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
						this.setUsage(!0 === t ? op : fy),
						this
					)
				}),
				(Ra.prototype.setArray = function () {
					console.error(
						"THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
					)
				}),
				(Hu.prototype.getArrays = function () {
					console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
				}),
				(Hu.prototype.addShapeList = function () {
					console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
				}),
				(Hu.prototype.addShape = function () {
					console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
				}),
				(nb.prototype.dispose = function () {
					console.error("THREE.Scene: .dispose() has been removed.")
				}),
				Object.defineProperties(DS.prototype, {
					dynamic: {
						set: function () {
							console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
						}
					},
					onUpdate: {
						value: function () {
							return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
						}
					}
				}),
				Object.defineProperties(jr.prototype, {
					wrapAround: {
						get: function () {
							console.warn("THREE.Material: .wrapAround has been removed.")
						},
						set: function () {
							console.warn("THREE.Material: .wrapAround has been removed.")
						}
					},
					overdraw: {
						get: function () {
							console.warn("THREE.Material: .overdraw has been removed.")
						},
						set: function () {
							console.warn("THREE.Material: .overdraw has been removed.")
						}
					},
					wrapRGB: {
						get: function () {
							return console.warn("THREE.Material: .wrapRGB has been removed."), new Lt()
						}
					},
					shading: {
						get: function () {
							console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
						},
						set: function (t) {
							console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
								(this.flatShading = t === qL)
						}
					},
					stencilMask: {
						get: function () {
							return (
								console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
								this.stencilFuncMask
							)
						},
						set: function (t) {
							console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
								(this.stencilFuncMask = t)
						}
					}
				}),
				Object.defineProperties(bS.prototype, {
					metal: {
						get: function () {
							return (
								console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
								!1
							)
						},
						set: function () {
							console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
						}
					}
				}),
				Object.defineProperties(uf.prototype, {
					transparency: {
						get: function () {
							return (
								console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
								this.transmission
							)
						},
						set: function (t) {
							console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
								(this.transmission = t)
						}
					}
				}),
				Object.defineProperties(Ds.prototype, {
					derivatives: {
						get: function () {
							return (
								console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
								this.extensions.derivatives
							)
						},
						set: function (t) {
							console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
								(this.extensions.derivatives = t)
						}
					}
				}),
				(dr.prototype.clearTarget = function (t, n, e, i) {
					console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
						this.setRenderTarget(t),
						this.clear(n, e, i)
				}),
				(dr.prototype.animate = function (t) {
					console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
				}),
				(dr.prototype.getCurrentRenderTarget = function () {
					return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
				}),
				(dr.prototype.getMaxAnisotropy = function () {
					return (
						console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
						this.capabilities.getMaxAnisotropy()
					)
				}),
				(dr.prototype.getPrecision = function () {
					return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
				}),
				(dr.prototype.resetGLState = function () {
					return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
				}),
				(dr.prototype.supportsFloatTextures = function () {
					return (
						console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
						this.extensions.get("OES_texture_float")
					)
				}),
				(dr.prototype.supportsHalfFloatTextures = function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
						),
						this.extensions.get("OES_texture_half_float")
					)
				}),
				(dr.prototype.supportsStandardDerivatives = function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
						),
						this.extensions.get("OES_standard_derivatives")
					)
				}),
				(dr.prototype.supportsCompressedTextureS3TC = function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
						),
						this.extensions.get("WEBGL_compressed_texture_s3tc")
					)
				}),
				(dr.prototype.supportsCompressedTexturePVRTC = function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
						),
						this.extensions.get("WEBGL_compressed_texture_pvrtc")
					)
				}),
				(dr.prototype.supportsBlendMinMax = function () {
					return (
						console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
						this.extensions.get("EXT_blend_minmax")
					)
				}),
				(dr.prototype.supportsVertexTextures = function () {
					return (
						console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
						this.capabilities.vertexTextures
					)
				}),
				(dr.prototype.supportsInstancedArrays = function () {
					return (
						console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
						this.extensions.get("ANGLE_instanced_arrays")
					)
				}),
				(dr.prototype.enableScissorTest = function (t) {
					console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
				}),
				(dr.prototype.initMaterial = function () {
					console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
				}),
				(dr.prototype.addPrePlugin = function () {
					console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
				}),
				(dr.prototype.addPostPlugin = function () {
					console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
				}),
				(dr.prototype.updateShadowMap = function () {
					console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
				}),
				(dr.prototype.setFaceCulling = function () {
					console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
				}),
				(dr.prototype.allocTextureUnit = function () {
					console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
				}),
				(dr.prototype.setTexture = function () {
					console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
				}),
				(dr.prototype.setTexture2D = function () {
					console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
				}),
				(dr.prototype.setTextureCube = function () {
					console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
				}),
				(dr.prototype.getActiveMipMapLevel = function () {
					return (
						console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
						this.getActiveMipmapLevel()
					)
				}),
				Object.defineProperties(dr.prototype, {
					shadowMapEnabled: {
						get: function () {
							return this.shadowMap.enabled
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), (this.shadowMap.enabled = t)
						}
					},
					shadowMapType: {
						get: function () {
							return this.shadowMap.type
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), (this.shadowMap.type = t)
						}
					},
					shadowMapCullFace: {
						get: function () {
							console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
						},
						set: function () {
							console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
						}
					},
					context: {
						get: function () {
							return (
								console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
								this.getContext()
							)
						}
					},
					vr: {
						get: function () {
							return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
						}
					},
					gammaInput: {
						get: function () {
							return (
								console.warn(
									"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
								),
								!1
							)
						},
						set: function () {
							console.warn(
								"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
							)
						}
					},
					gammaOutput: {
						get: function () {
							return (
								console.warn(
									"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
								),
								!1
							)
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
								(this.outputEncoding = !0 === t ? hy : fa)
						}
					},
					toneMappingWhitePoint: {
						get: function () {
							return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
						},
						set: function () {
							console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
						}
					}
				}),
				Object.defineProperties(h7.prototype, {
					cullFace: {
						get: function () {
							console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
						},
						set: function () {
							console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
						}
					},
					renderReverseSided: {
						get: function () {
							console.warn(
								"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
							)
						},
						set: function () {
							console.warn(
								"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
							)
						}
					},
					renderSingleSided: {
						get: function () {
							console.warn(
								"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
							)
						},
						set: function () {
							console.warn(
								"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
							)
						}
					}
				}),
				Object.defineProperties(ml.prototype, {
					wrapS: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), (this.texture.wrapS = t)
						}
					},
					wrapT: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), (this.texture.wrapT = t)
						}
					},
					magFilter: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), (this.texture.magFilter = t)
						}
					},
					minFilter: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), (this.texture.minFilter = t)
						}
					},
					anisotropy: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), (this.texture.anisotropy = t)
						}
					},
					offset: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), (this.texture.offset = t)
						}
					},
					repeat: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), (this.texture.repeat = t)
						}
					},
					format: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), (this.texture.format = t)
						}
					},
					type: {
						get: function () {
							return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), (this.texture.type = t)
						}
					},
					generateMipmaps: {
						get: function () {
							return (
								console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
								this.texture.generateMipmaps
							)
						},
						set: function (t) {
							console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
								(this.texture.generateMipmaps = t)
						}
					}
				}),
				Object.defineProperties(IP.prototype, {
					load: {
						value: function (t) {
							console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.")
							const n = this
							return (
								new oK().load(t, function (i) {
									n.setBuffer(i)
								}),
								this
							)
						}
					},
					startTime: {
						set: function () {
							console.warn("THREE.Audio: .startTime is now .play( delay ).")
						}
					}
				}),
				(fK.prototype.getData = function () {
					return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
				}),
				(HM.prototype.updateCubeMap = function (t, n) {
					return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, n)
				}),
				(HM.prototype.clear = function (t, n, e, i) {
					return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, n, e, i)
				}),
				(sp.crossOrigin = void 0),
				(sp.loadTexture = function (t, n, e, i) {
					console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.")
					const r = new ES()
					r.setCrossOrigin(this.crossOrigin)
					const o = r.load(t, e, void 0, i)
					return n && (o.mapping = n), o
				}),
				(sp.loadTextureCube = function (t, n, e, i) {
					console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.")
					const r = new z7()
					r.setCrossOrigin(this.crossOrigin)
					const o = r.load(t, e, void 0, i)
					return n && (o.mapping = n), o
				}),
				(sp.loadCompressedTexture = function () {
					console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
				}),
				(sp.loadCompressedTextureCube = function () {
					console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
				})
			const REe = {
				createMultiMaterialObject: function () {
					console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
				},
				detach: function () {
					console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
				},
				attach: function () {
					console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
				}
			}
			function PEe() {
				console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
			}
			typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: KL } })),
				typeof window < "u" &&
					(window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : (window.__THREE__ = KL))
			var OEe = A(6137),
				QK = A.n(OEe)
			class zK {
				constructor(n, e, i) {
					;(this.h = n), (this.s = e), (this.l = i)
				}
				toHex() {
					return `#${QK().hsl.hex([this.h, this.s, this.l])}`
				}
				decreaseLightness(n) {
					this.l -= n
				}
				getLightness() {
					return this.l
				}
				setLightness(n) {
					this.l = n
				}
				toString() {
					return `hsl(${this.h}, ${this.s}%, ${this.l}%)`
				}
			}
			class Li {
				static {
					this.colorToVector3Map = new Map()
				}
				static {
					this.colorToVector3ArrayMap = new Map()
				}
				static {
					this.hexToNumberMap = new Map()
				}
				static getVector3(n) {
					let e = this.colorToVector3Map.get(n)
					return void 0 === e && ((e = Li.colorToVector3(n)), this.colorToVector3Map.set(n, e)), e
				}
				static getVector3Array(n) {
					let e = this.colorToVector3ArrayMap.get(n)
					return void 0 === e && ((e = Li.colorToVector3Array(n)), this.colorToVector3ArrayMap.set(n, e)), e
				}
				static getNumber(n) {
					let e = this.hexToNumberMap.get(n)
					return void 0 === e && ((e = Li.convertHexToNumber(n)), this.hexToNumberMap.set(n, e)), e
				}
				static convertHexToNumber(n) {
					return +`0x${n.slice(1)}`
				}
				static convertNumberToHex(n) {
					const e = n.toString(16)
					return `#${"0".repeat(6 - e.length)}${e}`
				}
				static convertHexToRgba(n, e = 1) {
					return `rgba(${this.encodeHex(n).join(",")},${e})`
				}
				static convertHexToColorObject(n) {
					const e = this.encodeHex(n)
					return new Lt(...e)
				}
				static convertColorToHex(n) {
					return [n.r, n.g, n.b].reduce((e, i) => e + Math.round(i).toString(16).padStart(2, "0"), "#")
				}
				static hexToHSL(n) {
					const e = QK().hex.hsl(n)
					return new zK(...e)
				}
				static colorToVector3(n) {
					const e = Li.convertHexToNumber(n)
					return new K(((e >> 16) & 255) / 255, ((e >> 8) & 255) / 255, (255 & e) / 255)
				}
				static colorToVector3Array(n) {
					const e = Li.convertHexToNumber(n)
					return [((e >> 16) & 255) / 255, ((e >> 8) & 255) / 255, (255 & e) / 255]
				}
				static vector3ToRGB(n) {
					const e = Math.floor(255 * n.x),
						i = Math.floor(255 * n.y),
						r = Math.floor(255 * n.z)
					return new Lt(e, i, r)
				}
				static gradient(n, e, i) {
					const r = this.convertHexToColorObject(n),
						s = this.convertHexToColorObject(e).sub(r),
						a = []
					for (let c = 0; c <= i; c++) {
						const l = s.clone().multiplyScalar((1 / i) * c),
							d = r.clone().add(l)
						a[c] = this.convertColorToHex(d)
					}
					return a
				}
				static getImageDataUri(n) {
					const e = this.encodeHex(n),
						i = this.encodeRGB(e[0], e[1], e[2])
					return this.generatePixel(i)
				}
				static encodeHex(n) {
					let e = n.slice(1)
					return (
						3 === e.length && (e = `${e[0]}${e[0]}${e[1]}${e[1]}${e[2]}${e[2]}`),
						[
							Number.parseInt(`${e[0]}${e[1]}`, 16),
							Number.parseInt(`${e[2]}${e[3]}`, 16),
							Number.parseInt(`${e[4]}${e[5]}`, 16)
						]
					)
				}
				static encodeRGB(n, e, i) {
					return this.encodeTriplet(0, n, e) + this.encodeTriplet(i, 255, 255)
				}
				static encodeTriplet(n, e, i) {
					const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
						s = ((3 & n) << 4) | (e >> 4),
						a = ((15 & e) << 2) | (i >> 6),
						c = 63 & i
					return r.charAt(n >> 2) + r.charAt(s) + r.charAt(a) + r.charAt(c)
				}
				static generatePixel(n) {
					return `data:image/gif;base64,R0lGODlhAQABAPAA${n}/yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==`
				}
			}
			class QS {
				static getMapResolutionScaling(n) {
					const { width: e } = document.getElementById("codeMapScene"),
						i = QS.getScalingThreshold(e)
					return n > i ? i / n : 1
				}
				static getScalingThreshold(n) {
					return Math.min(4 * n, 10240)
				}
				static isLabelNode(n) {
					return !n.isLeaf && n.mapNodeDepth < 3
				}
			}
			class bb {
				constructor(n, e, i, r) {
					;(this.floorLabelPlanes = []),
						(this.folderGeometryHeight = 2.01),
						(this.lastScaling = new K(1, 1, 1)),
						(this.floorLabelPlaneLevel = new Map()),
						(this.floorLabelsPerLevel = new Map()),
						this.collectLabelsPerLevel(n),
						(this.rootNode = e),
						(this.mapSize = i),
						(this.scaling = r)
				}
				collectLabelsPerLevel(n) {
					for (const e of n)
						QS.isLabelNode(e) &&
							(this.floorLabelsPerLevel.has(e.mapNodeDepth) || this.floorLabelsPerLevel.set(e.mapNodeDepth, []),
							this.floorLabelsPerLevel.get(e.mapNodeDepth).push(e))
				}
				draw() {
					const { width: n, length: e } = this.rootNode,
						i = QS.getMapResolutionScaling(n),
						r = n * i,
						o = e * i
					for (const [s, a] of this.floorLabelsPerLevel) {
						const { textCanvas: c, context: l } = bb.createLabelPlaneCanvas(r, o)
						this.writeLabelsOnCanvas(l, a, i), this.drawLevelPlaneGeometry(c, r, o, s, i)
					}
					return this.floorLabelPlanes
				}
				translatePlaneCanvases(n) {
					for (const e of this.floorLabelPlanes) {
						const i = this.floorLabelPlaneLevel.get(e) + 1
						e.geometry.translate(0, 0, this.folderGeometryHeight * (i * this.lastScaling.y - i * n.y))
					}
					this.lastScaling = n
				}
				static createLabelPlaneCanvas(n, e) {
					const i = document.createElement("canvas")
					let r = n,
						o = e
					n > e && ((r = e), (o = n)), (i.width = r), (i.height = o)
					const s = i.getContext("2d")
					return (s.fillStyle = "white"), (s.textAlign = "center"), (s.textBaseline = "middle"), { textCanvas: i, context: s }
				}
				writeLabelsOnCanvas(n, e, i) {
					const { width: r, length: o } = this.rootNode
					for (const s of e) {
						let a = 0 === s.depth ? Math.max(Math.floor(0.03 * r), 120) : Math.max(Math.floor(0.023 * r), 95)
						;(a *= i), (n.font = `${a}px Arial`)
						const c = bb.getLabelAndSetContextFont(s, n, i, a)
						n.fillText(c.labelText, (o - s.y0 - s.length / 2) * i, (s.x0 + s.width) * i - c.fontSize / 2)
					}
				}
				drawLevelPlaneGeometry(n, e, i, r, o) {
					const s = new JR(n)
					;(s.wrapS = ep), (s.wrapT = ep), (s.repeat.x = -1), (s.needsUpdate = !0), (s.rotation = (90 * Math.PI) / 180)
					const a = new sf(e, i),
						l = new Mi(a, new Cd({ side: Lo, map: s, transparent: !0 }))
					l.rotateX((90 * Math.PI) / 180),
						a.translate(e / 2, i / 2, -this.folderGeometryHeight * this.scaling.y * (r + 1) - 2),
						l.scale.set(this.scaling.x / o, this.scaling.z / o, 1),
						l.position.set(-this.mapSize * this.scaling.x, 0, -this.mapSize * this.scaling.z),
						this.floorLabelPlanes.push(l),
						this.floorLabelPlaneLevel.set(l, r)
				}
				static getLabelAndSetContextFont(n, e, i, r) {
					const o = n.name,
						s = n.length * i
					e.font = `${r}px Arial`
					const a = e.measureText(o),
						c = bb.getFontScaleFactor(s, a.width)
					return c <= 0.5
						? ((r *= 0.5),
						  (r = Math.floor(Math.min(r, n.width * i))),
						  (e.font = `${r}px Arial`),
						  { labelText: bb.getFittingLabelText(e, s, o), fontSize: r })
						: ((r = Math.floor(Math.min(r * c, n.width * i))), (e.font = `${r}px Arial`), { labelText: o, fontSize: r })
				}
				static getFontScaleFactor(n, e) {
					return e < n ? 1 : n / e
				}
				static getFittingLabelText(n, e, i) {
					const { width: r } = n.measureText(i)
					let o = Math.floor((i.length * e) / r),
						s = `${i.slice(0, o)}\u2026`
					for (; n.measureText(s).width >= e && o > 1; ) (o -= 1), (s = `${i.slice(0, o)}\u2026`)
					return s
				}
			}
			const WP = Nt("SET_SELECTED_BUILDING_ID", { _as: "props", _p: void 0 }),
				NEe = /_\d{4}(?:-\d{1,2}){2}_\d{1,2}-\d{1,2}\./
			let pf = (() => {
				class t {
					static {
						this.JSON_EXTENSION = ".json"
					}
					static getNewFileName(e, i) {
						return `${this.getFileNameWithoutTimestamp(e, i)}_${this.getNewTimestamp()}`
					}
					static getNewTimestamp() {
						return t.getFormattedTimestamp(new Date())
					}
					static getFormattedTimestamp(e) {
						return e.toISOString().slice(0, 16).replace("T", "_").replace(":", "-")
					}
					static getFileNameWithoutTimestamp(e, i) {
						if (!i) {
							const r = NEe.exec(e)
							if (r) return e.slice(0, r.index)
							if (e.endsWith(wg.CC_FILE_EXTENSION)) return e.slice(0, -wg.CC_FILE_EXTENSION.length)
							if (e.endsWith(t.JSON_EXTENSION)) return e.slice(0, -t.JSON_EXTENSION.length)
						}
						return e
					}
					static withoutCCExtension(e) {
						return e.replace(/(\.cc)?(\.json)?(\.gz)?$/, "")
					}
				}
				return t
			})()
			function GK(t, n) {
				return (function UEe(t) {
					return t.startsWith(`${bd.rootPath}/`)
				})(n)
					? cw(t, n)
					: n
			}
			function cw(t, n) {
				const e = bd.rootPath.length + 1,
					i = n.length <= e ? "" : `/${n.slice(e)}`
				return `${bd.rootPath}/${t}${i}`
			}
			function jP(t, n) {
				do {
					n = n.slice(0, n.lastIndexOf("/"))
					const e = t.get(n)
					if (e) return e
				} while (n !== bd.rootPath && n.length > 0)
			}
			let $K = (() => {
				class t {
					static {
						this.projectNameArray = []
					}
					static {
						this.fileNameArray = []
					}
					static {
						this.fileChecksumArray = []
					}
					static {
						this.fileSizesSum = 0
					}
					static calculateAggregationFile(e) {
						const i = dd(e.map(r => r.file))
						if (1 === i.length) return i[0]
						this.resetVariables()
						for (const r of i)
							this.projectNameArray.push(r.fileMeta.projectName.replace(" ", "_")),
								this.fileNameArray.push(pf.withoutCCExtension(r.fileMeta.fileName).replace(" ", "_")),
								this.fileChecksumArray.push(r.fileMeta.fileChecksum),
								(this.fileSizesSum += r.fileMeta.exportedFileSize)
						return this.getNewAggregatedMap(i)
					}
					static getNewAggregatedMap(e) {
						const i = {
							fileMeta: {
								projectName: `project_aggregation_of_${this.projectNameArray.join("_and_")}`,
								fileName: `file_aggregation_of_${this.fileNameArray.join("_and_")}`,
								fileChecksum: this.fileChecksumArray.join(";"),
								apiVersion: Iv.sj.t,
								exportedFileSize: this.fileSizesSum
							},
							map: { name: bd.rootName, type: Da.FOLDER, children: [], attributes: {}, path: bd.rootPath },
							settings: {
								fileSettings: {
									edges: [],
									blacklist: [],
									attributeTypes: { nodes: {}, edges: {} },
									attributeDescriptors: {},
									markedPackages: []
								}
							}
						}
						for (const r of e) i.map.children.push(this.extractNodeFromMap(r))
						return this.aggregateRootAttributes(i), i
					}
					static aggregateRootAttributes(e) {
						for (const { attributes: i } of e.map.children)
							for (const r of Object.keys(i))
								void 0 === e.map.attributes[r] && (e.map.attributes[r] = 0), (e.map.attributes[r] += i[r])
					}
					static extractNodeFromMap(e) {
						const i = { name: e.fileMeta.fileName, children: e.map.children, type: e.map.type }
						e.map.path && (i.path = cw(e.fileMeta.fileName, e.map.path))
						for (const r of Object.keys(e.map)) "name" !== r && "path" !== r && "children" !== r && (i[r] = e.map[r])
						return this.updatePathOfAllChildren(e.fileMeta.fileName, i.children), i
					}
					static updatePathOfAllChildren(e, i) {
						for (const r of i) r.path && (r.path = cw(e, r.path)), r.children && this.updatePathOfAllChildren(e, r.children)
					}
					static resetVariables() {
						;(this.projectNameArray = []), (this.fileNameArray = []), (this.fileChecksumArray = []), (this.fileSizesSum = 0)
					}
				}
				return t
			})()
			const HEe = Mt(Fs, t => t.edgeMetricData.map(n => n.name))
			class VEe {
				static createCodeMapFromHashMap(n) {
					let e
					for (const [i, r] of n) i === bd.rootPath ? (e = r) : jP(n, i).children.push(r)
					return e
				}
				static getDeltaFile(n, e) {
					const i = this.getDeltaNodesByPath(n.map, e.map),
						r = this.createCodeMapFromHashMap(i),
						o = this.getFileMetaData(n, e)
					return this.getNewCCFileWithDeltas(r, o)
				}
				static getDeltaNodesByPath(n, e) {
					const i = new Map(),
						r = this.getReferenceNodesByPath(n)
					return this.addExistingAndNewNodesToDeltaMap(r, e, i), this.addDeletedNodesToDeltaMap(r, i), i
				}
				static getReferenceNodesByPath(n) {
					const e = new Map()
					for (const { data: i } of $r(n)) e.set(i.path, i)
					return e
				}
				static addExistingAndNewNodesToDeltaMap(n, e, i) {
					for (const { data: r } of $r(e)) {
						const o = n.get(r.path)
						if (o) {
							;(o.children || r.children) && (o.children = [])
							const { deltaList: a, differenceExists: c } = this.compareAttributeValues(o.attributes, r.attributes)
							o.deltas = a
							const l = c ? 1 : 0
							;(o.attributes = r.attributes), (o.fileCount = { added: 0, removed: 0, changed: l })
						} else
							r.children && (r.children = []),
								(r.deltas = { ...r.attributes }),
								(r.fileCount = { added: r.type === Da.FILE ? 1 : 0, removed: 0, changed: 0 })
						const s = o ?? r
						i.set(s.path, s), n.delete(s.path)
					}
				}
				static addDeletedNodesToDeltaMap(n, e) {
					for (const i of n.values()) {
						i.children && (i.children = []),
							(i.deltas = {}),
							(i.fileCount = { added: 0, removed: i.type === Da.FILE ? 1 : 0, changed: 0 })
						for (const [r, o] of Object.entries(i.attributes)) (i.deltas[r] = -o), (i.attributes[r] = 0)
						e.set(i.path, i)
					}
				}
				static compareAttributeValues(n, e) {
					const i = {}
					let r = !1
					const o = new Set(Object.keys(n))
					for (const s of Object.keys(e)) o.add(s)
					for (const s of o) {
						const a = n[s] ?? 0,
							c = e[s] ?? 0
						a !== c && (r = !0), (i[s] = c - a)
					}
					return { deltaList: i, differenceExists: r }
				}
				static getFileMetaData(n, e) {
					return {
						fileName: `delta_between_${pf.withoutCCExtension(n.fileMeta.fileName)}_and_${pf.withoutCCExtension(
							e.fileMeta.fileName
						)}`,
						fileChecksum: `${n.fileMeta.fileChecksum};${e.fileMeta.fileChecksum}`,
						apiVersion: Iv.sj.t,
						projectName: `delta_between_${n.fileMeta.projectName}_and_${e.fileMeta.projectName}`,
						exportedFileSize: n.fileMeta.exportedFileSize + e.fileMeta.exportedFileSize
					}
				}
				static getNewCCFileWithDeltas(n, e) {
					return {
						map: n,
						fileMeta: e,
						settings: {
							fileSettings: {
								edges: [],
								blacklist: [],
								attributeTypes: { nodes: {}, edges: {} },
								attributeDescriptors: {},
								markedPackages: []
							}
						}
					}
				}
			}
			const QEe = t => {
					if (2 === t.length) {
						let [n, e] = t
						if (n.selectedAs !== Fi.Reference) {
							const i = e
							;(e = n), (n = i)
						}
						return VEe.getDeltaFile(n.file, e.file)
					}
					return t[0].file
				},
				zEe = (t, n, e) => {
					const i = new Map()
					for (const r of e) {
						const o = t.get(r)
						o && i.set(r, o.get(n.data.path))
					}
					return i
				},
				KP = Mt(fv, t => t.attributeTypes),
				WK = Object.freeze({ unifiedMapNode: void 0, unifiedFileMeta: void 0 }),
				Vc = Mt(Fs, ld, KP, cd, HEe, (t, n, e, i, r) => {
					if (!iG(n) || !t.nodeMetricData) return WK
					const o = $Ee(dd(n))
					return o?.map
						? (dL.decorateMap(o.map, t, i),
						  ((t, n, e) => {
								if (0 !== e.length)
									for (const i of $r(n))
										if (uo(i)) {
											const r = zEe(t, i, e)
											for (const [o, s] of r) i.data.edgeAttributes[o] = s
										}
						  })(t.nodeEdgeMetricsMap, o.map, r),
						  dL.decorateParentNodesWithAggregatedAttributes(o.map, ad(n), e),
						  { unifiedMapNode: o.map, unifiedFileMeta: o.fileMeta })
						: WK
				}),
				$Ee = t => {
					if (rG(t)) return $K.calculateAggregationFile(t)
					if (ad(t)) {
						const [n, e] = t
						return e && n.file.map.name !== e.file.map.name ? $K.calculateAggregationFile(t) : QEe(t)
					}
				},
				_b = Mt(Vc, t => {
					if (!t.unifiedMapNode) return new Map()
					const n = new Map([[t.unifiedMapNode.id, t.unifiedMapNode]])
					for (const { data: e } of $r(t.unifiedMapNode)) n.set(e.id, e)
					return n
				}),
				vb = Mt(Tr, t => t.mapColors),
				Si = t => (n, e) => void 0 === e.value ? t : e.value,
				zS = t => (n, e) => void 0 === e.value ? t : { ...n, ...e.value },
				Vu = {
					positive: "#69AE40",
					neutral: "#ddcc00",
					negative: "#820E0E",
					selected: "#EB8319",
					positiveDelta: "#64d051",
					negativeDelta: "#ff0E0E",
					base: "#666666",
					flat: "#AAAAAA",
					markingColors: ["#FF1D8E", "#1d8eff", "#1DFFFF", "#8eff1d", "#8e1dff"],
					incomingEdge: "#00ffff",
					outgoingEdge: "#ff00ff",
					labelColorAndAlpha: { rgb: "#e0e0e0", alpha: 0.7 }
				},
				WEe = ni(
					Vu,
					Gt(Au, zS(Vu)),
					Gt(iE, t => ({ ...t, positive: t.negative, negative: t.positive })),
					Gt(rE, t => ({ ...t, positiveDelta: t.negativeDelta, negativeDelta: t.positiveDelta }))
				),
				cc = t => t.dynamicSettings,
				yb = Mt(cc, t => t.searchPattern),
				jK = Mt(Vc, yb, (t, n) =>
					(function jEe(t, n) {
						if (0 === (n = n.trimStart()).length || !t) return []
						const e = cG(n),
							i = []
						for (const { data: r } of $r(t)) e.ignoredNodePaths.ignores(hg(r.path)) === e.condition && i.push(r)
						return i
					})(t.unifiedMapNode, n)
				),
				XP = Mt(jK, t => new Set(t.map(n => n.path))),
				YP = {
					getColorByTrueGradient(t, n, e, i) {
						const r = (n.from + n.to) / 2,
							o = Li.convertHexToColorObject(t.neutral)
						if (i <= r) {
							const c = i / r,
								l = Li.convertHexToColorObject(t.positive)
							return Li.convertColorToHex(new Lt().lerpColors(l, o, c))
						}
						const s = (i - r) / (e.maxValue - r),
							a = Li.convertHexToColorObject(t.negative)
						return Li.convertColorToHex(new Lt().lerpColors(o, a, s))
					},
					getColorByFocusedGradient(t, n, e, i) {
						const r = (n.from + n.to) / 2,
							o = Li.convertHexToColorObject(t.neutral)
						if (i < n.from || n.from === e.maxValue) return t.positive
						if (i >= n.to && n.to !== e.maxValue) return t.negative
						if (i === r) return t.neutral
						if (i < r) {
							const c = i / (r + n.from),
								l = Li.convertHexToColorObject(t.positive)
							return Li.convertColorToHex(new Lt().lerpColors(l, o, c))
						}
						const s = (i - r) / (n.to - r),
							a = Li.convertHexToColorObject(t.negative)
						return Li.convertColorToHex(new Lt().lerpColors(o, a, s))
					},
					getColorByWeightedGradient(t, n, e, i) {
						const r = Math.max(n.from - (n.to - n.from) / 2, n.from / 2),
							o = 2 * n.from - r,
							s = n.to - (n.to - n.from) / 2,
							a = n.to
						if (r === o && o === s && s === a) return i < r || n.to === e.maxValue ? t.positive : t.negative
						if (i <= r) return t.positive
						if (i < o) {
							const c = (i - r) / (o - r),
								l = Li.convertHexToColorObject(t.positive),
								d = Li.convertHexToColorObject(t.neutral)
							return Li.convertColorToHex(new Lt().lerpColors(l, d, c))
						}
						if (i <= s) return t.neutral
						if (i < a || n.to === e.maxValue) {
							const c = (i - s) / (a - s),
								l = Li.convertHexToColorObject(t.neutral),
								d = Li.convertHexToColorObject(t.negative)
							return Li.convertColorToHex(new Lt().lerpColors(l, d, c))
						}
						return t.negative
					}
				},
				Af = Mt(cc, t => t.colorMetric),
				gf = Mt(Fs, Af, (t, n) => {
					const e = t.nodeMetricData.find(i => i.name === n)
					return { values: e?.values ?? [], minValue: e?.minValue ?? 0, maxValue: e?.maxValue ?? 0 }
				}),
				Oo = 250
			function qK(t, n, e, i) {
				const r = wE(t.files)
				if (i) return 2
				let o = n.attributes[t.dynamicSettings.heightMetric] || 0
				o *= r
				const s = t.dynamicSettings.heightMetric
				return 1 === t.fileSettings.attributeDescriptors[s]?.direction
					? t.appSettings.invertHeight
						? o
						: e - o
					: t.appSettings.invertHeight
					? e - o
					: o
			}
			function ZK(t, n, e, i) {
				const r = e.deltas?.[i.dynamicSettings.heightMetric] ? 0 : 2
				return Math.max(Math.abs(n * t), r)
			}
			function ZP(t, n, e, i) {
				return (
					!(t.isExcluded || (n && e.appSettings.hideFlatBuildings && i)) &&
					(!(e.dynamicSettings.focusedNodePath.length > 0) || t.path.startsWith(e.dynamicSettings.focusedNodePath[0]))
				)
			}
			function $S(t, n, e, i, r) {
				return t > e ? new K(i.x - r + t / 4, i.y + n, i.z - r + e / 2) : new K(i.x - r + t / 2, i.y + n, i.z - r + e / 4)
			}
			function JK(t, n, e, i, r) {
				return t > e ? new K(i.x - r + 0.75 * t, i.y + n, i.z - r + e / 2) : new K(i.x - r + t / 2, i.y + n, i.z - r + 0.75 * e)
			}
			function WS(t, n) {
				if (t.isFlattened) return !0
				const e = XP(n)
				return e && n.dynamicSettings.searchPattern?.length > 0
					? 0 === e.size ||
							(function ZEe(t, n) {
								return !XP(n).has(t.path)
							})(t, n)
					: !(!n.appSettings.showOnlyBuildingsWithEdges || !n.fileSettings.edges.some(i => i.visible)) &&
							(function qEe(t, n) {
								return (
									void 0 === t.edgeAttributes[n.dynamicSettings.edgeMetric] ||
									!n.fileSettings.edges.some(e => t.path === e.fromNodeName || t.path === e.toNodeName)
								)
							})(t, n)
			}
			function JP(t, { appSettings: n, dynamicSettings: e }, i, r, o) {
				const { mapColors: s } = n
				if (r) return s.base
				const a = t.attributes[e.colorMetric]
				if (void 0 === a) return s.base
				if (o) return s.flat
				const { colorRange: c, colorMode: l } = e
				return "unary" === e.colorMetric
					? s.positive
					: l === Rv.absolute
					? a < c.from || c.from === i.maxValue
						? s.positive
						: a < c.to || c.to === i.maxValue
						? s.neutral
						: s.negative
					: l === Rv.trueGradient
					? YP.getColorByTrueGradient(s, c, i, a)
					: l === Rv.focusedGradient
					? YP.getColorByFocusedGradient(s, c, i, a)
					: YP.getColorByWeightedGradient(s, c, i, a)
			}
			const $s = {
				countNodes: function XK(t) {
					let n = 1
					if (t.children) for (const e of t.children) n += XK(e)
					return n
				},
				buildingArrayToMap: function KEe(t) {
					const n = new Map()
					for (const e of t) n.set(e.id, e)
					return n
				},
				buildRootFolderForFixedFolders: function XEe(t, n, e, i) {
					const r = WS(t, e)
					return {
						name: t.name,
						id: 0,
						width: 100,
						height: 2,
						length: 100,
						depth: 0,
						x0: 0,
						z0: 0,
						y0: 0,
						isLeaf: !1,
						attributes: t.attributes,
						edgeAttributes: t.edgeAttributes,
						deltas: t.deltas,
						heightDelta: (t.deltas?.[e.dynamicSettings.heightMetric] ?? 0) * n,
						visible: ZP(t, !1, e, r),
						path: t.path,
						link: t.link,
						markingColor: vE(t, e.fileSettings.markedPackages),
						flat: !1,
						color: JP(t, e, gf(e), i, r),
						incomingEdgePoint: $S(100, 2, 100, new K(0, 0, 0), Oo),
						outgoingEdgePoint: JK(100, 2, 100, new K(0, 0, 0), Oo)
					}
				},
				calculateSize: function YK(t, n) {
					let e = t.attributes[n] || 0
					if (0 === e && t.children && t.children.length > 0) for (const i of t.children) e += YK(i, n)
					return e
				},
				buildNodeFrom: function YEe(t, n, e, i, r) {
					const o = wE(i.files),
						{ x0: s, x1: a, y0: c, y1: l, data: d } = t,
						u = uo(t),
						h = WS(d, i),
						f = qK(i, d, e, h),
						_ = d.path.split("/").length - 2,
						y = u ? ZK(f, n, d, i) * o : 2,
						C = a - s,
						x = l - c,
						w = 2 * _,
						S = (d.deltas?.[i.dynamicSettings.heightMetric] ?? 0) * n * o,
						M = y + (S < 0 ? Math.abs(S) : 0)
					return {
						name: d.name,
						id: d.id,
						width: C,
						height: y,
						length: x,
						depth: _,
						mapNodeDepth: t.depth,
						x0: s,
						z0: w,
						y0: c,
						isLeaf: u,
						attributes: d.attributes,
						edgeAttributes: d.edgeAttributes,
						deltas: d.deltas,
						heightDelta: S,
						visible: ZP(d, u, i, h),
						path: d.path,
						link: d.link,
						markingColor: vE(d, i.fileSettings.markedPackages),
						flat: h,
						color: JP(d, i, gf(i), r, h),
						incomingEdgePoint: $S(C, M, x, new K(s, w, c), Oo),
						outgoingEdgePoint: JK(C, M, x, new K(s, w, c), Oo)
					}
				},
				isNodeFlat: WS,
				resolveHeightValue: ZK,
				getHeightValue: qK,
				FOLDER_HEIGHT: 2,
				MIN_BUILDING_HEIGHT: 2,
				HEIGHT_VALUE_WHEN_METRIC_NOT_FOUND: 0
			}
			class eO {
				constructor() {
					this.listeners = {}
				}
				on(n, e) {
					;(this.listeners[n] ??= []), this.listeners[n].push(e)
				}
				emit(n, e) {
					if (!this.listeners[n]?.length) return !1
					for (const i of this.listeners[n]) i(e)
					return !0
				}
			}
			let lw = (() => {
				class t {
					constructor() {
						this.idToBuilding = new Map()
					}
					setIdToBuilding(e) {
						this.idToBuilding = new Map()
						for (const i of e) this.idToBuilding.set(i.node.id, i)
					}
					get(e) {
						return this.idToBuilding.get(e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			function Cl() {
				;(this.enabled = !0), (this.needsSwap = !0), (this.clear = !1), (this.renderToScreen = !1)
			}
			var t, n, e
			Object.assign(Cl.prototype, {
				setSize: function () {},
				render: function () {
					console.error("THREE.Pass: .render() must be implemented in derived pass.")
				}
			}),
				(Cl.FullScreenQuad =
					((t = new bp(-1, 1, 1, -1, 0, 1)),
					(n = new sf(2, 2)),
					(e = function (i) {
						this._mesh = new Mi(n, i)
					}),
					Object.defineProperty(e.prototype, "material", {
						get: function () {
							return this._mesh.material
						},
						set: function (i) {
							this._mesh.material = i
						}
					}),
					Object.assign(e.prototype, {
						dispose: function () {
							this._mesh.geometry.dispose()
						},
						render: function (i) {
							i.render(this._mesh, t)
						}
					}),
					e))
			var tO = function (t, n, e, i, r) {
				Cl.call(this),
					(this.scene = t),
					(this.camera = n),
					(this.overrideMaterial = e),
					(this.clearColor = i),
					(this.clearAlpha = void 0 !== r ? r : 0),
					(this.clear = !0),
					(this.clearDepth = !1),
					(this.needsSwap = !1),
					(this._oldClearColor = new Lt())
			}
			tO.prototype = Object.assign(Object.create(Cl.prototype), {
				constructor: tO,
				render: function (t, n, e) {
					var r,
						o,
						i = t.autoClear
					;(t.autoClear = !1),
						void 0 !== this.overrideMaterial &&
							((o = this.scene.overrideMaterial), (this.scene.overrideMaterial = this.overrideMaterial)),
						this.clearColor &&
							(t.getClearColor(this._oldClearColor),
							(r = t.getClearAlpha()),
							t.setClearColor(this.clearColor, this.clearAlpha)),
						this.clearDepth && t.clearDepth(),
						t.setRenderTarget(this.renderToScreen ? null : e),
						this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
						t.render(this.scene, this.camera),
						this.clearColor && t.setClearColor(this._oldClearColor, r),
						void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = o),
						(t.autoClear = i)
				}
			})
			var JEe_isWebGL2Available = function () {
					try {
						var t = document.createElement("canvas")
						return !(!window.WebGL2RenderingContext || !t.getContext("webgl2"))
					} catch {
						return !1
					}
				},
				dw = function (t, n) {
					Cl.call(this),
						(this.textureID = void 0 !== n ? n : "tDiffuse"),
						t instanceof Ds
							? ((this.uniforms = t.uniforms), (this.material = t))
							: t &&
							  ((this.uniforms = UM.clone(t.uniforms)),
							  (this.material = new Ds({
									defines: Object.assign({}, t.defines),
									uniforms: this.uniforms,
									vertexShader: t.vertexShader,
									fragmentShader: t.fragmentShader
							  }))),
						(this.fsQuad = new Cl.FullScreenQuad(this.material))
				}
			dw.prototype = Object.assign(Object.create(Cl.prototype), {
				constructor: dw,
				render: function (t, n, e) {
					this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = e.texture),
						(this.fsQuad.material = this.material),
						this.renderToScreen
							? (t.setRenderTarget(null), this.fsQuad.render(t))
							: (t.setRenderTarget(n),
							  this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
							  this.fsQuad.render(t))
				}
			})
			var uw = function (t, n) {
				Cl.call(this), (this.scene = t), (this.camera = n), (this.clear = !0), (this.needsSwap = !1), (this.inverse = !1)
			}
			uw.prototype = Object.assign(Object.create(Cl.prototype), {
				constructor: uw,
				render: function (t, n, e) {
					var o,
						s,
						i = t.getContext(),
						r = t.state
					r.buffers.color.setMask(!1),
						r.buffers.depth.setMask(!1),
						r.buffers.color.setLocked(!0),
						r.buffers.depth.setLocked(!0),
						this.inverse ? ((o = 0), (s = 1)) : ((o = 1), (s = 0)),
						r.buffers.stencil.setTest(!0),
						r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
						r.buffers.stencil.setFunc(i.ALWAYS, o, 4294967295),
						r.buffers.stencil.setClear(s),
						r.buffers.stencil.setLocked(!0),
						t.setRenderTarget(e),
						this.clear && t.clear(),
						t.render(this.scene, this.camera),
						t.setRenderTarget(n),
						this.clear && t.clear(),
						t.render(this.scene, this.camera),
						r.buffers.color.setLocked(!1),
						r.buffers.depth.setLocked(!1),
						r.buffers.stencil.setLocked(!1),
						r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
						r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
						r.buffers.stencil.setLocked(!0)
				}
			})
			var jS = function () {
				Cl.call(this), (this.needsSwap = !1)
			}
			;(jS.prototype = Object.create(Cl.prototype)),
				Object.assign(jS.prototype, {
					render: function (t) {
						t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
					}
				})
			var eX = {
					uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
					vertexShader: [
						"varying vec2 vUv;",
						"void main() {",
						"\tvUv = uv;",
						"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
						"}"
					].join("\n"),
					fragmentShader: [
						"uniform float opacity;",
						"uniform sampler2D tDiffuse;",
						"varying vec2 vUv;",
						"void main() {",
						"\tvec4 texel = texture2D( tDiffuse, vUv );",
						"\tgl_FragColor = opacity * texel;",
						"}"
					].join("\n")
				},
				tX = function (t, n) {
					if (((this.renderer = t), void 0 === n)) {
						var e = { minFilter: xo, magFilter: xo, format: ha },
							i = t.getSize(new lt())
						;(this._pixelRatio = t.getPixelRatio()),
							(this._width = i.width),
							(this._height = i.height),
							((n = new ml(this._width * this._pixelRatio, this._height * this._pixelRatio, e)).texture.name =
								"EffectComposer.rt1")
					} else (this._pixelRatio = 1), (this._width = n.width), (this._height = n.height)
					;(this.renderTarget1 = n),
						(this.renderTarget2 = n.clone()),
						(this.renderTarget2.texture.name = "EffectComposer.rt2"),
						(this.writeBuffer = this.renderTarget1),
						(this.readBuffer = this.renderTarget2),
						(this.renderToScreen = !0),
						(this.passes = []),
						void 0 === eX && console.error("THREE.EffectComposer relies on CopyShader"),
						void 0 === dw && console.error("THREE.EffectComposer relies on ShaderPass"),
						(this.copyPass = new dw(eX)),
						(this.clock = new BP())
				}
			Object.assign(tX.prototype, {
				swapBuffers: function () {
					var t = this.readBuffer
					;(this.readBuffer = this.writeBuffer), (this.writeBuffer = t)
				},
				addPass: function (t) {
					this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
				},
				insertPass: function (t, n) {
					this.passes.splice(n, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
				},
				removePass: function (t) {
					const n = this.passes.indexOf(t)
					;-1 !== n && this.passes.splice(n, 1)
				},
				isLastEnabledPass: function (t) {
					for (var n = t + 1; n < this.passes.length; n++) if (this.passes[n].enabled) return !1
					return !0
				},
				render: function (t) {
					void 0 === t && (t = this.clock.getDelta())
					var i,
						r,
						n = this.renderer.getRenderTarget(),
						e = !1,
						o = this.passes.length
					for (r = 0; r < o; r++)
						if (!1 !== (i = this.passes[r]).enabled) {
							if (
								((i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r)),
								i.render(this.renderer, this.writeBuffer, this.readBuffer, t, e),
								i.needsSwap)
							) {
								if (e) {
									var s = this.renderer.getContext(),
										a = this.renderer.state.buffers.stencil
									a.setFunc(s.NOTEQUAL, 1, 4294967295),
										this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t),
										a.setFunc(s.EQUAL, 1, 4294967295)
								}
								this.swapBuffers()
							}
							void 0 !== uw && (i instanceof uw ? (e = !0) : i instanceof jS && (e = !1))
						}
					this.renderer.setRenderTarget(n)
				},
				reset: function (t) {
					if (void 0 === t) {
						var n = this.renderer.getSize(new lt())
						;(this._pixelRatio = this.renderer.getPixelRatio()),
							(this._width = n.width),
							(this._height = n.height),
							(t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
					}
					this.renderTarget1.dispose(),
						this.renderTarget2.dispose(),
						(this.renderTarget1 = t),
						(this.renderTarget2 = t.clone()),
						(this.writeBuffer = this.renderTarget1),
						(this.readBuffer = this.renderTarget2)
				},
				setSize: function (t, n) {
					;(this._width = t), (this._height = n)
					var e = this._width * this._pixelRatio,
						i = this._height * this._pixelRatio
					this.renderTarget1.setSize(e, i), this.renderTarget2.setSize(e, i)
					for (var r = 0; r < this.passes.length; r++) this.passes[r].setSize(e, i)
				},
				setPixelRatio: function (t) {
					;(this._pixelRatio = t), this.setSize(this._width, this._height)
				}
			})
			var nX = function () {
				;(this.enabled = !0), (this.needsSwap = !0), (this.clear = !1), (this.renderToScreen = !1)
			}
			Object.assign(nX.prototype, {
				setSize: function () {},
				render: function () {
					console.error("THREE.Pass: .render() must be implemented in derived pass.")
				}
			}),
				(nX.FullScreenQuad = (function () {
					var t = new bp(-1, 1, 1, -1, 0, 1),
						n = new sf(2, 2),
						e = function (i) {
							this._mesh = new Mi(n, i)
						}
					return (
						Object.defineProperty(e.prototype, "material", {
							get: function () {
								return this._mesh.material
							},
							set: function (i) {
								this._mesh.material = i
							}
						}),
						Object.assign(e.prototype, {
							dispose: function () {
								this._mesh.geometry.dispose()
							},
							render: function (i) {
								i.render(this._mesh, t)
							}
						}),
						e
					)
				})())
			class iX extends tX {
				constructor(n, e) {
					super(n, e), (this.info = []), (this.memInfo = [])
				}
				getInfo() {
					const n = { calls: 0, lines: 0, triangles: 0, points: 0, frame: 0 }
					for (const e of this.info)
						(n.calls += e.calls), (n.lines += e.lines), (n.triangles += e.triangles), (n.points += e.points)
					return n
				}
				getMemoryInfo() {
					const n = { geometries: 0, textures: 0 }
					for (const e of this.memInfo) (n.geometries += e.geometries), (n.textures += e.textures)
					return n
				}
				render(n) {
					void 0 === n && (n = this.clock.getDelta())
					const e = this.renderer.getRenderTarget()
					let r,
						i = !1
					for (let o = 0; o < this.passes.length; o++)
						if (((r = this.passes[o]), !1 !== r.enabled)) {
							if (
								((r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(o)),
								(this.info[o] = { ...this.renderer.info.render }),
								(this.memInfo[o] = { ...this.renderer.info.memory }),
								r.render(this.renderer, this.writeBuffer, this.readBuffer, n, i),
								r.needsSwap)
							) {
								if (i) {
									const s = this.renderer.getContext(),
										a = this.renderer.state.buffers.stencil
									a.setFunc(s.NOTEQUAL, 1, 4294967295),
										this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, n, !1),
										a.setFunc(s.EQUAL, 1, 4294967295)
								}
								this.swapBuffers()
							}
							r instanceof uw ? (i = !0) : r instanceof jS && (i = !1)
						}
					this.renderer.setRenderTarget(e)
				}
				dispose() {
					for (let n = 0; n < this.passes.length; n++)
						this.passes[n].fsQuad?.material.dispose(), this.passes[n].fsQuad?._mesh?.geometry.dispose()
				}
			}
			const rX = Mt(Tr, t => t.isWhiteBackground)
			class eMe {
				constructor() {
					;(this.vertexShader = A(8489)),
						(this.fragmentShader = A(463)),
						(this.uniforms = { tDiffuse: { value: null }, resolution: { value: new lt(1 / 1024, 1 / 512) } })
				}
			}
			class Ri {
				static {
					this.BACKGROUND_COLOR = { white: 16777215, normal: 16053483 }
				}
				static {
					this.CLEAR_COLOR = Ri.BACKGROUND_COLOR.normal
				}
				static {
					this.CLEAR_ALPHA = 1
				}
				static {
					this.RENDER_OPTIONS = { antialias: !0, preserveDrawingBuffer: !0, alpha: !0 }
				}
				static {
					this.enableFXAA = !1
				}
				static {
					this.setPixelRatio = !1
				}
				constructor(n, e) {
					;(this.store = n),
						(this.state = e),
						(this.setBackgroundColorToState = i => {
							;(Ri.CLEAR_COLOR = i ? Ri.BACKGROUND_COLOR.white : Ri.BACKGROUND_COLOR.normal),
								this.renderer?.setClearColor(Ri.CLEAR_COLOR, Ri.CLEAR_ALPHA)
						}),
						(this.initGL = (i, r) => {
							if (
								(this.setGLOptions(),
								(this.renderer = new dr(Ri.RENDER_OPTIONS)),
								Ri.setPixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio),
								Ri.enableFXAA)
							)
								if (JEe_isWebGL2Available) {
									const o = this.renderer.getDrawingBufferSize(new lt()),
										s = new ml(o.width, o.height, { format: ha })
									this.composer = new iX(this.renderer, s)
								} else this.composer = new iX(this.renderer)
							this.renderer.setSize(i, r),
								(this.renderer.domElement.id = "codeMapScene"),
								Ri.enableFXAA && this.initComposer()
						}),
						(this.setGLOptions = () => {
							switch (this.state.getValue().appSettings.sharpnessMode) {
								case Qm.Standard:
									;(Ri.RENDER_OPTIONS.antialias = !0), (Ri.enableFXAA = !1), (Ri.setPixelRatio = !1)
									break
								case Qm.PixelRatioNoAA:
									;(Ri.RENDER_OPTIONS.antialias = !1), (Ri.enableFXAA = !1), (Ri.setPixelRatio = !0)
									break
								case Qm.PixelRatioFXAA:
									;(Ri.RENDER_OPTIONS.antialias = !1), (Ri.enableFXAA = !0), (Ri.setPixelRatio = !0)
									break
								case Qm.PixelRatioAA:
									;(Ri.RENDER_OPTIONS.antialias = !0), (Ri.enableFXAA = !1), (Ri.setPixelRatio = !0)
							}
						}),
						(this.initComposer = () => {
							const i = this.renderer.getPixelRatio()
							this.composer.setSize(window.innerWidth * i, window.innerHeight * i)
							const r = new tO(this.scene, this.camera)
							this.composer.addPass(r)
							const o = new dw(new eMe())
							;(o.renderToScreen = !1),
								(o.uniforms.resolution.value.x = 1 / (window.innerWidth * i)),
								(o.uniforms.resolution.value.y = 1 / (window.innerHeight * i)),
								this.composer.addPass(o)
						}),
						(this.getInfo = () => (Ri.enableFXAA ? this.composer.getInfo() : this.renderer.info.render)),
						(this.getMemoryInfo = () => (Ri.enableFXAA ? this.composer.getMemoryInfo() : this.renderer.info.memory))
				}
				init(n, e, i, r) {
					;(this.scene = i), (this.camera = r), this.initGL(n, e), this.store.select(rX).subscribe(this.setBackgroundColorToState)
				}
				render() {
					const { scene: n, camera: e, composer: i, renderer: r } = this
					Ri.enableFXAA ? i?.render() : r?.render(n, e)
				}
				static {
					this.ɵfac = function (e) {
						return new (e || Ri)(re(Ct), re(Sr))
					}
				}
				static {
					this.ɵprov = mt({ token: Ri, factory: Ri.ɵfac, providedIn: "root" })
				}
			}
			let Qc = (() => {
					class t {
						constructor(e, i, r, o) {
							;(this.store = e),
								(this.state = i),
								(this.idToBuilding = r),
								(this.threeRendererService = o),
								(this.eventEmitter = new eO()),
								(this.selected = null),
								(this.highlighted = []),
								(this.constantHighlight = new Map()),
								(this.folderLabelColorHighlighted = Li.convertHexToNumber("#FFFFFF")),
								(this.folderLabelColorNotHighlighted = Li.convertHexToNumber("#7A7777")),
								(this.rayPoint = new K(0, 0, 0)),
								(this.normedTransformVector = new K(0, 0, 0)),
								(this.highlightedLabel = null),
								(this.highlightedLineIndex = -1),
								(this.highlightedLine = null),
								(this.subscription = this.store.select(vb).subscribe(s => {
									;(this.folderLabelColorSelected = s.selected),
										(this.numberSelectionColor = Li.convertHexToNumber(this.folderLabelColorSelected))
								})),
								(this.scene = new nb()),
								(this.mapGeometry = new ps()),
								(this.lights = new ps()),
								(this.labels = new ps()),
								(this.floorLabelPlanes = new ps()),
								(this.edgeArrows = new ps()),
								this.initLights(),
								this.scene.add(this.mapGeometry),
								this.scene.add(this.edgeArrows),
								this.scene.add(this.labels),
								this.scene.add(this.lights),
								this.scene.add(this.floorLabelPlanes)
						}
						ngOnDestroy() {
							this.subscription.unsubscribe()
						}
						initFloorLabels(e) {
							this.floorLabelPlanes.clear()
							const { layoutAlgorithm: i, enableFloorLabels: r } = this.state.getValue().appSettings
							if (i !== Ad.SquarifiedTreeMap || !r) return
							const o = this.getRootNode(e)
							if (!o) return
							const s = this.state.getValue().appSettings.scaling,
								a = new K(s.x, s.y, s.z)
							this.floorLabelDrawer = new bb(this.mapMesh.getNodes(), o, Oo, a)
							const c = this.floorLabelDrawer.draw(this.state.getValue())
							c.length > 0 && (this.floorLabelPlanes.add(...c), this.scene.add(this.floorLabelPlanes))
						}
						getRootNode(e) {
							return e.find(i => 0 === i.id)
						}
						getConstantHighlight() {
							return this.constantHighlight
						}
						highlightBuildings() {
							const e = this.state.getValue()
							this.getMapMesh().highlightBuilding(this.highlighted, this.selected, e, this.constantHighlight),
								this.mapGeometry.children[0] && this.highlightMaterial(this.mapGeometry.children[0].material),
								this.threeRendererService.render()
						}
						selectMaterial(e) {
							e.find(({ userData: r }) => r.id === this.selected.node.id)?.color.setHex(this.numberSelectionColor)
						}
						resetMaterial(e) {
							const i = this.selected ? this.selected.node.id : -1
							for (const r of e) r.userData.id !== i && r.color?.setHex(this.folderLabelColorHighlighted)
						}
						scaleHeight() {
							const e = this.state.getValue().appSettings.scaling
							this.floorLabelDrawer?.translatePlaneCanvases(e),
								this.mapGeometry.scale.set(e.x, e.y, e.z),
								this.mapGeometry.position.set(-Oo * e.x, 0, -Oo * e.z),
								this.mapMesh.setScale(e)
						}
						highlightMaterial(e) {
							const i = new Set(this.highlighted.map(({ node: o }) => o.id)),
								r = new Set()
							for (const { node: o } of this.constantHighlight.values()) r.add(o.id)
							for (const o of e) {
								const s = o.userData.id
								this.selected && s === this.selected.node.id
									? o.color.setHex(this.numberSelectionColor)
									: i.has(s) || r.has(s)
									? o.color.setHex(this.folderLabelColorHighlighted)
									: o.color?.setHex(this.folderLabelColorNotHighlighted)
							}
						}
						highlightSingleBuilding(e) {
							;(this.highlighted = []), this.addBuildingToHighlightingList(e), this.highlightBuildings()
						}
						addBuildingToHighlightingList(e) {
							this.highlighted.push(e)
						}
						clearHoverHighlight() {
							;(this.highlighted = []), this.highlightBuildings()
						}
						clearHighlight() {
							this.getMapMesh() &&
								(this.getMapMesh().clearHighlight(this.selected),
								(this.highlighted = []),
								this.constantHighlight.clear(),
								this.mapGeometry.children[0] && this.resetMaterial(this.mapGeometry.children[0].material))
						}
						selectBuilding(e) {
							e.id !== this.selected?.id && this.store.dispatch(WP({ value: e.node.id })),
								this.getMapMesh().selectBuilding(e, this.folderLabelColorSelected),
								(this.selected = e),
								this.highlightBuildings(),
								this.eventEmitter.emit("onBuildingSelected", { building: this.selected }),
								this.mapGeometry.children[0] && this.selectMaterial(this.mapGeometry.children[0].material)
						}
						animateLabel(e, i, r) {
							if (null !== e && null !== i) {
								this.resetLabel(),
									e.material && (e.material.opacity = 1),
									(this.highlightedLineIndex = this.getHoveredLabelLineIndex(r, e)),
									(this.highlightedLine = r[this.highlightedLineIndex]),
									(this.rayPoint = new K()),
									this.rayPoint.subVectors(i.ray.origin, e.position)
								const o = Math.sqrt(this.rayPoint.x ** 2 + this.rayPoint.y ** 2 + this.rayPoint.z ** 2)
								this.normedTransformVector = new K(this.rayPoint.x / o, this.rayPoint.y / o, this.rayPoint.z / o)
								const a = this.calculateMaxDistance(e, r, i.ray.origin)
								this.normedTransformVector.multiplyScalar(a),
									e.position.add(this.normedTransformVector),
									this.toggleLineAnimation(e),
									(this.highlightedLabel = e)
							}
						}
						resetLineHighlight() {
							;(this.highlightedLineIndex = -1), (this.highlightedLine = null)
						}
						resetLabel() {
							null !== this.highlightedLabel &&
								(this.highlightedLabel.position.sub(this.normedTransformVector),
								(this.highlightedLabel.material.opacity = Vu.labelColorAndAlpha.alpha),
								this.highlightedLine && this.toggleLineAnimation(this.highlightedLabel),
								(this.highlightedLabel = null))
						}
						getHoveredLabelLineIndex(e, i) {
							const r = e.findIndex(({ uuid: o }) => o === i.uuid)
							if (r >= 0) return r + 1
						}
						toggleLineAnimation(e) {
							const i = new K(e.position.x, e.position.y, e.position.z),
								o = this.highlightedLine.geometry.attributes.position.array,
								a = new ma(new vn().setFromPoints([new K(o[0], o[1], o[2]), i]), this.highlightedLine.material)
							this.labels.children.splice(this.highlightedLineIndex, 1, a)
						}
						getLabelForHoveredNode(e, i) {
							for (let r = 0; r < i?.length; r += 2) if (i[r].userData.node === e.node) return i[r]
							return null
						}
						isOverlapping(e, i, r) {
							return +(e.max[r] >= i.min[r] && i.max[r] >= e.min[r])
						}
						getIntersectionDistanceFunction(e, i) {
							return r => {
								const o = this.normedTransformVector.clone()
								o.multiplyScalar(r), e.translate(o)
								const s = this.isOverlapping(i, e, "x") + this.isOverlapping(i, e, "y")
								return 2 === s || (1 === s && this.isOverlapping(i, e, "z")) ? r : 0
							}
						}
						calculateMaxDistance(e, i, r) {
							const o = new is().setFromObject(e),
								s = new K()
							o.getCenter(s)
							const a = r.distanceTo(s)
							let c = a / 20
							for (let l = 0; l < i.length; l += 2)
								if (i[l] !== e) {
									const d = o.clone(),
										u = new is().setFromObject(i[l]),
										h = new K()
									u.getCenter(h)
									const f = this.getIntersectionDistanceFunction(d, u)
									c = Math.max(f(a - r.distanceTo(h)), f(a - r.distanceTo(u.max)), f(a - r.distanceTo(u.min)), c)
								}
							return c
						}
						addNodeAndChildrenToConstantHighlight(e) {
							const r = _b(this.state.getValue()).get(e.id)
							for (const { data: o } of $r(r)) {
								const s = this.idToBuilding.get(o.id)
								s && this.constantHighlight.set(s.id, s)
							}
						}
						removeNodeAndChildrenFromConstantHighlight(e) {
							const r = _b(this.state.getValue()).get(e.id)
							for (const { data: o } of $r(r)) {
								const s = this.idToBuilding.get(o.id)
								s && this.constantHighlight.delete(s.id)
							}
						}
						clearConstantHighlight() {
							this.constantHighlight.size > 0 && this.clearHighlight()
						}
						clearSelection() {
							this.selected &&
								(this.getMapMesh().clearSelection(this.selected),
								this.store.dispatch(WP({ value: null })),
								this.eventEmitter.emit("onBuildingDeselected")),
								this.highlighted.length > 0 && this.highlightBuildings(),
								(this.selected = null),
								this.mapGeometry.children[0] && this.resetMaterial(this.mapGeometry.children[0].material)
						}
						initLights() {
							const e = new nw(7368816),
								i = new _p(14737632, 1)
							i.position.set(50, 10, 8).normalize()
							const r = new _p(14737632, 1)
							r.position.set(-50, 10, -8).normalize(), this.lights.add(e), this.lights.add(i), this.lights.add(r)
						}
						setMapMesh(e, i) {
							;(this.mapMesh = i),
								this.initFloorLabels(e),
								(this.mapGeometry.children.length = 0),
								(this.mapGeometry.position.x = -Oo),
								(this.mapGeometry.position.y = 0),
								(this.mapGeometry.position.z = -Oo),
								this.mapGeometry.add(this.mapMesh.getThreeMesh()),
								this.idToBuilding.setIdToBuilding(this.mapMesh.getMeshDescription().buildings)
						}
						getMapMesh() {
							return this.mapMesh
						}
						getSelectedBuilding() {
							return this.selected
						}
						getHighlightedBuilding() {
							return this.highlighted[0]
						}
						dispose() {
							this.mapMesh?.dispose()
						}
						subscribe(e, i) {
							this.eventEmitter.on(e, r => {
								i(r)
							})
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(Sr), re(lw), re(Ri))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				KS = (() => {
					class t {
						constructor(e) {
							;(this.threeSceneService = e),
								(this.isOpen = !1),
								this.threeSceneService.subscribe("onBuildingSelected", () => {
									this.isOpen = !0
								}),
								this.threeSceneService.subscribe("onBuildingDeselected", () => {
									this.isOpen = !1
								})
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Qc))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				Td = (() => {
					class t {
						static {
							this.VIEW_ANGLE = 45
						}
						static {
							this.NEAR = 50
						}
						static {
							this.FAR = 2e5
						}
						init(e, i) {
							;(this.camera = new Co(t.VIEW_ANGLE, e / i, t.NEAR, t.FAR)), this.setPosition(new K(0, 300, 1e3))
						}
						setPosition(e) {
							this.camera.position.set(e.x, e.y, e.z), this.camera.lookAt(0, 0, 0)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			var tMe = A(8336),
				oX = A.n(tMe)
			let El = (() => {
				class t {
					static {
						this.CAMERA_CHANGED_EVENT_NAME = "camera-changed"
					}
					constructor(e, i, r) {
						;(this.threeCameraService = e),
							(this.threeSceneService = i),
							(this.threeRendererService = r),
							(this.eventEmitter = new eO())
					}
					setControlTarget(e) {
						this.controls.target.set(e.x, e.y, e.z)
					}
					rotateCameraInVectorDirection(e, i, r) {
						const o = this.getZoom()
						this.lookAtDirectionFromTarget(e, i, r),
							this.applyOldZoom(o),
							this.threeRendererService.render(),
							this.onInput(this.threeCameraService.camera)
					}
					autoFitTo() {
						setTimeout(() => {
							const e = this.getBoundingSphere(),
								i = this.cameraPerspectiveLengthCalculation(e)
							this.threeCameraService.camera.position.set(i, i, e.center.z),
								this.controls.update(),
								this.focusCameraViewToCenter(e),
								this.threeRendererService.render(),
								this.onInput(this.threeCameraService.camera)
						})
					}
					cameraPerspectiveLengthCalculation(e) {
						const o = ((this.threeCameraService.camera.fov * Math.PI) / 180) * 1.3,
							s = e.radius / Math.tan(o / 2)
						return Math.sqrt(Math.pow(s, 2) + Math.pow(s, 2))
					}
					focusCameraViewToCenter(e) {
						const i = e.center.clone()
						i.setY(0),
							this.controls.target.set(i.x, i.y, i.z),
							this.threeCameraService.camera.lookAt(i),
							this.threeCameraService.camera.updateProjectionMatrix()
					}
					getBoundingSphere() {
						return new is().setFromObject(this.threeSceneService.mapGeometry).getBoundingSphere(new xd())
					}
					lookAtDirectionFromTarget(e, i, r) {
						this.threeCameraService.camera.position.set(this.controls.target.x, this.controls.target.y, this.controls.target.z)
						const o = new Mi(new _l(20, 20, 20), new _S())
						this.threeSceneService.scene.add(o),
							o.position.set(this.controls.target.x, this.controls.target.y, this.controls.target.z),
							o.translateX(e),
							o.translateY(i),
							o.translateZ(r),
							this.threeCameraService.camera.lookAt(o.getWorldPosition(o.position)),
							this.threeSceneService.scene.remove(o)
					}
					getZoom() {
						return this.threeCameraService.camera.position.distanceTo(this.controls.target)
					}
					applyOldZoom(e) {
						this.threeCameraService.camera.translateZ(e)
					}
					init(e) {
						const i = oX()(X)
						;(this.controls = new i(this.threeCameraService.camera, e)),
							this.controls.addEventListener("change", () => {
								this.onInput(this.threeCameraService.camera)
							})
					}
					onInput(e) {
						this.setControlTarget(this.controls.target), this.eventEmitter.emit("onCameraChanged", { camera: e })
					}
					subscribe(e, i) {
						this.eventEmitter.on(e, r => {
							i(r)
						})
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Td), re(Qc), re(Ri))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			var hw = function () {
				var t = 0,
					n = document.createElement("div")
				function e(d) {
					return n.appendChild(d.dom), d
				}
				function i(d) {
					for (var u = 0; u < n.children.length; u++) n.children[u].style.display = u === d ? "block" : "none"
					t = d
				}
				;(n.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
					n.addEventListener(
						"click",
						function (d) {
							d.preventDefault(), i(++t % n.children.length)
						},
						!1
					)
				var r = (performance || Date).now(),
					o = r,
					s = 0,
					a = e(new hw.Panel("FPS", "#0ff", "#002")),
					c = e(new hw.Panel("MS", "#0f0", "#020"))
				if (self.performance && self.performance.memory) var l = e(new hw.Panel("MB", "#f08", "#201"))
				return (
					i(0),
					{
						REVISION: 16,
						dom: n,
						addPanel: e,
						showPanel: i,
						begin: function () {
							r = (performance || Date).now()
						},
						end: function () {
							s++
							var d = (performance || Date).now()
							if ((c.update(d - r, 200), d >= o + 1e3 && (a.update((1e3 * s) / (d - o), 100), (o = d), (s = 0), l))) {
								var u = performance.memory
								l.update(u.usedJSHeapSize / 1048576, u.jsHeapSizeLimit / 1048576)
							}
							return d
						},
						update: function () {
							r = this.end()
						},
						domElement: n,
						setMode: i
					}
				)
			}
			hw.Panel = function (t, n, e) {
				var i = 1 / 0,
					r = 0,
					o = Math.round,
					s = o(window.devicePixelRatio || 1),
					a = 80 * s,
					c = 48 * s,
					l = 3 * s,
					d = 2 * s,
					u = 3 * s,
					h = 15 * s,
					f = 74 * s,
					_ = 30 * s,
					y = document.createElement("canvas")
				;(y.width = a), (y.height = c), (y.style.cssText = "width:80px;height:48px")
				var C = y.getContext("2d")
				return (
					(C.font = "bold " + 9 * s + "px Helvetica,Arial,sans-serif"),
					(C.textBaseline = "top"),
					(C.fillStyle = e),
					C.fillRect(0, 0, a, c),
					(C.fillStyle = n),
					C.fillText(t, l, d),
					C.fillRect(u, h, f, _),
					(C.fillStyle = e),
					(C.globalAlpha = 0.9),
					C.fillRect(u, h, f, _),
					{
						dom: y,
						update: function (x, w) {
							;(i = Math.min(i, x)),
								(r = Math.max(r, x)),
								(C.fillStyle = e),
								(C.globalAlpha = 1),
								C.fillRect(0, 0, a, h),
								(C.fillStyle = n),
								C.fillText(o(x) + " " + t + " (" + o(i) + "-" + o(r) + ")", l, d),
								C.drawImage(y, u + s, h, f - s, _, u, h, f - s, _),
								C.fillRect(u + f - s, h, s, _),
								(C.fillStyle = e),
								(C.globalAlpha = 0.9),
								C.fillRect(u + f - s, h, s, o((1 - x / w) * _))
						}
					}
				)
			}
			const fw = hw
			let sX = (() => {
					class t {
						constructor(e) {
							;(this.threeRendererService = e),
								(this.isDevelopmentMode = !1),
								(this.init = i => {
									this.isDevelopmentMode &&
										((this.stats = fw()),
										(this.stats.domElement.style.position = "absolute"),
										(this.stats.domElement.style.left = "0"),
										(this.stats.domElement.style.top = "0"),
										i.append(this.stats.dom),
										this.generateStatPanels(),
										(this.prevTime = this.getTimeFunctor().now()))
								}),
								(this.getTimeFunctor = () => (typeof performance > "u" ? Date : performance)),
								(this.generateStatPanels = () => {
									;(this.trianglesPanel = {
										panel: this.stats.addPanel(fw.Panel("triangles", "#ff8", "#221")),
										maxHeight: 0
									}),
										(this.glCallsPanel = {
											panel: this.stats.addPanel(fw.Panel("calls", "#f8f", "#212")),
											maxHeight: 0
										}),
										(this.geometryMemoryPanel = {
											panel: this.stats.addPanel(fw.Panel("geo. mem", "#f08", "#221")),
											maxHeight: 0
										}),
										(this.textureMemoryPanel = {
											panel: this.stats.addPanel(fw.Panel("tex. mem", "#0f8", "#221")),
											maxHeight: 0
										}),
										this.stats.showPanel(3)
								}),
								(this.updateStats = () => {
									if (this.isDevelopmentMode) {
										const i = this.getTimeFunctor().now()
										if (i >= this.prevTime + 1e3) {
											this.prevTime = i
											const r = this.threeRendererService.getInfo(),
												o = this.threeRendererService.getMemoryInfo()
											this.processPanel(this.trianglesPanel, r.triangles),
												this.processPanel(this.glCallsPanel, r.calls),
												this.processPanel(this.geometryMemoryPanel, o.geometries),
												this.processPanel(this.textureMemoryPanel, o.textures)
										}
										this.stats.update()
									}
								}),
								(this.resetPanels = () => {
									if (this.isDevelopmentMode)
										for (const i of [
											this.trianglesPanel,
											this.glCallsPanel,
											this.geometryMemoryPanel,
											this.textureMemoryPanel
										])
											void 0 !== i && (i.maxHeight = 0)
								}),
								(this.processPanel = (i, r) => {
									;(i.maxHeight = Math.max(i.maxHeight, r)), i.panel.update(r, 1.3 * i.maxHeight)
								}),
								(this.destroy = () => {
									this.isDevelopmentMode && this.stats.domElement.remove()
								})
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ri))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				aX = (() => {
					class t {
						constructor(e, i, r, o, s) {
							;(this.threeSceneService = e),
								(this.threeCameraService = i),
								(this.threeOrbitControlsService = r),
								(this.threeRendererService = o),
								(this.threeStatsService = s),
								(this.onWindowResize = () => {
									this.threeSceneService.scene.updateMatrixWorld(!1),
										this.threeRendererService.renderer.setSize(window.innerWidth, window.innerHeight),
										(this.threeCameraService.camera.aspect = window.innerWidth / window.innerHeight),
										this.threeCameraService.camera.updateProjectionMatrix(),
										this.animate()
								}),
								(this.onFocusIn = a => {
									"INPUT" === a.target.nodeName && (this.threeOrbitControlsService.controls.enableKeys = !1)
								}),
								(this.onFocusOut = a => {
									"INPUT" === a.target.nodeName && (this.threeOrbitControlsService.controls.enableKeys = !0)
								})
						}
						init(e) {
							this.threeCameraService.init(window.innerWidth, window.innerHeight)
							const i = this.threeCameraService.camera,
								r = this.threeSceneService.scene
							i.lookAt(r.position),
								r.add(i),
								this.threeRendererService.init(window.innerWidth, window.innerHeight, r, i),
								this.threeStatsService.init(e),
								this.threeOrbitControlsService.init(this.threeRendererService.renderer.domElement),
								e.append(this.threeRendererService.renderer.domElement),
								window.addEventListener("resize", this.onWindowResize),
								window.addEventListener("focusin", this.onFocusIn),
								window.addEventListener("focusout", this.onFocusOut),
								this.animate(),
								this.animateStats()
						}
						restart(e) {
							this.stopAnimate(), this.destroy(), this.init(e), this.autoFitTo(), this.animate(), this.animateStats()
						}
						enableRotation(e) {
							this.threeOrbitControlsService.controls.enableRotate = e
						}
						animate() {
							this.threeOrbitControlsService.controls.update(), this.threeRendererService.render()
						}
						animateStats() {
							;(this.animationFrameId = requestAnimationFrame(() => this.animateStats())),
								this.threeStatsService.updateStats()
						}
						getRenderCanvas() {
							return this.threeRendererService.renderer.domElement
						}
						getRenderLoseExtention() {
							return this.threeRendererService.renderer.getContext().getExtension("WEBGL_lose_context")
						}
						autoFitTo() {
							this.threeOrbitControlsService.autoFitTo()
						}
						stopAnimate() {
							cancelAnimationFrame(this.animationFrameId)
						}
						dispose() {
							this.threeRendererService?.composer?.dispose(), this.threeRendererService?.renderer?.dispose()
						}
						destroy() {
							window.removeEventListener("resize", this.onWindowResize),
								window.removeEventListener("focusin", this.onFocusIn),
								window.removeEventListener("focusout", this.onFocusOut),
								this.dispose(),
								this.threeStatsService.destroy(),
								this.getRenderCanvas().remove(),
								this.dispose()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Qc), re(Td), re(El), re(Ri), re(sX))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			const wb = Nt("SET_HOVERED_NODE_ID", { _as: "props", _p: void 0 }),
				xb = Nt("SET_RIGHT_CLICKED_NODE_DATA", { _as: "props", _p: void 0 }),
				nO = t => t.appStatus,
				mw = Mt(nO, t => t.hoveredNodeId)
			function Fd(t, n = 0) {
				let e
				return (...i) => {
					clearTimeout(e),
						(e = setTimeout(() => {
							t.apply(this, i), (e = null)
						}, n))
				}
			}
			let cX = (() => {
					class t {
						constructor(e, i, r, o) {
							;(this.state = e),
								(this.threeCameraService = i),
								(this.threeSceneService = r),
								(this.threeOrbitControlsService = o),
								(this.mapLabelColors = Vu.labelColorAndAlpha),
								(this.LABEL_COLOR_RGB = Li.convertHexToRgba(this.mapLabelColors.rgb)),
								(this.LABEL_WIDTH_DIVISOR = 2100),
								(this.LABEL_HEIGHT_DIVISOR = 35),
								(this.LABEL_CORNER_RADIUS = 40),
								(this.LABEL_SCALE_FACTOR = 0.7),
								(this.LABEL_HEIGHT_COEFFICIENT = 3.75),
								(this.LABEL_HEIGHT_POSITION = 60),
								(this.previousScaling = new K(1, 1, 1)),
								(this.lineCount = 1),
								(this.nodeHeight = 0),
								(this.labels = new Array()),
								this.threeOrbitControlsService.subscribe("onCameraChanged", () => this.onCameraChanged())
						}
						addLeafLabel(e, i, r = !1) {
							const { appSettings: o, dynamicSettings: s } = this.state.getValue(),
								{ scaling: a, layoutAlgorithm: c, showMetricLabelNodeName: l, showMetricLabelNameValue: d } = o,
								{ margin: u, heightMetric: h } = s,
								f = new K(a.x, a.y, a.z)
							let _ = ""
							if (l || (r && !d)) _ = `${e.name}`
							else if (!d) return
							d && ("" !== _ && (_ += "\n"), (_ += `${e.attributes[h]} ${h}`))
							const y = this.makeText(_, 30, e)
							let C = e.height + Math.abs(e.heightDelta ?? 0)
							;(C = C * f.y > i * f.y ? C : i), (this.nodeHeight = this.nodeHeight > C ? this.nodeHeight : C)
							const w = e.z0,
								M = (e.x0 - Oo + e.width / 2) * f.x,
								O = (w + this.nodeHeight) * f.y,
								N = (w + e.height) * f.y,
								j = (e.y0 - Oo + e.length / 2) * f.z,
								le = this.LABEL_HEIGHT_COEFFICIENT * u * this.LABEL_SCALE_FACTOR
							let ae = le + y.heightValue / 2
							switch (c) {
								case Ad.StreetMap:
								case Ad.TreeMapStreet:
									;(ae /= 10), (this.LABEL_HEIGHT_POSITION = 0), (y.line = this.makeLine(M, O + ae, N, j))
									break
								default:
									y.line = this.makeLine(M, O + le / 2, N, j)
							}
							y.sprite.position.set(M, O + ae, j),
								(y.sprite.material.color = new Lt(this.mapLabelColors.rgb)),
								(y.sprite.material.opacity = this.mapLabelColors.alpha),
								(y.sprite.userData = { node: e }),
								this.threeSceneService.labels.add(y.sprite),
								this.threeSceneService.labels.add(y.line),
								this.labels.push(y)
						}
						clearLabels() {
							this.threeSceneService.resetLabel(),
								this.threeSceneService.resetLineHighlight(),
								this.dispose(this.labels),
								(this.labels = []),
								(this.nodeHeight = 0),
								(this.LABEL_HEIGHT_POSITION = 60),
								this.dispose(this.threeSceneService.labels.children),
								(this.threeSceneService.labels.children = [])
						}
						disposeSprite(e) {
							e.material.dispose(), e.material.map.dispose(), e.geometry.dispose()
						}
						disposeLine(e) {
							e.material.dispose(), e.geometry.dispose()
						}
						dispose(e) {
							for (const i of e)
								i instanceof ab && this.disposeSprite(i),
									i instanceof ma && this.disposeLine(i),
									void 0 !== i.sprite && this.disposeSprite(i.sprite),
									void 0 !== i.line && this.disposeLine(i.line)
						}
						clearTemporaryLabel(e) {
							const i = this.labels.findIndex(({ node: r }) => r === e)
							i > -1 &&
								(this.labels.splice(i, 1),
								this.dispose(this.threeSceneService.labels.children),
								(this.threeSceneService.labels.children.length -= 2),
								this.threeSceneService.resetLineHighlight())
						}
						scale() {
							const { scaling: e } = this.state.getValue().appSettings,
								i = new K(e.x, e.y, e.z),
								{ margin: r } = this.state.getValue().dynamicSettings,
								o = new K(0, this.LABEL_HEIGHT_COEFFICIENT * r * this.LABEL_SCALE_FACTOR, 0)
							for (const s of this.labels) {
								const a = i.clone()
								s.sprite.position.sub(o).divide(this.previousScaling).multiply(a).add(o), a.y > 1 && (a.y = 1)
								const l = s.line.geometry.attributes.position
								l.setX(0, l.getX(0) * a.x),
									l.setY(0, l.getY(0) * a.y),
									l.setZ(0, l.getZ(0) * a.z),
									l.setX(1, s.sprite.position.x),
									l.setY(1, s.sprite.position.y),
									l.setZ(1, s.sprite.position.z),
									(l.needsUpdate = !0)
							}
							this.previousScaling.copy(i)
						}
						onCameraChanged() {
							for (const e of this.labels) this.setLabelSize(e.sprite, e, e.sprite.material.map.image.width)
						}
						makeText(e, i, r) {
							const o = document.createElement("canvas"),
								s = o.getContext("2d")
							s.font = `${i}px Roboto`
							const c = e.split("\n"),
								l = s.measureText(c[0]).width,
								d = s.measureText(c[1]).width
							;(o.width = l > d ? l + 25 : d + 25),
								(o.height = 25 + i * c.length),
								(s.font = `${i}px Roboto`),
								(s.fillStyle = "rgba(255,255,255,1)"),
								(s.lineJoin = "round"),
								(s.lineCap = "round"),
								(s.lineWidth = 5),
								t.drawRectangleWithRoundedCorners(s, 0, 0, o.width, o.height, this.LABEL_CORNER_RADIUS),
								(s.fillStyle = "rgba(0,0,0,1)"),
								(s.textAlign = "center"),
								(s.textBaseline = "middle")
							for (const [_, y] of c.entries()) s.fillText(y, o.width / 2, (o.height * (_ + 1)) / (c.length + 1))
							const u = new zo(o)
							;(u.minFilter = xo), (u.needsUpdate = !0)
							const h = new Iy({ map: u }),
								f = new ab(h)
							return (
								(this.lineCount = c.length),
								this.setLabelSize(f, null, o.width),
								{ sprite: f, heightValue: o.height, line: null, lineCount: c.length, node: r }
							)
						}
						static drawRectangleWithRoundedCorners(e, i, r, o, s, a) {
							o < 2 * a && (a = o / 2),
								s < 2 * a && (a = s / 2),
								e.beginPath(),
								e.moveTo(i + a, r),
								e.arcTo(i + o, r, i + o, r + s, a),
								e.arcTo(i + o, r + s, i, r + s, a),
								e.arcTo(i, r + s, i, r, a),
								e.arcTo(i, r, i + o, r, a),
								e.closePath(),
								e.fill()
						}
						setLabelSize(e, i, r = e.material.map.image.width) {
							const o = new is().setFromObject(this.threeSceneService.mapGeometry).getBoundingSphere(new xd()).center
							if (this.threeCameraService.camera) {
								const s = this.threeCameraService.camera.position.distanceTo(o)
								null !== i && (this.lineCount = i.lineCount),
									e.scale.set(
										(s / this.LABEL_WIDTH_DIVISOR) * r,
										this.lineCount > 1 ? s / 25 : s / this.LABEL_HEIGHT_DIVISOR,
										1
									)
							}
						}
						makeLine(e, i, r, o) {
							const s = new Go({ color: this.LABEL_COLOR_RGB, linewidth: 2 })
							return new ma(new vn().setFromPoints([new K(e, r, o), new K(e, i + this.LABEL_HEIGHT_POSITION, o)]), s)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Sr), re(Td), re(Qc), re(El))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				lX = (() => {
					class t {
						constructor(e) {
							;(this.threeOrbitControlsService = e),
								(this.eventEmitter = new eO()),
								(this.currentlyHovered = null),
								(this.isDragging = !1)
						}
						init(e, i, r) {
							;(this.cubeGroup = e),
								(this.camera = i),
								(this.renderer = r),
								this.initOrbitalControl(i, r),
								this.initRendererEventListeners(r)
						}
						resetIsDragging() {
							this.isDragging = !1
						}
						initOrbitalControl(e, i) {
							const r = oX()(X)
							;(this.controls = new r(e, i.domElement)),
								(this.controls.enableZoom = !1),
								(this.controls.enableKeys = !1),
								(this.controls.enablePan = !1),
								(this.controls.rotateSpeed = 1)
						}
						initRendererEventListeners(e) {
							e.domElement.addEventListener("mousemove", i => this.onDocumentMouseMove(i)),
								e.domElement.addEventListener("mouseup", i => this.onDocumentMouseUp(i)),
								e.domElement.addEventListener("mousedown", i => this.onDocumentMouseClick(i, "mousedown")),
								e.domElement.addEventListener("dblclick", i => this.onDocumentMouseClick(i, "dblclick")),
								e.domElement.addEventListener("mouseleave", i => this.onWindowMouseLeave(i)),
								e.domElement.addEventListener("mouseenter", () => this.onDocumentMouseEnter())
						}
						onDocumentMouseClick(e, i) {
							;(this.isDragging = !0), this.checkMouseIntersection(e, i)
						}
						onWindowMouseLeave(e) {
							;(null == e.relatedTarget || !(e.relatedTarget instanceof HTMLCanvasElement)) && this.enableRotation(!1)
						}
						onDocumentMouseEnter() {
							this.enableRotation(!0)
						}
						enableRotation(e) {
							this.controls.enableRotate = e
						}
						checkMouseIntersection(e, i) {
							this.getCubeIntersectedByMouse(e) || this.eventEmitter.emit("viewCubeEventPropagation", { type: i, event: e })
						}
						getCubeIntersectedByMouse(e) {
							const i = this.transformIntoCanvasVector(e),
								r = new ow()
							r.setFromCamera(i, this.camera)
							const o = []
							for (const a of $r(this.cubeGroup)) uo(a) && o.push(a.data)
							const [s] = r.intersectObjects(o)
							return s ? s.object : null
						}
						transformIntoCanvasVector(e) {
							const { domElement: i } = this.renderer,
								r = this.renderer.getPixelRatio(),
								o = i.getBoundingClientRect()
							return new lt(((e.clientX - o.left) / i.width) * r * 2 - 1, (-(e.clientY - o.top) / i.height) * r * 2 + 1)
						}
						propagateMovement() {
							if (this.isDragging) {
								const e = this.camera.position
								this.threeOrbitControlsService.rotateCameraInVectorDirection(-e.x, -e.y, -e.z)
							}
							return this.isDragging
						}
						onDocumentMouseMove(e) {
							if (this.propagateMovement()) return
							const i = this.getCubeIntersectedByMouse(e)
							i
								? this.currentlyHovered && i.uuid !== this.currentlyHovered.uuid
									? this.triggerViewCubeUnhoverEvent()
									: this.currentlyHovered || this.triggerViewCubeHoverEvent(i)
								: (this.currentlyHovered && this.triggerViewCubeUnhoverEvent(),
								  this.eventEmitter.emit("viewCubeEventPropagation", { type: "mousemove", event: e }))
						}
						onDocumentMouseUp(e) {
							this.isDragging = !1
							const i = this.getCubeIntersectedByMouse(e)
							i
								? this.eventEmitter.emit("viewCubeClicked", { cube: i })
								: this.eventEmitter.emit("viewCubeEventPropagation", { type: "mouseup", event: e })
						}
						triggerViewCubeHoverEvent(e) {
							;(this.currentlyHovered = e),
								pw.changeCursorIndicator(Qu.Pointer),
								this.eventEmitter.emit("viewCubeHoveredEvent", { cube: e })
						}
						triggerViewCubeUnhoverEvent() {
							;(this.currentlyHovered = null),
								pw.changeCursorIndicator(Qu.Default),
								this.eventEmitter.emit("viewCubeUnHoveredEvent")
						}
						subscribe(e, i) {
							this.eventEmitter.on(e, r => {
								i(r)
							})
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(El))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})()
			var XS = (function (t) {
					return (t[(t.LeftClick = 0)] = "LeftClick"), (t[(t.RightClick = 2)] = "RightClick"), t
				})(XS || {}),
				Qu = (function (t) {
					return (t.Default = "default"), (t.Grabbing = "grabbing"), (t.Pointer = "pointer"), (t.Moving = "move"), t
				})(Qu || {})
			let pw = (() => {
				class t {
					constructor(e, i, r, o, s, a, c, l, d) {
						;(this.threeCameraService = e),
							(this.threeRendererService = i),
							(this.threeSceneService = r),
							(this.store = o),
							(this.state = s),
							(this.codeMapLabelService = a),
							(this.viewCubeMouseEvents = c),
							(this.threeViewerService = l),
							(this.idToBuilding = d),
							(this.THRESHOLD_FOR_MOUSE_MOVEMENT_TRACKING = 3),
							(this.mouse = { x: 0, y: 0 }),
							(this.oldMouse = { x: 0, y: 0 }),
							(this.mouseOnLastClick = { x: 0, y: 0 }),
							(this.isGrabbing = !1),
							(this.isMoving = !1),
							(this.raycaster = new ow()),
							(this.labelHoveredBuilding = null),
							(this.labelSelectedBuilding = null),
							(this.subscriptions = [
								this.store
									.select(ld)
									.pipe(eo(() => this.onFilesSelectionChanged()))
									.subscribe(),
								this.store
									.select(cd)
									.pipe(eo(u => this.onBlacklistChanged(u)))
									.subscribe(),
								this.store
									.select(mw)
									.pipe(
										eo(u => {
											null !== u ? this.hoverNode(u) : this.unhoverNode(!1)
										})
									)
									.subscribe()
							]),
							(this.onViewCubeEventPropagation = u => {
								switch (u.type) {
									case "mousemove":
										this.onDocumentMouseMove(u.event)
										break
									case "mouseup":
										this.onDocumentMouseUp(u.event)
										break
									case "mousedown":
										this.onDocumentMouseDown(u.event)
										break
									case "dblclick":
										this.onDocumentDoubleClick()
								}
							}),
							(this.onDocumentMouseMove = u => {
								;(this.mouse.x = u.clientX),
									(this.mouse.y = u.clientY),
									this.updateHovering(),
									this.viewCubeMouseEvents.propagateMovement()
							})
					}
					ngOnDestroy() {
						for (const e of this.subscriptions) e.unsubscribe()
					}
					static changeCursorIndicator(e) {
						document.body.style.cursor = e
					}
					start() {
						this.threeRendererService.renderer.domElement.addEventListener("mousemove", Fd(this.onDocumentMouseMove, 1)),
							this.threeRendererService.renderer.domElement.addEventListener("mouseup", e => this.onDocumentMouseUp(e)),
							this.threeRendererService.renderer.domElement.addEventListener("mousedown", e => this.onDocumentMouseDown(e)),
							this.threeRendererService.renderer.domElement.addEventListener("dblclick", () => this.onDocumentDoubleClick()),
							this.threeRendererService.renderer.domElement.addEventListener("mouseleave", e => this.onDocumentMouseLeave(e)),
							this.threeRendererService.renderer.domElement.addEventListener("mouseenter", () => this.onDocumentMouseEnter()),
							this.threeRendererService.renderer.domElement.addEventListener(
								"wheel",
								Fd(() => this.threeRendererService.render(), 1)
							),
							this.viewCubeMouseEvents.subscribe("viewCubeEventPropagation", this.onViewCubeEventPropagation)
					}
					hoverNode(e) {
						if (this.isGrabbingOrMoving()) return
						const { buildings: i } = this.threeSceneService.getMapMesh().getMeshDescription()
						for (const r of i)
							if (r.node.id === e) {
								this.hoverBuilding(r, !1)
								break
							}
						this.threeRendererService.render()
					}
					unhoverNode(e = !0) {
						this.unhoverBuilding(e), this.threeRendererService.render()
					}
					onFilesSelectionChanged() {
						this.threeSceneService.clearSelection(),
							this.threeSceneService.clearConstantHighlight(),
							this.clearLabelHoveredBuilding()
					}
					onBlacklistChanged(e) {
						const i = this.threeSceneService.getSelectedBuilding()
						this.clearLabelHoveredBuilding(),
							i &&
								(function Kme(t, n) {
									return vu(t, n, "exclude") || vu(t, n, "flatten")
								})(i.node.path, e) &&
								this.threeSceneService.clearSelection(),
							this.unhoverBuilding()
					}
					updateHovering() {
						if (this.hasMouseMoved(this.oldMouse)) {
							const e = this.threeSceneService.labels?.children
							if (this.isGrabbingOrMoving())
								return (
									this.threeSceneService.resetLabel(),
									this.clearLabelHoveredBuilding(),
									void this.threeRendererService.render()
								)
							;(this.oldMouse.x = this.mouse.x), (this.oldMouse.y = this.mouse.y)
							const i = this.threeSceneService.getMapMesh()
							if (i) {
								this.threeCameraService.camera.updateMatrixWorld(!1)
								let r = ""
								const o = this.transformHTMLToSceneCoordinates(),
									s = this.threeCameraService.camera
								s.isPerspectiveCamera && this.raycaster.setFromCamera(o, s)
								const a = this.calculateHoveredLabel(e)
								a && (this.threeSceneService.animateLabel(a.object, this.raycaster, e), (r = a.object.userData.node.path)),
									(this.intersectedBuilding = "" !== r ? i.getBuildingByPath(r) : i.checkMouseRayMeshIntersection(o, s))
								const c = this.threeSceneService.getHighlightedBuilding(),
									l = this.intersectedBuilding
								c?.id !== l?.id &&
									(this.clearLabelHoveredBuilding(),
									this.threeSceneService.resetLabel(),
									this.unhoverBuilding(),
									l && !this.isGrabbingOrMoving() && (this.setLabelHoveredLeaf(l, e), this.hoverBuilding(l)))
							}
						}
					}
					setLabelHoveredLeaf(e, i) {
						if (e?.node?.isLeaf) {
							const r = this.threeSceneService.getLabelForHoveredNode(e, i) ?? this.drawLabelHoveredBuilding(e)
							this.threeSceneService.animateLabel(r, this.raycaster, i)
						}
					}
					drawLabelHoveredBuilding(e) {
						this.codeMapLabelService.addLeafLabel(e.node, 0, !0)
						const r = this.threeSceneService.labels?.children,
							o = this.threeSceneService.getLabelForHoveredNode(e, r)
						return (this.labelHoveredBuilding = e.node), o
					}
					drawLabelSelectedBuilding(e) {
						if (
							(this.clearLabelHoveredBuilding(),
							null !== this.labelSelectedBuilding && this.codeMapLabelService.clearTemporaryLabel(this.labelSelectedBuilding),
							!e.node.isLeaf)
						)
							return
						this.codeMapLabelService.addLeafLabel(e.node, 0, !0)
						const i = this.threeSceneService.labels?.children,
							r = this.threeSceneService.getLabelForHoveredNode(e, i)
						return this.threeSceneService.animateLabel(r, this.raycaster, i), (this.labelSelectedBuilding = e.node), r
					}
					clearLabelHoveredBuilding() {
						null !== this.labelHoveredBuilding &&
							(this.codeMapLabelService.clearTemporaryLabel(this.labelHoveredBuilding), (this.labelHoveredBuilding = null))
					}
					clearLabelSelectedBuilding() {
						null !== this.labelSelectedBuilding &&
							(this.codeMapLabelService.clearTemporaryLabel(this.labelSelectedBuilding), (this.labelSelectedBuilding = null))
					}
					EnableOrbitalsRotation(e) {
						this.threeViewerService.enableRotation(e), this.viewCubeMouseEvents.enableRotation(e)
					}
					onDocumentMouseEnter() {
						this.EnableOrbitalsRotation(!0)
					}
					onDocumentMouseLeave(e) {
						e.relatedTarget instanceof HTMLCanvasElement || this.EnableOrbitalsRotation(!1)
					}
					onDocumentDoubleClick() {
						const e = this.threeSceneService.getHighlightedBuilding(),
							i = this.threeSceneService.getSelectedBuilding(),
							r = e?.node.link
						if ((r && !this.hasMouseMoved(this.mouseOnLastClick) && window.open(r, "_blank"), i?.node.isLeaf)) {
							const o = i.node.link
							if (o) return void window.open(o, "_blank")
						}
					}
					onDocumentMouseDown(e) {
						e.button === XS.RightClick && ((this.isMoving = !0), t.changeCursorIndicator(Qu.Moving)),
							e.button === XS.LeftClick && ((this.isGrabbing = !0), t.changeCursorIndicator(Qu.Grabbing)),
							(this.mouseOnLastClick = { x: e.clientX, y: e.clientY }),
							document.activeElement.blur()
					}
					onDocumentMouseUp(e) {
						this.viewCubeMouseEvents.resetIsDragging(),
							e.button === XS.LeftClick ? this.onLeftClick() : this.onRightClick(),
							t.changeCursorIndicator(void 0 !== this.intersectedBuilding ? Qu.Pointer : Qu.Default)
					}
					calculateHoveredLabel(e) {
						let i = null
						for (let r = 0; r < e?.length; r += 2) {
							const o = this.raycaster.intersectObject(this.threeSceneService.labels.children[r])
							o.length > 0 && (i = null === i ? o[0] : i.distance < o[0].distance ? i : o[0])
						}
						return i
					}
					onRightClick() {
						;(this.isMoving = !1),
							this.intersectedBuilding &&
								!this.hasMouseMovedMoreThanThreePixels(this.mouseOnLastClick) &&
								this.store.dispatch(
									xb({
										value: {
											nodeId: this.intersectedBuilding.node.id,
											xPositionOfRightClickEvent: this.mouse.x,
											yPositionOfRightClickEvent: this.mouse.y
										}
									})
								),
							this.threeRendererService.render()
					}
					onLeftClick() {
						;(this.isGrabbing = !1),
							this.hasMouseMovedMoreThanThreePixels(this.mouseOnLastClick) ||
								(this.intersectedBuilding
									? (this.threeSceneService.selectBuilding(this.intersectedBuilding),
									  this.drawLabelSelectedBuilding(this.intersectedBuilding))
									: (this.threeSceneService.clearSelection(), this.clearLabelSelectedBuilding()),
								this.threeSceneService.clearConstantHighlight()),
							this.threeRendererService.render()
					}
					hasMouseMovedMoreThanThreePixels({ x: e, y: i }) {
						return (
							Math.abs(this.mouse.x - e) > this.THRESHOLD_FOR_MOUSE_MOVEMENT_TRACKING ||
							Math.abs(this.mouse.y - i) > this.THRESHOLD_FOR_MOUSE_MOVEMENT_TRACKING
						)
					}
					hasMouseMoved({ x: e, y: i }) {
						return this.mouse.x !== e || this.mouse.y !== i
					}
					isGrabbingOrMoving() {
						return this.isGrabbing || this.isMoving
					}
					hoverBuilding(e, i = !0) {
						t.changeCursorIndicator(Qu.Pointer)
						const o = _b(this.state.getValue()).get(e.node.id)
						for (const { data: s } of $r(o)) {
							const a = this.idToBuilding.get(s.id)
							a && this.threeSceneService.addBuildingToHighlightingList(a)
						}
						this.threeSceneService.highlightBuildings(), i && this.store.dispatch(wb({ value: e.node.id }))
					}
					transformHTMLToSceneCoordinates() {
						const {
								renderer: e,
								renderer: { domElement: i }
							} = this.threeRendererService,
							r = e.getPixelRatio(),
							o = i.getBoundingClientRect()
						return { x: (this.mouse.x / i.width) * r * 2 - 1, y: (-(this.mouse.y - o.top) / i.height) * r * 2 + 1 }
					}
					unhoverBuilding(e = !0) {
						this.isGrabbingOrMoving() || t.changeCursorIndicator(Qu.Default),
							this.threeSceneService.getConstantHighlight().size > 0
								? this.threeSceneService.clearHoverHighlight()
								: this.threeSceneService.clearHighlight(),
							e && this.store.dispatch(wb({ value: null }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Td), re(Ri), re(Qc), re(Ct), re(Sr), re(cX), re(lX), re(aX), re(lw))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			const iO = () => new hb({ color: 16580095 }),
				rO = () => new hb({ color: 16580095 }),
				dX = () => new hb({ color: 16580095 })
			class Ml {
				static buildCube(n) {
					const e = 1 / n,
						i = (1 - e) / 2,
						r = new _l(e, i, i),
						o = new _l(i, i, i),
						s = new _l(e, e, i)
					return Ml.buildCubeGroup(r, o, s)
				}
				static buildCubeGroup(n, e, i) {
					const r = new ps(),
						{
							group: o,
							topLeft: s,
							topCenter: a,
							topRight: c,
							bottomLeft: l,
							bottomCenter: d,
							bottomRight: u,
							middleLeft: h,
							middleCenter: f,
							middleRight: _
						} = Ml.buildFullFace(n, e, i),
						{
							group: y,
							topLeft: C,
							topCenter: x,
							topRight: w,
							bottomLeft: S,
							bottomCenter: M,
							bottomRight: O,
							middleLeft: N,
							middleCenter: j,
							middleRight: le
						} = Ml.buildFullFace(n, e, i),
						ae = n.parameters.width / 2 + e.parameters.width / 2
					;(y.position.z -= ae), (o.position.z += ae)
					const {
						group: ce,
						topLeftMiddle: ue,
						topMiddleMiddle: Se,
						topRightMiddle: ve,
						middleLeftMiddle: W,
						middleRightMiddle: me,
						bottomLeftMiddle: Z,
						bottomMiddleMiddle: Ae,
						bottomRightMiddle: Ie
					} = Ml.buildMiddleRing(i, n, e)
					return (
						r.add(o),
						r.add(y),
						r.add(ce),
						{
							group: r,
							front: {
								top: { left: s, middle: a, right: c },
								middle: { left: _, middle: f, right: h },
								bottom: { left: l, middle: d, right: u }
							},
							back: {
								top: { left: C, middle: x, right: w },
								middle: { left: N, middle: j, right: le },
								bottom: { left: S, middle: M, right: O }
							},
							middle: {
								top: { left: ue, middle: Se, right: ve },
								middle: { left: W, right: me },
								bottom: { left: Z, middle: Ae, right: Ie }
							}
						}
					)
				}
				static buildMiddleRing(n, e, i) {
					const { group: r, left: o, right: s, center: a } = Ml.buildMiddleFace(n, e),
						{ group: c, left: l, right: d, center: u } = Ml.buildMiddleFace(n, e),
						h = new Mi(n, rO()),
						f = new Mi(n, rO()),
						_ = e.parameters.width / 2 + i.parameters.width / 2
					;(r.position.x -= _),
						(r.rotation.x = Math.PI / 2),
						(r.rotation.y = Math.PI / 2),
						(c.position.x += _),
						(c.rotation.x = Math.PI / 2),
						(c.rotation.y = Math.PI / 2),
						(f.position.y -= _),
						(f.rotation.x = Math.PI / 2),
						(h.position.y += _),
						(h.rotation.x = Math.PI / 2)
					const y = new ps()
					return (
						y.add(r),
						y.add(c),
						y.add(f),
						y.add(h),
						{
							group: y,
							topLeftMiddle: o,
							topMiddleMiddle: h,
							topRightMiddle: l,
							middleLeftMiddle: a,
							middleRightMiddle: u,
							bottomLeftMiddle: s,
							bottomMiddleMiddle: f,
							bottomRightMiddle: d
						}
					)
				}
				static buildFullFace(n, e, i) {
					const { group: r, left: o, right: s, center: a } = Ml.buildFullEdge(n, e),
						{ group: c, left: l, right: d, center: u } = Ml.buildFullEdge(n, e),
						h = n.parameters.height / 2 + i.parameters.height / 2
					;(r.position.y += h), (c.position.y -= h)
					const { group: f, left: _, right: y, center: C } = Ml.buildMiddleFace(i, n),
						x = new ps()
					return (
						x.add(r),
						x.add(c),
						x.add(f),
						{
							group: x,
							topLeft: o,
							topCenter: a,
							topRight: s,
							bottomLeft: l,
							bottomCenter: u,
							bottomRight: d,
							middleLeft: _,
							middleCenter: C,
							middleRight: y
						}
					)
				}
				static buildMiddleFace(n, e) {
					const i = new Mi(n, rO()),
						r = new Mi(e, iO()),
						o = new Mi(e, iO()),
						s = n.parameters.height / 2 + e.parameters.height / 2
					;(r.position.y -= s), (o.position.y += s)
					const a = new ps()
					return (a.rotation.z = Math.PI / 2), a.add(i), a.add(r), a.add(o), { group: a, left: r, right: o, center: i }
				}
				static buildFullEdge(n, e) {
					const i = new Mi(n, iO()),
						r = new Mi(e, dX()),
						o = new Mi(e, dX()),
						s = n.parameters.width / 2 + e.parameters.width / 2
					;(r.position.x -= s), (o.position.x += s)
					const a = new ps()
					return a.add(i), a.add(r), a.add(o), { group: a, left: r, right: o, center: i }
				}
			}
			let iMe = (() => {
					class t {
						constructor(e) {
							this.threeOrbitControlsService = e
						}
						centerMap() {
							this.threeOrbitControlsService.autoFitTo()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(El))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-center-map-button"]],
								decls: 2,
								vars: 0,
								consts: [
									["aria-label", "Center map in View", "title", "Center map", 1, "cc-shadow", 3, "click"],
									[1, "fa", "fa-compass"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.centerMap()
										}),
										fe(1, "i", 1),
										L())
								},
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-center-map-button button{position:absolute;right:15px;width:36px;height:36px;font-size:28px;border-radius:100%;color:#fff;background-color:#1b9cfc}cc-center-map-button button i{margin-top:2px}cc-center-map-button button:hover{cursor:pointer;color:#eee}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				rMe = (() => {
					class t {
						constructor(e, i, r) {
							;(this.elementReference = e),
								(this.threeOrbitControlsService = i),
								(this.viewCubeMouseEvents = r),
								(this.WIDTH = 200),
								(this.HEIGHT = 200),
								(this.LENGTH_VIEWCUBE = 1),
								(this.hoverInfo = { cube: null, originalMaterial: null }),
								(this.cubeDefinition = { front: null, middle: null, back: null }),
								(this.onCameraChanged = o => {
									const s = this.calculateCameraPosition(o.camera)
									this.setCameraPosition(s), this.renderer.render(this.scene, this.camera)
								}),
								(this.onCubeHovered = o => {
									;(this.hoverInfo = { cube: o.cube, originalMaterial: o.cube.material }),
										(this.hoverInfo.cube.material.emissive = new Lt(16777215)),
										this.renderer.render(this.scene, this.camera)
								}),
								(this.onCubeUnhovered = () => {
									;(this.hoverInfo.cube.material.emissive = new Lt(0)),
										(this.hoverInfo.cube = null),
										this.renderer.render(this.scene, this.camera)
								}),
								(this.onCubeClicked = o => {
									switch (o.cube) {
										case this.cubeDefinition.front.top.middle:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(0, -1, -1)
											break
										case this.cubeDefinition.front.top.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, -1, -1)
											break
										case this.cubeDefinition.front.top.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, -1, -1)
											break
										case this.cubeDefinition.front.middle.middle:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(0, 0, 0)
											break
										case this.cubeDefinition.front.middle.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, 0, -1)
											break
										case this.cubeDefinition.front.middle.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, 0, -1)
											break
										case this.cubeDefinition.front.bottom.middle:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(0, 1, -1)
											break
										case this.cubeDefinition.front.bottom.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, 1, -1)
											break
										case this.cubeDefinition.front.bottom.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, 1, -1)
											break
										case this.cubeDefinition.middle.middle.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, 0, 0)
											break
										case this.cubeDefinition.middle.top.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, -1, 0)
											break
										case this.cubeDefinition.middle.bottom.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, 1, 0)
											break
										case this.cubeDefinition.middle.middle.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, 0, 0)
											break
										case this.cubeDefinition.middle.top.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, -1, 0)
											break
										case this.cubeDefinition.middle.bottom.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, 1, 0)
											break
										case this.cubeDefinition.middle.top.middle:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(0, -1, 0)
											break
										case this.cubeDefinition.middle.bottom.middle:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(0, 1, 0)
											break
										case this.cubeDefinition.back.top.middle:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(0, -1, 1)
											break
										case this.cubeDefinition.back.top.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, -1, 1)
											break
										case this.cubeDefinition.back.top.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, -1, 1)
											break
										case this.cubeDefinition.back.middle.middle:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(0, 0, 1)
											break
										case this.cubeDefinition.back.middle.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, 0, 1)
											break
										case this.cubeDefinition.back.middle.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, 0, 1)
											break
										case this.cubeDefinition.back.bottom.middle:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(0, 1, 1)
											break
										case this.cubeDefinition.back.bottom.left:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(-1, 1, 1)
											break
										case this.cubeDefinition.back.bottom.right:
											this.threeOrbitControlsService.rotateCameraInVectorDirection(1, 1, 1)
									}
								})
						}
						ngOnInit() {
							this.initScene(),
								this.initLights(),
								this.initRenderer(this.elementReference.nativeElement),
								this.initCube(),
								this.initAxesHelper(),
								this.initCamera(),
								this.viewCubeMouseEvents.init(this.cubeGroup, this.camera, this.renderer),
								this.threeOrbitControlsService.subscribe("onCameraChanged", this.onCameraChanged),
								this.viewCubeMouseEvents.subscribe("viewCubeHoveredEvent", this.onCubeHovered),
								this.viewCubeMouseEvents.subscribe("viewCubeUnHoveredEvent", this.onCubeUnhovered),
								this.viewCubeMouseEvents.subscribe("viewCubeClicked", this.onCubeClicked)
						}
						initAxesHelper() {
							const e = new VP(1.3),
								i = -this.LENGTH_VIEWCUBE / 2 + 0.01
							;(e.position.x += i), (e.position.y += i), (e.position.z += i), this.scene.add(e)
						}
						initCube() {
							const { group: e, front: i, middle: r, back: o } = Ml.buildCube(1.6)
							;(this.cubeGroup = e),
								(this.cubeDefinition.front = i),
								(this.cubeDefinition.middle = r),
								(this.cubeDefinition.back = o)
							const s = new UP(this.cubeGroup, new Lt(0))
							this.scene.add(this.cubeGroup), this.scene.add(s)
						}
						setCameraPosition(e) {
							this.camera.position.set(e.x, e.y, e.z), this.camera.lookAt(0, 0, 0), this.camera.updateProjectionMatrix()
						}
						calculateCameraPosition(e) {
							const i = this.threeOrbitControlsService.controls.target.clone()
							return e.position.clone().sub(i).normalize().multiplyScalar(3)
						}
						initScene() {
							this.scene = new nb()
						}
						initRenderer(e) {
							;(this.renderer = new dr({ alpha: !0, antialias: !0 })),
								this.renderer.setSize(this.WIDTH, this.HEIGHT),
								this.renderer.setPixelRatio(window.devicePixelRatio),
								e.appendChild(this.renderer.domElement)
						}
						initCamera() {
							;(this.camera = new Co(45, this.WIDTH / this.HEIGHT, 0.1, 1e3)), (this.camera.position.z = 4)
						}
						initLights() {
							this.lights = new ps()
							const e = new nw(7368816, 1.2),
								i = new _p(14737632, 0.4)
							i.position.set(50, 10, 8).normalize()
							const r = new _p(14737632, 0.4)
							r.position.set(-50, 10, -8).normalize(),
								this.lights.add(e),
								this.lights.add(i),
								this.lights.add(r),
								this.scene.add(this.lights)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(El), P(lX))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-view-cube"]],
								decls: 1,
								vars: 0,
								template: function (i, r) {
									1 & i && fe(0, "cc-center-map-button")
								},
								dependencies: [iMe],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const oMe = Mt(nO, t => t.selectedBuildingId),
				bf = Mt(oMe, _b, (t, n) => n?.get(t)),
				sMe = ["tooltip"],
				uX = new He("mat-tooltip-scroll-strategy"),
				lMe = {
					provide: uX,
					deps: [ec],
					useFactory: function cMe(t) {
						return () => t.scrollStrategies.reposition({ scrollThrottle: 20 })
					}
				},
				uMe = new He("mat-tooltip-default-options", {
					providedIn: "root",
					factory: function dMe() {
						return { showDelay: 0, hideDelay: 0, touchendHideDelay: 1500 }
					}
				}),
				hX = "tooltip-panel",
				fX = Rm({ passive: !0 })
			let gMe = (() => {
					class t {
						get position() {
							return this._position
						}
						set position(e) {
							e !== this._position &&
								((this._position = e),
								this._overlayRef &&
									(this._updatePosition(this._overlayRef),
									this._tooltipInstance?.show(0),
									this._overlayRef.updatePosition()))
						}
						get positionAtOrigin() {
							return this._positionAtOrigin
						}
						set positionAtOrigin(e) {
							;(this._positionAtOrigin = Mn(e)), this._detach(), (this._overlayRef = null)
						}
						get disabled() {
							return this._disabled
						}
						set disabled(e) {
							;(this._disabled = Mn(e)), this._disabled ? this.hide(0) : this._setupPointerEnterEventsIfNeeded()
						}
						get showDelay() {
							return this._showDelay
						}
						set showDelay(e) {
							this._showDelay = to(e)
						}
						get hideDelay() {
							return this._hideDelay
						}
						set hideDelay(e) {
							;(this._hideDelay = to(e)),
								this._tooltipInstance && (this._tooltipInstance._mouseLeaveHideDelay = this._hideDelay)
						}
						get message() {
							return this._message
						}
						set message(e) {
							this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message, "tooltip"),
								(this._message = null != e ? String(e).trim() : ""),
								!this._message && this._isTooltipVisible()
									? this.hide(0)
									: (this._setupPointerEnterEventsIfNeeded(),
									  this._updateTooltipMessage(),
									  this._ngZone.runOutsideAngular(() => {
											Promise.resolve().then(() => {
												this._ariaDescriber.describe(this._elementRef.nativeElement, this.message, "tooltip")
											})
									  }))
						}
						get tooltipClass() {
							return this._tooltipClass
						}
						set tooltipClass(e) {
							;(this._tooltipClass = e), this._tooltipInstance && this._setTooltipClass(this._tooltipClass)
						}
						constructor(e, i, r, o, s, a, c, l, d, u, h, f) {
							;(this._overlay = e),
								(this._elementRef = i),
								(this._scrollDispatcher = r),
								(this._viewContainerRef = o),
								(this._ngZone = s),
								(this._platform = a),
								(this._ariaDescriber = c),
								(this._focusMonitor = l),
								(this._dir = u),
								(this._defaultOptions = h),
								(this._position = "below"),
								(this._positionAtOrigin = !1),
								(this._disabled = !1),
								(this._viewInitialized = !1),
								(this._pointerExitEventsInitialized = !1),
								(this._viewportMargin = 8),
								(this._cssClassPrefix = "mat"),
								(this.touchGestures = "auto"),
								(this._message = ""),
								(this._passiveListeners = []),
								(this._destroyed = new vt()),
								(this._scrollStrategy = d),
								(this._document = f),
								h &&
									((this._showDelay = h.showDelay),
									(this._hideDelay = h.hideDelay),
									h.position && (this.position = h.position),
									h.positionAtOrigin && (this.positionAtOrigin = h.positionAtOrigin),
									h.touchGestures && (this.touchGestures = h.touchGestures)),
								u.change.pipe(kr(this._destroyed)).subscribe(() => {
									this._overlayRef && this._updatePosition(this._overlayRef)
								})
						}
						ngAfterViewInit() {
							;(this._viewInitialized = !0),
								this._setupPointerEnterEventsIfNeeded(),
								this._focusMonitor
									.monitor(this._elementRef)
									.pipe(kr(this._destroyed))
									.subscribe(e => {
										e ? "keyboard" === e && this._ngZone.run(() => this.show()) : this._ngZone.run(() => this.hide(0))
									})
						}
						ngOnDestroy() {
							const e = this._elementRef.nativeElement
							clearTimeout(this._touchstartTimeout),
								this._overlayRef && (this._overlayRef.dispose(), (this._tooltipInstance = null)),
								this._passiveListeners.forEach(([i, r]) => {
									e.removeEventListener(i, r, fX)
								}),
								(this._passiveListeners.length = 0),
								this._destroyed.next(),
								this._destroyed.complete(),
								this._ariaDescriber.removeDescription(e, this.message, "tooltip"),
								this._focusMonitor.stopMonitoring(e)
						}
						show(e = this.showDelay, i) {
							if (this.disabled || !this.message || this._isTooltipVisible())
								return void this._tooltipInstance?._cancelPendingAnimations()
							const r = this._createOverlay(i)
							this._detach(), (this._portal = this._portal || new vv(this._tooltipComponent, this._viewContainerRef))
							const o = (this._tooltipInstance = r.attach(this._portal).instance)
							;(o._triggerElement = this._elementRef.nativeElement),
								(o._mouseLeaveHideDelay = this._hideDelay),
								o
									.afterHidden()
									.pipe(kr(this._destroyed))
									.subscribe(() => this._detach()),
								this._setTooltipClass(this._tooltipClass),
								this._updateTooltipMessage(),
								o.show(e)
						}
						hide(e = this.hideDelay) {
							const i = this._tooltipInstance
							i && (i.isVisible() ? i.hide(e) : (i._cancelPendingAnimations(), this._detach()))
						}
						toggle(e) {
							this._isTooltipVisible() ? this.hide() : this.show(void 0, e)
						}
						_isTooltipVisible() {
							return !!this._tooltipInstance && this._tooltipInstance.isVisible()
						}
						_createOverlay(e) {
							if (this._overlayRef) {
								const o = this._overlayRef.getConfig().positionStrategy
								if ((!this.positionAtOrigin || !e) && o._origin instanceof wn) return this._overlayRef
								this._detach()
							}
							const i = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),
								r = this._overlay
									.position()
									.flexibleConnectedTo((this.positionAtOrigin && e) || this._elementRef)
									.withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`)
									.withFlexibleDimensions(!1)
									.withViewportMargin(this._viewportMargin)
									.withScrollableContainers(i)
							return (
								r.positionChanges.pipe(kr(this._destroyed)).subscribe(o => {
									this._updateCurrentPositionClass(o.connectionPair),
										this._tooltipInstance &&
											o.scrollableViewProperties.isOverlayClipped &&
											this._tooltipInstance.isVisible() &&
											this._ngZone.run(() => this.hide(0))
								}),
								(this._overlayRef = this._overlay.create({
									direction: this._dir,
									positionStrategy: r,
									panelClass: `${this._cssClassPrefix}-${hX}`,
									scrollStrategy: this._scrollStrategy()
								})),
								this._updatePosition(this._overlayRef),
								this._overlayRef
									.detachments()
									.pipe(kr(this._destroyed))
									.subscribe(() => this._detach()),
								this._overlayRef
									.outsidePointerEvents()
									.pipe(kr(this._destroyed))
									.subscribe(() => this._tooltipInstance?._handleBodyInteraction()),
								this._overlayRef
									.keydownEvents()
									.pipe(kr(this._destroyed))
									.subscribe(o => {
										this._isTooltipVisible() &&
											27 === o.keyCode &&
											!fl(o) &&
											(o.preventDefault(), o.stopPropagation(), this._ngZone.run(() => this.hide(0)))
									}),
								this._defaultOptions?.disableTooltipInteractivity &&
									this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`),
								this._overlayRef
							)
						}
						_detach() {
							this._overlayRef && this._overlayRef.hasAttached() && this._overlayRef.detach(), (this._tooltipInstance = null)
						}
						_updatePosition(e) {
							const i = e.getConfig().positionStrategy,
								r = this._getOrigin(),
								o = this._getOverlayPosition()
							i.withPositions([this._addOffset({ ...r.main, ...o.main }), this._addOffset({ ...r.fallback, ...o.fallback })])
						}
						_addOffset(e) {
							return e
						}
						_getOrigin() {
							const e = !this._dir || "ltr" == this._dir.value,
								i = this.position
							let r
							"above" == i || "below" == i
								? (r = { originX: "center", originY: "above" == i ? "top" : "bottom" })
								: "before" == i || ("left" == i && e) || ("right" == i && !e)
								? (r = { originX: "start", originY: "center" })
								: ("after" == i || ("right" == i && e) || ("left" == i && !e)) &&
								  (r = { originX: "end", originY: "center" })
							const { x: o, y: s } = this._invertPosition(r.originX, r.originY)
							return { main: r, fallback: { originX: o, originY: s } }
						}
						_getOverlayPosition() {
							const e = !this._dir || "ltr" == this._dir.value,
								i = this.position
							let r
							"above" == i
								? (r = { overlayX: "center", overlayY: "bottom" })
								: "below" == i
								? (r = { overlayX: "center", overlayY: "top" })
								: "before" == i || ("left" == i && e) || ("right" == i && !e)
								? (r = { overlayX: "end", overlayY: "center" })
								: ("after" == i || ("right" == i && e) || ("left" == i && !e)) &&
								  (r = { overlayX: "start", overlayY: "center" })
							const { x: o, y: s } = this._invertPosition(r.overlayX, r.overlayY)
							return { main: r, fallback: { overlayX: o, overlayY: s } }
						}
						_updateTooltipMessage() {
							this._tooltipInstance &&
								((this._tooltipInstance.message = this.message),
								this._tooltipInstance._markForCheck(),
								this._ngZone.onMicrotaskEmpty.pipe(Do(1), kr(this._destroyed)).subscribe(() => {
									this._tooltipInstance && this._overlayRef.updatePosition()
								}))
						}
						_setTooltipClass(e) {
							this._tooltipInstance && ((this._tooltipInstance.tooltipClass = e), this._tooltipInstance._markForCheck())
						}
						_invertPosition(e, i) {
							return (
								"above" === this.position || "below" === this.position
									? "top" === i
										? (i = "bottom")
										: "bottom" === i && (i = "top")
									: "end" === e
									? (e = "start")
									: "start" === e && (e = "end"),
								{ x: e, y: i }
							)
						}
						_updateCurrentPositionClass(e) {
							const { overlayY: i, originX: r, originY: o } = e
							let s
							if (
								((s =
									"center" === i
										? this._dir && "rtl" === this._dir.value
											? "end" === r
												? "left"
												: "right"
											: "start" === r
											? "left"
											: "right"
										: "bottom" === i && "top" === o
										? "above"
										: "below"),
								s !== this._currentPosition)
							) {
								const a = this._overlayRef
								if (a) {
									const c = `${this._cssClassPrefix}-${hX}-`
									a.removePanelClass(c + this._currentPosition), a.addPanelClass(c + s)
								}
								this._currentPosition = s
							}
						}
						_setupPointerEnterEventsIfNeeded() {
							this._disabled ||
								!this.message ||
								!this._viewInitialized ||
								this._passiveListeners.length ||
								(this._platformSupportsMouseEvents()
									? this._passiveListeners.push([
											"mouseenter",
											e => {
												let i
												this._setupPointerExitEventsIfNeeded(),
													void 0 !== e.x && void 0 !== e.y && (i = e),
													this.show(void 0, i)
											}
									  ])
									: "off" !== this.touchGestures &&
									  (this._disableNativeGesturesIfNecessary(),
									  this._passiveListeners.push([
											"touchstart",
											e => {
												const i = e.targetTouches?.[0],
													r = i ? { x: i.clientX, y: i.clientY } : void 0
												this._setupPointerExitEventsIfNeeded(),
													clearTimeout(this._touchstartTimeout),
													(this._touchstartTimeout = setTimeout(() => this.show(void 0, r), 500))
											}
									  ])),
								this._addListeners(this._passiveListeners))
						}
						_setupPointerExitEventsIfNeeded() {
							if (this._pointerExitEventsInitialized) return
							this._pointerExitEventsInitialized = !0
							const e = []
							if (this._platformSupportsMouseEvents())
								e.push(
									[
										"mouseleave",
										i => {
											const r = i.relatedTarget
											;(!r || !this._overlayRef?.overlayElement.contains(r)) && this.hide()
										}
									],
									["wheel", i => this._wheelListener(i)]
								)
							else if ("off" !== this.touchGestures) {
								this._disableNativeGesturesIfNecessary()
								const i = () => {
									clearTimeout(this._touchstartTimeout), this.hide(this._defaultOptions.touchendHideDelay)
								}
								e.push(["touchend", i], ["touchcancel", i])
							}
							this._addListeners(e), this._passiveListeners.push(...e)
						}
						_addListeners(e) {
							e.forEach(([i, r]) => {
								this._elementRef.nativeElement.addEventListener(i, r, fX)
							})
						}
						_platformSupportsMouseEvents() {
							return !this._platform.IOS && !this._platform.ANDROID
						}
						_wheelListener(e) {
							if (this._isTooltipVisible()) {
								const i = this._document.elementFromPoint(e.clientX, e.clientY),
									r = this._elementRef.nativeElement
								i !== r && !r.contains(i) && this.hide()
							}
						}
						_disableNativeGesturesIfNecessary() {
							const e = this.touchGestures
							if ("off" !== e) {
								const i = this._elementRef.nativeElement,
									r = i.style
								;("on" === e || ("INPUT" !== i.nodeName && "TEXTAREA" !== i.nodeName)) &&
									(r.userSelect = r.msUserSelect = r.webkitUserSelect = r.MozUserSelect = "none"),
									("on" === e || !i.draggable) && (r.webkitUserDrag = "none"),
									(r.touchAction = "none"),
									(r.webkitTapHighlightColor = "transparent")
							}
						}
						static {
							this.ɵfac = function (i) {
								Am()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								inputs: {
									position: ["matTooltipPosition", "position"],
									positionAtOrigin: ["matTooltipPositionAtOrigin", "positionAtOrigin"],
									disabled: ["matTooltipDisabled", "disabled"],
									showDelay: ["matTooltipShowDelay", "showDelay"],
									hideDelay: ["matTooltipHideDelay", "hideDelay"],
									touchGestures: ["matTooltipTouchGestures", "touchGestures"],
									message: ["matTooltip", "message"],
									tooltipClass: ["matTooltipClass", "tooltipClass"]
								}
							})
						}
					}
					return t
				})(),
				mX = (() => {
					class t extends gMe {
						constructor(e, i, r, o, s, a, c, l, d, u, h, f) {
							super(e, i, r, o, s, a, c, l, d, u, h, f),
								(this._tooltipComponent = _Me),
								(this._cssClassPrefix = "mat-mdc"),
								(this._viewportMargin = 8)
						}
						_addOffset(e) {
							const r = !this._dir || "ltr" == this._dir.value
							return (
								"top" === e.originY
									? (e.offsetY = -8)
									: "bottom" === e.originY
									? (e.offsetY = 8)
									: "start" === e.originX
									? (e.offsetX = r ? -8 : 8)
									: "end" === e.originX && (e.offsetX = r ? 8 : -8),
								e
							)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(
									P(ec),
									P(wn),
									P(pG),
									P(ra),
									P(mn),
									P(Wr),
									P(pAe),
									P(fd),
									P(uX),
									P(wu, 8),
									P(uMe, 8),
									P(wi)
								)
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "matTooltip", ""]],
								hostAttrs: [1, "mat-mdc-tooltip-trigger"],
								hostVars: 2,
								hostBindings: function (i, r) {
									2 & i && Zt("mat-mdc-tooltip-disabled", r.disabled)
								},
								exportAs: ["matTooltip"],
								features: [pn]
							})
						}
					}
					return t
				})(),
				bMe = (() => {
					class t {
						constructor(e, i) {
							;(this._changeDetectorRef = e),
								(this._closeOnInteraction = !1),
								(this._isVisible = !1),
								(this._onHide = new vt()),
								(this._animationsDisabled = "NoopAnimations" === i)
						}
						show(e) {
							null != this._hideTimeoutId && clearTimeout(this._hideTimeoutId),
								(this._showTimeoutId = setTimeout(() => {
									this._toggleVisibility(!0), (this._showTimeoutId = void 0)
								}, e))
						}
						hide(e) {
							null != this._showTimeoutId && clearTimeout(this._showTimeoutId),
								(this._hideTimeoutId = setTimeout(() => {
									this._toggleVisibility(!1), (this._hideTimeoutId = void 0)
								}, e))
						}
						afterHidden() {
							return this._onHide
						}
						isVisible() {
							return this._isVisible
						}
						ngOnDestroy() {
							this._cancelPendingAnimations(), this._onHide.complete(), (this._triggerElement = null)
						}
						_handleBodyInteraction() {
							this._closeOnInteraction && this.hide(0)
						}
						_markForCheck() {
							this._changeDetectorRef.markForCheck()
						}
						_handleMouseLeave({ relatedTarget: e }) {
							;(!e || !this._triggerElement.contains(e)) &&
								(this.isVisible() ? this.hide(this._mouseLeaveHideDelay) : this._finalizeAnimation(!1))
						}
						_onShow() {}
						_handleAnimationEnd({ animationName: e }) {
							;(e === this._showAnimation || e === this._hideAnimation) && this._finalizeAnimation(e === this._showAnimation)
						}
						_cancelPendingAnimations() {
							null != this._showTimeoutId && clearTimeout(this._showTimeoutId),
								null != this._hideTimeoutId && clearTimeout(this._hideTimeoutId),
								(this._showTimeoutId = this._hideTimeoutId = void 0)
						}
						_finalizeAnimation(e) {
							e ? (this._closeOnInteraction = !0) : this.isVisible() || this._onHide.next()
						}
						_toggleVisibility(e) {
							const i = this._tooltip.nativeElement,
								r = this._showAnimation,
								o = this._hideAnimation
							if (
								(i.classList.remove(e ? o : r),
								i.classList.add(e ? r : o),
								(this._isVisible = e),
								e && !this._animationsDisabled && "function" == typeof getComputedStyle)
							) {
								const s = getComputedStyle(i)
								;("0s" === s.getPropertyValue("animation-duration") || "none" === s.getPropertyValue("animation-name")) &&
									(this._animationsDisabled = !0)
							}
							e && this._onShow(),
								this._animationsDisabled && (i.classList.add("_mat-animation-noopable"), this._finalizeAnimation(e))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Jr), P(Bo, 8))
							}
						}
						static {
							this.ɵdir = yt({ type: t })
						}
					}
					return t
				})(),
				_Me = (() => {
					class t extends bMe {
						constructor(e, i, r) {
							super(e, r),
								(this._elementRef = i),
								(this._isMultiline = !1),
								(this._showAnimation = "mat-mdc-tooltip-show"),
								(this._hideAnimation = "mat-mdc-tooltip-hide")
						}
						_onShow() {
							;(this._isMultiline = this._isTooltipMultiline()), this._markForCheck()
						}
						_isTooltipMultiline() {
							const e = this._elementRef.nativeElement.getBoundingClientRect()
							return e.height > 24 && e.width >= 200
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Jr), P(wn), P(Bo, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-tooltip-component"]],
								viewQuery: function (i, r) {
									if ((1 & i && _i(sMe, 7), 2 & i)) {
										let o
										sn((o = an())) && (r._tooltip = o.first)
									}
								},
								hostAttrs: ["aria-hidden", "true"],
								hostVars: 2,
								hostBindings: function (i, r) {
									1 & i &&
										Le("mouseleave", function (s) {
											return r._handleMouseLeave(s)
										}),
										2 & i && bi("zoom", r.isVisible() ? 1 : null)
								},
								features: [pn],
								decls: 4,
								vars: 4,
								consts: [
									[1, "mdc-tooltip", "mdc-tooltip--shown", "mat-mdc-tooltip", 3, "ngClass", "animationend"],
									["tooltip", ""],
									[1, "mdc-tooltip__surface", "mdc-tooltip__surface-animation"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div", 0, 1),
										Le("animationend", function (s) {
											return r._handleAnimationEnd(s)
										}),
										F(2, "div", 2),
										ge(3),
										L()()),
										2 & i &&
											(Zt("mdc-tooltip--multiline", r._isMultiline),
											U("ngClass", r.tooltipClass),
											T(3),
											cr(r.message))
								},
								dependencies: [Em],
								styles: [
									'.mdc-tooltip__surface{word-break:break-all;word-break:var(--mdc-tooltip-word-break, normal);overflow-wrap:anywhere}.mdc-tooltip--showing-transition .mdc-tooltip__surface-animation{transition:opacity 150ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-tooltip--hide-transition .mdc-tooltip__surface-animation{transition:opacity 75ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-tooltip{position:fixed;display:none;z-index:9}.mdc-tooltip-wrapper--rich{position:relative}.mdc-tooltip--shown,.mdc-tooltip--showing,.mdc-tooltip--hide{display:inline-flex}.mdc-tooltip--shown.mdc-tooltip--rich,.mdc-tooltip--showing.mdc-tooltip--rich,.mdc-tooltip--hide.mdc-tooltip--rich{display:inline-block;left:-320px;position:absolute}.mdc-tooltip__surface{line-height:16px;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center}.mdc-tooltip__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-tooltip__surface::before{border-color:CanvasText}}.mdc-tooltip--rich .mdc-tooltip__surface{align-items:flex-start;display:flex;flex-direction:column;min-height:24px;min-width:40px;max-width:320px;position:relative}.mdc-tooltip--multiline .mdc-tooltip__surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mdc-tooltip__surface,.mdc-tooltip--multiline .mdc-tooltip__surface[dir=rtl]{text-align:right}.mdc-tooltip__surface .mdc-tooltip__title{margin:0 8px}.mdc-tooltip__surface .mdc-tooltip__content{max-width:calc(200px - (2 * 8px));margin:8px;text-align:left}[dir=rtl] .mdc-tooltip__surface .mdc-tooltip__content,.mdc-tooltip__surface .mdc-tooltip__content[dir=rtl]{text-align:right}.mdc-tooltip--rich .mdc-tooltip__surface .mdc-tooltip__content{max-width:calc(320px - (2 * 8px));align-self:stretch}.mdc-tooltip__surface .mdc-tooltip__content-link{text-decoration:none}.mdc-tooltip--rich-actions,.mdc-tooltip__content,.mdc-tooltip__title{z-index:1}.mdc-tooltip__surface-animation{opacity:0;transform:scale(0.8);will-change:transform,opacity}.mdc-tooltip--shown .mdc-tooltip__surface-animation{transform:scale(1);opacity:1}.mdc-tooltip--hide .mdc-tooltip__surface-animation{transform:scale(1)}.mdc-tooltip__caret-surface-top,.mdc-tooltip__caret-surface-bottom{position:absolute;height:24px;width:24px;transform:rotate(35deg) skewY(20deg) scaleX(0.9396926208)}.mdc-tooltip__caret-surface-top .mdc-elevation-overlay,.mdc-tooltip__caret-surface-bottom .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-tooltip__caret-surface-bottom{box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);outline:1px solid rgba(0,0,0,0);z-index:-1}@media screen and (forced-colors: active){.mdc-tooltip__caret-surface-bottom{outline-color:CanvasText}}.mat-mdc-tooltip{--mdc-plain-tooltip-container-shape:4px;--mdc-plain-tooltip-supporting-text-line-height:16px}.mat-mdc-tooltip .mdc-tooltip__surface{background-color:var(--mdc-plain-tooltip-container-color)}.mat-mdc-tooltip .mdc-tooltip__surface{border-radius:var(--mdc-plain-tooltip-container-shape)}.mat-mdc-tooltip .mdc-tooltip__caret-surface-top,.mat-mdc-tooltip .mdc-tooltip__caret-surface-bottom{border-radius:var(--mdc-plain-tooltip-container-shape)}.mat-mdc-tooltip .mdc-tooltip__surface{color:var(--mdc-plain-tooltip-supporting-text-color)}.mat-mdc-tooltip .mdc-tooltip__surface{font-family:var(--mdc-plain-tooltip-supporting-text-font);line-height:var(--mdc-plain-tooltip-supporting-text-line-height);font-size:var(--mdc-plain-tooltip-supporting-text-size);font-weight:var(--mdc-plain-tooltip-supporting-text-weight);letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking)}.mat-mdc-tooltip{position:relative;transform:scale(0)}.mat-mdc-tooltip::before{content:"";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}'
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				pX = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [lMe], imports: [ZD, Ot, Ev, Yi, Yi, _v] })
						}
					}
					return t
				})()
			const _f = Mt(_u, t => ad(t)),
				vMe = Mt(bf, t => {
					if (t)
						return {
							all: t.attributes?.unary ?? 0,
							added: t.fileCount?.added ?? 0,
							removed: t.fileCount?.removed ?? 0,
							changed: t.fileCount?.changed ?? 0
						}
				})
			function yMe(t, n) {
				if (
					(1 & t &&
						(F(0, "span", 4),
						ge(1, " | "),
						F(2, "span", 5),
						ge(3),
						L(),
						ge(4, " | "),
						F(5, "span", 6),
						ge(6),
						L(),
						ge(7, " | "),
						F(8, "span", 7),
						ge(9),
						L()()),
					2 & t)
				) {
					const e = Te().ngIf
					T(3),
						Vt(" \u0394", e.added, ""),
						T(3),
						Vt(" \u0394", e.removed > 0 ? -e.removed : 0, ""),
						T(3),
						Vt(" \u0394", e.changed, "")
				}
			}
			function wMe(t, n) {
				if ((1 & t && (F(0, "span", 4), ge(1), Ee(2, yMe, 10, 3, "span", 3), Me(3, "async"), ge(4, ") "), L()), 2 & t)) {
					const e = n.ngIf,
						i = Te(2)
					T(1),
						JA(" ( ", e.all, " ", 1 === e.all ? "file" : "files", " "),
						T(1),
						U("ngIf", (null == i.node.children ? null : i.node.children.length) && De(3, 3, i.isDeltaMode$))
				}
			}
			function xMe(t, n) {
				if ((1 & t && (F(0, "span", 2), ge(1), Ee(2, wMe, 5, 5, "span", 3), Me(3, "async"), L()), 2 & t)) {
					const e = Te()
					T(1),
						Vt(" ", e.node.path, " "),
						T(1),
						U("ngIf", De(3, 2, (null == e.node.children ? null : e.node.children.length) && e.fileCount$))
				}
			}
			let CMe = (() => {
					class t {
						constructor(e) {
							;(this.fileCount$ = e.select(vMe)), (this.isDeltaMode$ = e.select(_f))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-node-path"]],
								inputs: { node: "node" },
								decls: 2,
								vars: 1,
								consts: [
									[1, "cc-node-path"],
									["class", "file-path", 4, "ngIf"],
									[1, "file-path"],
									["class", "cc-node-file-count", 4, "ngIf"],
									[1, "cc-node-file-count"],
									["title", "Number of added files", 1, "added-files"],
									["title", "Number of removed files", 1, "removed-files"],
									["title", "Number of files with metric changes", 1, "files-with-metric-changes"]
								],
								template: function (i, r) {
									1 & i && (F(0, "p", 0), Ee(1, xMe, 4, 4, "span", 1), L()), 2 & i && (T(1), U("ngIf", r.node))
								},
								dependencies: [En, Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				oO = (() => {
					class t {
						transform(e) {
							return pf.withoutCCExtension(e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "removeExtension", type: t, pure: !0 })
						}
					}
					return t
				})()
			function EMe(t, n) {
				if ((1 & t && (F(0, "div", 5)(1, "a", 6)(2, "h2"), ge(3), L(), fe(4, "i", 7), L()()), 2 & t)) {
					const e = Te(2)
					Fa("matTooltip", e.node.link),
						U("matTooltipShowDelay", 200),
						T(1),
						Fa("href", e.node.link, fm),
						T(2),
						Vt("", e.node.name, "\xa0")
				}
			}
			function MMe(t, n) {
				if (1 & t) {
					const e = ri()
					Cr(0),
						F(1, "i", 1),
						Le("click", function () {
							return rn(e), on(Te().closeSideBar())
						}),
						L(),
						Ee(2, EMe, 5, 4, "div", 2),
						F(3, "p", 3),
						ge(4),
						Me(5, "removeExtension"),
						L(),
						fe(6, "cc-node-path", 4),
						Er()
				}
				if (2 & t) {
					const e = Te()
					T(2), U("ngIf", e.node.link), T(2), cr(De(5, 3, e.fileName)), T(2), U("node", e.node)
				}
			}
			let SMe = (() => {
				class t {
					constructor(e) {
						this.isAttributeSideBarVisibleService = e
					}
					closeSideBar() {
						this.isAttributeSideBarVisibleService.isOpen = !1
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(KS))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-attribute-side-bar-header-section"]],
							inputs: { node: "node", fileName: "fileName" },
							decls: 1,
							vars: 1,
							consts: [
								[4, "ngIf"],
								[1, "close-icon", "fa", "fa-times", 3, "click"],
								["data-testid", "file-link", "class", "node-name", 3, "matTooltip", "matTooltipShowDelay", 4, "ngIf"],
								[1, "node-origin"],
								[3, "node"],
								["data-testid", "file-link", 1, "node-name", 3, "matTooltip", "matTooltipShowDelay"],
								["target", "_blank", "rel", "noopener noreferrer", 1, "node-link", 3, "href"],
								[1, "fa", "fa-external-link"]
							],
							template: function (i, r) {
								1 & i && Ee(0, MMe, 7, 5, "ng-container", 0), 2 & i && U("ngIf", r.node)
							},
							dependencies: [En, mX, CMe, oO],
							styles: [
								"cc-attribute-side-bar-header-section{display:flex;flex-direction:column}cc-attribute-side-bar-header-section .close-icon,cc-attribute-side-bar-header-section .node-link{color:gray;padding:0;cursor:pointer;outline:none;transition:.2s}cc-attribute-side-bar-header-section .close-icon:hover,cc-attribute-side-bar-header-section .node-link:hover{color:#444}cc-attribute-side-bar-header-section .close-icon{align-self:flex-end;font-size:20px}cc-attribute-side-bar-header-section .node-name{width:90%;cursor:pointer}cc-attribute-side-bar-header-section .node-name .node-link{font-size:11pt}cc-attribute-side-bar-header-section .node-name .node-link h2{color:#000;display:inline}cc-attribute-side-bar-header-section .node-origin,cc-attribute-side-bar-header-section .cc-node-path{color:gray;margin:5px 0}cc-attribute-side-bar-header-section .node-origin .file-path,cc-attribute-side-bar-header-section .cc-node-path .file-path{word-wrap:break-word}cc-attribute-side-bar-header-section .node-origin .cc-node-file-count,cc-attribute-side-bar-header-section .cc-node-path .cc-node-file-count{background:#f0f0f0;border-radius:3px;padding:1px 3px;color:#000}cc-attribute-side-bar-header-section .node-origin .cc-node-file-count .added-files,cc-attribute-side-bar-header-section .cc-node-path .cc-node-file-count .added-files{color:#64d051}cc-attribute-side-bar-header-section .node-origin .cc-node-file-count .removed-files,cc-attribute-side-bar-header-section .cc-node-path .cc-node-file-count .removed-files{color:#ff0e0e}cc-attribute-side-bar-header-section .node-origin .cc-node-file-count .changed-files,cc-attribute-side-bar-header-section .cc-node-path .cc-node-file-count .changed-files{color:#0e2eff}cc-attribute-side-bar-header-section .node-name,cc-attribute-side-bar-header-section .node-origin,cc-attribute-side-bar-header-section .node-path{word-break:break-all;-webkit-user-select:text;user-select:text}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const sO = Mt(bf, t => t && !uo(t)),
				Cb = Mt(cc, t => t.areaMetric),
				zu = Mt(cc, t => t.edgeMetric),
				Aw = Mt(cc, t => t.heightMetric),
				YS = Mt(Cb, Aw, Af, zu, (t, n, e, i) => ({ areaMetric: t, heightMetric: n, colorMetric: e, edgeMetric: i })),
				kMe = Mt(bf, YS, (t, n) => {
					if (t)
						return {
							area: { name: n.areaMetric, value: t.attributes[n.areaMetric] },
							height: { name: n.heightMetric, value: t.attributes[n.heightMetric] },
							color: { name: n.colorMetric, value: t.attributes[n.colorMetric] },
							edge: TMe(n.edgeMetric, t)
						}
				})
			function TMe(t, n) {
				return null == t ? null : { name: t, incoming: n.edgeAttributes[t]?.incoming, outgoing: n.edgeAttributes[t]?.outgoing }
			}
			const qS = Mt(fv, t => t.attributeDescriptors)
			class ZS {
				get selected() {
					return this._selected || (this._selected = Array.from(this._selection.values())), this._selected
				}
				constructor(n = !1, e, i = !0, r) {
					;(this._multiple = n),
						(this._emitChanges = i),
						(this.compareWith = r),
						(this._selection = new Set()),
						(this._deselectedToEmit = []),
						(this._selectedToEmit = []),
						(this.changed = new vt()),
						e &&
							e.length &&
							(n ? e.forEach(o => this._markSelected(o)) : this._markSelected(e[0]), (this._selectedToEmit.length = 0))
				}
				select(...n) {
					this._verifyValueAssignment(n), n.forEach(i => this._markSelected(i))
					const e = this._hasQueuedChanges()
					return this._emitChangeEvent(), e
				}
				deselect(...n) {
					this._verifyValueAssignment(n), n.forEach(i => this._unmarkSelected(i))
					const e = this._hasQueuedChanges()
					return this._emitChangeEvent(), e
				}
				setSelection(...n) {
					this._verifyValueAssignment(n)
					const e = this.selected,
						i = new Set(n)
					n.forEach(o => this._markSelected(o)), e.filter(o => !i.has(o)).forEach(o => this._unmarkSelected(o))
					const r = this._hasQueuedChanges()
					return this._emitChangeEvent(), r
				}
				toggle(n) {
					return this.isSelected(n) ? this.deselect(n) : this.select(n)
				}
				clear(n = !0) {
					this._unmarkAll()
					const e = this._hasQueuedChanges()
					return n && this._emitChangeEvent(), e
				}
				isSelected(n) {
					return this._selection.has(this._getConcreteValue(n))
				}
				isEmpty() {
					return 0 === this._selection.size
				}
				hasValue() {
					return !this.isEmpty()
				}
				sort(n) {
					this._multiple && this.selected && this._selected.sort(n)
				}
				isMultipleSelection() {
					return this._multiple
				}
				_emitChangeEvent() {
					;(this._selected = null),
						(this._selectedToEmit.length || this._deselectedToEmit.length) &&
							(this.changed.next({ source: this, added: this._selectedToEmit, removed: this._deselectedToEmit }),
							(this._deselectedToEmit = []),
							(this._selectedToEmit = []))
				}
				_markSelected(n) {
					;(n = this._getConcreteValue(n)),
						this.isSelected(n) ||
							(this._multiple || this._unmarkAll(),
							this.isSelected(n) || this._selection.add(n),
							this._emitChanges && this._selectedToEmit.push(n))
				}
				_unmarkSelected(n) {
					;(n = this._getConcreteValue(n)),
						this.isSelected(n) && (this._selection.delete(n), this._emitChanges && this._deselectedToEmit.push(n))
				}
				_unmarkAll() {
					this.isEmpty() || this._selection.forEach(n => this._unmarkSelected(n))
				}
				_verifyValueAssignment(n) {}
				_hasQueuedChanges() {
					return !(!this._deselectedToEmit.length && !this._selectedToEmit.length)
				}
				_getConcreteValue(n) {
					if (this.compareWith) {
						for (let e of this._selection) if (this.compareWith(n, e)) return e
						return n
					}
					return n
				}
			}
			let AX = (() => {
				class t {
					constructor() {
						this._listeners = []
					}
					notify(e, i) {
						for (let r of this._listeners) r(e, i)
					}
					listen(e) {
						return (
							this._listeners.push(e),
							() => {
								this._listeners = this._listeners.filter(i => e !== i)
							}
						)
					}
					ngOnDestroy() {
						this._listeners = []
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			const FMe = ["button"],
				BMe = ["*"],
				gX = new He("MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS"),
				bX = new He("MatButtonToggleGroup"),
				IMe = { provide: ds, useExisting: Kn(() => aO), multi: !0 }
			let _X = 0
			class vX {
				constructor(n, e) {
					;(this.source = n), (this.value = e)
				}
			}
			let aO = (() => {
				class t {
					get name() {
						return this._name
					}
					set name(e) {
						;(this._name = e), this._markButtonsForCheck()
					}
					get vertical() {
						return this._vertical
					}
					set vertical(e) {
						this._vertical = Mn(e)
					}
					get value() {
						const e = this._selectionModel ? this._selectionModel.selected : []
						return this.multiple ? e.map(i => i.value) : e[0] ? e[0].value : void 0
					}
					set value(e) {
						this._setSelectionByValue(e), this.valueChange.emit(this.value)
					}
					get selected() {
						const e = this._selectionModel ? this._selectionModel.selected : []
						return this.multiple ? e : e[0] || null
					}
					get multiple() {
						return this._multiple
					}
					set multiple(e) {
						;(this._multiple = Mn(e)), this._markButtonsForCheck()
					}
					get disabled() {
						return this._disabled
					}
					set disabled(e) {
						;(this._disabled = Mn(e)), this._markButtonsForCheck()
					}
					constructor(e, i) {
						;(this._changeDetector = e),
							(this._vertical = !1),
							(this._multiple = !1),
							(this._disabled = !1),
							(this._controlValueAccessorChangeFn = () => {}),
							(this._onTouched = () => {}),
							(this._name = "mat-button-toggle-group-" + _X++),
							(this.valueChange = new _n()),
							(this.change = new _n()),
							(this.appearance = i && i.appearance ? i.appearance : "standard")
					}
					ngOnInit() {
						this._selectionModel = new ZS(this.multiple, void 0, !1)
					}
					ngAfterContentInit() {
						this._selectionModel.select(...this._buttonToggles.filter(e => e.checked))
					}
					writeValue(e) {
						;(this.value = e), this._changeDetector.markForCheck()
					}
					registerOnChange(e) {
						this._controlValueAccessorChangeFn = e
					}
					registerOnTouched(e) {
						this._onTouched = e
					}
					setDisabledState(e) {
						this.disabled = e
					}
					_emitChangeEvent(e) {
						const i = new vX(e, this.value)
						;(this._rawValue = i.value), this._controlValueAccessorChangeFn(i.value), this.change.emit(i)
					}
					_syncButtonToggle(e, i, r = !1, o = !1) {
						!this.multiple && this.selected && !e.checked && (this.selected.checked = !1),
							this._selectionModel ? (i ? this._selectionModel.select(e) : this._selectionModel.deselect(e)) : (o = !0),
							o ? Promise.resolve().then(() => this._updateModelValue(e, r)) : this._updateModelValue(e, r)
					}
					_isSelected(e) {
						return this._selectionModel && this._selectionModel.isSelected(e)
					}
					_isPrechecked(e) {
						return (
							!(typeof this._rawValue > "u") &&
							(this.multiple && Array.isArray(this._rawValue)
								? this._rawValue.some(i => null != e.value && i === e.value)
								: e.value === this._rawValue)
						)
					}
					_setSelectionByValue(e) {
						;(this._rawValue = e),
							this._buttonToggles &&
								(this.multiple && e
									? (Array.isArray(e), this._clearSelection(), e.forEach(i => this._selectValue(i)))
									: (this._clearSelection(), this._selectValue(e)))
					}
					_clearSelection() {
						this._selectionModel.clear(), this._buttonToggles.forEach(e => (e.checked = !1))
					}
					_selectValue(e) {
						const i = this._buttonToggles.find(r => null != r.value && r.value === e)
						i && ((i.checked = !0), this._selectionModel.select(i))
					}
					_updateModelValue(e, i) {
						i && this._emitChangeEvent(e), this.valueChange.emit(this.value)
					}
					_markButtonsForCheck() {
						this._buttonToggles?.forEach(e => e._markForCheck())
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Jr), P(gX, 8))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [["mat-button-toggle-group"]],
							contentQueries: function (i, r, o) {
								if ((1 & i && yr(o, cO, 5), 2 & i)) {
									let s
									sn((s = an())) && (r._buttonToggles = s)
								}
							},
							hostAttrs: ["role", "group", 1, "mat-button-toggle-group"],
							hostVars: 5,
							hostBindings: function (i, r) {
								2 & i &&
									(qn("aria-disabled", r.disabled),
									Zt("mat-button-toggle-vertical", r.vertical)(
										"mat-button-toggle-group-appearance-standard",
										"standard" === r.appearance
									))
							},
							inputs: {
								appearance: "appearance",
								name: "name",
								vertical: "vertical",
								value: "value",
								multiple: "multiple",
								disabled: "disabled"
							},
							outputs: { valueChange: "valueChange", change: "change" },
							exportAs: ["matButtonToggleGroup"],
							features: [Xn([IMe, { provide: bX, useExisting: t }])]
						})
					}
				}
				return t
			})()
			const DMe = Um(class {})
			let cO = (() => {
					class t extends DMe {
						get buttonId() {
							return `${this.id}-button`
						}
						get appearance() {
							return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance
						}
						set appearance(e) {
							this._appearance = e
						}
						get checked() {
							return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked
						}
						set checked(e) {
							const i = Mn(e)
							i !== this._checked &&
								((this._checked = i),
								this.buttonToggleGroup && this.buttonToggleGroup._syncButtonToggle(this, this._checked),
								this._changeDetectorRef.markForCheck())
						}
						get disabled() {
							return this._disabled || (this.buttonToggleGroup && this.buttonToggleGroup.disabled)
						}
						set disabled(e) {
							this._disabled = Mn(e)
						}
						constructor(e, i, r, o, s, a) {
							super(),
								(this._changeDetectorRef = i),
								(this._elementRef = r),
								(this._focusMonitor = o),
								(this._checked = !1),
								(this.ariaLabelledby = null),
								(this._disabled = !1),
								(this.change = new _n())
							const c = Number(s)
							;(this.tabIndex = c || 0 === c ? c : null),
								(this.buttonToggleGroup = e),
								(this.appearance = a && a.appearance ? a.appearance : "standard")
						}
						ngOnInit() {
							const e = this.buttonToggleGroup
							;(this.id = this.id || "mat-button-toggle-" + _X++),
								e &&
									(e._isPrechecked(this)
										? (this.checked = !0)
										: e._isSelected(this) !== this._checked && e._syncButtonToggle(this, this._checked))
						}
						ngAfterViewInit() {
							this._focusMonitor.monitor(this._elementRef, !0)
						}
						ngOnDestroy() {
							const e = this.buttonToggleGroup
							this._focusMonitor.stopMonitoring(this._elementRef),
								e && e._isSelected(this) && e._syncButtonToggle(this, !1, !1, !0)
						}
						focus(e) {
							this._buttonElement.nativeElement.focus(e)
						}
						_onButtonClick() {
							const e = !!this._isSingleSelector() || !this._checked
							e !== this._checked &&
								((this._checked = e),
								this.buttonToggleGroup &&
									(this.buttonToggleGroup._syncButtonToggle(this, this._checked, !0),
									this.buttonToggleGroup._onTouched())),
								this.change.emit(new vX(this, this.value))
						}
						_markForCheck() {
							this._changeDetectorRef.markForCheck()
						}
						_getButtonName() {
							return this._isSingleSelector() ? this.buttonToggleGroup.name : this.name || null
						}
						_isSingleSelector() {
							return this.buttonToggleGroup && !this.buttonToggleGroup.multiple
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(bX, 8), P(Jr), P(wn), P(fd), Ma("tabindex"), P(gX, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-button-toggle"]],
								viewQuery: function (i, r) {
									if ((1 & i && _i(FMe, 5), 2 & i)) {
										let o
										sn((o = an())) && (r._buttonElement = o.first)
									}
								},
								hostAttrs: ["role", "presentation", 1, "mat-button-toggle"],
								hostVars: 12,
								hostBindings: function (i, r) {
									1 & i &&
										Le("focus", function () {
											return r.focus()
										}),
										2 & i &&
											(qn("aria-label", null)("aria-labelledby", null)("id", r.id)("name", null),
											Zt("mat-button-toggle-standalone", !r.buttonToggleGroup)(
												"mat-button-toggle-checked",
												r.checked
											)("mat-button-toggle-disabled", r.disabled)(
												"mat-button-toggle-appearance-standard",
												"standard" === r.appearance
											))
								},
								inputs: {
									disableRipple: "disableRipple",
									ariaLabel: ["aria-label", "ariaLabel"],
									ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
									id: "id",
									name: "name",
									value: "value",
									tabIndex: "tabIndex",
									appearance: "appearance",
									checked: "checked",
									disabled: "disabled"
								},
								outputs: { change: "change" },
								exportAs: ["matButtonToggle"],
								features: [pn],
								ngContentSelectors: BMe,
								decls: 6,
								vars: 9,
								consts: [
									["type", "button", 1, "mat-button-toggle-button", "mat-focus-indicator", 3, "id", "disabled", "click"],
									["button", ""],
									[1, "mat-button-toggle-label-content"],
									[1, "mat-button-toggle-focus-overlay"],
									["matRipple", "", 1, "mat-button-toggle-ripple", 3, "matRippleTrigger", "matRippleDisabled"]
								],
								template: function (i, r) {
									if (
										(1 & i &&
											(co(),
											F(0, "button", 0, 1),
											Le("click", function () {
												return r._onButtonClick()
											}),
											F(2, "span", 2),
											Ln(3),
											L()(),
											fe(4, "span", 3)(5, "span", 4)),
										2 & i)
									) {
										const o = br(1)
										U("id", r.buttonId)("disabled", r.disabled || null),
											qn("tabindex", r.disabled ? -1 : r.tabIndex)("aria-pressed", r.checked)(
												"name",
												r._getButtonName()
											)("aria-label", r.ariaLabel)("aria-labelledby", r.ariaLabelledby),
											T(5),
											U("matRippleTrigger", o)("matRippleDisabled", r.disableRipple || r.disabled)
									}
								},
								dependencies: [Cu],
								styles: [
									".mat-button-toggle-standalone,.mat-button-toggle-group{--mat-legacy-button-toggle-height:36px;--mat-legacy-button-toggle-shape:2px;--mat-legacy-button-toggle-focus-state-layer-opacity:1;position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);transform:translateZ(0);border-radius:var(--mat-legacy-button-toggle-shape)}.mat-button-toggle-standalone:not([class*=mat-elevation-z]),.mat-button-toggle-group:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}.cdk-high-contrast-active .mat-button-toggle-standalone,.cdk-high-contrast-active .mat-button-toggle-group{outline:solid 1px}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{--mat-standard-button-toggle-shape:4px;--mat-standard-button-toggle-hover-state-layer-opacity:0.04;--mat-standard-button-toggle-focus-state-layer-opacity:0.12;border-radius:var(--mat-standard-button-toggle-shape);border:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard:not([class*=mat-elevation-z]),.mat-button-toggle-group-appearance-standard:not([class*=mat-elevation-z]){box-shadow:none}.cdk-high-contrast-active .mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.cdk-high-contrast-active .mat-button-toggle-group-appearance-standard{outline:0}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative;color:var(--mat-legacy-button-toggle-text-color);font-family:var(--mat-legacy-button-toggle-text-font)}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:var(--mat-legacy-button-toggle-focus-state-layer-opacity)}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle-checked{color:var(--mat-legacy-button-toggle-selected-state-text-color);background-color:var(--mat-legacy-button-toggle-selected-state-background-color)}.mat-button-toggle-disabled{color:var(--mat-legacy-button-toggle-disabled-state-text-color);background-color:var(--mat-legacy-button-toggle-disabled-state-background-color)}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:var(--mat-legacy-button-toggle-disabled-selected-state-background-color)}.mat-button-toggle-appearance-standard{--mat-standard-button-toggle-shape:4px;--mat-standard-button-toggle-hover-state-layer-opacity:0.04;--mat-standard-button-toggle-focus-state-layer-opacity:0.12;color:var(--mat-standard-button-toggle-text-color);background-color:var(--mat-standard-button-toggle-background-color);font-family:var(--mat-standard-button-toggle-text-font)}.mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:solid 1px var(--mat-standard-button-toggle-divider-color)}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:none;border-top:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-selected-state-text-color);background-color:var(--mat-standard-button-toggle-selected-state-background-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled{color:var(--mat-standard-button-toggle-disabled-state-text-color);background-color:var(--mat-standard-button-toggle-disabled-state-background-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-disabled-selected-state-text-color);background-color:var(--mat-standard-button-toggle-disabled-selected-state-background-color)}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:var(--mat-standard-button-toggle-state-layer-color)}.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-hover-state-layer-opacity)}.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-focus-state-layer-opacity)}@media(hover: none){.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;user-select:none;display:inline-block;padding:0 16px;line-height:var(--mat-legacy-button-toggle-height);position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{padding:0 12px;line-height:var(--mat-standard-button-toggle-height)}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;pointer-events:none;opacity:0;background-color:var(--mat-legacy-button-toggle-state-layer-color)}.cdk-high-contrast-active .mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 500px;opacity:.5;height:0}.cdk-high-contrast-active .mat-button-toggle-checked:hover .mat-button-toggle-focus-overlay{opacity:.6}.cdk-high-contrast-active .mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 500px}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:none;color:inherit;padding:0;margin:0;font:inherit;outline:none;width:100%;cursor:pointer}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}"
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				yX = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Vh, Yi] })
						}
					}
					return t
				})(),
				lO = (() => {
					class t {
						constructor(e) {
							;(this.store = e), (this.attributeTypes$ = this.store.select(KP))
						}
						setToAbsolute() {
							this.setAttributeType(zh.absolute)
						}
						setToRelative() {
							this.setAttributeType(zh.relative)
						}
						setAttributeType(e) {
							this.store.dispatch(eD({ category: this.metricType, name: this.metricName, attributeType: e }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-attribute-type-selector"]],
								inputs: { metricName: "metricName", metricType: "metricType" },
								decls: 6,
								vars: 3,
								consts: [
									[3, "value"],
									["title", "Select Sum", "value", "absolute", 3, "click"],
									["title", "Select Median", "value", "relative", 3, "click"]
								],
								template: function (i, r) {
									if (
										(1 & i &&
											(F(0, "mat-button-toggle-group", 0),
											Me(1, "async"),
											F(2, "mat-button-toggle", 1),
											Le("click", function () {
												return r.setToAbsolute()
											}),
											ge(3, "\u03a3"),
											L(),
											F(4, "mat-button-toggle", 2),
											Le("click", function () {
												return r.setToRelative()
											}),
											ge(5, "x\u0342"),
											L()()),
										2 & i)
									) {
										let o
										U(
											"value",
											null !== (o = De(1, 1, r.attributeTypes$)[r.metricType][r.metricName]) && void 0 !== o
												? o
												: "absolute"
										)
									}
								},
								dependencies: [aO, cO, Bn],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-attribute-type-selector .mat-button-toggle-appearance-standard .mat-button-toggle-label-content{display:flex;align-items:center;height:100%}cc-attribute-type-selector button{align-items:center;height:100%}cc-attribute-type-selector button:hover{background-color:#0000000d;color:#1b9cfc}cc-attribute-type-selector .mat-button-toggle-standalone.mat-button-toggle-appearance-standard:not([class*=mat-elevation-z]),cc-attribute-type-selector .mat-button-toggle-group-appearance-standard:not([class*=mat-elevation-z]){height:22px;border:.5px solid darkgrey}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function LMe(t, n) {
				if ((1 & t && (Cr(0), F(1, "span"), Me(2, "async"), ge(3), Me(4, "number"), L(), Er()), 2 & t)) {
					const e = n.ngIf,
						i = Te()
					T(1),
						bi("color", De(2, 3, i.mapColors$)[e > 0 ? "positiveDelta" : "negativeDelta"]),
						T(2),
						Vt(" \u0394", lo(4, 5, e, "1.1-2"), " ")
				}
			}
			let wX = (() => {
				class t {
					constructor(e) {
						this.store = e
					}
					ngOnInit() {
						;(this.selectedNode$ = this.store.select(bf)), (this.mapColors$ = this.store.select(vb))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-metric-delta-selected"]],
							inputs: { metricName: "metricName" },
							decls: 2,
							vars: 3,
							consts: [[4, "ngIf"]],
							template: function (i, r) {
								if ((1 & i && (Ee(0, LMe, 5, 8, "ng-container", 0), Me(1, "async")), 2 & i)) {
									let o
									U("ngIf", null == (o = De(1, 1, r.selectedNode$)) || null == o.deltas ? null : o.deltas[r.metricName])
								}
							},
							dependencies: [En, Bn, C0],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function RMe(t, n) {
				1 & t && fe(0, "cc-attribute-type-selector", 7), 2 & t && U("metricName", Te().metric.name)("metricType", "nodes")
			}
			function PMe(t, n) {
				if ((1 & t && (F(0, "a", 8), ge(1), fe(2, "i", 9), L()), 2 & t)) {
					const e = n.ngIf,
						i = Te()
					U("href", e, fm), T(1), Vt(" ", i.metric.name, " ")
				}
			}
			function OMe(t, n) {
				if ((1 & t && (F(0, "span", 10), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1), cr(e.metric.name)
				}
			}
			let NMe = (() => {
				class t {
					constructor(e) {
						this.showAttributeTypeSelector$ = e.select(sO)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-attribute-side-bar-primary-metric"]],
							inputs: { iconName: "iconName", metric: "metric", metricLink: "metricLink" },
							decls: 12,
							vars: 12,
							consts: [
								[1, "primary-metric-box"],
								[1, "primary-metric-row"],
								["class", "attribute-type-select", 3, "metricName", "metricType", 4, "ngIf"],
								[1, "primary-metric-value"],
								[3, "metricName"],
								["class", "metric-name", "target", "_blank", 3, "href", 4, "ngIf", "ngIfElse"],
								["primaryMetricNoLink", ""],
								[1, "attribute-type-select", 3, "metricName", "metricType"],
								["target", "_blank", 1, "metric-name", 3, "href"],
								[1, "fa", "fa-external-link"],
								[1, "metric-name"]
							],
							template: function (i, r) {
								if (
									(1 & i &&
										(F(0, "div", 0)(1, "div", 1),
										fe(2, "i"),
										Ee(3, RMe, 1, 2, "cc-attribute-type-selector", 2),
										Me(4, "async"),
										F(5, "span", 3),
										ge(6),
										Me(7, "number"),
										L()(),
										fe(8, "cc-metric-delta-selected", 4),
										Ee(9, PMe, 3, 2, "a", 5),
										Ee(10, OMe, 2, 1, "ng-template", null, 6, oa),
										L()),
									2 & i)
								) {
									const o = br(11)
									T(2),
										c0(r.iconName),
										T(1),
										U("ngIf", De(4, 7, r.showAttributeTypeSelector$)),
										T(3),
										cr(lo(7, 9, r.metric.value, "1.0-0")),
										T(2),
										U("metricName", r.metric.name),
										T(1),
										U("ngIf", r.metricLink)("ngIfElse", o)
								}
							},
							dependencies: [En, lO, wX, Bn, C0],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const dO = new Map([
				["loc", "Lines of Code"],
				["rloc", "Real Lines of Code"],
				["comment_lines", "Number of Code Lines with Comments"],
				["mcc", "Cyclomatic Complexity"],
				["avgCommits", "Average Number of Commits from this file"],
				["functions", "Number of Functions"],
				["pairingRate", "Pairing Rate of selected building"],
				["unary", "-"],
				["line_coverage", "Number of Code Lines covered by tests"],
				["sonar_code_smells", "Number of Smells Sonar has identified"],
				["avg_code_churn", "Average Number of Lines added or removed from this file"],
				["number_of_authors", "Number of Authors that have edited this file"],
				["statements", "Number of Statements"]
			])
			let JS = (() => {
				class t {
					transform(e, i) {
						if (null == e) return dO.get(i) ?? ""
						const r = e.title ? `${e.title} (${i})` : `${i}`
						let o = e.description ? `\n${e.description}` : ""
						return (
							(o += e.hintHighValue ? `\nHigh Values: ${e.hintHighValue}` : ""),
							(o += e.hintLowValue ? `\nLow Values: ${e.hintLowValue}` : ""),
							o.length > 0 ? `${r}:${o}` : r
						)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵpipe = Zi({ name: "attributeDescriptorTooltip", type: t, pure: !0 })
					}
				}
				return t
			})()
			function UMe(t, n) {
				1 & t && fe(0, "cc-attribute-type-selector", 15), 2 & t && U("metricName", Te().ngIf.name)("metricType", "edges")
			}
			function HMe(t, n) {
				if ((1 & t && (F(0, "a", 16), ge(1), fe(2, "i", 17), L()), 2 & t)) {
					const e = n.ngIf,
						i = Te().ngIf
					U("href", e, fm), T(1), Vt(" ", i.name, " (in/out) ")
				}
			}
			function VMe(t, n) {
				if ((1 & t && (F(0, "span", 18), ge(1), L()), 2 & t)) {
					const e = Te().ngIf
					T(1), Vt("", e.name, " (in/out)")
				}
			}
			function QMe(t, n) {
				if (
					(1 & t &&
						(Cr(0),
						F(1, "td", 5),
						Me(2, "attributeDescriptorTooltip"),
						F(3, "div", 9)(4, "div", 10),
						fe(5, "i", 11),
						Ee(6, UMe, 1, 2, "cc-attribute-type-selector", 12),
						Me(7, "async"),
						F(8, "span"),
						ge(9),
						Me(10, "number"),
						F(11, "span"),
						ge(12, "/"),
						L(),
						ge(13),
						Me(14, "number"),
						L()(),
						Ee(15, HMe, 3, 2, "a", 13),
						Ee(16, VMe, 2, 1, "ng-template", null, 14, oa),
						L()(),
						Er()),
					2 & t)
				) {
					const e = n.ngIf,
						i = br(17),
						r = Te(2).ngIf,
						o = Te()
					T(1),
						U("title", lo(2, 6, r[e.name], e.name)),
						T(5),
						U("ngIf", De(7, 9, o.showAttributeTypeSelector$)),
						T(3),
						Vt(" ", lo(10, 11, e.incoming, "1.0-0"), " "),
						T(4),
						Vt(" ", lo(14, 14, e.outgoing, "1.0-0"), " "),
						T(2),
						U("ngIf", null == r[e.name] ? null : r[e.name].link)("ngIfElse", i)
				}
			}
			function zMe(t, n) {
				1 & t && (F(0, "td")(1, "span", 18), ge(2, "No edge metric available"), L()())
			}
			function GMe(t, n) {
				if (
					(1 & t &&
						(F(0, "table", 3)(1, "th", 4),
						ge(2, "Primary Metrics"),
						L(),
						F(3, "tr")(4, "td", 5),
						Me(5, "attributeDescriptorTooltip"),
						fe(6, "cc-attribute-side-bar-primary-metric", 6),
						L(),
						F(7, "td", 5),
						Me(8, "attributeDescriptorTooltip"),
						fe(9, "cc-attribute-side-bar-primary-metric", 6),
						L()(),
						F(10, "tr")(11, "td", 5),
						Me(12, "attributeDescriptorTooltip"),
						fe(13, "cc-attribute-side-bar-primary-metric", 6),
						L(),
						Ee(14, QMe, 18, 17, "ng-container", 7),
						Ee(15, zMe, 3, 0, "ng-template", null, 8, oa),
						L()()),
					2 & t)
				) {
					const e = n.$implicit,
						i = br(16),
						r = Te().ngIf
					T(4),
						U("title", lo(5, 14, r[e.area.name], e.area.name)),
						T(2),
						U("iconName", "fa fa-arrows-alt")("metric", e.area)(
							"metricLink",
							null == r[e.area.name] ? null : r[e.area.name].link
						),
						T(1),
						U("title", lo(8, 17, r[e.height.name], e.height.name)),
						T(2),
						U("iconName", "fa fa-arrows-v")("metric", e.height)(
							"metricLink",
							null == r[e.height.name] ? null : r[e.height.name].link
						),
						T(2),
						U("title", lo(12, 20, r[e.color.name], e.color.name)),
						T(2),
						U("iconName", "fa fa-paint-brush")("metric", e.color)(
							"metricLink",
							null == r[e.color.name] ? null : r[e.color.name].link
						),
						T(1),
						U("ngIf", e.edge)("ngIfElse", i)
				}
			}
			function $Me(t, n) {
				if ((1 & t && (F(0, "div", 1), Ee(1, GMe, 17, 23, "table", 2), Me(2, "async"), L()), 2 & t)) {
					const e = Te()
					T(1), U("ngIf", De(2, 1, e.primaryMetrics$))
				}
			}
			let WMe = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.primaryMetrics$ = this.store.select(kMe)),
							(this.showAttributeTypeSelector$ = this.store.select(sO)),
							(this.attributeDescriptors$ = this.store.select(qS))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-attribute-side-bar-primary-metrics"]],
							decls: 2,
							vars: 3,
							consts: [
								["class", "metric-box", 4, "ngIf"],
								[1, "metric-box"],
								["class", "primary-metrics", "aria-hidden", "true", 4, "ngIf"],
								["aria-hidden", "true", 1, "primary-metrics"],
								["scope", "col"],
								[3, "title"],
								[3, "iconName", "metric", "metricLink"],
								[4, "ngIf", "ngIfElse"],
								["sidebarPrimaryMetricsEdgeElse", ""],
								[1, "primary-metric-box"],
								[1, "primary-metric-row"],
								[1, "fa", "fa-exchange"],
								["class", "attribute-type-select", 3, "metricName", "metricType", 4, "ngIf"],
								["class", "metric-name", "target", "_blank", 3, "href", 4, "ngIf", "ngIfElse"],
								["primaryMetricNoLink", ""],
								[1, "attribute-type-select", 3, "metricName", "metricType"],
								["target", "_blank", 1, "metric-name", 3, "href"],
								[1, "fa", "fa-external-link"],
								[1, "metric-name"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, $Me, 3, 3, "div", 0), Me(1, "async")), 2 & i && U("ngIf", De(1, 1, r.attributeDescriptors$))
							},
							dependencies: [En, lO, NMe, Bn, C0, JS],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const jMe = Mt(bf, t => !!t?.deltas),
				KMe = Mt(YS, bf, (t, n) => {
					if (!n) return []
					const e = Object.values(t)
					return Object.keys(n.attributes)
						.filter(r => "unary" !== r && !e.includes(r))
						.sort((r, o) => r.localeCompare(o))
						.map(r => ({ name: r, value: n.attributes[r] }))
				})
			function XMe(t, n) {
				1 & t && fe(0, "cc-attribute-type-selector", 16), 2 & t && U("metricName", Te().$implicit.name)("metricType", "nodes")
			}
			function YMe(t, n) {
				if ((1 & t && (F(0, "a", 17), ge(1), fe(2, "i", 18), L()), 2 & t)) {
					const e = n.ngIf,
						i = Te().$implicit
					U("href", e, fm), T(1), Vt(" ", i.name, " ")
				}
			}
			function qMe(t, n) {
				if ((1 & t && (F(0, "span", 19), ge(1), L()), 2 & t)) {
					const e = Te().$implicit
					T(1), cr(e.name)
				}
			}
			function ZMe(t, n) {
				if (
					(1 & t &&
						(F(0, "tr", 7),
						Me(1, "attributeDescriptorTooltip"),
						F(2, "td", 8)(3, "div", 9),
						Ee(4, XMe, 1, 2, "cc-attribute-type-selector", 10),
						Me(5, "async"),
						F(6, "span", 11),
						ge(7),
						Me(8, "number"),
						L()()(),
						F(9, "td", 12),
						Me(10, "async"),
						fe(11, "cc-metric-delta-selected", 13),
						L(),
						F(12, "td"),
						Ee(13, YMe, 3, 2, "a", 14),
						Ee(14, qMe, 2, 1, "ng-template", null, 15, oa),
						L()()),
					2 & t)
				) {
					const e = n.$implicit,
						i = br(15),
						r = Te().ngIf,
						o = Te()
					U("title", lo(1, 7, r[e.name], e.name)),
						T(4),
						U("ngIf", De(5, 10, o.showAttributeTypeSelector$)),
						T(3),
						cr(lo(8, 12, e.value, "1.0-0")),
						T(2),
						U("hidden", !De(10, 15, o.showDeltaValue$)),
						T(2),
						U("metricName", e.name),
						T(2),
						U("ngIf", null == r[e.name] ? null : r[e.name].link)("ngIfElse", i)
				}
			}
			function JMe(t, n) {
				if (
					(1 & t &&
						(F(0, "div", 3)(1, "table", 4)(2, "tr")(3, "th", 5),
						ge(4, "Secondary Metrics"),
						L()(),
						Ee(5, ZMe, 16, 17, "tr", 6),
						Me(6, "async"),
						L()()),
					2 & t)
				) {
					const e = Te()
					T(5), U("ngForOf", De(6, 1, e.secondaryMetrics$))
				}
			}
			let eSe = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.secondaryMetrics$ = this.store.select(KMe)),
								(this.showAttributeTypeSelector$ = this.store.select(sO)),
								(this.showDeltaValue$ = this.store.select(jMe)),
								(this.attributeDescriptors$ = this.store.select(qS))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-attribute-side-bar-secondary-metrics"]],
								decls: 4,
								vars: 3,
								consts: [
									[1, "secondary-metrics-wrapper"],
									[1, "metrics-wrapper"],
									["class", "metric-box scrollable-content", 4, "ngIf"],
									[1, "metric-box", "scrollable-content"],
									["aria-hidden", "true", 1, "secondary-metrics"],
									["scope", "col", "colspan", "2"],
									[3, "title", 4, "ngFor", "ngForOf"],
									[3, "title"],
									[1, "secondary-metric-box"],
									[1, "secondary-metric-row"],
									["class", "attribute-type-select", 3, "metricName", "metricType", 4, "ngIf"],
									[1, "metric-value"],
									[1, "delta-value-box", 3, "hidden"],
									[3, "metricName"],
									["class", "metric-name", "target", "_blank", 3, "href", 4, "ngIf", "ngIfElse"],
									["secondaryMetricNoLink", ""],
									[1, "attribute-type-select", 3, "metricName", "metricType"],
									["target", "_blank", 1, "metric-name", 3, "href"],
									[1, "fa", "fa-external-link"],
									[1, "metric-name"]
								],
								template: function (i, r) {
									1 & i && (F(0, "div", 0)(1, "div", 1), Ee(2, JMe, 7, 3, "div", 2), Me(3, "async"), L()()),
										2 & i && (T(2), U("ngIf", De(3, 1, r.attributeDescriptors$)))
								},
								dependencies: [_o, En, lO, wX, Bn, C0, JS],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				tSe = (() => {
					class t {
						constructor(e, i) {
							;(this.isAttributeSideBarVisibleService = e),
								(this.store = i),
								(this.selectedNode$ = this.store.select(bf)),
								(this.fileName$ = this.store.select(Vc).pipe(Ke(r => r.unifiedFileMeta?.fileName ?? "")))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(KS), P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-attribute-side-bar"]],
								decls: 6,
								vars: 8,
								consts: [
									[1, "side-bar-container", "cc-shadow"],
									[3, "node", "fileName"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div", 0),
										fe(1, "cc-attribute-side-bar-header-section", 1),
										Me(2, "async"),
										Me(3, "async"),
										fe(4, "cc-attribute-side-bar-primary-metrics")(5, "cc-attribute-side-bar-secondary-metrics"),
										L()),
										2 & i &&
											(Zt("expanded", r.isAttributeSideBarVisibleService.isOpen),
											T(1),
											U("node", De(2, 4, r.selectedNode$))("fileName", De(3, 6, r.fileName$)))
								},
								dependencies: [SMe, WMe, eSe, Bn],
								styles: [
									'cc-attribute-side-bar .side-bar-container{width:350px;height:calc(100% - 98px);padding:8px;font-size:11pt;position:absolute;right:-355px;background:white}cc-attribute-side-bar .side-bar-container.expanded{display:block;right:0}cc-attribute-side-bar .side-bar-container:before{content:"";height:100%;float:left}cc-attribute-side-bar .side-bar-container .secondary-metrics-wrapper{position:relative}cc-attribute-side-bar .side-bar-container .secondary-metrics-wrapper:after{content:"";clear:both;display:block}cc-attribute-side-bar .side-bar-container .secondary-metrics-wrapper .metrics-wrapper{position:absolute;width:100%;height:100%;padding-top:12px}cc-attribute-side-bar .side-bar-container .metric-box{border-radius:5px;background-color:#f0f0f0;padding:5px}cc-attribute-side-bar .side-bar-container .metric-box.scrollable-content{max-height:100%;overflow:auto}cc-attribute-side-bar .side-bar-container .metric-box table th{text-align:left}cc-attribute-side-bar .side-bar-container .metric-box table.primary-metrics{table-layout:fixed;width:100%;border-collapse:collapse}cc-attribute-side-bar .side-bar-container .metric-box table.primary-metrics tr:not(:last-child) td{border-bottom:3px solid white}cc-attribute-side-bar .side-bar-container .metric-box table.primary-metrics td{padding:5px}cc-attribute-side-bar .side-bar-container .metric-box table.primary-metrics td:first-child{border-right:3px solid white}cc-attribute-side-bar .side-bar-container .metric-box table.primary-metrics .primary-metric-box{display:flex;flex-direction:column;height:100%;width:100%}cc-attribute-side-bar .side-bar-container .metric-box table.primary-metrics .metric-name{margin-top:5px}cc-attribute-side-bar .side-bar-container .metric-box table.primary-metrics .primary-metric-value{margin-right:-5px}cc-attribute-side-bar .side-bar-container .metric-box table.primary-metrics i.fa{font-size:12pt;min-width:17px;text-align:center}cc-attribute-side-bar .side-bar-container .metric-box table.secondary-metrics td{padding-left:5px}cc-attribute-side-bar .side-bar-container .metric-box table.secondary-metrics td:first-child{padding-left:4px}cc-attribute-side-bar .side-bar-container .metric-box table.secondary-metrics .secondary-metric-box{border-radius:3px;padding:4px;vertical-align:middle;background:#d5d5d5}cc-attribute-side-bar .side-bar-container .metric-box table.secondary-metrics .secondary-metric-row{flex-wrap:nowrap}cc-attribute-side-bar .side-bar-container .metric-box table .primary-metric-row,cc-attribute-side-bar .side-bar-container .metric-box table .secondary-metric-row{display:flex;align-items:center;flex-wrap:wrap;gap:5px}cc-attribute-side-bar .side-bar-container .metric-box table .metric-name{color:gray;word-break:break-word;vertical-align:middle}cc-attribute-side-bar .side-bar-container .metric-box table .delta-value-box{vertical-align:middle}cc-attribute-side-bar .side-bar-container .metric-box cc-metric-delta-selected:has(span){margin-top:5px}cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metric-box i.fa.fa-external-link,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metrics-wrapper i.fa.fa-external-link,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metric-box i.fa.fa-external-link,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metrics-wrapper i.fa.fa-external-link{font-size:10px;min-width:10px;text-align:center}cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metric-box a:link,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metric-box a:visited,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metrics-wrapper a:link,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metrics-wrapper a:visited,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metric-box a:link,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metric-box a:visited,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metrics-wrapper a:link,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metrics-wrapper a:visited{text-decoration:none}cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metric-box a:hover,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metrics-wrapper a:hover,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metric-box a:hover,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metrics-wrapper a:hover{color:#00f;-webkit-text-decoration:solid;text-decoration:solid;text-decoration-line:underline}cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metric-box a:active,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-primary-metrics .metrics-wrapper a:active,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metric-box a:active,cc-attribute-side-bar .side-bar-container cc-attribute-side-bar-secondary-metrics .metrics-wrapper a:active{color:red}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				nSe = (() => {
					class t {
						constructor(e, i, r, o, s) {
							;(this.isAttributeSideBarVisibleService = e),
								(this.store = i),
								(this.threeViewerService = r),
								(this.codeMapMouseEventService = o),
								(this.elementReference = s),
								(this.isLoadingFile$ = this.store.select(jL)),
								(this.restartOnSharpnessModeChangesSubscription = this.store
									.select(eW)
									.pipe(
										Mv(1),
										eo(() => {
											this.threeViewerService.restart(this.elementReference.nativeElement.querySelector("#codeMap")),
												this.codeMapMouseEventService.start()
										})
									)
									.subscribe())
						}
						ngAfterViewInit() {
							this.threeViewerService.init(this.elementReference.nativeElement.querySelector("#codeMap")),
								this.codeMapMouseEventService.start()
						}
						ngOnDestroy() {
							this.restartOnSharpnessModeChangesSubscription.unsubscribe()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(KS), P(Ct), P(aX), P(pw), P(wn))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-code-map"]],
								decls: 4,
								vars: 6,
								consts: [["id", "codeMap"]],
								template: function (i, r) {
									1 & i && (F(0, "div", 0), Me(1, "async"), fe(2, "cc-view-cube")(3, "cc-attribute-side-bar"), L()),
										2 & i &&
											(Zt("hidden", De(1, 4, r.isLoadingFile$)),
											T(2),
											Zt("sideBarVisible", r.isAttributeSideBarVisibleService.isOpen))
								},
								dependencies: [rMe, tSe, Bn],
								styles: [
									"cc-code-map .hidden{display:none}cc-code-map cc-view-cube{position:absolute;z-index:11;right:0;top:10px}cc-code-map cc-view-cube.sideBarVisible{right:350px}cc-code-map unfocus-button-component.sideBarVisible{right:390px}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const xX = Mt(fv, t => t.markedPackages),
				iSe = Mt(xX, t =>
					t.reduce((n, { color: e, path: i }) => (Object.prototype.hasOwnProperty.call(n, e) || (n[e] = []), n[e].push(i), n), {})
				)
			function Ls(t, n) {
				;(function rSe(t) {
					return "string" == typeof t && -1 !== t.indexOf(".") && 1 === parseFloat(t)
				})(t) && (t = "100%")
				var e = (function oSe(t) {
					return "string" == typeof t && -1 !== t.indexOf("%")
				})(t)
				return (
					(t = 360 === n ? t : Math.min(n, Math.max(0, parseFloat(t)))),
					e && (t = parseInt(String(t * n), 10) / 100),
					Math.abs(t - n) < 1e-6
						? 1
						: (t = 360 === n ? (t < 0 ? (t % n) + n : t % n) / parseFloat(String(n)) : (t % n) / parseFloat(String(n)))
				)
			}
			function ek(t) {
				return Math.min(1, Math.max(0, t))
			}
			function CX(t) {
				return (t = parseFloat(t)), (isNaN(t) || t < 0 || t > 1) && (t = 1), t
			}
			function tk(t) {
				return t <= 1 ? "".concat(100 * Number(t), "%") : t
			}
			function Mp(t) {
				return 1 === t.length ? "0" + t : String(t)
			}
			function EX(t, n, e) {
				;(t = Ls(t, 255)), (n = Ls(n, 255)), (e = Ls(e, 255))
				var i = Math.max(t, n, e),
					r = Math.min(t, n, e),
					o = 0,
					s = 0,
					a = (i + r) / 2
				if (i === r) (s = 0), (o = 0)
				else {
					var c = i - r
					switch (((s = a > 0.5 ? c / (2 - i - r) : c / (i + r)), i)) {
						case t:
							o = (n - e) / c + (n < e ? 6 : 0)
							break
						case n:
							o = (e - t) / c + 2
							break
						case e:
							o = (t - n) / c + 4
					}
					o /= 6
				}
				return { h: o, s, l: a }
			}
			function uO(t, n, e) {
				return (
					e < 0 && (e += 1),
					e > 1 && (e -= 1),
					e < 1 / 6 ? t + 6 * e * (n - t) : e < 0.5 ? n : e < 2 / 3 ? t + (n - t) * (2 / 3 - e) * 6 : t
				)
			}
			function MX(t, n, e) {
				;(t = Ls(t, 255)), (n = Ls(n, 255)), (e = Ls(e, 255))
				var i = Math.max(t, n, e),
					r = Math.min(t, n, e),
					o = 0,
					s = i,
					a = i - r,
					c = 0 === i ? 0 : a / i
				if (i === r) o = 0
				else {
					switch (i) {
						case t:
							o = (n - e) / a + (n < e ? 6 : 0)
							break
						case n:
							o = (e - t) / a + 2
							break
						case e:
							o = (t - n) / a + 4
					}
					o /= 6
				}
				return { h: o, s: c, v: s }
			}
			function SX(t, n, e, i) {
				var r = [Mp(Math.round(t).toString(16)), Mp(Math.round(n).toString(16)), Mp(Math.round(e).toString(16))]
				return i && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1))
					? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0)
					: r.join("")
			}
			function kX(t) {
				return Math.round(255 * parseFloat(t)).toString(16)
			}
			function TX(t) {
				return lc(t) / 255
			}
			function lc(t) {
				return parseInt(t, 16)
			}
			var hO = {
				aliceblue: "#f0f8ff",
				antiquewhite: "#faebd7",
				aqua: "#00ffff",
				aquamarine: "#7fffd4",
				azure: "#f0ffff",
				beige: "#f5f5dc",
				bisque: "#ffe4c4",
				black: "#000000",
				blanchedalmond: "#ffebcd",
				blue: "#0000ff",
				blueviolet: "#8a2be2",
				brown: "#a52a2a",
				burlywood: "#deb887",
				cadetblue: "#5f9ea0",
				chartreuse: "#7fff00",
				chocolate: "#d2691e",
				coral: "#ff7f50",
				cornflowerblue: "#6495ed",
				cornsilk: "#fff8dc",
				crimson: "#dc143c",
				cyan: "#00ffff",
				darkblue: "#00008b",
				darkcyan: "#008b8b",
				darkgoldenrod: "#b8860b",
				darkgray: "#a9a9a9",
				darkgreen: "#006400",
				darkgrey: "#a9a9a9",
				darkkhaki: "#bdb76b",
				darkmagenta: "#8b008b",
				darkolivegreen: "#556b2f",
				darkorange: "#ff8c00",
				darkorchid: "#9932cc",
				darkred: "#8b0000",
				darksalmon: "#e9967a",
				darkseagreen: "#8fbc8f",
				darkslateblue: "#483d8b",
				darkslategray: "#2f4f4f",
				darkslategrey: "#2f4f4f",
				darkturquoise: "#00ced1",
				darkviolet: "#9400d3",
				deeppink: "#ff1493",
				deepskyblue: "#00bfff",
				dimgray: "#696969",
				dimgrey: "#696969",
				dodgerblue: "#1e90ff",
				firebrick: "#b22222",
				floralwhite: "#fffaf0",
				forestgreen: "#228b22",
				fuchsia: "#ff00ff",
				gainsboro: "#dcdcdc",
				ghostwhite: "#f8f8ff",
				goldenrod: "#daa520",
				gold: "#ffd700",
				gray: "#808080",
				green: "#008000",
				greenyellow: "#adff2f",
				grey: "#808080",
				honeydew: "#f0fff0",
				hotpink: "#ff69b4",
				indianred: "#cd5c5c",
				indigo: "#4b0082",
				ivory: "#fffff0",
				khaki: "#f0e68c",
				lavenderblush: "#fff0f5",
				lavender: "#e6e6fa",
				lawngreen: "#7cfc00",
				lemonchiffon: "#fffacd",
				lightblue: "#add8e6",
				lightcoral: "#f08080",
				lightcyan: "#e0ffff",
				lightgoldenrodyellow: "#fafad2",
				lightgray: "#d3d3d3",
				lightgreen: "#90ee90",
				lightgrey: "#d3d3d3",
				lightpink: "#ffb6c1",
				lightsalmon: "#ffa07a",
				lightseagreen: "#20b2aa",
				lightskyblue: "#87cefa",
				lightslategray: "#778899",
				lightslategrey: "#778899",
				lightsteelblue: "#b0c4de",
				lightyellow: "#ffffe0",
				lime: "#00ff00",
				limegreen: "#32cd32",
				linen: "#faf0e6",
				magenta: "#ff00ff",
				maroon: "#800000",
				mediumaquamarine: "#66cdaa",
				mediumblue: "#0000cd",
				mediumorchid: "#ba55d3",
				mediumpurple: "#9370db",
				mediumseagreen: "#3cb371",
				mediumslateblue: "#7b68ee",
				mediumspringgreen: "#00fa9a",
				mediumturquoise: "#48d1cc",
				mediumvioletred: "#c71585",
				midnightblue: "#191970",
				mintcream: "#f5fffa",
				mistyrose: "#ffe4e1",
				moccasin: "#ffe4b5",
				navajowhite: "#ffdead",
				navy: "#000080",
				oldlace: "#fdf5e6",
				olive: "#808000",
				olivedrab: "#6b8e23",
				orange: "#ffa500",
				orangered: "#ff4500",
				orchid: "#da70d6",
				palegoldenrod: "#eee8aa",
				palegreen: "#98fb98",
				paleturquoise: "#afeeee",
				palevioletred: "#db7093",
				papayawhip: "#ffefd5",
				peachpuff: "#ffdab9",
				peru: "#cd853f",
				pink: "#ffc0cb",
				plum: "#dda0dd",
				powderblue: "#b0e0e6",
				purple: "#800080",
				rebeccapurple: "#663399",
				red: "#ff0000",
				rosybrown: "#bc8f8f",
				royalblue: "#4169e1",
				saddlebrown: "#8b4513",
				salmon: "#fa8072",
				sandybrown: "#f4a460",
				seagreen: "#2e8b57",
				seashell: "#fff5ee",
				sienna: "#a0522d",
				silver: "#c0c0c0",
				skyblue: "#87ceeb",
				slateblue: "#6a5acd",
				slategray: "#708090",
				slategrey: "#708090",
				snow: "#fffafa",
				springgreen: "#00ff7f",
				steelblue: "#4682b4",
				tan: "#d2b48c",
				teal: "#008080",
				thistle: "#d8bfd8",
				tomato: "#ff6347",
				turquoise: "#40e0d0",
				violet: "#ee82ee",
				wheat: "#f5deb3",
				white: "#ffffff",
				whitesmoke: "#f5f5f5",
				yellow: "#ffff00",
				yellowgreen: "#9acd32"
			}
			var vf = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")"),
				fO = "[\\s|\\(]+(".concat(vf, ")[,|\\s]+(").concat(vf, ")[,|\\s]+(").concat(vf, ")\\s*\\)?"),
				mO = "[\\s|\\(]+(".concat(vf, ")[,|\\s]+(").concat(vf, ")[,|\\s]+(").concat(vf, ")[,|\\s]+(").concat(vf, ")\\s*\\)?"),
				Sl = {
					CSS_UNIT: new RegExp(vf),
					rgb: new RegExp("rgb" + fO),
					rgba: new RegExp("rgba" + mO),
					hsl: new RegExp("hsl" + fO),
					hsla: new RegExp("hsla" + mO),
					hsv: new RegExp("hsv" + fO),
					hsva: new RegExp("hsva" + mO),
					hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
					hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
					hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
					hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
				}
			function Gu(t) {
				return !!Sl.CSS_UNIT.exec(String(t))
			}
			var gw = (function () {
				function t(n, e) {
					var i
					if ((void 0 === n && (n = ""), void 0 === e && (e = {}), n instanceof t)) return n
					"number" == typeof n &&
						(n = (function dSe(t) {
							return { r: t >> 16, g: (65280 & t) >> 8, b: 255 & t }
						})(n)),
						(this.originalInput = n)
					var r = (function uSe(t) {
						var n = { r: 0, g: 0, b: 0 },
							e = 1,
							i = null,
							r = null,
							o = null,
							s = !1,
							a = !1
						return (
							"string" == typeof t &&
								(t = (function mSe(t) {
									if (0 === (t = t.trim().toLowerCase()).length) return !1
									var n = !1
									if (hO[t]) (t = hO[t]), (n = !0)
									else if ("transparent" === t) return { r: 0, g: 0, b: 0, a: 0, format: "name" }
									var e = Sl.rgb.exec(t)
									return e
										? { r: e[1], g: e[2], b: e[3] }
										: (e = Sl.rgba.exec(t))
										? { r: e[1], g: e[2], b: e[3], a: e[4] }
										: (e = Sl.hsl.exec(t))
										? { h: e[1], s: e[2], l: e[3] }
										: (e = Sl.hsla.exec(t))
										? { h: e[1], s: e[2], l: e[3], a: e[4] }
										: (e = Sl.hsv.exec(t))
										? { h: e[1], s: e[2], v: e[3] }
										: (e = Sl.hsva.exec(t))
										? { h: e[1], s: e[2], v: e[3], a: e[4] }
										: (e = Sl.hex8.exec(t))
										? { r: lc(e[1]), g: lc(e[2]), b: lc(e[3]), a: TX(e[4]), format: n ? "name" : "hex8" }
										: (e = Sl.hex6.exec(t))
										? { r: lc(e[1]), g: lc(e[2]), b: lc(e[3]), format: n ? "name" : "hex" }
										: (e = Sl.hex4.exec(t))
										? {
												r: lc(e[1] + e[1]),
												g: lc(e[2] + e[2]),
												b: lc(e[3] + e[3]),
												a: TX(e[4] + e[4]),
												format: n ? "name" : "hex8"
										  }
										: !!(e = Sl.hex3.exec(t)) && {
												r: lc(e[1] + e[1]),
												g: lc(e[2] + e[2]),
												b: lc(e[3] + e[3]),
												format: n ? "name" : "hex"
										  }
								})(t)),
							"object" == typeof t &&
								(Gu(t.r) && Gu(t.g) && Gu(t.b)
									? ((n = (function sSe(t, n, e) {
											return { r: 255 * Ls(t, 255), g: 255 * Ls(n, 255), b: 255 * Ls(e, 255) }
									  })(t.r, t.g, t.b)),
									  (s = !0),
									  (a = "%" === String(t.r).substr(-1) ? "prgb" : "rgb"))
									: Gu(t.h) && Gu(t.s) && Gu(t.v)
									? ((i = tk(t.s)),
									  (r = tk(t.v)),
									  (n = (function cSe(t, n, e) {
											;(t = 6 * Ls(t, 360)), (n = Ls(n, 100)), (e = Ls(e, 100))
											var i = Math.floor(t),
												r = t - i,
												o = e * (1 - n),
												s = e * (1 - r * n),
												a = e * (1 - (1 - r) * n),
												c = i % 6
											return {
												r: 255 * [e, s, o, o, a, e][c],
												g: 255 * [a, e, e, s, o, o][c],
												b: 255 * [o, o, a, e, e, s][c]
											}
									  })(t.h, i, r)),
									  (s = !0),
									  (a = "hsv"))
									: Gu(t.h) &&
									  Gu(t.s) &&
									  Gu(t.l) &&
									  ((i = tk(t.s)),
									  (o = tk(t.l)),
									  (n = (function aSe(t, n, e) {
											var i, r, o
											if (((t = Ls(t, 360)), (n = Ls(n, 100)), (e = Ls(e, 100)), 0 === n)) (r = e), (o = e), (i = e)
											else {
												var s = e < 0.5 ? e * (1 + n) : e + n - e * n,
													a = 2 * e - s
												;(i = uO(a, s, t + 1 / 3)), (r = uO(a, s, t)), (o = uO(a, s, t - 1 / 3))
											}
											return { r: 255 * i, g: 255 * r, b: 255 * o }
									  })(t.h, i, o)),
									  (s = !0),
									  (a = "hsl")),
								Object.prototype.hasOwnProperty.call(t, "a") && (e = t.a)),
							(e = CX(e)),
							{
								ok: s,
								format: t.format || a,
								r: Math.min(255, Math.max(n.r, 0)),
								g: Math.min(255, Math.max(n.g, 0)),
								b: Math.min(255, Math.max(n.b, 0)),
								a: e
							}
						)
					})(n)
					;(this.originalInput = n),
						(this.r = r.r),
						(this.g = r.g),
						(this.b = r.b),
						(this.a = r.a),
						(this.roundA = Math.round(100 * this.a) / 100),
						(this.format = null !== (i = e.format) && void 0 !== i ? i : r.format),
						(this.gradientType = e.gradientType),
						this.r < 1 && (this.r = Math.round(this.r)),
						this.g < 1 && (this.g = Math.round(this.g)),
						this.b < 1 && (this.b = Math.round(this.b)),
						(this.isValid = r.ok)
				}
				return (
					(t.prototype.isDark = function () {
						return this.getBrightness() < 128
					}),
					(t.prototype.isLight = function () {
						return !this.isDark()
					}),
					(t.prototype.getBrightness = function () {
						var n = this.toRgb()
						return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3
					}),
					(t.prototype.getLuminance = function () {
						var n = this.toRgb(),
							o = n.r / 255,
							s = n.g / 255,
							a = n.b / 255
						return (
							0.2126 * (o <= 0.03928 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4)) +
							0.7152 * (s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4)) +
							0.0722 * (a <= 0.03928 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4))
						)
					}),
					(t.prototype.getAlpha = function () {
						return this.a
					}),
					(t.prototype.setAlpha = function (n) {
						return (this.a = CX(n)), (this.roundA = Math.round(100 * this.a) / 100), this
					}),
					(t.prototype.isMonochrome = function () {
						return 0 === this.toHsl().s
					}),
					(t.prototype.toHsv = function () {
						var n = MX(this.r, this.g, this.b)
						return { h: 360 * n.h, s: n.s, v: n.v, a: this.a }
					}),
					(t.prototype.toHsvString = function () {
						var n = MX(this.r, this.g, this.b),
							e = Math.round(360 * n.h),
							i = Math.round(100 * n.s),
							r = Math.round(100 * n.v)
						return 1 === this.a
							? "hsv(".concat(e, ", ").concat(i, "%, ").concat(r, "%)")
							: "hsva(".concat(e, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")")
					}),
					(t.prototype.toHsl = function () {
						var n = EX(this.r, this.g, this.b)
						return { h: 360 * n.h, s: n.s, l: n.l, a: this.a }
					}),
					(t.prototype.toHslString = function () {
						var n = EX(this.r, this.g, this.b),
							e = Math.round(360 * n.h),
							i = Math.round(100 * n.s),
							r = Math.round(100 * n.l)
						return 1 === this.a
							? "hsl(".concat(e, ", ").concat(i, "%, ").concat(r, "%)")
							: "hsla(".concat(e, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")")
					}),
					(t.prototype.toHex = function (n) {
						return void 0 === n && (n = !1), SX(this.r, this.g, this.b, n)
					}),
					(t.prototype.toHexString = function (n) {
						return void 0 === n && (n = !1), "#" + this.toHex(n)
					}),
					(t.prototype.toHex8 = function (n) {
						return (
							void 0 === n && (n = !1),
							(function lSe(t, n, e, i, r) {
								var o = [
									Mp(Math.round(t).toString(16)),
									Mp(Math.round(n).toString(16)),
									Mp(Math.round(e).toString(16)),
									Mp(kX(i))
								]
								return r &&
									o[0].startsWith(o[0].charAt(1)) &&
									o[1].startsWith(o[1].charAt(1)) &&
									o[2].startsWith(o[2].charAt(1)) &&
									o[3].startsWith(o[3].charAt(1))
									? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0)
									: o.join("")
							})(this.r, this.g, this.b, this.a, n)
						)
					}),
					(t.prototype.toHex8String = function (n) {
						return void 0 === n && (n = !1), "#" + this.toHex8(n)
					}),
					(t.prototype.toRgb = function () {
						return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b), a: this.a }
					}),
					(t.prototype.toRgbString = function () {
						var n = Math.round(this.r),
							e = Math.round(this.g),
							i = Math.round(this.b)
						return 1 === this.a
							? "rgb(".concat(n, ", ").concat(e, ", ").concat(i, ")")
							: "rgba(".concat(n, ", ").concat(e, ", ").concat(i, ", ").concat(this.roundA, ")")
					}),
					(t.prototype.toPercentageRgb = function () {
						var n = function (e) {
							return "".concat(Math.round(100 * Ls(e, 255)), "%")
						}
						return { r: n(this.r), g: n(this.g), b: n(this.b), a: this.a }
					}),
					(t.prototype.toPercentageRgbString = function () {
						var n = function (e) {
							return Math.round(100 * Ls(e, 255))
						}
						return 1 === this.a
							? "rgb(".concat(n(this.r), "%, ").concat(n(this.g), "%, ").concat(n(this.b), "%)")
							: "rgba(".concat(n(this.r), "%, ").concat(n(this.g), "%, ").concat(n(this.b), "%, ").concat(this.roundA, ")")
					}),
					(t.prototype.toName = function () {
						if (0 === this.a) return "transparent"
						if (this.a < 1) return !1
						for (var n = "#" + SX(this.r, this.g, this.b, !1), e = 0, i = Object.entries(hO); e < i.length; e++) {
							var r = i[e]
							if (n === r[1]) return r[0]
						}
						return !1
					}),
					(t.prototype.toString = function (n) {
						var e = !!n
						n = n ?? this.format
						var i = !1
						return !e && this.a < 1 && this.a >= 0 && (n.startsWith("hex") || "name" === n)
							? "name" === n && 0 === this.a
								? this.toName()
								: this.toRgbString()
							: ("rgb" === n && (i = this.toRgbString()),
							  "prgb" === n && (i = this.toPercentageRgbString()),
							  ("hex" === n || "hex6" === n) && (i = this.toHexString()),
							  "hex3" === n && (i = this.toHexString(!0)),
							  "hex4" === n && (i = this.toHex8String(!0)),
							  "hex8" === n && (i = this.toHex8String()),
							  "name" === n && (i = this.toName()),
							  "hsl" === n && (i = this.toHslString()),
							  "hsv" === n && (i = this.toHsvString()),
							  i || this.toHexString())
					}),
					(t.prototype.toNumber = function () {
						return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
					}),
					(t.prototype.clone = function () {
						return new t(this.toString())
					}),
					(t.prototype.lighten = function (n) {
						void 0 === n && (n = 10)
						var e = this.toHsl()
						return (e.l += n / 100), (e.l = ek(e.l)), new t(e)
					}),
					(t.prototype.brighten = function (n) {
						void 0 === n && (n = 10)
						var e = this.toRgb()
						return (
							(e.r = Math.max(0, Math.min(255, e.r - Math.round((-n / 100) * 255)))),
							(e.g = Math.max(0, Math.min(255, e.g - Math.round((-n / 100) * 255)))),
							(e.b = Math.max(0, Math.min(255, e.b - Math.round((-n / 100) * 255)))),
							new t(e)
						)
					}),
					(t.prototype.darken = function (n) {
						void 0 === n && (n = 10)
						var e = this.toHsl()
						return (e.l -= n / 100), (e.l = ek(e.l)), new t(e)
					}),
					(t.prototype.tint = function (n) {
						return void 0 === n && (n = 10), this.mix("white", n)
					}),
					(t.prototype.shade = function (n) {
						return void 0 === n && (n = 10), this.mix("black", n)
					}),
					(t.prototype.desaturate = function (n) {
						void 0 === n && (n = 10)
						var e = this.toHsl()
						return (e.s -= n / 100), (e.s = ek(e.s)), new t(e)
					}),
					(t.prototype.saturate = function (n) {
						void 0 === n && (n = 10)
						var e = this.toHsl()
						return (e.s += n / 100), (e.s = ek(e.s)), new t(e)
					}),
					(t.prototype.greyscale = function () {
						return this.desaturate(100)
					}),
					(t.prototype.spin = function (n) {
						var e = this.toHsl(),
							i = (e.h + n) % 360
						return (e.h = i < 0 ? 360 + i : i), new t(e)
					}),
					(t.prototype.mix = function (n, e) {
						void 0 === e && (e = 50)
						var i = this.toRgb(),
							r = new t(n).toRgb(),
							o = e / 100
						return new t({
							r: (r.r - i.r) * o + i.r,
							g: (r.g - i.g) * o + i.g,
							b: (r.b - i.b) * o + i.b,
							a: (r.a - i.a) * o + i.a
						})
					}),
					(t.prototype.analogous = function (n, e) {
						void 0 === n && (n = 6), void 0 === e && (e = 30)
						var i = this.toHsl(),
							r = 360 / e,
							o = [this]
						for (i.h = (i.h - ((r * n) >> 1) + 720) % 360; --n; ) (i.h = (i.h + r) % 360), o.push(new t(i))
						return o
					}),
					(t.prototype.complement = function () {
						var n = this.toHsl()
						return (n.h = (n.h + 180) % 360), new t(n)
					}),
					(t.prototype.monochromatic = function (n) {
						void 0 === n && (n = 6)
						for (var e = this.toHsv(), i = e.h, r = e.s, o = e.v, s = [], a = 1 / n; n--; )
							s.push(new t({ h: i, s: r, v: o })), (o = (o + a) % 1)
						return s
					}),
					(t.prototype.splitcomplement = function () {
						var n = this.toHsl(),
							e = n.h
						return [this, new t({ h: (e + 72) % 360, s: n.s, l: n.l }), new t({ h: (e + 216) % 360, s: n.s, l: n.l })]
					}),
					(t.prototype.onBackground = function (n) {
						var e = this.toRgb(),
							i = new t(n).toRgb()
						return new t({ r: i.r + (e.r - i.r) * e.a, g: i.g + (e.g - i.g) * e.a, b: i.b + (e.b - i.b) * e.a })
					}),
					(t.prototype.triad = function () {
						return this.polyad(3)
					}),
					(t.prototype.tetrad = function () {
						return this.polyad(4)
					}),
					(t.prototype.polyad = function (n) {
						for (var e = this.toHsl(), i = e.h, r = [this], o = 360 / n, s = 1; s < n; s++)
							r.push(new t({ h: (i + s * o) % 360, s: e.s, l: e.l }))
						return r
					}),
					(t.prototype.equals = function (n) {
						return this.toRgbString() === new t(n).toRgbString()
					}),
					t
				)
			})()
			function pSe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "span", 3),
						Le("mousedown", function (r) {
							return rn(e), on(Te().handleMousedown(r))
						}),
						ge(1),
						L()
				}
				if (2 & t) {
					const e = Te()
					U("id", e.uniqueId)("ngStyle", e.labelStyle), T(1), Vt(" ", e.label, " ")
				}
			}
			function ASe(t, n) {
				if ((1 & t && (F(0, "div", 2), fe(1, "div", 3), L()), 2 & t)) {
					const e = Te()
					bi("left", e.left)("top", e.top), T(1), U("ngStyle", e.pointer)
				}
			}
			const pO = {}
			let FX = (() => {
					class t {
						constructor() {
							;(this.white = "transparent"), (this.size = 8), (this.grey = "rgba(0,0,0,.08)")
						}
						ngOnInit() {
							const e = (function bSe(t, n, e) {
								const i = `${t}-${n}-${e}`
								if (pO[i]) return pO[i]
								const r = (function gSe(t, n, e) {
									if (typeof document > "u") return null
									const i = document.createElement("canvas")
									;(i.width = 2 * e), (i.height = 2 * e)
									const r = i.getContext("2d")
									return r
										? ((r.fillStyle = t),
										  r.fillRect(0, 0, i.width, i.height),
										  (r.fillStyle = n),
										  r.fillRect(0, 0, e, e),
										  r.translate(e, e),
										  r.fillRect(0, 0, e, e),
										  i.toDataURL())
										: null
								})(t, n, e)
								return r ? ((pO[i] = r), r) : null
							})(this.white, this.grey, this.size)
							this.gridStyles = {
								borderRadius: this.borderRadius,
								boxShadow: this.boxShadow,
								background: `url(${e}) center left`
							}
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵcmp = Ye({
							type: t,
							selectors: [["color-checkboard"]],
							inputs: { white: "white", size: "size", grey: "grey", boxShadow: "boxShadow", borderRadius: "borderRadius" },
							decls: 1,
							vars: 1,
							consts: [[1, "grid", 3, "ngStyle"]],
							template: function (e, i) {
								1 & e && fe(0, "div", 0), 2 & e && U("ngStyle", i.gridStyles)
							},
							dependencies: [og],
							styles: [".grid[_ngcontent-%COMP%]{top:0px;right:0px;bottom:0px;left:0px;position:absolute}"],
							changeDetection: 0
						})),
						t
					)
				})(),
				BX = (() => {
					class t {}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵmod = at({ type: t })),
						(t.ɵinj = rt({ imports: [[Ot]] })),
						t
					)
				})(),
				AO = (() => {
					class t {
						constructor(e) {
							;(this.el = e), (this.coordinatesChange = new vt()), (this.mousechange = new vt()), (this.mouseListening = !1)
						}
						mousemove(e, i, r, o = !1) {
							this.mouseListening && (e.preventDefault(), this.mousechange.next({ $event: e, x: i, y: r, isTouch: o }))
						}
						mouseup() {
							this.mouseListening = !1
						}
						mousedown(e, i, r, o = !1) {
							e.preventDefault(), (this.mouseListening = !0), this.mousechange.next({ $event: e, x: i, y: r, isTouch: o })
						}
						ngOnInit() {
							this.sub = this.mousechange
								.pipe(Ys((e, i) => e.x === i.x && e.y === i.y))
								.subscribe(e => this.handleChange(e.x, e.y, e.$event, e.isTouch))
						}
						ngOnDestroy() {
							this.sub.unsubscribe()
						}
						handleChange(e, i, r, o) {
							const s = this.el.nativeElement.clientWidth,
								a = this.el.nativeElement.clientHeight,
								c = e - (this.el.nativeElement.getBoundingClientRect().left + window.pageXOffset)
							let l = i - this.el.nativeElement.getBoundingClientRect().top
							o || (l -= window.pageYOffset),
								this.coordinatesChange.next({
									x: e,
									y: i,
									top: l,
									left: c,
									containerWidth: s,
									containerHeight: a,
									$event: r
								})
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)(P(wn))
						}),
						(t.ɵdir = yt({
							type: t,
							selectors: [["", "ngx-color-coordinates", ""]],
							hostBindings: function (e, i) {
								1 & e &&
									Le(
										"mousemove",
										function (o) {
											return i.mousemove(o, o.pageX, o.pageY)
										},
										0,
										q_
									)(
										"touchmove",
										function (o) {
											return i.mousemove(o, o.touches[0].clientX, o.touches[0].clientY, !0)
										},
										!1,
										q_
									)(
										"mouseup",
										function () {
											return i.mouseup()
										},
										!1,
										q_
									)(
										"touchend",
										function () {
											return i.mouseup()
										},
										!1,
										q_
									)("mousedown", function (o) {
										return i.mousedown(o, o.pageX, o.pageY)
									})("touchstart", function (o) {
										return i.mousedown(o, o.touches[0].clientX, o.touches[0].clientY, !0)
									})
							},
							outputs: { coordinatesChange: "coordinatesChange" }
						})),
						t
					)
				})(),
				gO = (() => {
					class t {}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵmod = at({ type: t })),
						(t.ɵinj = rt({})),
						t
					)
				})(),
				_Se = (() => {
					class t {
						constructor() {
							;(this.direction = "horizontal"), (this.onChange = new _n())
						}
						ngOnChanges() {
							"vertical" === this.direction
								? ((this.pointerLeft = 0),
								  (this.pointerTop = 100 * this.rgb.a),
								  (this.gradient = {
										background: `linear-gradient(to bottom, rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 0) 0%,\n          rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 1) 100%)`
								  }))
								: ((this.gradient = {
										background: `linear-gradient(to right, rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 0) 0%,\n          rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 1) 100%)`
								  }),
								  (this.pointerLeft = 100 * this.rgb.a))
						}
						handleChange({ top: e, left: i, containerHeight: r, containerWidth: o, $event: s }) {
							let a
							if ("vertical" === this.direction) {
								let c
								;(c = e < 0 ? 0 : e > r ? 1 : Math.round((100 * e) / r) / 100),
									this.hsl.a !== c && (a = { h: this.hsl.h, s: this.hsl.s, l: this.hsl.l, a: c, source: "rgb" })
							} else {
								let c
								;(c = i < 0 ? 0 : i > o ? 1 : Math.round((100 * i) / o) / 100),
									this.hsl.a !== c && (a = { h: this.hsl.h, s: this.hsl.s, l: this.hsl.l, a: c, source: "rgb" })
							}
							a && this.onChange.emit({ data: a, $event: s })
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵcmp = Ye({
							type: t,
							selectors: [["color-alpha"]],
							inputs: {
								hsl: "hsl",
								rgb: "rgb",
								pointer: "pointer",
								shadow: "shadow",
								radius: "radius",
								direction: "direction"
							},
							outputs: { onChange: "onChange" },
							features: [Ar],
							decls: 7,
							vars: 15,
							consts: [
								[1, "alpha"],
								[1, "alpha-checkboard"],
								[1, "alpha-gradient", 3, "ngStyle"],
								["ngx-color-coordinates", "", 3, "coordinatesChange"],
								[1, "alpha-pointer"],
								[1, "alpha-slider", 3, "ngStyle"]
							],
							template: function (e, i) {
								1 & e &&
									(F(0, "div", 0)(1, "div", 1),
									fe(2, "color-checkboard"),
									L(),
									fe(3, "div", 2),
									F(4, "div", 3),
									Le("coordinatesChange", function (o) {
										return i.handleChange(o)
									}),
									F(5, "div", 4),
									fe(6, "div", 5),
									L()()()),
									2 & e &&
										(bi("border-radius", i.radius),
										T(3),
										bi("box-shadow", i.shadow)("border-radius", i.radius),
										U("ngStyle", i.gradient),
										T(1),
										du("alpha-container color-alpha-", i.direction, ""),
										T(1),
										bi("left", i.pointerLeft, "%")("top", i.pointerTop, "%"),
										T(1),
										U("ngStyle", i.pointer))
							},
							dependencies: [FX, og, AO],
							styles: [
								".alpha[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;left:0;right:0}.alpha-checkboard[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;left:0;right:0;overflow:hidden}.alpha-gradient[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;left:0;right:0}.alpha-container[_ngcontent-%COMP%]{position:relative;height:100%;margin:0 3px}.alpha-pointer[_ngcontent-%COMP%]{position:absolute}.alpha-slider[_ngcontent-%COMP%]{width:4px;border-radius:1px;height:8px;box-shadow:0 0 2px #0009;background:#fff;margin-top:1px;transform:translate(-2px)}"
							],
							changeDetection: 0
						})),
						t
					)
				})(),
				vSe = (() => {
					class t {}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵmod = at({ type: t })),
						(t.ɵinj = rt({ imports: [[Ot, BX, gO]] })),
						t
					)
				})()
			function IX(t) {
				let e = 0,
					i = 0
				return (
					["r", "g", "b", "a", "h", "s", "l", "v"].forEach(r => {
						t[r] && ((e += 1), isNaN(t[r]) || (i += 1), ("s" === r || "l" === r) && /^\d+%$/.test(t[r]) && (i += 1))
					}),
					e === i && t
				)
			}
			function bw(t, n, e) {
				const i = new gw(t.hex ? t.hex : t)
				e && i.setAlpha(1)
				const r = i.toHsl(),
					o = i.toHsv(),
					s = i.toRgb(),
					a = i.toHex()
				return (
					0 === r.s && ((r.h = n || 0), (o.h = n || 0)),
					{
						hsl: r,
						hex: "000000" === a && 0 === s.a ? "transparent" : i.toHexString(),
						rgb: s,
						hsv: o,
						oldHue: t.h || n || r.h,
						source: t.source
					}
				)
			}
			var Eb = (function (t) {
				return (t.HEX = "hex"), (t.HSL = "hsl"), (t.HSV = "hsv"), (t.RGB = "rgb"), t
			})(Eb || {})
			let DX = (() => {
					class t {
						constructor() {
							;(this.mode = Eb.HEX),
								(this.color = { h: 250, s: 0.5, l: 0.2, a: 1 }),
								(this.colorChange = new _n()),
								(this.onChange = new _n()),
								(this.onChangeComplete = new _n()),
								(this.onSwatchHover = new _n()),
								(this._onChangeCompleteSubscription = new D()),
								(this._onSwatchHoverSubscription = new D())
						}
						ngOnInit() {
							;(this.changes = this.onChange
								.pipe(
									ug(100),
									eo(e => {
										switch ((this.onChangeComplete.emit(e), this.mode)) {
											case Eb.HEX:
												this.colorChange.emit(e.color.hex)
												break
											case Eb.HSL:
												this.colorChange.emit(e.color.hsl)
												break
											case Eb.HSV:
												this.colorChange.emit(e.color.hsv)
												break
											case Eb.RGB:
												this.colorChange.emit(e.color.rgb)
												break
											default:
												console.warn(`The mode '${this.mode}' is not supported`)
										}
									})
								)
								.subscribe()),
								this.setState(bw(this.color, 0)),
								(this.currentColor = this.hex)
						}
						ngOnChanges() {
							this.setState(bw(this.color, this.oldHue))
						}
						ngOnDestroy() {
							this.changes?.unsubscribe(),
								this._onChangeCompleteSubscription.unsubscribe(),
								this._onSwatchHoverSubscription.unsubscribe()
						}
						setState(e) {
							;(this.oldHue = e.oldHue),
								(this.hsl = e.hsl),
								(this.hsv = e.hsv),
								(this.rgb = e.rgb),
								(this.hex = e.hex),
								(this.source = e.source),
								this.afterValidChange()
						}
						handleChange(e, i) {
							if (IX(e)) {
								const o = bw(e, e.h || this.oldHue, this.disableAlpha)
								this.setState(o), this.onChange.emit({ color: o, $event: i }), this.afterValidChange()
							}
						}
						afterValidChange() {}
						handleSwatchHover(e, i) {
							if (IX(e)) {
								const o = bw(e, e.h || this.oldHue)
								this.setState(o), this.onSwatchHover.emit({ color: o, $event: i })
							}
						}
						registerOnChange(e) {
							this._onChangeCompleteSubscription.add(this.onChangeComplete.pipe(eo(i => e(i.color.hex))).subscribe())
						}
						registerOnTouched(e) {
							this._onSwatchHoverSubscription.add(this.onSwatchHover.pipe(eo(() => e())).subscribe())
						}
						setDisabledState(e) {}
						writeValue(e) {
							this.color = e
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵcmp = Ye({
							type: t,
							selectors: [["color-wrap"]],
							inputs: { className: "className", mode: "mode", color: "color" },
							outputs: {
								colorChange: "colorChange",
								onChange: "onChange",
								onChangeComplete: "onChangeComplete",
								onSwatchHover: "onSwatchHover"
							},
							features: [Xn([{ provide: ds, useExisting: Kn(() => t), multi: !0 }]), Ar],
							decls: 0,
							vars: 0,
							template: function (e, i) {},
							encapsulation: 2
						})),
						t
					)
				})(),
				wSe = 0,
				xSe = (() => {
					class t {
						constructor() {
							;(this.placeholder = ""),
								(this.onChange = new _n()),
								(this.focus = !1),
								(this.uniqueId = "editableInput-" + ++wSe)
						}
						ngOnInit() {
							;(this.wrapStyle = this.style && this.style.wrap ? this.style.wrap : {}),
								(this.inputStyle = this.style && this.style.input ? this.style.input : {}),
								(this.labelStyle = this.style && this.style.label ? this.style.label : {}),
								this.dragLabel && (this.labelStyle.cursor = "ew-resize")
						}
						handleFocus(e) {
							this.focus = !0
						}
						handleFocusOut(e) {
							;(this.focus = !1), (this.currentValue = this.blurValue)
						}
						handleKeydown(e) {
							const i = String(e.target.value),
								r = i.indexOf("%") > -1,
								o = Number(i.replace(/%/g, ""))
							if (isNaN(o)) return
							const s = this.arrowOffset || 1
							38 === e.keyCode &&
								(this.onChange.emit(this.label ? { data: { [this.label]: o + s }, $event: e } : { data: o + s, $event: e }),
								(this.currentValue = r ? `${o + s}%` : o + s)),
								40 === e.keyCode &&
									(this.onChange.emit(
										this.label ? { data: { [this.label]: o - s }, $event: e } : { data: o - s, $event: e }
									),
									(this.currentValue = r ? o - s + "%" : o - s))
						}
						handleKeyup(e) {
							40 === e.keyCode ||
								38 === e.keyCode ||
								(`${this.currentValue}` !== e.target.value &&
									this.onChange.emit(
										this.label
											? { data: { [this.label]: e.target.value }, $event: e }
											: { data: e.target.value, $event: e }
									))
						}
						ngOnChanges() {
							this.focus || (this.currentValue = String(this.value).toUpperCase()),
								(this.blurValue = String(this.value).toUpperCase())
						}
						ngOnDestroy() {
							this.unsubscribe()
						}
						subscribe() {
							;(this.mousemove = mg(document, "mousemove").subscribe(e => this.handleDrag(e))),
								(this.mouseup = mg(document, "mouseup").subscribe(() => this.unsubscribe()))
						}
						unsubscribe() {
							this.mousemove && this.mousemove.unsubscribe(), this.mouseup && this.mouseup.unsubscribe()
						}
						handleMousedown(e) {
							this.dragLabel && (e.preventDefault(), this.handleDrag(e), this.subscribe())
						}
						handleDrag(e) {
							if (this.dragLabel) {
								const i = Math.round(this.value + e.movementX)
								i >= 0 && i <= this.dragMax && this.onChange.emit({ data: { [this.label]: i }, $event: e })
							}
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵcmp = Ye({
							type: t,
							selectors: [["color-editable-input"]],
							inputs: {
								style: "style",
								label: "label",
								value: "value",
								arrowOffset: "arrowOffset",
								dragLabel: "dragLabel",
								dragMax: "dragMax",
								placeholder: "placeholder"
							},
							outputs: { onChange: "onChange" },
							features: [Ar],
							decls: 3,
							vars: 6,
							consts: [
								[1, "wrap", 3, "ngStyle"],
								["spellCheck", "false", 3, "ngStyle", "value", "placeholder", "keydown", "keyup", "focus", "focusout"],
								[3, "id", "ngStyle", "mousedown", 4, "ngIf"],
								[3, "id", "ngStyle", "mousedown"]
							],
							template: function (e, i) {
								1 & e &&
									(F(0, "div", 0)(1, "input", 1),
									Le("keydown", function (o) {
										return i.handleKeydown(o)
									})("keyup", function (o) {
										return i.handleKeyup(o)
									})("focus", function (o) {
										return i.handleFocus(o)
									})("focusout", function (o) {
										return i.handleFocusOut(o)
									}),
									L(),
									Ee(2, pSe, 2, 3, "span", 2),
									L()),
									2 & e &&
										(U("ngStyle", i.wrapStyle),
										T(1),
										U("ngStyle", i.inputStyle)("value", i.currentValue)("placeholder", i.placeholder),
										qn("aria-labelledby", i.uniqueId),
										T(1),
										U("ngIf", i.label))
							},
							dependencies: [og, En],
							styles: ["[_nghost-%COMP%]{display:flex}.wrap[_ngcontent-%COMP%]{position:relative}"],
							changeDetection: 0
						})),
						t
					)
				})(),
				CSe = (() => {
					class t {}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵmod = at({ type: t })),
						(t.ɵinj = rt({ imports: [[Ot]] })),
						t
					)
				})(),
				ESe = (() => {
					class t {
						constructor() {
							;(this.hidePointer = !1),
								(this.direction = "horizontal"),
								(this.onChange = new _n()),
								(this.left = "0px"),
								(this.top = "")
						}
						ngOnChanges() {
							"horizontal" === this.direction
								? (this.left = (100 * this.hsl.h) / 360 + "%")
								: (this.top = (-100 * this.hsl.h) / 360 + 100 + "%")
						}
						handleChange({ top: e, left: i, containerHeight: r, containerWidth: o, $event: s }) {
							let a
							if ("vertical" === this.direction) {
								let c
								;(c = e < 0 ? 359 : e > r ? 0 : (360 * ((-100 * e) / r + 100)) / 100),
									this.hsl.h !== c && (a = { h: c, s: this.hsl.s, l: this.hsl.l, a: this.hsl.a, source: "rgb" })
							} else {
								let c
								;(c = i < 0 ? 0 : i > o ? 359 : (((100 * i) / o) * 360) / 100),
									this.hsl.h !== c && (a = { h: c, s: this.hsl.s, l: this.hsl.l, a: this.hsl.a, source: "rgb" })
							}
							a && this.onChange.emit({ data: a, $event: s })
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵcmp = Ye({
							type: t,
							selectors: [["color-hue"]],
							inputs: {
								hsl: "hsl",
								pointer: "pointer",
								radius: "radius",
								shadow: "shadow",
								hidePointer: "hidePointer",
								direction: "direction"
							},
							outputs: { onChange: "onChange" },
							features: [Ar],
							decls: 3,
							vars: 8,
							consts: [
								["ngx-color-coordinates", "", 1, "color-hue-container", 3, "coordinatesChange"],
								["class", "color-hue-pointer", 3, "left", "top", 4, "ngIf"],
								[1, "color-hue-pointer"],
								[1, "color-hue-slider", 3, "ngStyle"]
							],
							template: function (e, i) {
								1 & e &&
									(F(0, "div")(1, "div", 0),
									Le("coordinatesChange", function (o) {
										return i.handleChange(o)
									}),
									Ee(2, ASe, 2, 5, "div", 1),
									L()()),
									2 & e &&
										(du("color-hue color-hue-", i.direction, ""),
										bi("border-radius", i.radius, "px")("box-shadow", i.shadow),
										T(2),
										U("ngIf", !i.hidePointer))
							},
							dependencies: [AO, En, og],
							styles: [
								".color-hue[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;left:0;right:0}.color-hue-container[_ngcontent-%COMP%]{margin:0 2px;position:relative;height:100%}.color-hue-pointer[_ngcontent-%COMP%]{position:absolute}.color-hue-slider[_ngcontent-%COMP%]{margin-top:1px;width:4px;border-radius:1px;height:8px;box-shadow:0 0 2px #0009;background:#fff;transform:translate(-2px)}.color-hue-horizontal[_ngcontent-%COMP%]{background:linear-gradient(to right,#f00 0%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00 100%)}.color-hue-vertical[_ngcontent-%COMP%]{background:linear-gradient(to top,#f00 0%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00 100%)}"
							],
							changeDetection: 0
						})),
						t
					)
				})(),
				MSe = (() => {
					class t {}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵmod = at({ type: t })),
						(t.ɵinj = rt({ imports: [[Ot, gO]] })),
						t
					)
				})(),
				SSe = (() => {
					class t {
						constructor() {
							this.onChange = new _n()
						}
						ngOnChanges() {
							;(this.background = `hsl(${this.hsl.h}, 100%, 50%)`),
								(this.pointerTop = -100 * this.hsv.v + 1 + 100 + "%"),
								(this.pointerLeft = 100 * this.hsv.s + "%")
						}
						handleChange({ top: e, left: i, containerHeight: r, containerWidth: o, $event: s }) {
							i < 0 ? (i = 0) : i > o ? (i = o) : e < 0 ? (e = 0) : e > r && (e = r)
							let c = -e / r + 1
							;(c = c > 0 ? c : 0),
								(c = c > 1 ? 1 : c),
								this.onChange.emit({ data: { h: this.hsl.h, s: i / o, v: c, a: this.hsl.a, source: "hsva" }, $event: s })
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵcmp = Ye({
							type: t,
							selectors: [["color-saturation"]],
							inputs: { hsl: "hsl", hsv: "hsv", radius: "radius", pointer: "pointer", circle: "circle" },
							outputs: { onChange: "onChange" },
							features: [Ar],
							decls: 5,
							vars: 8,
							consts: [
								["ngx-color-coordinates", "", 1, "color-saturation", 3, "coordinatesChange"],
								[1, "saturation-white"],
								[1, "saturation-black"],
								[1, "saturation-pointer", 3, "ngStyle"],
								[1, "saturation-circle", 3, "ngStyle"]
							],
							template: function (e, i) {
								1 & e &&
									(F(0, "div", 0),
									Le("coordinatesChange", function (o) {
										return i.handleChange(o)
									}),
									F(1, "div", 1),
									fe(2, "div", 2),
									F(3, "div", 3),
									fe(4, "div", 4),
									L()()()),
									2 & e &&
										(bi("background", i.background),
										T(3),
										bi("top", i.pointerTop)("left", i.pointerLeft),
										U("ngStyle", i.pointer),
										T(1),
										U("ngStyle", i.circle))
							},
							dependencies: [AO, og],
							styles: [
								".saturation-white[_ngcontent-%COMP%]{background:linear-gradient(to right,#fff,rgba(255,255,255,0));position:absolute;top:0;bottom:0;left:0;right:0}.saturation-black[_ngcontent-%COMP%]{background:linear-gradient(to top,#000,rgba(0,0,0,0));position:absolute;top:0;bottom:0;left:0;right:0}.color-saturation[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;left:0;right:0}.saturation-pointer[_ngcontent-%COMP%]{position:absolute;cursor:default}.saturation-circle[_ngcontent-%COMP%]{width:4px;height:4px;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px #0000004d,0 0 1px 2px #0006;border-radius:50%;cursor:hand;transform:translate(-2px,-4px)}"
							],
							changeDetection: 0
						})),
						t
					)
				})(),
				kSe = (() => {
					class t {}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵmod = at({ type: t })),
						(t.ɵinj = rt({ imports: [[Ot, gO]] })),
						t
					)
				})()
			const $u = function (t, n) {
				return { input: t, label: n }
			}
			function TSe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div", 11)(1, "color-editable-input", 12),
						Le("onChange", function (r) {
							return rn(e), on(Te().handleChange(r))
						}),
						L()()
				}
				if (2 & t) {
					const e = Te()
					T(1), es(al(3, $u, e.input, e.label)), U("value", e.hex)
				}
			}
			function FSe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "color-editable-input", 17),
						Le("onChange", function (r) {
							return rn(e), on(Te(2).handleChange(r))
						}),
						L()
				}
				if (2 & t) {
					const e = Te(2)
					es(al(4, $u, e.input, e.label)), U("value", e.rgb.a)("arrowOffset", 0.01)
				}
			}
			function BSe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div", 11)(1, "color-editable-input", 13),
						Le("onChange", function (r) {
							return rn(e), on(Te().handleChange(r))
						}),
						L()(),
						F(2, "div", 11)(3, "color-editable-input", 14),
						Le("onChange", function (r) {
							return rn(e), on(Te().handleChange(r))
						}),
						L()(),
						F(4, "div", 11)(5, "color-editable-input", 15),
						Le("onChange", function (r) {
							return rn(e), on(Te().handleChange(r))
						}),
						L()(),
						F(6, "div", 11),
						Ee(7, FSe, 1, 7, "color-editable-input", 16),
						L()
				}
				if (2 & t) {
					const e = Te()
					T(1),
						es(al(10, $u, e.input, e.label)),
						U("value", e.rgb.r),
						T(2),
						es(al(13, $u, e.input, e.label)),
						U("value", e.rgb.g),
						T(2),
						es(al(16, $u, e.input, e.label)),
						U("value", e.rgb.b),
						T(2),
						U("ngIf", !e.disableAlpha)
				}
			}
			function ISe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "color-editable-input", 17),
						Le("onChange", function (r) {
							return rn(e), on(Te(2).handleChange(r))
						}),
						L()
				}
				if (2 & t) {
					const e = Te(2)
					es(al(4, $u, e.input, e.label)), U("value", e.hsl.a)("arrowOffset", 0.01)
				}
			}
			function DSe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div", 11)(1, "color-editable-input", 18),
						Le("onChange", function (r) {
							return rn(e), on(Te().handleChange(r))
						}),
						L()(),
						F(2, "div", 11)(3, "color-editable-input", 19),
						Le("onChange", function (r) {
							return rn(e), on(Te().handleChange(r))
						}),
						L()(),
						F(4, "div", 11)(5, "color-editable-input", 20),
						Le("onChange", function (r) {
							return rn(e), on(Te().handleChange(r))
						}),
						L()(),
						F(6, "div", 11),
						Ee(7, ISe, 1, 7, "color-editable-input", 16),
						L()
				}
				if (2 & t) {
					const e = Te()
					T(1),
						es(al(10, $u, e.input, e.label)),
						U("value", e.round(e.hsl.h)),
						T(2),
						es(al(13, $u, e.input, e.label)),
						U("value", e.round(100 * e.hsl.s) + "%"),
						T(2),
						es(al(16, $u, e.input, e.label)),
						U("value", e.round(100 * e.hsl.l) + "%"),
						T(2),
						U("ngIf", !e.disableAlpha)
				}
			}
			function LSe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div", 12)(1, "color-alpha", 13),
						Le("onChange", function (r) {
							return rn(e), on(Te().handleValueChange(r))
						}),
						L()()
				}
				if (2 & t) {
					const e = Te()
					T(1), U("radius", 2)("rgb", e.rgb)("hsl", e.hsl)("pointer", e.pointer)
				}
			}
			let RSe = (() => {
					class t {
						constructor() {
							;(this.onChange = new _n()),
								(this.view = ""),
								(this.input = {
									fontSize: "11px",
									color: "#333",
									width: "100%",
									borderRadius: "2px",
									border: "none",
									boxShadow: "inset 0 0 0 1px #dadada",
									height: "21px",
									"text-align": "center"
								}),
								(this.label = {
									"text-transform": "uppercase",
									fontSize: "11px",
									"line-height": "11px",
									color: "#969696",
									"text-align": "center",
									display: "block",
									marginTop: "12px"
								})
						}
						ngOnInit() {
							1 === this.hsl.a && "hex" !== this.view
								? (this.view = "hex")
								: "rgb" !== this.view && "hsl" !== this.view && (this.view = "rgb")
						}
						toggleViews() {
							"hex" === this.view
								? (this.view = "rgb")
								: "rgb" === this.view
								? (this.view = "hsl")
								: "hsl" === this.view && (this.view = 1 === this.hsl.a ? "hex" : "rgb")
						}
						round(e) {
							return Math.round(e)
						}
						handleChange({ data: e, $event: i }) {
							if (e.hex) {
								if (
									(function ySe(t) {
										return new gw(t).isValid
									})(e.hex)
								) {
									const r = new gw(e.hex)
									this.onChange.emit({
										data: { hex: this.disableAlpha ? r.toHex() : r.toHex8(), source: "hex" },
										$event: i
									})
								}
							} else if (e.r || e.g || e.b)
								this.onChange.emit({
									data: { r: e.r || this.rgb.r, g: e.g || this.rgb.g, b: e.b || this.rgb.b, source: "rgb" },
									$event: i
								})
							else if (e.a)
								e.a < 0 ? (e.a = 0) : e.a > 1 && (e.a = 1),
									this.disableAlpha && (e.a = 1),
									this.onChange.emit({
										data: {
											h: this.hsl.h,
											s: this.hsl.s,
											l: this.hsl.l,
											a: Math.round(100 * e.a) / 100,
											source: "rgb"
										},
										$event: i
									})
							else if (e.h || e.s || e.l) {
								const r = e.s && e.s.replace("%", ""),
									o = e.l && e.l.replace("%", "")
								this.onChange.emit({
									data: { h: e.h || this.hsl.h, s: Number(r || this.hsl.s), l: Number(o || this.hsl.l), source: "hsl" },
									$event: i
								})
							}
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵcmp = Ye({
							type: t,
							selectors: [["color-chrome-fields"]],
							inputs: { disableAlpha: "disableAlpha", hsl: "hsl", rgb: "rgb", hex: "hex" },
							outputs: { onChange: "onChange" },
							decls: 13,
							vars: 3,
							consts: [
								[1, "chrome-wrap"],
								[1, "chrome-fields"],
								[3, "ngIf"],
								[1, "chrome-toggle"],
								[1, "chrome-icon", 3, "click"],
								["icon", ""],
								["viewBox", "0 0 24 24", 1, "chrome-toggle-svg"],
								["fill", "#333", "d", "M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z"],
								["iconUp", ""],
								["fill", "#333", "d", "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15Z"],
								["iconDown", ""],
								[1, "chrome-field"],
								["label", "hex", 3, "value", "onChange"],
								["label", "r", 3, "value", "onChange"],
								["label", "g", 3, "value", "onChange"],
								["label", "b", 3, "value", "onChange"],
								["label", "a", 3, "style", "value", "arrowOffset", "onChange", 4, "ngIf"],
								["label", "a", 3, "value", "arrowOffset", "onChange"],
								["label", "h", 3, "value", "onChange"],
								["label", "s", 3, "value", "onChange"],
								["label", "l", 3, "value", "onChange"]
							],
							template: function (e, i) {
								1 & e &&
									(F(0, "div", 0)(1, "div", 1),
									Ee(2, TSe, 2, 6, "ng-template", 2),
									Ee(3, BSe, 8, 19, "ng-template", 2),
									Ee(4, DSe, 8, 19, "ng-template", 2),
									L(),
									F(5, "div", 3)(6, "div", 4, 5),
									Le("click", function () {
										return i.toggleViews()
									}),
									Xa(),
									F(8, "svg", 6),
									fe(9, "path", 7, 8)(11, "path", 9, 10),
									L()()()()),
									2 & e &&
										(T(2),
										U("ngIf", "hex" === i.view),
										T(1),
										U("ngIf", "rgb" === i.view),
										T(1),
										U("ngIf", "hsl" === i.view))
							},
							dependencies: [xSe, En],
							styles: [
								".chrome-wrap[_ngcontent-%COMP%]{padding-top:16px;display:flex}.chrome-fields[_ngcontent-%COMP%]{flex:1;display:flex;margin-left:-6px}.chrome-field[_ngcontent-%COMP%]{padding-left:6px;width:100%}.chrome-toggle[_ngcontent-%COMP%]{width:32px;text-align:right;position:relative}.chrome-icon[_ngcontent-%COMP%]{margin-right:-4px;margin-top:12px;cursor:pointer;position:relative}.chrome-toggle-svg[_ngcontent-%COMP%]{width:24px;height:24px;border:1px transparent solid;border-radius:5px}.chrome-toggle-svg[_ngcontent-%COMP%]:hover{background:#eee}"
							],
							changeDetection: 0
						})),
						t
					)
				})(),
				PSe = (() => {
					class t extends DX {
						constructor() {
							super(),
								(this.disableAlpha = !1),
								(this.circle = {
									width: "12px",
									height: "12px",
									borderRadius: "6px",
									boxShadow: "rgb(255, 255, 255) 0px 0px 0px 1px inset",
									transform: "translate(-6px, -8px)"
								}),
								(this.pointer = {
									width: "12px",
									height: "12px",
									borderRadius: "6px",
									transform: "translate(-6px, -2px)",
									backgroundColor: "rgb(248, 248, 248)",
									boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
								})
						}
						afterValidChange() {
							this.activeBackground = `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${
								this.disableAlpha ? 1 : this.rgb.a
							})`
						}
						handleValueChange({ data: e, $event: i }) {
							this.handleChange(e, i)
						}
					}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵcmp = Ye({
							type: t,
							selectors: [["color-chrome"]],
							inputs: { disableAlpha: "disableAlpha" },
							features: [
								Xn([
									{ provide: ds, useExisting: Kn(() => t), multi: !0 },
									{ provide: DX, useExisting: Kn(() => t) }
								]),
								pn
							],
							decls: 14,
							vars: 16,
							consts: [
								[1, "saturation"],
								[3, "hsl", "hsv", "circle", "onChange"],
								[1, "chrome-body"],
								[1, "chrome-controls"],
								[1, "chrome-color"],
								[1, "chrome-swatch"],
								[1, "chrome-active"],
								[1, "chrome-toggles"],
								[1, "chrome-hue"],
								[3, "radius", "hsl", "pointer", "onChange"],
								["class", "chrome-alpha", 4, "ngIf"],
								[3, "rgb", "hsl", "hex", "disableAlpha", "onChange"],
								[1, "chrome-alpha"],
								[3, "radius", "rgb", "hsl", "pointer", "onChange"]
							],
							template: function (e, i) {
								1 & e &&
									(F(0, "div")(1, "div", 0)(2, "color-saturation", 1),
									Le("onChange", function (o) {
										return i.handleValueChange(o)
									}),
									L()(),
									F(3, "div", 2)(4, "div", 3)(5, "div", 4)(6, "div", 5),
									fe(7, "div", 6)(8, "color-checkboard"),
									L()(),
									F(9, "div", 7)(10, "div", 8)(11, "color-hue", 9),
									Le("onChange", function (o) {
										return i.handleValueChange(o)
									}),
									L()(),
									Ee(12, LSe, 2, 4, "div", 10),
									L()(),
									F(13, "color-chrome-fields", 11),
									Le("onChange", function (o) {
										return i.handleValueChange(o)
									}),
									L()()()),
									2 & e &&
										(du("chrome-picker ", i.className, ""),
										T(2),
										U("hsl", i.hsl)("hsv", i.hsv)("circle", i.circle),
										T(5),
										bi("background", i.activeBackground),
										T(4),
										U("radius", 2)("hsl", i.hsl)("pointer", i.pointer),
										T(1),
										U("ngIf", !i.disableAlpha),
										T(1),
										U("rgb", i.rgb)("hsl", i.hsl)("hex", i.hex)("disableAlpha", i.disableAlpha))
							},
							dependencies: function () {
								return [SSe, FX, ESe, _Se, RSe, En]
							},
							styles: [
								'.chrome-picker[_ngcontent-%COMP%]{background:#fff;border-radius:2px;box-shadow:0 0 2px #0000004d,0 4px 8px #0000004d;box-sizing:initial;width:225px;font-family:"Menlo"}.chrome-controls[_ngcontent-%COMP%]{display:flex}.chrome-color[_ngcontent-%COMP%]{width:42px}.chrome-body[_ngcontent-%COMP%]{padding:14px 14px 12px}.chrome-active[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;left:0;right:0;border-radius:20px;box-shadow:inset 0 0 0 1px #0000001a;z-index:2}.chrome-swatch[_ngcontent-%COMP%]{width:28px;height:28px;border-radius:15px;position:relative;overflow:hidden}.saturation[_ngcontent-%COMP%]{width:100%;padding-bottom:55%;position:relative;border-radius:2px 2px 0 0;overflow:hidden}.chrome-toggles[_ngcontent-%COMP%]{flex:1}.chrome-hue[_ngcontent-%COMP%]{height:10px;position:relative;margin-bottom:8px}.chrome-alpha[_ngcontent-%COMP%]{height:10px;position:relative}'
							],
							changeDetection: 0
						})),
						t
					)
				})(),
				OSe = (() => {
					class t {}
					return (
						(t.ɵfac = function (e) {
							return new (e || t)()
						}),
						(t.ɵmod = at({ type: t })),
						(t.ɵinj = rt({ imports: [[Ot, vSe, BX, CSe, MSe, kSe]] })),
						t
					)
				})()
			function LX(t, n) {
				return n
					? e => NE(n.pipe(Do(1), Q8()), e.pipe(LX(t)))
					: ir((e, i) =>
							_e(t(e, i)).pipe(
								Do(1),
								(function NSe(t) {
									return Ke(() => t)
								})(e)
							)
					  )
			}
			function RX(t, n = dg) {
				const e = ID(t, n)
				return LX(() => e)
			}
			const USe = ["mat-menu-item", ""]
			function HSe(t, n) {
				1 & t && (Xa(), F(0, "svg", 3), fe(1, "polygon", 4), L())
			}
			const VSe = [[["mat-icon"], ["", "matMenuItemIcon", ""]], "*"],
				QSe = ["mat-icon, [matMenuItemIcon]", "*"]
			function zSe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div", 0),
						Le("keydown", function (r) {
							return rn(e), on(Te()._handleKeydown(r))
						})("click", function () {
							return rn(e), on(Te().closed.emit("click"))
						})("@transformMenu.start", function (r) {
							return rn(e), on(Te()._onAnimationStart(r))
						})("@transformMenu.done", function (r) {
							return rn(e), on(Te()._onAnimationDone(r))
						}),
						F(1, "div", 1),
						Ln(2),
						L()()
				}
				if (2 & t) {
					const e = Te()
					U("id", e.panelId)("ngClass", e._classList)("@transformMenu", e._panelAnimationState),
						qn("aria-label", e.ariaLabel || null)("aria-labelledby", e.ariaLabelledby || null)(
							"aria-describedby",
							e.ariaDescribedby || null
						)
				}
			}
			const GSe = ["*"],
				bO = new He("MAT_MENU_PANEL"),
				$Se = Um(Sv(class {}))
			let nk = (() => {
				class t extends $Se {
					constructor(e, i, r, o, s) {
						super(),
							(this._elementRef = e),
							(this._document = i),
							(this._focusMonitor = r),
							(this._parentMenu = o),
							(this._changeDetectorRef = s),
							(this.role = "menuitem"),
							(this._hovered = new vt()),
							(this._focused = new vt()),
							(this._highlighted = !1),
							(this._triggersSubmenu = !1),
							o?.addItem?.(this)
					}
					focus(e, i) {
						this._focusMonitor && e
							? this._focusMonitor.focusVia(this._getHostElement(), e, i)
							: this._getHostElement().focus(i),
							this._focused.next(this)
					}
					ngAfterViewInit() {
						this._focusMonitor && this._focusMonitor.monitor(this._elementRef, !1)
					}
					ngOnDestroy() {
						this._focusMonitor && this._focusMonitor.stopMonitoring(this._elementRef),
							this._parentMenu && this._parentMenu.removeItem && this._parentMenu.removeItem(this),
							this._hovered.complete(),
							this._focused.complete()
					}
					_getTabIndex() {
						return this.disabled ? "-1" : "0"
					}
					_getHostElement() {
						return this._elementRef.nativeElement
					}
					_checkDisabled(e) {
						this.disabled && (e.preventDefault(), e.stopPropagation())
					}
					_handleMouseEnter() {
						this._hovered.next(this)
					}
					getLabel() {
						const e = this._elementRef.nativeElement.cloneNode(!0),
							i = e.querySelectorAll("mat-icon, .material-icons")
						for (let r = 0; r < i.length; r++) i[r].remove()
						return e.textContent?.trim() || ""
					}
					_setHighlighted(e) {
						;(this._highlighted = e), this._changeDetectorRef?.markForCheck()
					}
					_setTriggersSubmenu(e) {
						;(this._triggersSubmenu = e), this._changeDetectorRef?.markForCheck()
					}
					_hasFocus() {
						return this._document && this._document.activeElement === this._getHostElement()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(wn), P(wi), P(fd), P(bO, 8), P(Jr))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["", "mat-menu-item", ""]],
							hostAttrs: [1, "mat-mdc-menu-item", "mat-mdc-focus-indicator"],
							hostVars: 8,
							hostBindings: function (i, r) {
								1 & i &&
									Le("click", function (s) {
										return r._checkDisabled(s)
									})("mouseenter", function () {
										return r._handleMouseEnter()
									}),
									2 & i &&
										(qn("role", r.role)("tabindex", r._getTabIndex())("aria-disabled", r.disabled)(
											"disabled",
											r.disabled || null
										),
										Zt("mat-mdc-menu-item-highlighted", r._highlighted)(
											"mat-mdc-menu-item-submenu-trigger",
											r._triggersSubmenu
										))
							},
							inputs: { disabled: "disabled", disableRipple: "disableRipple", role: "role" },
							exportAs: ["matMenuItem"],
							features: [pn],
							attrs: USe,
							ngContentSelectors: QSe,
							decls: 5,
							vars: 3,
							consts: [
								[1, "mat-mdc-menu-item-text"],
								["matRipple", "", 1, "mat-mdc-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"],
								[
									"class",
									"mat-mdc-menu-submenu-icon",
									"viewBox",
									"0 0 5 10",
									"focusable",
									"false",
									"aria-hidden",
									"true",
									4,
									"ngIf"
								],
								["viewBox", "0 0 5 10", "focusable", "false", "aria-hidden", "true", 1, "mat-mdc-menu-submenu-icon"],
								["points", "0,0 5,5 0,10"]
							],
							template: function (i, r) {
								1 & i && (co(VSe), Ln(0), F(1, "span", 0), Ln(2, 1), L(), fe(3, "div", 1), Ee(4, HSe, 2, 0, "svg", 2)),
									2 & i &&
										(T(3),
										U("matRippleDisabled", r.disableRipple || r.disabled)("matRippleTrigger", r._getHostElement()),
										T(1),
										U("ngIf", r._triggersSubmenu))
							},
							dependencies: [En, Cu],
							encapsulation: 2,
							changeDetection: 0
						})
					}
				}
				return t
			})()
			const WSe = new He("MatMenuContent"),
				ik = {
					transformMenu: Mu("transformMenu", [
						Pc("void", wo({ opacity: 0, transform: "scale(0.8)" })),
						tc("void => enter", Rc("120ms cubic-bezier(0, 0, 0.2, 1)", wo({ opacity: 1, transform: "scale(1)" }))),
						tc("* => void", Rc("100ms 25ms linear", wo({ opacity: 0 })))
					]),
					fadeInItems: Mu("fadeInItems", [
						Pc("showing", wo({ opacity: 1 })),
						tc("void => *", [wo({ opacity: 0 }), Rc("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")])
					])
				}
			let jSe = 0
			const PX = new He("mat-menu-default-options", {
				providedIn: "root",
				factory: function KSe() {
					return { overlapTrigger: !1, xPosition: "after", yPosition: "below", backdropClass: "cdk-overlay-transparent-backdrop" }
				}
			})
			let _w = (() => {
					class t {
						get xPosition() {
							return this._xPosition
						}
						set xPosition(e) {
							;(this._xPosition = e), this.setPositionClasses()
						}
						get yPosition() {
							return this._yPosition
						}
						set yPosition(e) {
							;(this._yPosition = e), this.setPositionClasses()
						}
						get overlapTrigger() {
							return this._overlapTrigger
						}
						set overlapTrigger(e) {
							this._overlapTrigger = Mn(e)
						}
						get hasBackdrop() {
							return this._hasBackdrop
						}
						set hasBackdrop(e) {
							this._hasBackdrop = Mn(e)
						}
						set panelClass(e) {
							const i = this._previousPanelClass
							i &&
								i.length &&
								i.split(" ").forEach(r => {
									this._classList[r] = !1
								}),
								(this._previousPanelClass = e),
								e &&
									e.length &&
									(e.split(" ").forEach(r => {
										this._classList[r] = !0
									}),
									(this._elementRef.nativeElement.className = ""))
						}
						get classList() {
							return this.panelClass
						}
						set classList(e) {
							this.panelClass = e
						}
						constructor(e, i, r, o) {
							;(this._elementRef = e),
								(this._ngZone = i),
								(this._changeDetectorRef = o),
								(this._directDescendantItems = new ym()),
								(this._classList = {}),
								(this._panelAnimationState = "void"),
								(this._animationDone = new vt()),
								(this.closed = new _n()),
								(this.close = this.closed),
								(this.panelId = "mat-menu-panel-" + jSe++),
								(this.overlayPanelClass = r.overlayPanelClass || ""),
								(this._xPosition = r.xPosition),
								(this._yPosition = r.yPosition),
								(this.backdropClass = r.backdropClass),
								(this._overlapTrigger = r.overlapTrigger),
								(this._hasBackdrop = r.hasBackdrop)
						}
						ngOnInit() {
							this.setPositionClasses()
						}
						ngAfterContentInit() {
							this._updateDirectDescendants(),
								(this._keyManager = new jD(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd()),
								this._keyManager.tabOut.subscribe(() => this.closed.emit("tab")),
								this._directDescendantItems.changes
									.pipe(
										hd(this._directDescendantItems),
										ya(e => oo(...e.map(i => i._focused)))
									)
									.subscribe(e => this._keyManager.updateActiveItem(e)),
								this._directDescendantItems.changes.subscribe(e => {
									const i = this._keyManager
									if ("enter" === this._panelAnimationState && i.activeItem?._hasFocus()) {
										const r = e.toArray(),
											o = Math.max(0, Math.min(r.length - 1, i.activeItemIndex || 0))
										r[o] && !r[o].disabled ? i.setActiveItem(o) : i.setNextItemActive()
									}
								})
						}
						ngOnDestroy() {
							this._keyManager?.destroy(),
								this._directDescendantItems.destroy(),
								this.closed.complete(),
								this._firstItemFocusSubscription?.unsubscribe()
						}
						_hovered() {
							return this._directDescendantItems.changes.pipe(
								hd(this._directDescendantItems),
								ya(i => oo(...i.map(r => r._hovered)))
							)
						}
						addItem(e) {}
						removeItem(e) {}
						_handleKeydown(e) {
							const i = e.keyCode,
								r = this._keyManager
							switch (i) {
								case 27:
									fl(e) || (e.preventDefault(), this.closed.emit("keydown"))
									break
								case 37:
									this.parentMenu && "ltr" === this.direction && this.closed.emit("keydown")
									break
								case 39:
									this.parentMenu && "rtl" === this.direction && this.closed.emit("keydown")
									break
								default:
									return (38 === i || 40 === i) && r.setFocusOrigin("keyboard"), void r.onKeydown(e)
							}
							e.stopPropagation()
						}
						focusFirstItem(e = "program") {
							this._firstItemFocusSubscription?.unsubscribe(),
								(this._firstItemFocusSubscription = this._ngZone.onStable.pipe(Do(1)).subscribe(() => {
									let i = null
									if (
										(this._directDescendantItems.length &&
											(i = this._directDescendantItems.first._getHostElement().closest('[role="menu"]')),
										!i || !i.contains(document.activeElement))
									) {
										const r = this._keyManager
										r.setFocusOrigin(e).setFirstItemActive(), !r.activeItem && i && i.focus()
									}
								}))
						}
						resetActiveItem() {
							this._keyManager.setActiveItem(-1)
						}
						setElevation(e) {
							const i = Math.min(this._baseElevation + e, 24),
								r = `${this._elevationPrefix}${i}`,
								o = Object.keys(this._classList).find(s => s.startsWith(this._elevationPrefix))
							;(!o || o === this._previousElevation) &&
								(this._previousElevation && (this._classList[this._previousElevation] = !1),
								(this._classList[r] = !0),
								(this._previousElevation = r))
						}
						setPositionClasses(e = this.xPosition, i = this.yPosition) {
							const r = this._classList
							;(r["mat-menu-before"] = "before" === e),
								(r["mat-menu-after"] = "after" === e),
								(r["mat-menu-above"] = "above" === i),
								(r["mat-menu-below"] = "below" === i),
								this._changeDetectorRef?.markForCheck()
						}
						_startAnimation() {
							this._panelAnimationState = "enter"
						}
						_resetAnimation() {
							this._panelAnimationState = "void"
						}
						_onAnimationDone(e) {
							this._animationDone.next(e), (this._isAnimating = !1)
						}
						_onAnimationStart(e) {
							;(this._isAnimating = !0),
								"enter" === e.toState && 0 === this._keyManager.activeItemIndex && (e.element.scrollTop = 0)
						}
						_updateDirectDescendants() {
							this._allItems.changes.pipe(hd(this._allItems)).subscribe(e => {
								this._directDescendantItems.reset(e.filter(i => i._parentMenu === this)),
									this._directDescendantItems.notifyOnChanges()
							})
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(mn), P(PX), P(Jr))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								contentQueries: function (i, r, o) {
									if ((1 & i && (yr(o, WSe, 5), yr(o, nk, 5), yr(o, nk, 4)), 2 & i)) {
										let s
										sn((s = an())) && (r.lazyContent = s.first),
											sn((s = an())) && (r._allItems = s),
											sn((s = an())) && (r.items = s)
									}
								},
								viewQuery: function (i, r) {
									if ((1 & i && _i(Za, 5), 2 & i)) {
										let o
										sn((o = an())) && (r.templateRef = o.first)
									}
								},
								inputs: {
									backdropClass: "backdropClass",
									ariaLabel: ["aria-label", "ariaLabel"],
									ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
									ariaDescribedby: ["aria-describedby", "ariaDescribedby"],
									xPosition: "xPosition",
									yPosition: "yPosition",
									overlapTrigger: "overlapTrigger",
									hasBackdrop: "hasBackdrop",
									panelClass: ["class", "panelClass"],
									classList: "classList"
								},
								outputs: { closed: "closed", close: "close" }
							})
						}
					}
					return t
				})(),
				vw = (() => {
					class t extends _w {
						constructor(e, i, r, o) {
							super(e, i, r, o), (this._elevationPrefix = "mat-elevation-z"), (this._baseElevation = 8)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(mn), P(PX), P(Jr))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-menu"]],
								hostAttrs: ["ngSkipHydration", ""],
								hostVars: 3,
								hostBindings: function (i, r) {
									2 & i && qn("aria-label", null)("aria-labelledby", null)("aria-describedby", null)
								},
								exportAs: ["matMenu"],
								features: [Xn([{ provide: bO, useExisting: t }]), pn],
								ngContentSelectors: GSe,
								decls: 1,
								vars: 0,
								consts: [
									[
										"tabindex",
										"-1",
										"role",
										"menu",
										1,
										"mat-mdc-menu-panel",
										"mat-mdc-elevation-specific",
										3,
										"id",
										"ngClass",
										"keydown",
										"click"
									],
									[1, "mat-mdc-menu-content"]
								],
								template: function (i, r) {
									1 & i && (co(), Ee(0, zSe, 3, 6, "ng-template"))
								},
								dependencies: [Em],
								styles: [
									'mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;list-style-type:none}.mat-mdc-menu-content:focus{outline:none}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;white-space:normal;font-family:var(--mat-menu-item-label-text-font);line-height:var(--mat-menu-item-label-text-line-height);font-size:var(--mat-menu-item-label-text-size);letter-spacing:var(--mat-menu-item-label-text-tracking);font-weight:var(--mat-menu-item-label-text-weight)}.mat-mdc-menu-panel{--mat-menu-container-shape:4px;min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;box-sizing:border-box;outline:0;border-radius:var(--mat-menu-container-shape);background-color:var(--mat-menu-container-color);will-change:transform,opacity}.mat-mdc-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-mdc-menu-panel{outline:solid 1px}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;align-items:center;min-height:48px}.mat-mdc-menu-item:focus{outline:none}[dir=rtl] .mat-mdc-menu-item,.mat-mdc-menu-item[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-menu-item::-moz-focus-inner{border:0}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color)}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color)}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item .mat-icon{margin-right:16px}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:16px}.mat-mdc-menu-item.mat-mdc-menu-item-submenu-trigger{padding-right:32px}[dir=rtl] .mat-mdc-menu-item.mat-mdc-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color)}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color)}.cdk-high-contrast-active .mat-mdc-menu-item{margin-top:1px}.mat-mdc-menu-submenu-icon{position:absolute;top:50%;right:16px;transform:translateY(-50%);width:5px;height:10px;fill:currentColor}[dir=rtl] .mat-mdc-menu-submenu-icon{right:auto;left:16px;transform:translateY(-50%) scaleX(-1)}.cdk-high-contrast-active .mat-mdc-menu-submenu-icon{fill:CanvasText}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}'
								],
								encapsulation: 2,
								data: { animation: [ik.transformMenu, ik.fadeInItems] },
								changeDetection: 0
							})
						}
					}
					return t
				})()
			const OX = new He("mat-menu-scroll-strategy"),
				YSe = {
					provide: OX,
					deps: [ec],
					useFactory: function XSe(t) {
						return () => t.scrollStrategies.reposition()
					}
				},
				NX = Rm({ passive: !0 })
			let qSe = (() => {
					class t {
						get _deprecatedMatMenuTriggerFor() {
							return this.menu
						}
						set _deprecatedMatMenuTriggerFor(e) {
							this.menu = e
						}
						get menu() {
							return this._menu
						}
						set menu(e) {
							e !== this._menu &&
								((this._menu = e),
								this._menuCloseSubscription.unsubscribe(),
								e &&
									(this._menuCloseSubscription = e.close.subscribe(i => {
										this._destroyMenu(i),
											("click" === i || "tab" === i) &&
												this._parentMaterialMenu &&
												this._parentMaterialMenu.closed.emit(i)
									})),
								this._menuItemInstance?._setTriggersSubmenu(this.triggersSubmenu()))
						}
						constructor(e, i, r, o, s, a, c, l, d) {
							;(this._overlay = e),
								(this._element = i),
								(this._viewContainerRef = r),
								(this._menuItemInstance = a),
								(this._dir = c),
								(this._focusMonitor = l),
								(this._ngZone = d),
								(this._overlayRef = null),
								(this._menuOpen = !1),
								(this._closingActionsSubscription = D.EMPTY),
								(this._hoverSubscription = D.EMPTY),
								(this._menuCloseSubscription = D.EMPTY),
								(this._changeDetectorRef = Rt(Jr)),
								(this._handleTouchStart = u => {
									YD(u) || (this._openedBy = "touch")
								}),
								(this._openedBy = void 0),
								(this.restoreFocus = !0),
								(this.menuOpened = new _n()),
								(this.onMenuOpen = this.menuOpened),
								(this.menuClosed = new _n()),
								(this.onMenuClose = this.menuClosed),
								(this._scrollStrategy = o),
								(this._parentMaterialMenu = s instanceof _w ? s : void 0),
								i.nativeElement.addEventListener("touchstart", this._handleTouchStart, NX)
						}
						ngAfterContentInit() {
							this._handleHover()
						}
						ngOnDestroy() {
							this._overlayRef && (this._overlayRef.dispose(), (this._overlayRef = null)),
								this._element.nativeElement.removeEventListener("touchstart", this._handleTouchStart, NX),
								this._menuCloseSubscription.unsubscribe(),
								this._closingActionsSubscription.unsubscribe(),
								this._hoverSubscription.unsubscribe()
						}
						get menuOpen() {
							return this._menuOpen
						}
						get dir() {
							return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr"
						}
						triggersSubmenu() {
							return !!(this._menuItemInstance && this._parentMaterialMenu && this.menu)
						}
						toggleMenu() {
							return this._menuOpen ? this.closeMenu() : this.openMenu()
						}
						openMenu() {
							const e = this.menu
							if (this._menuOpen || !e) return
							const i = this._createOverlay(e),
								r = i.getConfig(),
								o = r.positionStrategy
							this._setPosition(e, o),
								(r.hasBackdrop = null == e.hasBackdrop ? !this.triggersSubmenu() : e.hasBackdrop),
								i.attach(this._getPortal(e)),
								e.lazyContent && e.lazyContent.attach(this.menuData),
								(this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu())),
								this._initMenu(e),
								e instanceof _w &&
									(e._startAnimation(),
									e._directDescendantItems.changes.pipe(kr(e.close)).subscribe(() => {
										o.withLockedPosition(!1).reapplyLastPosition(), o.withLockedPosition(!0)
									}))
						}
						closeMenu() {
							this.menu?.close.emit()
						}
						focus(e, i) {
							this._focusMonitor && e
								? this._focusMonitor.focusVia(this._element, e, i)
								: this._element.nativeElement.focus(i)
						}
						updatePosition() {
							this._overlayRef?.updatePosition()
						}
						_destroyMenu(e) {
							if (!this._overlayRef || !this.menuOpen) return
							const i = this.menu
							this._closingActionsSubscription.unsubscribe(),
								this._overlayRef.detach(),
								this.restoreFocus &&
									("keydown" === e || !this._openedBy || !this.triggersSubmenu()) &&
									this.focus(this._openedBy),
								(this._openedBy = void 0),
								i instanceof _w
									? (i._resetAnimation(),
									  i.lazyContent
											? i._animationDone
													.pipe(
														xi(r => "void" === r.toState),
														Do(1),
														kr(i.lazyContent._attached)
													)
													.subscribe({
														next: () => i.lazyContent.detach(),
														complete: () => this._setIsMenuOpen(!1)
													})
											: this._setIsMenuOpen(!1))
									: (this._setIsMenuOpen(!1), i?.lazyContent?.detach())
						}
						_initMenu(e) {
							;(e.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : void 0),
								(e.direction = this.dir),
								this._setMenuElevation(e),
								e.focusFirstItem(this._openedBy || "program"),
								this._setIsMenuOpen(!0)
						}
						_setMenuElevation(e) {
							if (e.setElevation) {
								let i = 0,
									r = e.parentMenu
								for (; r; ) i++, (r = r.parentMenu)
								e.setElevation(i)
							}
						}
						_setIsMenuOpen(e) {
							e !== this._menuOpen &&
								((this._menuOpen = e),
								this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit(),
								this.triggersSubmenu() && this._menuItemInstance._setHighlighted(e),
								this._changeDetectorRef.markForCheck())
						}
						_createOverlay(e) {
							if (!this._overlayRef) {
								const i = this._getOverlayConfig(e)
								this._subscribeToPositions(e, i.positionStrategy),
									(this._overlayRef = this._overlay.create(i)),
									this._overlayRef.keydownEvents().subscribe()
							}
							return this._overlayRef
						}
						_getOverlayConfig(e) {
							return new PE({
								positionStrategy: this._overlay
									.position()
									.flexibleConnectedTo(this._element)
									.withLockedPosition()
									.withGrowAfterOpen()
									.withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"),
								backdropClass: e.backdropClass || "cdk-overlay-transparent-backdrop",
								panelClass: e.overlayPanelClass,
								scrollStrategy: this._scrollStrategy(),
								direction: this._dir
							})
						}
						_subscribeToPositions(e, i) {
							e.setPositionClasses &&
								i.positionChanges.subscribe(r => {
									const o = "start" === r.connectionPair.overlayX ? "after" : "before",
										s = "top" === r.connectionPair.overlayY ? "below" : "above"
									this._ngZone ? this._ngZone.run(() => e.setPositionClasses(o, s)) : e.setPositionClasses(o, s)
								})
						}
						_setPosition(e, i) {
							let [r, o] = "before" === e.xPosition ? ["end", "start"] : ["start", "end"],
								[s, a] = "above" === e.yPosition ? ["bottom", "top"] : ["top", "bottom"],
								[c, l] = [s, a],
								[d, u] = [r, o],
								h = 0
							if (this.triggersSubmenu()) {
								if (
									((u = r = "before" === e.xPosition ? "start" : "end"),
									(o = d = "end" === r ? "start" : "end"),
									this._parentMaterialMenu)
								) {
									if (null == this._parentInnerPadding) {
										const f = this._parentMaterialMenu.items.first
										this._parentInnerPadding = f ? f._getHostElement().offsetTop : 0
									}
									h = "bottom" === s ? this._parentInnerPadding : -this._parentInnerPadding
								}
							} else e.overlapTrigger || ((c = "top" === s ? "bottom" : "top"), (l = "top" === a ? "bottom" : "top"))
							i.withPositions([
								{ originX: r, originY: c, overlayX: d, overlayY: s, offsetY: h },
								{ originX: o, originY: c, overlayX: u, overlayY: s, offsetY: h },
								{ originX: r, originY: l, overlayX: d, overlayY: a, offsetY: -h },
								{ originX: o, originY: l, overlayX: u, overlayY: a, offsetY: -h }
							])
						}
						_menuClosingActions() {
							const e = this._overlayRef.backdropClick(),
								i = this._overlayRef.detachments()
							return oo(
								e,
								this._parentMaterialMenu ? this._parentMaterialMenu.closed : Wo(),
								this._parentMaterialMenu
									? this._parentMaterialMenu._hovered().pipe(
											xi(s => s !== this._menuItemInstance),
											xi(() => this._menuOpen)
									  )
									: Wo(),
								i
							)
						}
						_handleMousedown(e) {
							XD(e) || ((this._openedBy = 0 === e.button ? "mouse" : void 0), this.triggersSubmenu() && e.preventDefault())
						}
						_handleKeydown(e) {
							const i = e.keyCode
							;(13 === i || 32 === i) && (this._openedBy = "keyboard"),
								this.triggersSubmenu() &&
									((39 === i && "ltr" === this.dir) || (37 === i && "rtl" === this.dir)) &&
									((this._openedBy = "keyboard"), this.openMenu())
						}
						_handleClick(e) {
							this.triggersSubmenu() ? (e.stopPropagation(), this.openMenu()) : this.toggleMenu()
						}
						_handleHover() {
							!this.triggersSubmenu() ||
								!this._parentMaterialMenu ||
								(this._hoverSubscription = this._parentMaterialMenu
									._hovered()
									.pipe(
										xi(e => e === this._menuItemInstance && !e.disabled),
										RX(0, BD)
									)
									.subscribe(() => {
										;(this._openedBy = "mouse"),
											this.menu instanceof _w && this.menu._isAnimating
												? this.menu._animationDone
														.pipe(Do(1), RX(0, BD), kr(this._parentMaterialMenu._hovered()))
														.subscribe(() => this.openMenu())
												: this.openMenu()
									}))
						}
						_getPortal(e) {
							return (
								(!this._portal || this._portal.templateRef !== e.templateRef) &&
									(this._portal = new yv(e.templateRef, this._viewContainerRef)),
								this._portal
							)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(ec), P(wn), P(ra), P(OX), P(bO, 8), P(nk, 10), P(wu, 8), P(fd), P(mn))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								hostVars: 3,
								hostBindings: function (i, r) {
									1 & i &&
										Le("click", function (s) {
											return r._handleClick(s)
										})("mousedown", function (s) {
											return r._handleMousedown(s)
										})("keydown", function (s) {
											return r._handleKeydown(s)
										}),
										2 & i &&
											qn("aria-haspopup", r.menu ? "menu" : null)("aria-expanded", r.menuOpen)(
												"aria-controls",
												r.menuOpen ? r.menu.panelId : null
											)
								},
								inputs: {
									_deprecatedMatMenuTriggerFor: ["mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"],
									menu: ["matMenuTriggerFor", "menu"],
									menuData: ["matMenuTriggerData", "menuData"],
									restoreFocus: ["matMenuTriggerRestoreFocus", "restoreFocus"]
								},
								outputs: {
									menuOpened: "menuOpened",
									onMenuOpen: "onMenuOpen",
									menuClosed: "menuClosed",
									onMenuClose: "onMenuClose"
								}
							})
						}
					}
					return t
				})(),
				yw = (() => {
					class t extends qSe {
						static {
							this.ɵfac = (function () {
								let e
								return function (r) {
									return (e || (e = gr(t)))(r || t)
								}
							})()
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [
									["", "mat-menu-trigger-for", ""],
									["", "matMenuTriggerFor", ""]
								],
								hostAttrs: [1, "mat-mdc-menu-trigger"],
								exportAs: ["matMenuTrigger"],
								features: [pn]
							})
						}
					}
					return t
				})(),
				UX = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [YSe], imports: [Ot, Vh, Yi, Ev, _v, Yi] })
						}
					}
					return t
				})()
			const ZSe = ["colorPickerMenuTrigger"],
				JSe = function (t, n) {
					return { isOpen: t, isHovered: n }
				}
			let HX = (() => {
					class t {
						constructor() {
							;(this.openXPosition = "after"),
								(this.onColorChange = new _n()),
								(this.isHovered = !1),
								(this.isClickInside = !1)
						}
						handleChangeComplete(e) {
							this.onColorChange.emit(e)
						}
						onMouseEnter() {
							this.isHovered = !0
						}
						onMouseLeave() {
							this.isHovered = !1
						}
						onClick() {
							;(this.isClickInside = !0), this.colorPickerMenuTrigger.openMenu()
						}
						handleDocumentClick() {
							!this.isClickInside && this.colorPickerMenuTrigger.menuOpen && this.colorPickerMenuTrigger.closeMenu(),
								(this.isClickInside = !1)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-color-picker"]],
								viewQuery: function (i, r) {
									if ((1 & i && _i(ZSe, 5), 2 & i)) {
										let o
										sn((o = an())) && (r.colorPickerMenuTrigger = o.first)
									}
								},
								hostBindings: function (i, r) {
									1 & i &&
										Le("mouseenter", function () {
											return r.onMouseEnter()
										})("mouseleave", function () {
											return r.onMouseLeave()
										})("click", function () {
											return r.onClick()
										})(
											"click",
											function () {
												return r.handleDocumentClick()
											},
											!1,
											N4
										)
								},
								inputs: { hexColor: "hexColor", openXPosition: "openXPosition", triggerTemplate: "triggerTemplate" },
								outputs: { onColorChange: "onColorChange" },
								decls: 6,
								vars: 10,
								consts: [
									[3, "ngTemplateOutlet", "ngTemplateOutletContext"],
									[3, "matMenuTriggerFor"],
									["colorPickerMenuTrigger", "matMenuTrigger"],
									[1, "cc-color-picker-menu", 3, "xPosition", "hasBackdrop"],
									["menu", "matMenu"],
									["role", "colorpicker", 3, "disableAlpha", "color", "click", "onChangeComplete"]
								],
								template: function (i, r) {
									if (
										(1 & i &&
											(qA(0, 0),
											fe(1, "span", 1, 2),
											F(3, "mat-menu", 3, 4)(5, "color-chrome", 5),
											Le("click", function (s) {
												return s.stopPropagation()
											})("onChangeComplete", function (s) {
												return r.handleChangeComplete(s.color.hex)
											}),
											L()()),
										2 & i)
									) {
										const o = br(2),
											s = br(4)
										U("ngTemplateOutlet", r.triggerTemplate)(
											"ngTemplateOutletContext",
											al(7, JSe, o.menuOpen, r.isHovered)
										),
											T(1),
											U("matMenuTriggerFor", s),
											T(2),
											U("xPosition", r.openXPosition)("hasBackdrop", !1),
											T(2),
											U("disableAlpha", !0)("color", r.hexColor)
									}
								},
								dependencies: [x0, PSe, vw, yw],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				tke = (() => {
					class t {
						transform(e) {
							return (t =>
								(299 * Number.parseInt(t.slice(1, 3), 16) +
									587 * Number.parseInt(t.slice(3, 5), 16) +
									114 * Number.parseInt(t.slice(5, 7), 16)) /
									1e3 >=
								128
									? "black"
									: "white")(e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "readableColorForBackground", type: t, pure: !0 })
						}
					}
					return t
				})()
			function nke(t, n) {
				1 & t && fe(0, "br")
			}
			function ike(t, n) {
				if ((1 & t && (F(0, "span"), ge(1), Ee(2, nke, 1, 0, "br", 8), L()), 2 & t)) {
					const e = n.$implicit,
						i = n.last
					T(1), Vt(" ", e, " "), T(1), U("ngIf", !i)
				}
			}
			function rke(t, n) {
				if (
					(1 & t &&
						(F(0, "div", 2)(1, "div", 3),
						fe(2, "span", 4),
						F(3, "span", 5),
						Me(4, "readableColorForBackground"),
						L()(),
						F(5, "div", 6),
						Ee(6, ike, 3, 2, "span", 7),
						L()()),
					2 & t)
				) {
					const e = n.isOpen,
						i = n.isHovered,
						r = Te()
					T(2),
						bi("background-color", r.hexColor),
						T(1),
						bi("color", De(4, 7, r.hexColor))("opacity", i || e ? "1" : "0"),
						T(3),
						U("ngForOf", r.labels)
				}
			}
			let VX = (() => {
				class t {
					constructor() {
						this.onColorChange = new _n()
					}
					handleColorChange(e) {
						this.onColorChange.emit(e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-labelled-color-picker"]],
							inputs: { hexColor: "hexColor", labels: "labels" },
							outputs: { onColorChange: "onColorChange" },
							decls: 3,
							vars: 3,
							consts: [
								[3, "hexColor", "openXPosition", "triggerTemplate", "onColorChange"],
								["colorPickerTriggerTemplate", ""],
								[1, "cc-labelled-color-picker-container"],
								[1, "cc-color-swatch-container"],
								[1, "cc-color-swatch"],
								[1, "cc-color-brush", "fa", "fa-paint-brush"],
								[1, "cc-labelled-color-picker-label"],
								[4, "ngFor", "ngForOf"],
								[4, "ngIf"]
							],
							template: function (i, r) {
								if (
									(1 & i &&
										(F(0, "cc-color-picker", 0),
										Le("onColorChange", function (s) {
											return r.handleColorChange(s)
										}),
										L(),
										Ee(1, rke, 7, 9, "ng-template", null, 1, oa)),
									2 & i)
								) {
									const o = br(2)
									U("hexColor", r.hexColor)("openXPosition", "before")("triggerTemplate", o)
								}
							},
							dependencies: [_o, En, HX, tke],
							styles: [
								"cc-labelled-color-picker .cc-labelled-color-picker-container{display:flex;height:40px;align-items:center}cc-labelled-color-picker .cc-labelled-color-picker-container:hover{cursor:pointer}cc-labelled-color-picker .cc-labelled-color-picker-container .cc-color-swatch-container{position:relative;margin:0 11px;width:18px;height:18px}cc-labelled-color-picker .cc-labelled-color-picker-container .cc-color-swatch-container .cc-color-swatch{display:inline-block;width:inherit;height:inherit;border-radius:2px}cc-labelled-color-picker .cc-labelled-color-picker-container .cc-color-swatch-container .cc-color-brush{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);opacity:0}.mat-mdc-menu-panel.cc-color-picker-menu .mat-mdc-menu-content{padding:0}color-chrome .chrome-hue{margin-top:10px}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function oke(t, n) {
				if (1 & t) {
					const e = ri()
					Cr(0),
						F(1, "cc-labelled-color-picker", 2),
						Le("onColorChange", function (r) {
							const s = rn(e).$implicit
							return on(Te(2).handleColorChange(r, s.value))
						}),
						L(),
						Er()
				}
				if (2 & t) {
					const e = n.$implicit
					T(1), U("hexColor", e.key)("labels", e.value)
				}
			}
			function ske(t, n) {
				if ((1 & t && (Cr(0), fe(1, "hr"), Ee(2, oke, 2, 2, "ng-container", 1), Me(3, "keyvalue"), Me(4, "async"), Er()), 2 & t)) {
					const e = Te()
					T(2),
						U("ngForOf", lo(3, 2, De(4, 5, e.markedPackagesMap$), e.sortMarkedPackagesMap))(
							"ngForTrackBy",
							e.trackMarkedPackage
						)
				}
			}
			let ake = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.markedPackagesMap$ = e.select(iSe)),
							(this.hasMarkedPackages$ = this.markedPackagesMap$.pipe(Ke(i => Object.keys(i).length > 0)))
					}
					handleColorChange(e, i) {
						this.store.dispatch(dv({ packages: i.map(r => ({ color: e, path: r })) }))
					}
					trackMarkedPackage(e, { value: i }) {
						return i.join(",")
					}
					sortMarkedPackagesMap(e, i) {
						return e.value[0].localeCompare(i.value[0])
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-legend-marked-packages"]],
							decls: 2,
							vars: 3,
							consts: [
								[4, "ngIf"],
								[4, "ngFor", "ngForOf", "ngForTrackBy"],
								[3, "hexColor", "labels", "onColorChange"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, ske, 5, 7, "ng-container", 0), Me(1, "async")),
									2 & i && U("ngIf", De(1, 1, r.hasMarkedPackages$))
							},
							dependencies: [_o, En, VX, Bn, wC],
							styles: ["cc-legend-marked-packages cc-labelled-color-picker{display:block}\n"],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const QX = Mt(cc, t => t.colorRange)
			let cke = (() => {
				class t {
					transform(e, i, r, o) {
						switch (e) {
							case "positive":
								return "unary" === o
									? `${r.minValue} - ${r.maxValue}`
									: r.minValue === i.from
									? "-"
									: r.maxValue === i.from
									? `${r.minValue} to ${this.formatNumber(i.from)}`
									: `${r.minValue} to ${this.formatNumber(i.from - 1)}`
							case "neutral":
								return i.from === i.to
									? "-"
									: i.to === r.maxValue
									? `${this.formatNumber(i.from)} to ${this.formatNumber(i.to)}`
									: `${this.formatNumber(i.from)} to ${this.formatNumber(i.to - 1)}`
							case "negative":
								return r.maxValue === i.to ? "-" : `${this.formatNumber(i.to)} to ${this.formatNumber(r.maxValue)}`
							case "positiveDelta":
								return "+\u0394 positive delta"
							case "negativeDelta":
								return "\u2013\u0394 negative delta"
							case "selected":
								return "selected"
							case "outgoingEdge":
								return "Outgoing Edge"
							case "incomingEdge":
								return "Incoming Edge"
						}
					}
					formatNumber(e) {
						return (e || 0).toLocaleString()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵpipe = Zi({ name: "mapColorLabel", type: t, pure: !0 })
					}
				}
				return t
			})()
			const lke = function (t) {
				return [t]
			}
			let _O = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.colorMetric$ = this.store.select(Af)),
							(this.mapColors$ = this.store.select(vb)),
							(this.colorRange$ = this.store.select(QX)),
							(this.nodeMetricRange$ = this.store.select(gf))
					}
					handleColorChange(e) {
						this.store.dispatch(Au({ value: { [this.mapColorFor]: e } }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-color-picker-for-map-color"]],
							inputs: { mapColorFor: "mapColorFor" },
							decls: 6,
							vars: 17,
							consts: [[3, "hexColor", "labels", "onColorChange"]],
							template: function (i, r) {
								1 & i &&
									(F(0, "cc-labelled-color-picker", 0),
									Le("onColorChange", function (s) {
										return r.handleColorChange(s)
									}),
									Me(1, "async"),
									Me(2, "mapColorLabel"),
									Me(3, "async"),
									Me(4, "async"),
									Me(5, "async"),
									L()),
									2 & i &&
										U("hexColor", De(1, 2, r.mapColors$)[r.mapColorFor])(
											"labels",
											(function hV(t, n, e, i) {
												return fV(bt(), xs(), t, n, e, i)
											})(
												15,
												lke,
												(function bV(t, n, e, i, r, o) {
													const s = t + Ei,
														a = bt(),
														c = zl(a, s)
													return A0(a, s) ? AV(a, xs(), n, c.transform, e, i, r, o, c) : c.transform(e, i, r, o)
												})(
													2,
													4,
													r.mapColorFor,
													De(3, 9, r.colorRange$),
													De(4, 11, r.nodeMetricRange$),
													De(5, 13, r.colorMetric$)
												)
											)
										)
							},
							dependencies: [VX, Bn, cke],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function dke(t, n) {
				if ((1 & t && (F(0, "a", 7)(1, "span", 8), ge(2), L(), ge(3), fe(4, "i", 9), L()), 2 & t)) {
					const e = n.ngIf,
						i = Te().ngIf,
						r = Te(2)
					U("href", e, fm), T(2), cr(i), T(1), Vt(" (", r.metricName, ") ")
				}
			}
			function uke(t, n) {
				if ((1 & t && (F(0, "span", 8), ge(1), L(), ge(2)), 2 & t)) {
					const e = Te().ngIf,
						i = Te(2)
					T(1), cr(e), T(1), Vt(" (", i.metricName, ") ")
				}
			}
			function hke(t, n) {
				if (
					(1 & t &&
						(Cr(0, 3),
						F(1, "div", 4),
						Me(2, "attributeDescriptorTooltip"),
						ge(3),
						Ee(4, dke, 5, 3, "a", 5),
						Ee(5, uke, 3, 2, "ng-template", null, 6, oa),
						L(),
						Er()),
					2 & t)
				) {
					const e = br(6),
						i = Te().ngIf,
						r = Te()
					T(1),
						U("title", lo(2, 4, i[r.metricName], r.metricName)),
						T(2),
						Vt(" ", r.metricSpecification, " metric: "),
						T(1),
						U("ngIf", i[r.metricName].link)("ngIfElse", e)
				}
			}
			function fke(t, n) {
				if ((1 & t && (Cr(0), F(1, "span", 8), ge(2), L(), ge(3), Er()), 2 & t)) {
					const e = n.ngIf,
						i = Te(3)
					T(2), cr(e), T(1), Vt(" (", i.metricName, ") ")
				}
			}
			function mke(t, n) {
				if ((1 & t && (F(0, "span", 8), ge(1), L()), 2 & t)) {
					const e = Te(3)
					T(1), Vt(" ", e.metricName, " ")
				}
			}
			function pke(t, n) {
				if (
					(1 & t &&
						(F(0, "div"), ge(1), Ee(2, fke, 4, 2, "ng-container", 10), Ee(3, mke, 2, 1, "ng-template", null, 11, oa), L()),
					2 & t)
				) {
					const e = br(4),
						i = Te(2)
					T(1), Vt(" ", i.metricSpecification, " metric: "), T(1), U("ngIf", i.fallbackTitles.get(i.metricName))("ngIfElse", e)
				}
			}
			function Ake(t, n) {
				if ((1 & t && (Cr(0), Ee(1, hke, 7, 7, "ng-container", 1), Ee(2, pke, 5, 3, "ng-template", null, 2, oa), Er()), 2 & t)) {
					const e = n.ngIf,
						i = br(3),
						r = Te()
					T(1), U("ngIf", null == e[r.metricName] ? null : e[r.metricName].title)("ngIfElse", i)
				}
			}
			let gke = (() => {
				class t {
					constructor(e) {
						;(this.store = e), (this.attributeDescriptors$ = this.store.select(qS)), (this.fallbackTitles = dO)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-legend-block"]],
							inputs: { metricName: "metricName", metricSpecification: "metricSpecification" },
							decls: 2,
							vars: 3,
							consts: [
								[4, "ngIf"],
								["class", "legend-block", 4, "ngIf", "ngIfElse"],
								["metricTitleFallback", ""],
								[1, "legend-block"],
								[3, "title"],
								["target", "_blank", 3, "href", 4, "ngIf", "ngIfElse"],
								["metricNoLink", ""],
								["target", "_blank", 3, "href"],
								[1, "bold"],
								[1, "fa", "fa-external-link"],
								[4, "ngIf", "ngIfElse"],
								["noFallback", ""]
							],
							template: function (i, r) {
								1 & i && (Ee(0, Ake, 4, 2, "ng-container", 0), Me(1, "async")),
									2 & i && U("ngIf", De(1, 1, r.attributeDescriptors$))
							},
							dependencies: [En, Bn, JS],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function bke(t, n) {
				1 & t && fe(0, "cc-legend-block", 8), 2 & t && U("metricName", n.$implicit)
			}
			function _ke(t, n) {
				if (
					(1 & t &&
						(F(0, "div"),
						fe(1, "cc-legend-block", 4),
						Me(2, "async"),
						fe(3, "cc-legend-block", 5),
						Me(4, "async"),
						Ee(5, bke, 1, 1, "cc-legend-block", 6),
						Me(6, "async"),
						fe(7, "hr")(8, "cc-legend-block", 7),
						Me(9, "async"),
						fe(10, "cc-color-picker-for-map-color", 2)(11, "cc-color-picker-for-map-color", 2)(
							12,
							"cc-color-picker-for-map-color",
							2
						),
						L()),
					2 & t)
				) {
					const e = Te()
					T(1),
						U("metricName", De(2, 7, e.areaMetric$)),
						T(2),
						U("metricName", De(4, 9, e.heightMetric$)),
						T(2),
						U("ngIf", De(6, 11, e.edgeMetric$)),
						T(3),
						U("metricName", De(9, 13, e.colorMetric$)),
						T(2),
						U("mapColorFor", "positive"),
						T(1),
						U("mapColorFor", "neutral"),
						T(1),
						U("mapColorFor", "negative")
				}
			}
			function vke(t, n) {
				1 & t && (F(0, "div"), fe(1, "cc-color-picker-for-map-color", 2)(2, "cc-color-picker-for-map-color", 2), L()),
					2 & t && (T(1), U("mapColorFor", "positiveDelta"), T(1), U("mapColorFor", "negativeDelta"))
			}
			function yke(t, n) {
				1 & t && (Cr(0), fe(1, "hr")(2, "cc-color-picker-for-map-color", 2)(3, "cc-color-picker-for-map-color", 2), Er()),
					2 & t && (T(2), U("mapColorFor", "outgoingEdge"), T(1), U("mapColorFor", "incomingEdge"))
			}
			let wke = (() => {
				class t {
					constructor(e, i) {
						;(this.store = e),
							(this.isAttributeSideBarVisibleService = i),
							(this.isLegendVisible = !1),
							(this.isDeltaState$ = this.store.select(_f)),
							(this.heightMetric$ = this.store.select(Aw)),
							(this.areaMetric$ = this.store.select(Cb)),
							(this.colorMetric$ = this.store.select(Af)),
							(this.edgeMetric$ = this.store.select(zu))
					}
					toggleIsLegendVisible() {
						this.isLegendVisible = !this.isLegendVisible
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct), P(KS))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-legend-panel"]],
							decls: 12,
							vars: 17,
							consts: [
								["id", "legend-panel", 1, "block-wrapper"],
								[4, "ngIf"],
								[3, "mapColorFor"],
								["id", "legend-panel-button", "color", "primary", 1, "panel-button", 3, "title", "click"],
								["metricSpecification", "Area", 3, "metricName"],
								["metricSpecification", "Height", 3, "metricName"],
								["metricSpecification", "Edge", 3, "metricName", 4, "ngIf"],
								["metricSpecification", "Color", 3, "metricName"],
								["metricSpecification", "Edge", 3, "metricName"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "div", 0),
									Ee(1, _ke, 13, 15, "div", 1),
									Me(2, "async"),
									Ee(3, vke, 3, 2, "div", 1),
									Me(4, "async"),
									fe(5, "hr")(6, "cc-color-picker-for-map-color", 2),
									Ee(7, yke, 4, 2, "ng-container", 1),
									Me(8, "async"),
									fe(9, "cc-legend-marked-packages"),
									L(),
									F(10, "button", 3),
									Le("click", function () {
										return r.toggleIsLegendVisible()
									}),
									ge(11, " LEGEND\n"),
									L()),
									2 & i &&
										(Zt("visible", r.isLegendVisible)(
											"isAttributeSideBarVisible",
											r.isAttributeSideBarVisibleService.isOpen
										),
										T(1),
										U("ngIf", !De(2, 11, r.isDeltaState$)),
										T(2),
										U("ngIf", De(4, 13, r.isDeltaState$)),
										T(3),
										U("mapColorFor", "selected"),
										T(1),
										U("ngIf", De(8, 15, r.edgeMetric$)),
										T(3),
										Zt("isAttributeSideBarVisible", r.isAttributeSideBarVisibleService.isOpen),
										Fa("title", r.isLegendVisible ? "Hide panel" : "Show panel"))
							},
							dependencies: [En, ake, _O, gke, Bn],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-legend-panel .rotated-button,cc-legend-panel .panel-button{position:fixed;transform:rotate(90deg);border-radius:0 0 5px 5px;height:36px;right:-35px;color:#fff;-webkit-user-select:none;user-select:none;background-color:#1b9cfc}cc-legend-panel .rotated-button:hover,cc-legend-panel .panel-button:hover{background-color:#0374c9}cc-legend-panel .rotated-button.isAttributeSideBarVisible,cc-legend-panel .isAttributeSideBarVisible.panel-button{right:316px}cc-legend-panel .panel-button{margin:6px 8px;bottom:55px;width:88px}cc-legend-panel .block-wrapper{background-color:#fff;border:1px solid #cdcdcd;position:fixed;bottom:35px;padding:10px;right:40px;visibility:hidden;border-radius:5px;min-width:200px;max-width:30%}cc-legend-panel .block-wrapper.isAttributeSideBarVisible{right:390px}cc-legend-panel .block-wrapper.visible{visibility:visible}cc-legend-panel .block-wrapper hr{border-right-style:none;border-left-style:none;border-bottom-style:none;color:#000}cc-legend-panel .block-wrapper cc-legend-block a:link,cc-legend-panel .block-wrapper cc-legend-block a:visited{text-decoration:none;color:#000}cc-legend-panel .block-wrapper cc-legend-block a:hover{color:#00f;-webkit-text-decoration:solid;text-decoration:solid;text-decoration-line:underline}cc-legend-panel .block-wrapper cc-legend-block a:active{color:red}cc-legend-panel .block-wrapper cc-legend-block i.fa.fa-external-link{font-size:10px;min-width:10px;text-align:center}cc-legend-panel .block-wrapper cc-legend-block span{display:inline-block}cc-legend-panel .block-wrapper .bold{font-weight:600}cc-legend-panel .block-wrapper .cc-labelled-color-picker-container>.cc-labelled-color-picker-label{white-space:nowrap;text-overflow:ellipsis;direction:rtl}cc-legend-panel .block-wrapper .cc-labelled-color-picker-container>.cc-labelled-color-picker-label span{unicode-bidi:plaintext}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const vO = Mt(Tr, t => t.experimentalFeaturesEnabled),
				xke = ["*"],
				kke = new He("MAT_CARD_CONFIG")
			let rk = (() => {
					class t {
						constructor(e) {
							this.appearance = e?.appearance || "raised"
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(kke, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-card"]],
								hostAttrs: [1, "mat-mdc-card", "mdc-card"],
								hostVars: 4,
								hostBindings: function (i, r) {
									2 & i &&
										Zt("mat-mdc-card-outlined", "outlined" === r.appearance)(
											"mdc-card--outlined",
											"outlined" === r.appearance
										)
								},
								inputs: { appearance: "appearance" },
								exportAs: ["matCard"],
								ngContentSelectors: xke,
								decls: 1,
								vars: 0,
								template: function (i, r) {
									1 & i && (co(), Ln(0))
								},
								styles: [
									'.mdc-card{display:flex;flex-direction:column;box-sizing:border-box}.mdc-card::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none;pointer-events:none}@media screen and (forced-colors: active){.mdc-card::after{border-color:CanvasText}}.mdc-card--outlined::after{border:none}.mdc-card__content{border-radius:inherit;height:100%}.mdc-card__media{position:relative;box-sizing:border-box;background-repeat:no-repeat;background-position:center;background-size:cover}.mdc-card__media::before{display:block;content:""}.mdc-card__media:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__media:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mdc-card__media--square::before{margin-top:100%}.mdc-card__media--16-9::before{margin-top:56.25%}.mdc-card__media-content{position:absolute;top:0;right:0;bottom:0;left:0;box-sizing:border-box}.mdc-card__primary-action{display:flex;flex-direction:column;box-sizing:border-box;position:relative;outline:none;color:inherit;text-decoration:none;cursor:pointer;overflow:hidden}.mdc-card__primary-action:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__primary-action:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mdc-card__actions{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;min-height:52px;padding:8px}.mdc-card__actions--full-bleed{padding:0}.mdc-card__action-buttons,.mdc-card__action-icons{display:flex;flex-direction:row;align-items:center;box-sizing:border-box}.mdc-card__action-icons{color:rgba(0, 0, 0, 0.6);flex-grow:1;justify-content:flex-end}.mdc-card__action-buttons+.mdc-card__action-icons{margin-left:16px;margin-right:0}[dir=rtl] .mdc-card__action-buttons+.mdc-card__action-icons,.mdc-card__action-buttons+.mdc-card__action-icons[dir=rtl]{margin-left:0;margin-right:16px}.mdc-card__action{display:inline-flex;flex-direction:row;align-items:center;box-sizing:border-box;justify-content:center;cursor:pointer;user-select:none}.mdc-card__action:focus{outline:none}.mdc-card__action--button{margin-left:0;margin-right:8px;padding:0 8px}[dir=rtl] .mdc-card__action--button,.mdc-card__action--button[dir=rtl]{margin-left:8px;margin-right:0}.mdc-card__action--button:last-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-card__action--button:last-child,.mdc-card__action--button:last-child[dir=rtl]{margin-left:0;margin-right:0}.mdc-card__actions--full-bleed .mdc-card__action--button{justify-content:space-between;width:100%;height:auto;max-height:none;margin:0;padding:8px 16px;text-align:left}[dir=rtl] .mdc-card__actions--full-bleed .mdc-card__action--button,.mdc-card__actions--full-bleed .mdc-card__action--button[dir=rtl]{text-align:right}.mdc-card__action--icon{margin:-6px 0;padding:12px}.mdc-card__action--icon:not(:disabled){color:rgba(0, 0, 0, 0.6)}.mat-mdc-card{border-radius:var(--mdc-elevated-card-container-shape);background-color:var(--mdc-elevated-card-container-color);border-width:0;border-style:solid;border-color:var(--mdc-elevated-card-container-color);box-shadow:var(--mdc-elevated-card-container-elevation);--mdc-elevated-card-container-shape:4px;--mdc-outlined-card-container-shape:4px;--mdc-outlined-card-outline-width:1px}.mat-mdc-card .mdc-card::after{border-radius:var(--mdc-elevated-card-container-shape)}.mat-mdc-card-outlined{border-width:var(--mdc-outlined-card-outline-width);border-style:solid;border-color:var(--mdc-outlined-card-outline-color);border-radius:var(--mdc-outlined-card-container-shape);background-color:var(--mdc-outlined-card-container-color);box-shadow:var(--mdc-outlined-card-container-elevation)}.mat-mdc-card-outlined .mdc-card::after{border-radius:var(--mdc-outlined-card-container-shape)}.mat-mdc-card-title{font-family:var(--mat-card-title-text-font);line-height:var(--mat-card-title-text-line-height);font-size:var(--mat-card-title-text-size);letter-spacing:var(--mat-card-title-text-tracking);font-weight:var(--mat-card-title-text-weight)}.mat-mdc-card-subtitle{color:var(--mat-card-subtitle-text-color);font-family:var(--mat-card-subtitle-text-font);line-height:var(--mat-card-subtitle-text-line-height);font-size:var(--mat-card-subtitle-text-size);letter-spacing:var(--mat-card-subtitle-text-tracking);font-weight:var(--mat-card-subtitle-text-weight)}.mat-mdc-card{position:relative}.mat-mdc-card-title,.mat-mdc-card-subtitle{display:block;margin:0}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle{padding:16px 16px 0}.mat-mdc-card-header{display:flex;padding:16px 16px 0}.mat-mdc-card-content{display:block;padding:0 16px}.mat-mdc-card-content:first-child{padding-top:16px}.mat-mdc-card-content:last-child{padding-bottom:16px}.mat-mdc-card-title-group{display:flex;justify-content:space-between;width:100%}.mat-mdc-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;margin-bottom:16px;object-fit:cover}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title{line-height:normal}.mat-mdc-card-sm-image{width:80px;height:80px}.mat-mdc-card-md-image{width:112px;height:112px}.mat-mdc-card-lg-image{width:152px;height:152px}.mat-mdc-card-xl-image{width:240px;height:240px}.mat-mdc-card-subtitle~.mat-mdc-card-title,.mat-mdc-card-title~.mat-mdc-card-subtitle,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-title-group .mat-mdc-card-title,.mat-mdc-card-title-group .mat-mdc-card-subtitle{padding-top:0}.mat-mdc-card-content>:last-child:not(.mat-mdc-card-footer){margin-bottom:0}.mat-mdc-card-actions-align-end{justify-content:flex-end}'
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				zX = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Ot, Yi] })
						}
					}
					return t
				})()
			const GX = Mt(Tr, t => t.isSearchPanelPinned)
			let $X = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.searchPanelMode = "minimized"),
							(this.updateSearchPanelMode = i => {
								this.setSearchPanelMode(this.searchPanelMode === i ? "minimized" : i)
							}),
							(this.closeSearchPanelOnOutsideClick = i => {
								this.isOutside(i) && !this.isSearchPanelPinned && this.setSearchPanelMode("minimized")
							})
					}
					ngOnInit() {
						this.isSearchPanelPinnedSubscription = this.store.select(GX).subscribe(e => {
							this.isSearchPanelPinned = e
						})
					}
					ngOnDestroy() {
						this.isSearchPanelPinnedSubscription.unsubscribe()
					}
					openSearchPanel() {
						this.setSearchPanelMode("treeView")
					}
					setSearchPanelMode(e) {
						"minimized" === this.searchPanelMode &&
							"minimized" !== e &&
							document.addEventListener("mousedown", this.closeSearchPanelOnOutsideClick),
							"minimized" !== this.searchPanelMode &&
								"minimized" === e &&
								document.removeEventListener("mousedown", this.closeSearchPanelOnOutsideClick),
							(this.searchPanelMode = e)
					}
					isOutside(e) {
						return e
							.composedPath()
							.every(
								i =>
									"CC-SEARCH-PANEL" !== i.nodeName &&
									"COLOR-CHROME" !== i.nodeName &&
									"MAT-OPTION" !== i.nodeName &&
									"codemap-context-menu" !== i.id
							)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-search-panel"]],
							decls: 12,
							vars: 9,
							consts: [
								["appearance", "outlined", 1, "search-panel-card"],
								[1, "section"],
								[1, "section-header"],
								[3, "click"],
								[3, "searchPanelMode", "updateSearchPanelMode"],
								[1, "section-title", 3, "click"],
								["title", "Show folder structure", 1, "fa", "fa-angle-down"],
								[1, "section-body"],
								[3, "hidden"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-card", 0)(1, "div", 1)(2, "div", 2)(3, "cc-search-bar", 3),
									Le("click", function () {
										return r.openSearchPanel()
									}),
									L(),
									fe(4, "cc-search-panel-mode-selector", 4),
									L(),
									F(5, "span", 5),
									Le("click", function () {
										return r.updateSearchPanelMode("treeView")
									}),
									ge(6, " File/Node Explorer "),
									fe(7, "i", 6),
									L(),
									F(8, "div", 7),
									fe(9, "cc-blacklist-panel", 8)(10, "cc-matching-files-counter", 8)(11, "cc-map-tree-view", 8),
									L()()()),
									2 & i &&
										(Zt("expanded", "minimized" !== r.searchPanelMode),
										T(4),
										U("searchPanelMode", r.searchPanelMode)("updateSearchPanelMode", r.updateSearchPanelMode),
										T(4),
										Zt("hidden", "minimized" === r.searchPanelMode),
										T(1),
										U("hidden", "blacklist" !== r.searchPanelMode),
										T(1),
										U("hidden", "treeView" !== r.searchPanelMode),
										T(1),
										U("hidden", "treeView" !== r.searchPanelMode))
							},
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-search-panel .search-panel-card{border-left:none;width:100%}cc-search-panel .search-panel-card .section-body{display:flex;flex-direction:column;padding:6px;position:absolute;top:45px;background:white;border:1px solid #b5b5b5;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f}cc-search-panel .search-panel-card .section-body.hidden{display:none;pointer-events:none}cc-search-panel .submenu-button{border:2px solid #1b9cfc}cc-search-panel .submenu-button:hover{border:2px solid #0374c9}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function yO(t) {
				for (const e of Object.keys(t))
					if ("object" == typeof t[e] && null !== t[e]) {
						const { x: i, y: r, z: o } = t[e]
						void 0 !== i || void 0 !== r || void 0 !== o ? (t[e] = new K(i ?? 1, r ?? 1, o ?? 1)) : yO(t[e])
					}
			}
			const Tke = JSON.parse(
				'[{"name":"Complexity","settings":{"appSettings":{},"dynamicSettings":{"areaMetric":"rloc","heightMetric":"mcc","colorMetric":"mcc","distributionMetric":"rloc"}}},{"name":"Average Complexity*","settings":{"appSettings":{},"dynamicSettings":{"areaMetric":"unary","heightMetric":"Average Complexity*","colorMetric":"Average Complexity*","distributionMetric":"unary"}}},{"name":"Coverage","settings":{"appSettings":{},"dynamicSettings":{"areaMetric":"rloc","heightMetric":"mcc","colorMetric":"line_coverage","distributionMetric":"rloc"}}},{"name":"Code Churn","settings":{"appSettings":{},"dynamicSettings":{"areaMetric":"rloc","heightMetric":"abs_code_churn","colorMetric":"weeks_with_commits","distributionMetric":"rloc"}}}]'
			)
			class Wu {
				static {
					this.SCENARIOS_LOCAL_STORAGE_VERSION = "1.0.0"
				}
				static {
					this.SCENARIOS_LOCAL_STORAGE_ELEMENT = "scenarios"
				}
				static {
					this.scenarios = Wu.loadScenarios()
				}
				static getScenarioItems(n) {
					const e = []
					for (const i of this.scenarios.values())
						e.push({
							scenarioName: i.name,
							isScenarioApplicable: this.isScenarioApplicable(i, n),
							icons: [
								{ faIconClass: "fa-video-camera", isSaved: !!i.camera, tooltip: "Camera angle" },
								{ faIconClass: "fa-arrows-alt", isSaved: !!i.area, tooltip: "Area metric" },
								{ faIconClass: "fa-arrows-v", isSaved: !!i.height, tooltip: "Height metric" },
								{ faIconClass: "fa-paint-brush", isSaved: !!i.color, tooltip: "Color metric" },
								{ faIconClass: "fa-exchange", isSaved: !!i.edge, tooltip: "Edge metric" }
							]
						})
					return e
				}
				static isScenarioApplicable(n, e) {
					const { area: i, color: r, height: o, edge: s } = n
					if (i || r || o) {
						const a = new Set(e.nodeMetricData.map(c => c.name))
						if ((i && !a.has(i.areaMetric)) || (r && !a.has(r.colorMetric)) || (o && !a.has(o.heightMetric))) return !1
					}
					return !(s && !e.edgeMetricData.some(a => a.name === s.edgeMetric))
				}
				static getPreLoadScenarios() {
					const n = this.importScenarios(Tke),
						e = new Map()
					for (const i of n) e.set(i.name, this.transformScenarioAsSettingsToScenario(i))
					return e
				}
				static transformScenarioAsSettingsToScenario(n) {
					const e = { name: n.name },
						{ dynamicSettings: i, appSettings: r } = n.settings
					return (
						void 0 !== i.areaMetric && (e.area = { areaMetric: i.areaMetric, margin: i.margin }),
						void 0 !== i.heightMetric &&
							(e.height = { heightMetric: i.heightMetric, labelSlider: r.amountOfTopLabels, heightSlider: r.scaling }),
						void 0 !== i.colorMetric &&
							(e.color = { colorMetric: i.colorMetric, colorRange: i.colorRange, mapColors: r.mapColors }),
						void 0 !== i.edgeMetric &&
							(e.edge = { edgeMetric: i.edgeMetric, edgeHeight: r.edgeHeight, edgePreview: r.amountOfEdgePreviews }),
						e
					)
				}
				static setScenariosToLocalStorage(n) {
					const e = { version: this.SCENARIOS_LOCAL_STORAGE_VERSION, scenarios: [...n] }
					localStorage.setItem(this.SCENARIOS_LOCAL_STORAGE_ELEMENT, JSON.stringify(e))
				}
				static loadScenarios() {
					const n = JSON.parse(localStorage.getItem(this.SCENARIOS_LOCAL_STORAGE_ELEMENT))
					if (n) return new Map(n.scenarios)
					const e = this.getPreLoadScenarios()
					return this.setScenariosToLocalStorage(e), e
				}
				static addScenario(n, e) {
					const i = Wu.createNewScenario(n, e)
					this.scenarios.set(i.name, i), this.setScenariosToLocalStorage(this.scenarios)
				}
				static createNewScenario(n, e) {
					const i = { name: n }
					for (const r of e.filter(o => o.isSelected))
						switch (r.metricType) {
							case "Camera-Position":
								i.camera = { camera: r.savedValues.camera, cameraTarget: r.savedValues.cameraTarget }
								break
							case "Area-Metric":
								i.area = { areaMetric: r.metricName, margin: r.savedValues }
								break
							case "Height-Metric":
								i.height = {
									heightMetric: r.metricName,
									heightSlider: r.savedValues.heightSlider,
									labelSlider: r.savedValues.labelSlider
								}
								break
							case "Color-Metric":
								i.color = {
									colorMetric: r.metricName,
									colorRange: r.savedValues.colorRange,
									mapColors: r.savedValues.mapColors
								}
								break
							case "Edge-Metric":
								i.edge = {
									edgeMetric: r.metricName,
									edgePreview: r.savedValues.edgePreview,
									edgeHeight: r.savedValues.edgeHeight
								}
								break
							default:
								throw new Error(`Unknown metric type "${r.metricType}" detected`)
						}
					return i
				}
				static deleteScenario(n) {
					this.scenarios.delete(n), this.setScenariosToLocalStorage(this.scenarios)
				}
				static getScenarioSettings(n) {
					const e = {},
						i = {}
					return (
						n &&
							(n.area && ((e.areaMetric = n.area.areaMetric), (e.margin = n.area.margin)),
							n.height &&
								((e.heightMetric = n.height.heightMetric),
								(i.amountOfTopLabels = n.height.labelSlider),
								(i.scaling = n.height.heightSlider)),
							n.color &&
								((e.colorMetric = n.color.colorMetric),
								(e.colorRange = n.color.colorRange),
								(i.mapColors = n.color.mapColors)),
							n.edge &&
								((e.edgeMetric = n.edge.edgeMetric),
								(i.edgeHeight = n.edge.edgeHeight),
								(i.amountOfEdgePreviews = n.edge.edgePreview))),
						{ appSettings: i, dynamicSettings: e }
					)
				}
				static importScenarios(n) {
					for (const e of n)
						yO(e.settings),
							e.camera &&
								((e.camera.camera = new K(e.camera.camera.x, e.camera.camera.y, e.camera.camera.z)),
								(e.camera.cameraTarget = new K(e.camera.camera.x, e.camera.camera.y, e.camera.camera.z)))
					return n
				}
				static isScenarioExisting(n) {
					return this.scenarios.has(n)
				}
			}
			const Sp = Nt("SET_STATE", { _as: "props", _p: void 0 })
			let wO = (() => {
				class t {
					constructor(e, i, r, o, s) {
						;(this.state = e),
							(this.store = i),
							(this.dialog = r),
							(this.threeCameraService = o),
							(this.threeOrbitControlsService = s)
					}
					getScenarios() {
						return Wu.getScenarioItems(Fs(this.state.getValue()))
					}
					applyScenario(e) {
						const i = Wu.scenarios.get(e),
							r = Wu.getScenarioSettings(i)
						this.store.dispatch(Sp({ value: r })),
							this.store.dispatch(sd({ value: r.dynamicSettings.colorRange })),
							this.store.dispatch(Au({ value: r.appSettings.mapColors })),
							i.camera &&
								(this.threeCameraService.setPosition(i.camera.camera),
								this.threeOrbitControlsService.setControlTarget(i.camera.cameraTarget))
					}
					removeScenario(e) {
						"Complexity" !== e
							? (Wu.deleteScenario(e), this.dialog.open(yg, { data: { title: "Info", message: `${e} deleted.` } }))
							: this.dialog.open(yg, {
									data: { title: "Error", message: `${e} cannot be deleted as it is the default Scenario.` }
							  })
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Sr), re(Ct), re(la), re(Td), re(El))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			class Dke extends vt {
				constructor(n = 1 / 0, e = 1 / 0, i = yI) {
					super(),
						(this._bufferSize = n),
						(this._windowTime = e),
						(this._timestampProvider = i),
						(this._buffer = []),
						(this._infiniteTimeWindow = !0),
						(this._infiniteTimeWindow = e === 1 / 0),
						(this._bufferSize = Math.max(1, n)),
						(this._windowTime = Math.max(1, e))
				}
				next(n) {
					const { isStopped: e, _buffer: i, _infiniteTimeWindow: r, _timestampProvider: o, _windowTime: s } = this
					e || (i.push(n), !r && i.push(o.now() + s)), this._trimBuffer(), super.next(n)
				}
				_subscribe(n) {
					this._throwIfClosed(), this._trimBuffer()
					const e = this._innerSubscribe(n),
						{ _infiniteTimeWindow: i, _buffer: r } = this,
						o = r.slice()
					for (let s = 0; s < o.length && !n.closed; s += i ? 1 : 2) n.next(o[s])
					return this._checkFinalizedStatuses(n), e
				}
				_trimBuffer() {
					const { _bufferSize: n, _timestampProvider: e, _buffer: i, _infiniteTimeWindow: r } = this,
						o = (r ? 1 : 2) * n
					if ((n < 1 / 0 && o < i.length && i.splice(0, i.length - o), !r)) {
						const s = e.now()
						let a = 0
						for (let c = 1; c < i.length && i[c] <= s; c += 2) a = c
						a && i.splice(0, a + 1)
					}
				}
			}
			class Rke {
				constructor(n) {
					;(this._box = n),
						(this._destroyed = new vt()),
						(this._resizeSubject = new vt()),
						(this._elementObservables = new Map()),
						typeof ResizeObserver < "u" && (this._resizeObserver = new ResizeObserver(e => this._resizeSubject.next(e)))
				}
				observe(n) {
					return (
						this._elementObservables.has(n) ||
							this._elementObservables.set(
								n,
								new Ge(e => {
									const i = this._resizeSubject.subscribe(e)
									return (
										this._resizeObserver?.observe(n, { box: this._box }),
										() => {
											this._resizeObserver?.unobserve(n), i.unsubscribe(), this._elementObservables.delete(n)
										}
									)
								}).pipe(
									xi(e => e.some(i => i.target === n)),
									(function Lke(t, n, e) {
										let i,
											r = !1
										return (
											t && "object" == typeof t
												? ({ bufferSize: i = 1 / 0, windowTime: n = 1 / 0, refCount: r = !1, scheduler: e } = t)
												: (i = t ?? 1 / 0),
											Rl({
												connector: () => new Dke(i, n, e),
												resetOnError: !0,
												resetOnComplete: !1,
												resetOnRefCountZero: r
											})
										)
									})({ bufferSize: 1, refCount: !0 }),
									kr(this._destroyed)
								)
							),
						this._elementObservables.get(n)
					)
				}
				destroy() {
					this._destroyed.next(), this._destroyed.complete(), this._resizeSubject.complete(), this._elementObservables.clear()
				}
			}
			let Pke = (() => {
				class t {
					constructor() {
						;(this._observers = new Map()), (this._ngZone = Rt(mn))
					}
					ngOnDestroy() {
						for (const [, e] of this._observers) e.destroy()
						this._observers.clear()
					}
					observe(e, i) {
						const r = i?.box || "content-box"
						return this._observers.has(r) || this._observers.set(r, new Rke(r)), this._observers.get(r).observe(e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
					}
				}
				return t
			})()
			const Oke = ["notch"],
				Nke = ["matFormFieldNotchedOutline", ""],
				Uke = ["*"],
				Hke = ["textField"],
				Vke = ["iconPrefixContainer"],
				Qke = ["textPrefixContainer"]
			function zke(t, n) {
				1 & t && fe(0, "span", 19)
			}
			function Gke(t, n) {
				if ((1 & t && (F(0, "label", 17), Ln(1, 1), Ee(2, zke, 1, 0, "span", 18), L()), 2 & t)) {
					const e = Te(2)
					U("floating", e._shouldLabelFloat())("monitorResize", e._hasOutline())("id", e._labelId),
						qn("for", e._control.id),
						T(2),
						U("ngIf", !e.hideRequiredMarker && e._control.required)
				}
			}
			function $ke(t, n) {
				1 & t && Ee(0, Gke, 3, 5, "label", 16), 2 & t && U("ngIf", Te()._hasFloatingLabel())
			}
			function Wke(t, n) {
				1 & t && fe(0, "div", 20)
			}
			function jke(t, n) {}
			function Kke(t, n) {
				1 & t && Ee(0, jke, 0, 0, "ng-template", 22), 2 & t && (Te(2), U("ngTemplateOutlet", br(1)))
			}
			function Xke(t, n) {
				if ((1 & t && (F(0, "div", 21), Ee(1, Kke, 1, 1, "ng-template", 9), L()), 2 & t)) {
					const e = Te()
					U("matFormFieldNotchedOutlineOpen", e._shouldLabelFloat()), T(1), U("ngIf", !e._forceDisplayInfixLabel())
				}
			}
			function Yke(t, n) {
				1 & t && (F(0, "div", 23, 24), Ln(2, 2), L())
			}
			function qke(t, n) {
				1 & t && (F(0, "div", 25, 26), Ln(2, 3), L())
			}
			function Zke(t, n) {}
			function Jke(t, n) {
				1 & t && Ee(0, Zke, 0, 0, "ng-template", 22), 2 & t && (Te(), U("ngTemplateOutlet", br(1)))
			}
			function eTe(t, n) {
				1 & t && (F(0, "div", 27), Ln(1, 4), L())
			}
			function tTe(t, n) {
				1 & t && (F(0, "div", 28), Ln(1, 5), L())
			}
			function nTe(t, n) {
				1 & t && fe(0, "div", 29)
			}
			function iTe(t, n) {
				1 & t && (F(0, "div", 30), Ln(1, 6), L()), 2 & t && U("@transitionMessages", Te()._subscriptAnimationState)
			}
			function rTe(t, n) {
				if ((1 & t && (F(0, "mat-hint", 34), ge(1), L()), 2 & t)) {
					const e = Te(2)
					U("id", e._hintLabelId), T(1), cr(e.hintLabel)
				}
			}
			function oTe(t, n) {
				if ((1 & t && (F(0, "div", 31), Ee(1, rTe, 2, 2, "mat-hint", 32), Ln(2, 7), fe(3, "div", 33), Ln(4, 8), L()), 2 & t)) {
					const e = Te()
					U("@transitionMessages", e._subscriptAnimationState), T(1), U("ngIf", e.hintLabel)
				}
			}
			const sTe = [
					"*",
					[["mat-label"]],
					[
						["", "matPrefix", ""],
						["", "matIconPrefix", ""]
					],
					[["", "matTextPrefix", ""]],
					[["", "matTextSuffix", ""]],
					[
						["", "matSuffix", ""],
						["", "matIconSuffix", ""]
					],
					[["mat-error"], ["", "matError", ""]],
					[["mat-hint", 3, "align", "end"]],
					[["mat-hint", "align", "end"]]
				],
				aTe = [
					"*",
					"mat-label",
					"[matPrefix], [matIconPrefix]",
					"[matTextPrefix]",
					"[matTextSuffix]",
					"[matSuffix], [matIconSuffix]",
					"mat-error, [matError]",
					"mat-hint:not([align='end'])",
					"mat-hint[align='end']"
				]
			let yf = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({ type: t, selectors: [["mat-label"]] })
						}
					}
					return t
				})(),
				cTe = 0
			const WX = new He("MatError")
			let jX = (() => {
					class t {
						constructor(e, i) {
							;(this.id = "mat-mdc-error-" + cTe++), e || i.nativeElement.setAttribute("aria-live", "polite")
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(Ma("aria-live"), P(wn))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["mat-error"], ["", "matError", ""]],
								hostAttrs: ["aria-atomic", "true", 1, "mat-mdc-form-field-error", "mat-mdc-form-field-bottom-align"],
								hostVars: 1,
								hostBindings: function (i, r) {
									2 & i && td("id", r.id)
								},
								inputs: { id: "id" },
								features: [Xn([{ provide: WX, useExisting: t }])]
							})
						}
					}
					return t
				})(),
				lTe = 0,
				xO = (() => {
					class t {
						constructor() {
							;(this.align = "start"), (this.id = "mat-mdc-hint-" + lTe++)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["mat-hint"]],
								hostAttrs: [1, "mat-mdc-form-field-hint", "mat-mdc-form-field-bottom-align"],
								hostVars: 4,
								hostBindings: function (i, r) {
									2 & i && (td("id", r.id), qn("align", null), Zt("mat-mdc-form-field-hint-end", "end" === r.align))
								},
								inputs: { align: "align", id: "id" }
							})
						}
					}
					return t
				})()
			const KX = new He("MatPrefix")
			let XX = (() => {
				class t {
					constructor() {
						this._isText = !1
					}
					set _isTextSelector(e) {
						this._isText = !0
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [
								["", "matPrefix", ""],
								["", "matIconPrefix", ""],
								["", "matTextPrefix", ""]
							],
							inputs: { _isTextSelector: ["matTextPrefix", "_isTextSelector"] },
							features: [Xn([{ provide: KX, useExisting: t }])]
						})
					}
				}
				return t
			})()
			const dTe = new He("MatSuffix"),
				YX = new He("FloatingLabelParent")
			let qX = (() => {
				class t {
					get floating() {
						return this._floating
					}
					set floating(e) {
						;(this._floating = e), this.monitorResize && this._handleResize()
					}
					get monitorResize() {
						return this._monitorResize
					}
					set monitorResize(e) {
						;(this._monitorResize = e), this._monitorResize ? this._subscribeToResize() : this._resizeSubscription.unsubscribe()
					}
					constructor(e) {
						;(this._elementRef = e),
							(this._floating = !1),
							(this._monitorResize = !1),
							(this._resizeObserver = Rt(Pke)),
							(this._ngZone = Rt(mn)),
							(this._parent = Rt(YX)),
							(this._resizeSubscription = new D())
					}
					ngOnDestroy() {
						this._resizeSubscription.unsubscribe()
					}
					getWidth() {
						return (function uTe(t) {
							if (null !== t.offsetParent) return t.scrollWidth
							const e = t.cloneNode(!0)
							e.style.setProperty("position", "absolute"),
								e.style.setProperty("transform", "translate(-9999px, -9999px)"),
								document.documentElement.appendChild(e)
							const i = e.scrollWidth
							return e.remove(), i
						})(this._elementRef.nativeElement)
					}
					get element() {
						return this._elementRef.nativeElement
					}
					_handleResize() {
						setTimeout(() => this._parent._handleLabelResized())
					}
					_subscribeToResize() {
						this._resizeSubscription.unsubscribe(),
							this._ngZone.runOutsideAngular(() => {
								this._resizeSubscription = this._resizeObserver
									.observe(this._elementRef.nativeElement, { box: "border-box" })
									.subscribe(() => this._handleResize())
							})
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(wn))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [["label", "matFormFieldFloatingLabel", ""]],
							hostAttrs: [1, "mdc-floating-label", "mat-mdc-floating-label"],
							hostVars: 2,
							hostBindings: function (i, r) {
								2 & i && Zt("mdc-floating-label--float-above", r.floating)
							},
							inputs: { floating: "floating", monitorResize: "monitorResize" }
						})
					}
				}
				return t
			})()
			const ZX = "mdc-line-ripple--active",
				ok = "mdc-line-ripple--deactivating"
			let JX = (() => {
					class t {
						constructor(e, i) {
							;(this._elementRef = e),
								(this._handleTransitionEnd = r => {
									const o = this._elementRef.nativeElement.classList,
										s = o.contains(ok)
									"opacity" === r.propertyName && s && o.remove(ZX, ok)
								}),
								i.runOutsideAngular(() => {
									e.nativeElement.addEventListener("transitionend", this._handleTransitionEnd)
								})
						}
						activate() {
							const e = this._elementRef.nativeElement.classList
							e.remove(ok), e.add(ZX)
						}
						deactivate() {
							this._elementRef.nativeElement.classList.add(ok)
						}
						ngOnDestroy() {
							this._elementRef.nativeElement.removeEventListener("transitionend", this._handleTransitionEnd)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(mn))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["div", "matFormFieldLineRipple", ""]],
								hostAttrs: [1, "mdc-line-ripple"]
							})
						}
					}
					return t
				})(),
				eY = (() => {
					class t {
						constructor(e, i) {
							;(this._elementRef = e), (this._ngZone = i), (this.open = !1)
						}
						ngAfterViewInit() {
							const e = this._elementRef.nativeElement.querySelector(".mdc-floating-label")
							e
								? (this._elementRef.nativeElement.classList.add("mdc-notched-outline--upgraded"),
								  "function" == typeof requestAnimationFrame &&
										((e.style.transitionDuration = "0s"),
										this._ngZone.runOutsideAngular(() => {
											requestAnimationFrame(() => (e.style.transitionDuration = ""))
										})))
								: this._elementRef.nativeElement.classList.add("mdc-notched-outline--no-label")
						}
						_setNotchWidth(e) {
							this._notch.nativeElement.style.width =
								this.open && e ? `calc(${e}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + 9px)` : ""
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(mn))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["div", "matFormFieldNotchedOutline", ""]],
								viewQuery: function (i, r) {
									if ((1 & i && _i(Oke, 5), 2 & i)) {
										let o
										sn((o = an())) && (r._notch = o.first)
									}
								},
								hostAttrs: [1, "mdc-notched-outline"],
								hostVars: 2,
								hostBindings: function (i, r) {
									2 & i && Zt("mdc-notched-outline--notched", r.open)
								},
								inputs: { open: ["matFormFieldNotchedOutlineOpen", "open"] },
								attrs: Nke,
								ngContentSelectors: Uke,
								decls: 5,
								vars: 0,
								consts: [
									[1, "mdc-notched-outline__leading"],
									[1, "mdc-notched-outline__notch"],
									["notch", ""],
									[1, "mdc-notched-outline__trailing"]
								],
								template: function (i, r) {
									1 & i && (co(), fe(0, "div", 0), F(1, "div", 1, 2), Ln(3), L(), fe(4, "div", 3))
								},
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})()
			const hTe = {
				transitionMessages: Mu("transitionMessages", [
					Pc("enter", wo({ opacity: 1, transform: "translateY(0%)" })),
					tc("void => enter", [wo({ opacity: 0, transform: "translateY(-5px)" }), Rc("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])
				])
			}
			let CO = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵdir = yt({ type: t })
					}
				}
				return t
			})()
			const EO = new He("MatFormField"),
				fTe = new He("MAT_FORM_FIELD_DEFAULT_OPTIONS")
			let tY = 0,
				Bd = (() => {
					class t {
						get hideRequiredMarker() {
							return this._hideRequiredMarker
						}
						set hideRequiredMarker(e) {
							this._hideRequiredMarker = Mn(e)
						}
						get floatLabel() {
							return this._floatLabel || this._defaults?.floatLabel || "auto"
						}
						set floatLabel(e) {
							e !== this._floatLabel && ((this._floatLabel = e), this._changeDetectorRef.markForCheck())
						}
						get appearance() {
							return this._appearance
						}
						set appearance(e) {
							const i = this._appearance
							;(this._appearance = e || this._defaults?.appearance || "fill"),
								"outline" === this._appearance &&
									this._appearance !== i &&
									(this._needsOutlineLabelOffsetUpdateOnStable = !0)
						}
						get subscriptSizing() {
							return this._subscriptSizing || this._defaults?.subscriptSizing || "fixed"
						}
						set subscriptSizing(e) {
							this._subscriptSizing = e || this._defaults?.subscriptSizing || "fixed"
						}
						get hintLabel() {
							return this._hintLabel
						}
						set hintLabel(e) {
							;(this._hintLabel = e), this._processHints()
						}
						get _control() {
							return this._explicitFormFieldControl || this._formFieldControl
						}
						set _control(e) {
							this._explicitFormFieldControl = e
						}
						constructor(e, i, r, o, s, a, c, l) {
							;(this._elementRef = e),
								(this._changeDetectorRef = i),
								(this._ngZone = r),
								(this._dir = o),
								(this._platform = s),
								(this._defaults = a),
								(this._animationMode = c),
								(this._hideRequiredMarker = !1),
								(this.color = "primary"),
								(this._appearance = "fill"),
								(this._subscriptSizing = null),
								(this._hintLabel = ""),
								(this._hasIconPrefix = !1),
								(this._hasTextPrefix = !1),
								(this._hasIconSuffix = !1),
								(this._hasTextSuffix = !1),
								(this._labelId = "mat-mdc-form-field-label-" + tY++),
								(this._hintLabelId = "mat-mdc-hint-" + tY++),
								(this._subscriptAnimationState = ""),
								(this._destroyed = new vt()),
								(this._isFocused = null),
								(this._needsOutlineLabelOffsetUpdateOnStable = !1),
								a &&
									(a.appearance && (this.appearance = a.appearance),
									(this._hideRequiredMarker = !!a?.hideRequiredMarker),
									a.color && (this.color = a.color))
						}
						ngAfterViewInit() {
							this._updateFocusState(), (this._subscriptAnimationState = "enter"), this._changeDetectorRef.detectChanges()
						}
						ngAfterContentInit() {
							this._assertFormFieldControl(),
								this._initializeControl(),
								this._initializeSubscript(),
								this._initializePrefixAndSuffix(),
								this._initializeOutlineLabelOffsetSubscriptions()
						}
						ngAfterContentChecked() {
							this._assertFormFieldControl()
						}
						ngOnDestroy() {
							this._destroyed.next(), this._destroyed.complete()
						}
						getLabelId() {
							return this._hasFloatingLabel() ? this._labelId : null
						}
						getConnectedOverlayOrigin() {
							return this._textField || this._elementRef
						}
						_animateAndLockLabel() {
							this._hasFloatingLabel() && (this.floatLabel = "always")
						}
						_initializeControl() {
							const e = this._control
							e.controlType && this._elementRef.nativeElement.classList.add(`mat-mdc-form-field-type-${e.controlType}`),
								e.stateChanges.subscribe(() => {
									this._updateFocusState(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck()
								}),
								e.ngControl &&
									e.ngControl.valueChanges &&
									e.ngControl.valueChanges
										.pipe(kr(this._destroyed))
										.subscribe(() => this._changeDetectorRef.markForCheck())
						}
						_checkPrefixAndSuffixTypes() {
							;(this._hasIconPrefix = !!this._prefixChildren.find(e => !e._isText)),
								(this._hasTextPrefix = !!this._prefixChildren.find(e => e._isText)),
								(this._hasIconSuffix = !!this._suffixChildren.find(e => !e._isText)),
								(this._hasTextSuffix = !!this._suffixChildren.find(e => e._isText))
						}
						_initializePrefixAndSuffix() {
							this._checkPrefixAndSuffixTypes(),
								oo(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => {
									this._checkPrefixAndSuffixTypes(), this._changeDetectorRef.markForCheck()
								})
						}
						_initializeSubscript() {
							this._hintChildren.changes.subscribe(() => {
								this._processHints(), this._changeDetectorRef.markForCheck()
							}),
								this._errorChildren.changes.subscribe(() => {
									this._syncDescribedByIds(), this._changeDetectorRef.markForCheck()
								}),
								this._validateHints(),
								this._syncDescribedByIds()
						}
						_assertFormFieldControl() {}
						_updateFocusState() {
							this._control.focused && !this._isFocused
								? ((this._isFocused = !0), this._lineRipple?.activate())
								: !this._control.focused &&
								  (this._isFocused || null === this._isFocused) &&
								  ((this._isFocused = !1), this._lineRipple?.deactivate()),
								this._textField?.nativeElement.classList.toggle("mdc-text-field--focused", this._control.focused)
						}
						_initializeOutlineLabelOffsetSubscriptions() {
							this._prefixChildren.changes.subscribe(() => (this._needsOutlineLabelOffsetUpdateOnStable = !0)),
								this._ngZone.runOutsideAngular(() => {
									this._ngZone.onStable.pipe(kr(this._destroyed)).subscribe(() => {
										this._needsOutlineLabelOffsetUpdateOnStable &&
											((this._needsOutlineLabelOffsetUpdateOnStable = !1), this._updateOutlineLabelOffset())
									})
								}),
								this._dir.change
									.pipe(kr(this._destroyed))
									.subscribe(() => (this._needsOutlineLabelOffsetUpdateOnStable = !0))
						}
						_shouldAlwaysFloat() {
							return "always" === this.floatLabel
						}
						_hasOutline() {
							return "outline" === this.appearance
						}
						_forceDisplayInfixLabel() {
							return !this._platform.isBrowser && this._prefixChildren.length && !this._shouldLabelFloat()
						}
						_hasFloatingLabel() {
							return !!this._labelChildNonStatic || !!this._labelChildStatic
						}
						_shouldLabelFloat() {
							return this._control.shouldLabelFloat || this._shouldAlwaysFloat()
						}
						_shouldForward(e) {
							const i = this._control ? this._control.ngControl : null
							return i && i[e]
						}
						_getDisplayedMessages() {
							return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint"
						}
						_handleLabelResized() {
							this._refreshOutlineNotchWidth()
						}
						_refreshOutlineNotchWidth() {
							this._hasOutline() && this._floatingLabel && this._shouldLabelFloat()
								? this._notchedOutline?._setNotchWidth(this._floatingLabel.getWidth())
								: this._notchedOutline?._setNotchWidth(0)
						}
						_processHints() {
							this._validateHints(), this._syncDescribedByIds()
						}
						_validateHints() {}
						_syncDescribedByIds() {
							if (this._control) {
								let e = []
								if (
									(this._control.userAriaDescribedBy &&
										"string" == typeof this._control.userAriaDescribedBy &&
										e.push(...this._control.userAriaDescribedBy.split(" ")),
									"hint" === this._getDisplayedMessages())
								) {
									const i = this._hintChildren ? this._hintChildren.find(o => "start" === o.align) : null,
										r = this._hintChildren ? this._hintChildren.find(o => "end" === o.align) : null
									i ? e.push(i.id) : this._hintLabel && e.push(this._hintLabelId), r && e.push(r.id)
								} else this._errorChildren && e.push(...this._errorChildren.map(i => i.id))
								this._control.setDescribedByIds(e)
							}
						}
						_updateOutlineLabelOffset() {
							if (!this._platform.isBrowser || !this._hasOutline() || !this._floatingLabel) return
							const e = this._floatingLabel.element
							if (!this._iconPrefixContainer && !this._textPrefixContainer) return void (e.style.transform = "")
							if (!this._isAttachedToDom()) return void (this._needsOutlineLabelOffsetUpdateOnStable = !0)
							const i = this._iconPrefixContainer?.nativeElement,
								r = this._textPrefixContainer?.nativeElement,
								o = i?.getBoundingClientRect().width ?? 0,
								s = r?.getBoundingClientRect().width ?? 0
							e.style.transform = `var(\n        --mat-mdc-form-field-label-transform,\n        translateY(-50%) translateX(calc(${
								"rtl" === this._dir.value ? "-1" : "1"
							} * (${o + s}px + var(--mat-mdc-form-field-label-offset-x, 0px))))\n    )`
						}
						_isAttachedToDom() {
							const e = this._elementRef.nativeElement
							if (e.getRootNode) {
								const i = e.getRootNode()
								return i && i !== e
							}
							return document.documentElement.contains(e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(Jr), P(mn), P(wu), P(Wr), P(fTe, 8), P(Bo, 8), P(wi))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-form-field"]],
								contentQueries: function (i, r, o) {
									if (
										(1 & i &&
											(yr(o, yf, 5),
											yr(o, yf, 7),
											yr(o, CO, 5),
											yr(o, KX, 5),
											yr(o, dTe, 5),
											yr(o, WX, 5),
											yr(o, xO, 5)),
										2 & i)
									) {
										let s
										sn((s = an())) && (r._labelChildNonStatic = s.first),
											sn((s = an())) && (r._labelChildStatic = s.first),
											sn((s = an())) && (r._formFieldControl = s.first),
											sn((s = an())) && (r._prefixChildren = s),
											sn((s = an())) && (r._suffixChildren = s),
											sn((s = an())) && (r._errorChildren = s),
											sn((s = an())) && (r._hintChildren = s)
									}
								},
								viewQuery: function (i, r) {
									if ((1 & i && (_i(Hke, 5), _i(Vke, 5), _i(Qke, 5), _i(qX, 5), _i(eY, 5), _i(JX, 5)), 2 & i)) {
										let o
										sn((o = an())) && (r._textField = o.first),
											sn((o = an())) && (r._iconPrefixContainer = o.first),
											sn((o = an())) && (r._textPrefixContainer = o.first),
											sn((o = an())) && (r._floatingLabel = o.first),
											sn((o = an())) && (r._notchedOutline = o.first),
											sn((o = an())) && (r._lineRipple = o.first)
									}
								},
								hostAttrs: [1, "mat-mdc-form-field"],
								hostVars: 42,
								hostBindings: function (i, r) {
									2 & i &&
										Zt("mat-mdc-form-field-label-always-float", r._shouldAlwaysFloat())(
											"mat-mdc-form-field-has-icon-prefix",
											r._hasIconPrefix
										)("mat-mdc-form-field-has-icon-suffix", r._hasIconSuffix)(
											"mat-form-field-invalid",
											r._control.errorState
										)("mat-form-field-disabled", r._control.disabled)(
											"mat-form-field-autofilled",
											r._control.autofilled
										)("mat-form-field-no-animations", "NoopAnimations" === r._animationMode)(
											"mat-form-field-appearance-fill",
											"fill" == r.appearance
										)("mat-form-field-appearance-outline", "outline" == r.appearance)(
											"mat-form-field-hide-placeholder",
											r._hasFloatingLabel() && !r._shouldLabelFloat()
										)("mat-focused", r._control.focused)("mat-primary", "accent" !== r.color && "warn" !== r.color)(
											"mat-accent",
											"accent" === r.color
										)("mat-warn", "warn" === r.color)("ng-untouched", r._shouldForward("untouched"))(
											"ng-touched",
											r._shouldForward("touched")
										)("ng-pristine", r._shouldForward("pristine"))("ng-dirty", r._shouldForward("dirty"))(
											"ng-valid",
											r._shouldForward("valid")
										)("ng-invalid", r._shouldForward("invalid"))("ng-pending", r._shouldForward("pending"))
								},
								inputs: {
									hideRequiredMarker: "hideRequiredMarker",
									color: "color",
									floatLabel: "floatLabel",
									appearance: "appearance",
									subscriptSizing: "subscriptSizing",
									hintLabel: "hintLabel"
								},
								exportAs: ["matFormField"],
								features: [
									Xn([
										{ provide: EO, useExisting: t },
										{ provide: YX, useExisting: t }
									])
								],
								ngContentSelectors: aTe,
								decls: 18,
								vars: 23,
								consts: [
									["labelTemplate", ""],
									[1, "mat-mdc-text-field-wrapper", "mdc-text-field", 3, "click"],
									["textField", ""],
									["class", "mat-mdc-form-field-focus-overlay", 4, "ngIf"],
									[1, "mat-mdc-form-field-flex"],
									["matFormFieldNotchedOutline", "", 3, "matFormFieldNotchedOutlineOpen", 4, "ngIf"],
									["class", "mat-mdc-form-field-icon-prefix", 4, "ngIf"],
									["class", "mat-mdc-form-field-text-prefix", 4, "ngIf"],
									[1, "mat-mdc-form-field-infix"],
									[3, "ngIf"],
									["class", "mat-mdc-form-field-text-suffix", 4, "ngIf"],
									["class", "mat-mdc-form-field-icon-suffix", 4, "ngIf"],
									["matFormFieldLineRipple", "", 4, "ngIf"],
									[1, "mat-mdc-form-field-subscript-wrapper", "mat-mdc-form-field-bottom-align", 3, "ngSwitch"],
									["class", "mat-mdc-form-field-error-wrapper", 4, "ngSwitchCase"],
									["class", "mat-mdc-form-field-hint-wrapper", 4, "ngSwitchCase"],
									["matFormFieldFloatingLabel", "", 3, "floating", "monitorResize", "id", 4, "ngIf"],
									["matFormFieldFloatingLabel", "", 3, "floating", "monitorResize", "id"],
									[
										"aria-hidden",
										"true",
										"class",
										"mat-mdc-form-field-required-marker mdc-floating-label--required",
										4,
										"ngIf"
									],
									["aria-hidden", "true", 1, "mat-mdc-form-field-required-marker", "mdc-floating-label--required"],
									[1, "mat-mdc-form-field-focus-overlay"],
									["matFormFieldNotchedOutline", "", 3, "matFormFieldNotchedOutlineOpen"],
									[3, "ngTemplateOutlet"],
									[1, "mat-mdc-form-field-icon-prefix"],
									["iconPrefixContainer", ""],
									[1, "mat-mdc-form-field-text-prefix"],
									["textPrefixContainer", ""],
									[1, "mat-mdc-form-field-text-suffix"],
									[1, "mat-mdc-form-field-icon-suffix"],
									["matFormFieldLineRipple", ""],
									[1, "mat-mdc-form-field-error-wrapper"],
									[1, "mat-mdc-form-field-hint-wrapper"],
									[3, "id", 4, "ngIf"],
									[1, "mat-mdc-form-field-hint-spacer"],
									[3, "id"]
								],
								template: function (i, r) {
									1 & i &&
										(co(sTe),
										Ee(0, $ke, 1, 1, "ng-template", null, 0, oa),
										F(2, "div", 1, 2),
										Le("click", function (s) {
											return r._control.onContainerClick(s)
										}),
										Ee(4, Wke, 1, 0, "div", 3),
										F(5, "div", 4),
										Ee(6, Xke, 2, 2, "div", 5),
										Ee(7, Yke, 3, 0, "div", 6),
										Ee(8, qke, 3, 0, "div", 7),
										F(9, "div", 8),
										Ee(10, Jke, 1, 1, "ng-template", 9),
										Ln(11),
										L(),
										Ee(12, eTe, 2, 0, "div", 10),
										Ee(13, tTe, 2, 0, "div", 11),
										L(),
										Ee(14, nTe, 1, 0, "div", 12),
										L(),
										F(15, "div", 13),
										Ee(16, iTe, 2, 1, "div", 14),
										Ee(17, oTe, 5, 2, "div", 15),
										L()),
										2 & i &&
											(T(2),
											Zt("mdc-text-field--filled", !r._hasOutline())("mdc-text-field--outlined", r._hasOutline())(
												"mdc-text-field--no-label",
												!r._hasFloatingLabel()
											)("mdc-text-field--disabled", r._control.disabled)(
												"mdc-text-field--invalid",
												r._control.errorState
											),
											T(2),
											U("ngIf", !r._hasOutline() && !r._control.disabled),
											T(2),
											U("ngIf", r._hasOutline()),
											T(1),
											U("ngIf", r._hasIconPrefix),
											T(1),
											U("ngIf", r._hasTextPrefix),
											T(2),
											U("ngIf", !r._hasOutline() || r._forceDisplayInfixLabel()),
											T(2),
											U("ngIf", r._hasTextSuffix),
											T(1),
											U("ngIf", r._hasIconSuffix),
											T(1),
											U("ngIf", !r._hasOutline()),
											T(1),
											Zt("mat-mdc-form-field-subscript-dynamic-size", "dynamic" === r.subscriptSizing),
											U("ngSwitch", r._getDisplayedMessages()),
											T(1),
											U("ngSwitchCase", "error"),
											T(1),
											U("ngSwitchCase", "hint"))
								},
								dependencies: [En, x0, w0, R2, xO, qX, eY, JX],
								styles: [
									'.mdc-text-field{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:0;border-bottom-left-radius:0;display:inline-flex;align-items:baseline;padding:0 16px;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color}.mdc-text-field .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-text-field__input{height:28px;width:100%;min-width:0;border:none;border-radius:0;background:none;appearance:none;padding:0}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}@media all{.mdc-text-field__input::placeholder{opacity:0}}@media all{.mdc-text-field__input:-ms-input-placeholder{opacity:0}}@media all{.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{opacity:1}}@media all{.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{opacity:1}}.mdc-text-field__affix{height:28px;opacity:0;white-space:nowrap}.mdc-text-field--label-floating .mdc-text-field__affix,.mdc-text-field--no-label .mdc-text-field__affix{opacity:1}@supports(-webkit-hyphens: none){.mdc-text-field--outlined .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field__affix--prefix,.mdc-text-field__affix--prefix[dir=rtl]{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:0;padding-right:12px}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--end-aligned .mdc-text-field__affix--prefix[dir=rtl]{padding-left:12px;padding-right:0}.mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field__affix--suffix,.mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px;padding-right:0}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--end-aligned .mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:2px}.mdc-text-field--filled{height:56px}.mdc-text-field--filled::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}.mdc-text-field--filled .mdc-floating-label{left:16px;right:initial}[dir=rtl] .mdc-text-field--filled .mdc-floating-label,.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label{display:none}.mdc-text-field--filled.mdc-text-field--no-label::before{display:none}@supports(-webkit-hyphens: none){.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--outlined{height:56px;overflow:visible}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined .mdc-text-field__input{height:100%}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-shape-small, 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined .mdc-text-field__input{display:flex;border:none !important;background-color:rgba(0,0,0,0)}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mdc-text-field--textarea{flex-direction:column;align-items:center;width:auto;height:auto;padding:0}.mdc-text-field--textarea .mdc-floating-label{top:19px}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea .mdc-text-field__input{flex-grow:1;height:auto;min-height:1.5rem;overflow-x:hidden;overflow-y:auto;box-sizing:border-box;resize:none;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--filled::before{display:none}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-10.25px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--filled .mdc-text-field__input{margin-top:23px;margin-bottom:9px}.mdc-text-field--textarea.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-27.25px) scale(1)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-24.75px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label{top:18px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field__input{margin-bottom:2px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter{align-self:flex-end;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::after{display:inline-block;width:0;height:16px;content:"";vertical-align:-16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::before{display:none}.mdc-text-field__resizer{align-self:stretch;display:inline-flex;flex-direction:column;flex-grow:1;max-height:100%;max-width:100%;min-height:56px;min-width:fit-content;min-width:-moz-available;min-width:-webkit-fill-available;overflow:hidden;resize:both}.mdc-text-field--filled .mdc-text-field__resizer{transform:translateY(-1px)}.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(-1px) translateY(-1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer,.mdc-text-field--outlined .mdc-text-field__resizer[dir=rtl]{transform:translateX(1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateX(1px) translateY(1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input[dir=rtl],.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter[dir=rtl]{transform:translateX(-1px) translateY(1px)}.mdc-text-field--with-leading-icon{padding-left:0;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon,.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:16px;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 48px);left:48px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-trailing-icon{padding-left:16px;padding-right:0}[dir=rtl] .mdc-text-field--with-trailing-icon,.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-trailing-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 96px / 0.75)}.mdc-text-field-helper-line{display:flex;justify-content:space-between;box-sizing:border-box}.mdc-text-field+.mdc-text-field-helper-line{padding-right:16px;padding-left:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--focused.mdc-text-field--outlined.mdc-text-field--textarea .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--disabled{pointer-events:none}@media screen and (forced-colors: active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--disabled.mdc-text-field--filled .mdc-text-field__ripple{display:none}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl]{text-align:left}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix{direction:ltr}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--leading,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--leading{order:1}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{order:2}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input{order:3}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{order:4}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--trailing,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--trailing{order:5}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--prefix{padding-right:12px}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--suffix{padding-left:2px}.mdc-floating-label{position:absolute;left:0;-webkit-transform-origin:left top;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:1px;margin-right:0px;content:"*"}[dir=rtl] .mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after,.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)[dir=rtl]::after{margin-left:0;margin-right:1px}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;pointer-events:none}.mdc-notched-outline__trailing{flex-grow:1}.mdc-notched-outline__notch{flex:0 0 auto;width:auto}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{z-index:1}.mdc-line-ripple::after{transform:scaleX(0);opacity:0;z-index:2}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{border-top:1px solid;border-bottom:1px solid}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{max-width:calc(100% - 12px * 2)}.mdc-line-ripple::before{border-bottom-width:1px}.mdc-line-ripple::after{border-bottom-width:2px}.mdc-text-field--filled{--mdc-filled-text-field-active-indicator-height:1px;--mdc-filled-text-field-focus-active-indicator-height:2px;--mdc-filled-text-field-container-shape:4px;border-top-left-radius:var(--mdc-filled-text-field-container-shape);border-top-right-radius:var(--mdc-filled-text-field-container-shape);border-bottom-right-radius:0;border-bottom-left-radius:0}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-filled-text-field-caret-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-filled-text-field-error-caret-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-filled-text-field-input-text-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-filled-text-field-disabled-input-text-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-label-text-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-focus-label-text-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--disabled .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-disabled-label-text-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-error-label-text-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-error-focus-label-text-color)}.mdc-text-field--filled .mdc-floating-label{font-family:var(--mdc-filled-text-field-label-text-font);font-size:var(--mdc-filled-text-field-label-text-size);font-weight:var(--mdc-filled-text-field-label-text-weight);letter-spacing:var(--mdc-filled-text-field-label-text-tracking)}@media all{.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}}@media all{.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:var(--mdc-filled-text-field-container-color)}.mdc-text-field--filled.mdc-text-field--disabled{background-color:var(--mdc-filled-text-field-disabled-container-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-active-indicator-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-hover-active-indicator-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-focus-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-disabled-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-hover-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-error-focus-active-indicator-color)}.mdc-text-field--filled .mdc-line-ripple::before{border-bottom-width:var(--mdc-filled-text-field-active-indicator-height)}.mdc-text-field--filled .mdc-line-ripple::after{border-bottom-width:var(--mdc-filled-text-field-focus-active-indicator-height)}.mdc-text-field--outlined{--mdc-outlined-text-field-outline-width:1px;--mdc-outlined-text-field-focus-outline-width:2px;--mdc-outlined-text-field-container-shape:4px}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-outlined-text-field-caret-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-outlined-text-field-error-caret-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-outlined-text-field-input-text-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-outlined-text-field-disabled-input-text-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-label-text-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-focus-label-text-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-disabled-label-text-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-error-label-text-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-error-focus-label-text-color)}.mdc-text-field--outlined .mdc-floating-label{font-family:var(--mdc-outlined-text-field-label-text-font);font-size:var(--mdc-outlined-text-field-label-text-size);font-weight:var(--mdc-outlined-text-field-label-text-weight);letter-spacing:var(--mdc-outlined-text-field-label-text-tracking)}@media all{.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color)}}@media all{.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:var(--mdc-outlined-text-field-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-outlined-text-field-container-shape))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-outlined-text-field-container-shape))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:var(--mdc-outlined-text-field-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-outlined-text-field-container-shape))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-hover-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-focus-outline-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-disabled-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-hover-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-focus-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__trailing{border-width:var(--mdc-outlined-text-field-outline-width)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__trailing{border-width:var(--mdc-outlined-text-field-focus-outline-width)}.mat-mdc-form-field-textarea-control{vertical-align:middle;resize:vertical;box-sizing:border-box;height:auto;margin:0;padding:0;border:none;overflow:auto}.mat-mdc-form-field-input-control.mat-mdc-form-field-input-control{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font:inherit;letter-spacing:inherit;text-decoration:inherit;text-transform:inherit;border:none}.mat-mdc-form-field .mat-mdc-floating-label.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;line-height:normal;pointer-events:all}.mat-mdc-form-field:not(.mat-form-field-disabled) .mat-mdc-floating-label.mdc-floating-label{cursor:inherit}.mdc-text-field--no-label:not(.mdc-text-field--textarea) .mat-mdc-form-field-input-control.mdc-text-field__input,.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control{height:auto}.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control.mdc-text-field__input[type=color]{height:23px}.mat-mdc-text-field-wrapper{height:auto;flex:auto}.mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-left:0;--mat-mdc-form-field-label-offset-x: -16px}.mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-right:0}[dir=rtl] .mat-mdc-text-field-wrapper{padding-left:16px;padding-right:16px}[dir=rtl] .mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-left:0}[dir=rtl] .mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-right:0}.mat-form-field-disabled .mdc-text-field__input::placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input::-moz-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input::-webkit-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input:-ms-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-mdc-form-field-label-always-float .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mat-mdc-text-field-wrapper .mat-mdc-form-field-infix .mat-mdc-floating-label{left:auto;right:auto}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-text-field__input{display:inline-block}.mat-mdc-form-field .mat-mdc-text-field-wrapper.mdc-text-field .mdc-notched-outline__notch{padding-top:0}.mat-mdc-text-field-wrapper::before{content:none}.mat-mdc-form-field-subscript-wrapper{box-sizing:border-box;width:100%;position:relative}.mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-error-wrapper{position:absolute;top:0;left:0;right:0;padding:0 16px}.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-error-wrapper{position:static}.mat-mdc-form-field-bottom-align::before{content:"";display:inline-block;height:16px}.mat-mdc-form-field-bottom-align.mat-mdc-form-field-subscript-dynamic-size::before{content:unset}.mat-mdc-form-field-hint-end{order:1}.mat-mdc-form-field-hint-wrapper{display:flex}.mat-mdc-form-field-hint-spacer{flex:1 0 1em}.mat-mdc-form-field-error{display:block}.mat-mdc-form-field-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;opacity:0;pointer-events:none}select.mat-mdc-form-field-input-control{-moz-appearance:none;-webkit-appearance:none;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box}select.mat-mdc-form-field-input-control:not(:disabled){cursor:pointer}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;right:0;top:50%;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{right:auto;left:0}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:15px}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:0;padding-left:15px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-mdc-text-field-wrapper{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-form-field-disabled .mat-mdc-text-field-wrapper{outline-color:GrayText}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-mdc-text-field-wrapper{outline:dashed 3px}.cdk-high-contrast-active .mat-mdc-form-field.mat-focused .mdc-notched-outline{border:dashed 3px}.mat-mdc-form-field-input-control[type=date],.mat-mdc-form-field-input-control[type=datetime],.mat-mdc-form-field-input-control[type=datetime-local],.mat-mdc-form-field-input-control[type=month],.mat-mdc-form-field-input-control[type=week],.mat-mdc-form-field-input-control[type=time]{line-height:1}.mat-mdc-form-field-input-control::-webkit-datetime-edit{line-height:1;padding:0;margin-bottom:-2px}.mat-mdc-form-field{--mat-mdc-form-field-floating-label-scale: 0.75;display:inline-flex;flex-direction:column;min-width:0;text-align:left;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-form-field-container-text-font);line-height:var(--mat-form-field-container-text-line-height);font-size:var(--mat-form-field-container-text-size);letter-spacing:var(--mat-form-field-container-text-tracking);font-weight:var(--mat-form-field-container-text-weight)}[dir=rtl] .mat-mdc-form-field{text-align:right}.mat-mdc-form-field .mdc-text-field--outlined .mdc-floating-label--float-above{font-size:calc(var(--mat-form-field-outlined-label-text-populated-size) * var(--mat-mdc-form-field-floating-label-scale))}.mat-mdc-form-field .mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:var(--mat-form-field-outlined-label-text-populated-size)}.mat-mdc-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-mdc-text-field-wrapper{width:100%}.mat-mdc-form-field-icon-prefix,.mat-mdc-form-field-icon-suffix{align-self:center;line-height:0;pointer-events:auto;position:relative;z-index:1}.mat-mdc-form-field-icon-prefix,[dir=rtl] .mat-mdc-form-field-icon-suffix{padding:0 4px 0 0}.mat-mdc-form-field-icon-suffix,[dir=rtl] .mat-mdc-form-field-icon-prefix{padding:0 0 0 4px}.mat-mdc-form-field-icon-prefix>.mat-icon,.mat-mdc-form-field-icon-suffix>.mat-icon{padding:12px;box-sizing:content-box}.mat-mdc-form-field-subscript-wrapper .mat-icon,.mat-mdc-form-field label .mat-icon{width:1em;height:1em;font-size:inherit}.mat-mdc-form-field-infix{flex:auto;min-width:0;width:180px;position:relative;box-sizing:border-box}.mat-mdc-form-field .mdc-notched-outline__notch{margin-left:-1px;-webkit-clip-path:inset(-9em -999em -9em 1px);clip-path:inset(-9em -999em -9em 1px)}[dir=rtl] .mat-mdc-form-field .mdc-notched-outline__notch{margin-left:0;margin-right:-1px;-webkit-clip-path:inset(-9em 1px -9em -999em);clip-path:inset(-9em 1px -9em -999em)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition-delay:40ms;transition-duration:110ms}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__affix{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled.mdc-ripple-upgraded--background-focused .mdc-text-field__ripple::before,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple::before{transition-duration:75ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea{transition:none}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-filled 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-filled{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}[dir=rtl] .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-floating-label{transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-notched-outline .mdc-floating-label{max-width:calc(100% + 1px)}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(133.3333333333% + 1px)}'
								],
								encapsulation: 2,
								data: { animation: [hTe.transitionMessages] },
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				ww = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Ot, zD, Yi] })
						}
					}
					return t
				})()
			const ATe = ["*", [["mat-toolbar-row"]]],
				gTe = ["*", "mat-toolbar-row"],
				bTe = _g(
					class {
						constructor(t) {
							this._elementRef = t
						}
					}
				)
			let _Te = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["mat-toolbar-row"]],
								hostAttrs: [1, "mat-toolbar-row"],
								exportAs: ["matToolbarRow"]
							})
						}
					}
					return t
				})(),
				Mb = (() => {
					class t extends bTe {
						constructor(e, i, r) {
							super(e), (this._platform = i), (this._document = r)
						}
						ngAfterViewInit() {
							this._platform.isBrowser &&
								(this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes()))
						}
						_checkToolbarMixedModes() {}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(Wr), P(wi))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-toolbar"]],
								contentQueries: function (i, r, o) {
									if ((1 & i && yr(o, _Te, 5), 2 & i)) {
										let s
										sn((s = an())) && (r._toolbarRows = s)
									}
								},
								hostAttrs: [1, "mat-toolbar"],
								hostVars: 4,
								hostBindings: function (i, r) {
									2 & i &&
										Zt("mat-toolbar-multiple-rows", r._toolbarRows.length > 0)(
											"mat-toolbar-single-row",
											0 === r._toolbarRows.length
										)
								},
								inputs: { color: "color" },
								exportAs: ["matToolbar"],
								features: [pn],
								ngContentSelectors: gTe,
								decls: 2,
								vars: 0,
								template: function (i, r) {
									1 & i && (co(ATe), Ln(0), Ln(1, 1))
								},
								styles: [
									".mat-toolbar{background:var(--mat-toolbar-container-background-color);color:var(--mat-toolbar-container-text-color)}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font-family:var(--mat-toolbar-title-text-font);font-size:var(--mat-toolbar-title-text-size);line-height:var(--mat-toolbar-title-text-line-height);font-weight:var(--mat-toolbar-title-text-weight);letter-spacing:var(--mat-toolbar-title-text-tracking);margin:0}.cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar .mat-mdc-button-base.mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color: inherit;--mdc-outlined-button-label-text-color: inherit}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap;height:var(--mat-toolbar-standard-height)}@media(max-width: 599px){.mat-toolbar-row,.mat-toolbar-single-row{height:var(--mat-toolbar-mobile-height)}}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%;min-height:var(--mat-toolbar-standard-height)}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:var(--mat-toolbar-mobile-height)}}"
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				rY = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Yi] })
						}
					}
					return t
				})()
			const oY = Rm({ passive: !0 })
			let vTe = (() => {
					class t {
						constructor(e, i) {
							;(this._platform = e), (this._ngZone = i), (this._monitoredElements = new Map())
						}
						monitor(e) {
							if (!this._platform.isBrowser) return Ai
							const i = yu(e),
								r = this._monitoredElements.get(i)
							if (r) return r.subject
							const o = new vt(),
								s = "cdk-text-field-autofilled",
								a = c => {
									"cdk-text-field-autofill-start" !== c.animationName || i.classList.contains(s)
										? "cdk-text-field-autofill-end" === c.animationName &&
										  i.classList.contains(s) &&
										  (i.classList.remove(s), this._ngZone.run(() => o.next({ target: c.target, isAutofilled: !1 })))
										: (i.classList.add(s), this._ngZone.run(() => o.next({ target: c.target, isAutofilled: !0 })))
								}
							return (
								this._ngZone.runOutsideAngular(() => {
									i.addEventListener("animationstart", a, oY), i.classList.add("cdk-text-field-autofill-monitored")
								}),
								this._monitoredElements.set(i, {
									subject: o,
									unlisten: () => {
										i.removeEventListener("animationstart", a, oY)
									}
								}),
								o
							)
						}
						stopMonitoring(e) {
							const i = yu(e),
								r = this._monitoredElements.get(i)
							r &&
								(r.unlisten(),
								r.subject.complete(),
								i.classList.remove("cdk-text-field-autofill-monitored"),
								i.classList.remove("cdk-text-field-autofilled"),
								this._monitoredElements.delete(i))
						}
						ngOnDestroy() {
							this._monitoredElements.forEach((e, i) => this.stopMonitoring(i))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Wr), re(mn))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				sY = (() => {
					class t {
						get minRows() {
							return this._minRows
						}
						set minRows(e) {
							;(this._minRows = to(e)), this._setMinHeight()
						}
						get maxRows() {
							return this._maxRows
						}
						set maxRows(e) {
							;(this._maxRows = to(e)), this._setMaxHeight()
						}
						get enabled() {
							return this._enabled
						}
						set enabled(e) {
							;(e = Mn(e)), this._enabled !== e && ((this._enabled = e) ? this.resizeToFitContent(!0) : this.reset())
						}
						get placeholder() {
							return this._textareaElement.placeholder
						}
						set placeholder(e) {
							;(this._cachedPlaceholderHeight = void 0),
								e
									? this._textareaElement.setAttribute("placeholder", e)
									: this._textareaElement.removeAttribute("placeholder"),
								this._cacheTextareaPlaceholderHeight()
						}
						constructor(e, i, r, o) {
							;(this._elementRef = e),
								(this._platform = i),
								(this._ngZone = r),
								(this._destroyed = new vt()),
								(this._enabled = !0),
								(this._previousMinRows = -1),
								(this._isViewInited = !1),
								(this._handleFocusEvent = s => {
									this._hasFocus = "focus" === s.type
								}),
								(this._document = o),
								(this._textareaElement = this._elementRef.nativeElement)
						}
						_setMinHeight() {
							const e = this.minRows && this._cachedLineHeight ? this.minRows * this._cachedLineHeight + "px" : null
							e && (this._textareaElement.style.minHeight = e)
						}
						_setMaxHeight() {
							const e = this.maxRows && this._cachedLineHeight ? this.maxRows * this._cachedLineHeight + "px" : null
							e && (this._textareaElement.style.maxHeight = e)
						}
						ngAfterViewInit() {
							this._platform.isBrowser &&
								((this._initialHeight = this._textareaElement.style.height),
								this.resizeToFitContent(),
								this._ngZone.runOutsideAngular(() => {
									mg(this._getWindow(), "resize")
										.pipe(DD(16), kr(this._destroyed))
										.subscribe(() => this.resizeToFitContent(!0)),
										this._textareaElement.addEventListener("focus", this._handleFocusEvent),
										this._textareaElement.addEventListener("blur", this._handleFocusEvent)
								}),
								(this._isViewInited = !0),
								this.resizeToFitContent(!0))
						}
						ngOnDestroy() {
							this._textareaElement.removeEventListener("focus", this._handleFocusEvent),
								this._textareaElement.removeEventListener("blur", this._handleFocusEvent),
								this._destroyed.next(),
								this._destroyed.complete()
						}
						_cacheTextareaLineHeight() {
							if (this._cachedLineHeight) return
							let e = this._textareaElement.cloneNode(!1)
							;(e.rows = 1),
								(e.style.position = "absolute"),
								(e.style.visibility = "hidden"),
								(e.style.border = "none"),
								(e.style.padding = "0"),
								(e.style.height = ""),
								(e.style.minHeight = ""),
								(e.style.maxHeight = ""),
								(e.style.overflow = "hidden"),
								this._textareaElement.parentNode.appendChild(e),
								(this._cachedLineHeight = e.clientHeight),
								e.remove(),
								this._setMinHeight(),
								this._setMaxHeight()
						}
						_measureScrollHeight() {
							const e = this._textareaElement,
								i = e.style.marginBottom || "",
								r = this._platform.FIREFOX,
								o = r && this._hasFocus,
								s = r ? "cdk-textarea-autosize-measuring-firefox" : "cdk-textarea-autosize-measuring"
							o && (e.style.marginBottom = `${e.clientHeight}px`), e.classList.add(s)
							const a = e.scrollHeight - 4
							return e.classList.remove(s), o && (e.style.marginBottom = i), a
						}
						_cacheTextareaPlaceholderHeight() {
							if (!this._isViewInited || null != this._cachedPlaceholderHeight) return
							if (!this.placeholder) return void (this._cachedPlaceholderHeight = 0)
							const e = this._textareaElement.value
							;(this._textareaElement.value = this._textareaElement.placeholder),
								(this._cachedPlaceholderHeight = this._measureScrollHeight()),
								(this._textareaElement.value = e)
						}
						ngDoCheck() {
							this._platform.isBrowser && this.resizeToFitContent()
						}
						resizeToFitContent(e = !1) {
							if (
								!this._enabled ||
								(this._cacheTextareaLineHeight(), this._cacheTextareaPlaceholderHeight(), !this._cachedLineHeight)
							)
								return
							const i = this._elementRef.nativeElement,
								r = i.value
							if (!e && this._minRows === this._previousMinRows && r === this._previousValue) return
							const o = this._measureScrollHeight(),
								s = Math.max(o, this._cachedPlaceholderHeight || 0)
							;(i.style.height = `${s}px`),
								this._ngZone.runOutsideAngular(() => {
									typeof requestAnimationFrame < "u"
										? requestAnimationFrame(() => this._scrollToCaretPosition(i))
										: setTimeout(() => this._scrollToCaretPosition(i))
								}),
								(this._previousValue = r),
								(this._previousMinRows = this._minRows)
						}
						reset() {
							void 0 !== this._initialHeight && (this._textareaElement.style.height = this._initialHeight)
						}
						_noopInputHandler() {}
						_getDocument() {
							return this._document || document
						}
						_getWindow() {
							return this._getDocument().defaultView || window
						}
						_scrollToCaretPosition(e) {
							const { selectionStart: i, selectionEnd: r } = e
							!this._destroyed.isStopped && this._hasFocus && e.setSelectionRange(i, r)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(Wr), P(mn), P(wi, 8))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["textarea", "cdkTextareaAutosize", ""]],
								hostAttrs: ["rows", "1", 1, "cdk-textarea-autosize"],
								hostBindings: function (i, r) {
									1 & i &&
										Le("input", function () {
											return r._noopInputHandler()
										})
								},
								inputs: {
									minRows: ["cdkAutosizeMinRows", "minRows"],
									maxRows: ["cdkAutosizeMaxRows", "maxRows"],
									enabled: ["cdkTextareaAutosize", "enabled"],
									placeholder: "placeholder"
								},
								exportAs: ["cdkTextareaAutosize"]
							})
						}
					}
					return t
				})(),
				yTe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})()
			const wTe = new He("MAT_INPUT_VALUE_ACCESSOR"),
				xTe = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]
			let CTe = 0
			const ETe = KG(
				class {
					constructor(t, n, e, i) {
						;(this._defaultErrorStateMatcher = t),
							(this._parentForm = n),
							(this._parentFormGroup = e),
							(this.ngControl = i),
							(this.stateChanges = new vt())
					}
				}
			)
			let kp = (() => {
					class t extends ETe {
						get disabled() {
							return this._disabled
						}
						set disabled(e) {
							;(this._disabled = Mn(e)), this.focused && ((this.focused = !1), this.stateChanges.next())
						}
						get id() {
							return this._id
						}
						set id(e) {
							this._id = e || this._uid
						}
						get required() {
							return this._required ?? this.ngControl?.control?.hasValidator(nI.required) ?? !1
						}
						set required(e) {
							this._required = Mn(e)
						}
						get type() {
							return this._type
						}
						set type(e) {
							;(this._type = e || "text"),
								this._validateType(),
								!this._isTextarea && mG().has(this._type) && (this._elementRef.nativeElement.type = this._type)
						}
						get value() {
							return this._inputValueAccessor.value
						}
						set value(e) {
							e !== this.value && ((this._inputValueAccessor.value = e), this.stateChanges.next())
						}
						get readonly() {
							return this._readonly
						}
						set readonly(e) {
							this._readonly = Mn(e)
						}
						constructor(e, i, r, o, s, a, c, l, d, u) {
							super(a, o, s, r),
								(this._elementRef = e),
								(this._platform = i),
								(this._autofillMonitor = l),
								(this._formField = u),
								(this._uid = "mat-input-" + CTe++),
								(this.focused = !1),
								(this.stateChanges = new vt()),
								(this.controlType = "mat-input"),
								(this.autofilled = !1),
								(this._disabled = !1),
								(this._type = "text"),
								(this._readonly = !1),
								(this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(_ =>
									mG().has(_)
								)),
								(this._iOSKeyupListener = _ => {
									const y = _.target
									!y.value &&
										0 === y.selectionStart &&
										0 === y.selectionEnd &&
										(y.setSelectionRange(1, 1), y.setSelectionRange(0, 0))
								})
							const h = this._elementRef.nativeElement,
								f = h.nodeName.toLowerCase()
							;(this._inputValueAccessor = c || h),
								(this._previousNativeValue = this.value),
								(this.id = this.id),
								i.IOS &&
									d.runOutsideAngular(() => {
										e.nativeElement.addEventListener("keyup", this._iOSKeyupListener)
									}),
								(this._isServer = !this._platform.isBrowser),
								(this._isNativeSelect = "select" === f),
								(this._isTextarea = "textarea" === f),
								(this._isInFormField = !!u),
								this._isNativeSelect && (this.controlType = h.multiple ? "mat-native-select-multiple" : "mat-native-select")
						}
						ngAfterViewInit() {
							this._platform.isBrowser &&
								this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(e => {
									;(this.autofilled = e.isAutofilled), this.stateChanges.next()
								})
						}
						ngOnChanges() {
							this.stateChanges.next()
						}
						ngOnDestroy() {
							this.stateChanges.complete(),
								this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement),
								this._platform.IOS && this._elementRef.nativeElement.removeEventListener("keyup", this._iOSKeyupListener)
						}
						ngDoCheck() {
							this.ngControl &&
								(this.updateErrorState(),
								null !== this.ngControl.disabled &&
									this.ngControl.disabled !== this.disabled &&
									((this.disabled = this.ngControl.disabled), this.stateChanges.next())),
								this._dirtyCheckNativeValue(),
								this._dirtyCheckPlaceholder()
						}
						focus(e) {
							this._elementRef.nativeElement.focus(e)
						}
						_focusChanged(e) {
							e !== this.focused && ((this.focused = e), this.stateChanges.next())
						}
						_onInput() {}
						_dirtyCheckNativeValue() {
							const e = this._elementRef.nativeElement.value
							this._previousNativeValue !== e && ((this._previousNativeValue = e), this.stateChanges.next())
						}
						_dirtyCheckPlaceholder() {
							const e = this._getPlaceholder()
							if (e !== this._previousPlaceholder) {
								const i = this._elementRef.nativeElement
								;(this._previousPlaceholder = e), e ? i.setAttribute("placeholder", e) : i.removeAttribute("placeholder")
							}
						}
						_getPlaceholder() {
							return this.placeholder || null
						}
						_validateType() {
							xTe.indexOf(this._type)
						}
						_isNeverEmpty() {
							return this._neverEmptyInputTypes.indexOf(this._type) > -1
						}
						_isBadInput() {
							let e = this._elementRef.nativeElement.validity
							return e && e.badInput
						}
						get empty() {
							return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled)
						}
						get shouldLabelFloat() {
							if (this._isNativeSelect) {
								const e = this._elementRef.nativeElement,
									i = e.options[0]
								return this.focused || e.multiple || !this.empty || !!(e.selectedIndex > -1 && i && i.label)
							}
							return this.focused || !this.empty
						}
						setDescribedByIds(e) {
							e.length
								? this._elementRef.nativeElement.setAttribute("aria-describedby", e.join(" "))
								: this._elementRef.nativeElement.removeAttribute("aria-describedby")
						}
						onContainerClick() {
							this.focused || this.focus()
						}
						_isInlineSelect() {
							const e = this._elementRef.nativeElement
							return this._isNativeSelect && (e.multiple || e.size > 1)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(Wr), P(rd, 10), P(R0, 8), P(O0, 8), P(XG), P(wTe, 10), P(vTe), P(mn), P(EO, 8))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [
									["input", "matInput", ""],
									["textarea", "matInput", ""],
									["select", "matNativeControl", ""],
									["input", "matNativeControl", ""],
									["textarea", "matNativeControl", ""]
								],
								hostAttrs: [1, "mat-mdc-input-element"],
								hostVars: 18,
								hostBindings: function (i, r) {
									1 & i &&
										Le("focus", function () {
											return r._focusChanged(!0)
										})("blur", function () {
											return r._focusChanged(!1)
										})("input", function () {
											return r._onInput()
										}),
										2 & i &&
											(td("id", r.id)("disabled", r.disabled)("required", r.required),
											qn("name", r.name || null)("readonly", (r.readonly && !r._isNativeSelect) || null)(
												"aria-invalid",
												r.empty && r.required ? null : r.errorState
											)("aria-required", r.required)("id", r.id),
											Zt("mat-input-server", r._isServer)(
												"mat-mdc-form-field-textarea-control",
												r._isInFormField && r._isTextarea
											)("mat-mdc-form-field-input-control", r._isInFormField)(
												"mdc-text-field__input",
												r._isInFormField
											)("mat-mdc-native-select-inline", r._isInlineSelect()))
								},
								inputs: {
									disabled: "disabled",
									id: "id",
									placeholder: "placeholder",
									name: "name",
									required: "required",
									type: "type",
									errorStateMatcher: "errorStateMatcher",
									userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"],
									value: "value",
									readonly: "readonly"
								},
								exportAs: ["matInput"],
								features: [Xn([{ provide: CO, useExisting: t }]), pn, Ar]
							})
						}
					}
					return t
				})(),
				MO = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, ww, ww, yTe, Yi] })
						}
					}
					return t
				})()
			const MTe = ["switch"]
			function STe(t, n) {
				1 & t && (F(0, "div", 12), Xa(), F(1, "svg", 13), fe(2, "path", 14), L(), F(3, "svg", 15), fe(4, "path", 16), L()())
			}
			const kTe = ["*"],
				TTe = new He("mat-slide-toggle-default-options", {
					providedIn: "root",
					factory: () => ({ disableToggleValue: !1, hideIcon: !1 })
				}),
				FTe = { provide: ds, useExisting: Kn(() => sk), multi: !0 }
			class aY {
				constructor(n, e) {
					;(this.source = n), (this.checked = e)
				}
			}
			let BTe = 0
			const ITe = GE(
				_g(
					Um(
						Sv(
							class {
								constructor(t) {
									this._elementRef = t
								}
							}
						)
					)
				)
			)
			let DTe = (() => {
					class t extends ITe {
						get required() {
							return this._required
						}
						set required(e) {
							this._required = Mn(e)
						}
						get checked() {
							return this._checked
						}
						set checked(e) {
							;(this._checked = Mn(e)), this._changeDetectorRef.markForCheck()
						}
						get hideIcon() {
							return this._hideIcon
						}
						set hideIcon(e) {
							this._hideIcon = Mn(e)
						}
						get inputId() {
							return `${this.id || this._uniqueId}-input`
						}
						constructor(e, i, r, o, s, a, c) {
							super(e),
								(this._focusMonitor = i),
								(this._changeDetectorRef = r),
								(this.defaults = s),
								(this._onChange = l => {}),
								(this._onTouched = () => {}),
								(this._required = !1),
								(this._checked = !1),
								(this.name = null),
								(this.labelPosition = "after"),
								(this.ariaLabel = null),
								(this.ariaLabelledby = null),
								(this._hideIcon = !1),
								(this.change = new _n()),
								(this.toggleChange = new _n()),
								(this.tabIndex = parseInt(o) || 0),
								(this.color = this.defaultColor = s.color || "accent"),
								(this._noopAnimations = "NoopAnimations" === a),
								(this.id = this._uniqueId = `${c}${++BTe}`),
								(this._hideIcon = s.hideIcon ?? !1)
						}
						ngAfterContentInit() {
							this._focusMonitor.monitor(this._elementRef, !0).subscribe(e => {
								"keyboard" === e || "program" === e
									? ((this._focused = !0), this._changeDetectorRef.markForCheck())
									: e ||
									  Promise.resolve().then(() => {
											;(this._focused = !1), this._onTouched(), this._changeDetectorRef.markForCheck()
									  })
							})
						}
						ngOnDestroy() {
							this._focusMonitor.stopMonitoring(this._elementRef)
						}
						writeValue(e) {
							this.checked = !!e
						}
						registerOnChange(e) {
							this._onChange = e
						}
						registerOnTouched(e) {
							this._onTouched = e
						}
						setDisabledState(e) {
							;(this.disabled = e), this._changeDetectorRef.markForCheck()
						}
						toggle() {
							;(this.checked = !this.checked), this._onChange(this.checked)
						}
						_emitChangeEvent() {
							this._onChange(this.checked), this.change.emit(this._createChangeEvent(this.checked))
						}
						static {
							this.ɵfac = function (i) {
								Am()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								inputs: {
									name: "name",
									id: "id",
									labelPosition: "labelPosition",
									ariaLabel: ["aria-label", "ariaLabel"],
									ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
									ariaDescribedby: ["aria-describedby", "ariaDescribedby"],
									required: "required",
									checked: "checked",
									hideIcon: "hideIcon"
								},
								outputs: { change: "change", toggleChange: "toggleChange" },
								features: [pn]
							})
						}
					}
					return t
				})(),
				sk = (() => {
					class t extends DTe {
						get buttonId() {
							return `${this.id || this._uniqueId}-button`
						}
						constructor(e, i, r, o, s, a) {
							super(e, i, r, o, s, a, "mat-mdc-slide-toggle-"), (this._labelId = this._uniqueId + "-label")
						}
						_handleClick() {
							this.toggleChange.emit(),
								this.defaults.disableToggleValue ||
									((this.checked = !this.checked),
									this._onChange(this.checked),
									this.change.emit(new aY(this, this.checked)))
						}
						focus() {
							this._switchElement.nativeElement.focus()
						}
						_createChangeEvent(e) {
							return new aY(this, e)
						}
						_getAriaLabelledBy() {
							return this.ariaLabelledby ? this.ariaLabelledby : this.ariaLabel ? null : this._labelId
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(fd), P(Jr), Ma("tabindex"), P(TTe), P(Bo, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-slide-toggle"]],
								viewQuery: function (i, r) {
									if ((1 & i && _i(MTe, 5), 2 & i)) {
										let o
										sn((o = an())) && (r._switchElement = o.first)
									}
								},
								hostAttrs: [1, "mat-mdc-slide-toggle"],
								hostVars: 11,
								hostBindings: function (i, r) {
									2 & i &&
										(td("id", r.id),
										qn("tabindex", null)("aria-label", null)("name", null)("aria-labelledby", null),
										Zt("mat-mdc-slide-toggle-focused", r._focused)("mat-mdc-slide-toggle-checked", r.checked)(
											"_mat-animation-noopable",
											r._noopAnimations
										))
								},
								inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex" },
								exportAs: ["matSlideToggle"],
								features: [Xn([FTe]), pn],
								ngContentSelectors: kTe,
								decls: 13,
								vars: 25,
								consts: [
									[1, "mdc-form-field"],
									["role", "switch", "type", "button", 1, "mdc-switch", 3, "tabIndex", "disabled", "click"],
									["switch", ""],
									[1, "mdc-switch__track"],
									[1, "mdc-switch__handle-track"],
									[1, "mdc-switch__handle"],
									[1, "mdc-switch__shadow"],
									[1, "mdc-elevation-overlay"],
									[1, "mdc-switch__ripple"],
									[
										"mat-ripple",
										"",
										1,
										"mat-mdc-slide-toggle-ripple",
										"mat-mdc-focus-indicator",
										3,
										"matRippleTrigger",
										"matRippleDisabled",
										"matRippleCentered"
									],
									["class", "mdc-switch__icons", 4, "ngIf"],
									[1, "mdc-label", 3, "for", "click"],
									[1, "mdc-switch__icons"],
									["viewBox", "0 0 24 24", "aria-hidden", "true", 1, "mdc-switch__icon", "mdc-switch__icon--on"],
									["d", "M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z"],
									["viewBox", "0 0 24 24", "aria-hidden", "true", 1, "mdc-switch__icon", "mdc-switch__icon--off"],
									["d", "M20 13H4v-2h16v2z"]
								],
								template: function (i, r) {
									if (
										(1 & i &&
											(co(),
											F(0, "div", 0)(1, "button", 1, 2),
											Le("click", function () {
												return r._handleClick()
											}),
											fe(3, "div", 3),
											F(4, "div", 4)(5, "div", 5)(6, "div", 6),
											fe(7, "div", 7),
											L(),
											F(8, "div", 8),
											fe(9, "div", 9),
											L(),
											Ee(10, STe, 5, 0, "div", 10),
											L()()(),
											F(11, "label", 11),
											Le("click", function (s) {
												return s.stopPropagation()
											}),
											Ln(12),
											L()()),
										2 & i)
									) {
										const o = br(2)
										Zt("mdc-form-field--align-end", "before" == r.labelPosition),
											T(1),
											Zt("mdc-switch--selected", r.checked)("mdc-switch--unselected", !r.checked)(
												"mdc-switch--checked",
												r.checked
											)("mdc-switch--disabled", r.disabled),
											U("tabIndex", r.tabIndex)("disabled", r.disabled),
											qn("id", r.buttonId)("name", r.name)("aria-label", r.ariaLabel)(
												"aria-labelledby",
												r._getAriaLabelledBy()
											)("aria-describedby", r.ariaDescribedby)("aria-required", r.required || null)(
												"aria-checked",
												r.checked
											),
											T(8),
											U("matRippleTrigger", o)("matRippleDisabled", r.disableRipple || r.disabled)(
												"matRippleCentered",
												!0
											),
											T(1),
											U("ngIf", !r.hideIcon),
											T(1),
											U("for", r.buttonId),
											qn("id", r._labelId)
									}
								},
								dependencies: [Cu, En],
								styles: [
									'.mdc-form-field{display:inline-flex;align-items:center;vertical-align:middle}.mdc-form-field[hidden]{display:none}.mdc-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{margin-left:auto;margin-right:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{padding-left:0;padding-right:4px}.mdc-form-field--nowrap>label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{padding-left:4px;padding-right:0}.mdc-form-field--space-between{justify-content:space-between}.mdc-form-field--space-between>label{margin:0}[dir=rtl] .mdc-form-field--space-between>label,.mdc-form-field--space-between>label[dir=rtl]{margin:0}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--mdc-elevation-overlay-color)}.mdc-switch{align-items:center;background:none;border:none;cursor:pointer;display:inline-flex;flex-shrink:0;margin:0;outline:none;overflow:visible;padding:0;position:relative}.mdc-switch[hidden]{display:none}.mdc-switch:disabled{cursor:default;pointer-events:none}.mdc-switch__track{overflow:hidden;position:relative;width:100%}.mdc-switch__track::before,.mdc-switch__track::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;position:absolute;width:100%}@media screen and (forced-colors: active){.mdc-switch__track::before,.mdc-switch__track::after{border-color:currentColor}}.mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0)}.mdc-switch__track::after{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(-100%)}[dir=rtl] .mdc-switch__track::after,.mdc-switch__track[dir=rtl]::after{transform:translateX(100%)}.mdc-switch--selected .mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__track::before,.mdc-switch--selected .mdc-switch__track[dir=rtl]::before{transform:translateX(-100%)}.mdc-switch--selected .mdc-switch__track::after{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0)}.mdc-switch__handle-track{height:100%;pointer-events:none;position:absolute;top:0;transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);left:0;right:auto;transform:translateX(0)}[dir=rtl] .mdc-switch__handle-track,.mdc-switch__handle-track[dir=rtl]{left:auto;right:0}.mdc-switch--selected .mdc-switch__handle-track{transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__handle-track,.mdc-switch--selected .mdc-switch__handle-track[dir=rtl]{transform:translateX(-100%)}.mdc-switch__handle{display:flex;pointer-events:auto;position:absolute;top:50%;transform:translateY(-50%);left:0;right:auto}[dir=rtl] .mdc-switch__handle,.mdc-switch__handle[dir=rtl]{left:auto;right:0}.mdc-switch__handle::before,.mdc-switch__handle::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";width:100%;height:100%;left:0;position:absolute;top:0;transition:background-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1),border-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);z-index:-1}@media screen and (forced-colors: active){.mdc-switch__handle::before,.mdc-switch__handle::after{border-color:currentColor}}.mdc-switch__shadow{border-radius:inherit;bottom:0;left:0;position:absolute;right:0;top:0}.mdc-elevation-overlay{bottom:0;left:0;right:0;top:0}.mdc-switch__ripple{left:50%;position:absolute;top:50%;transform:translate(-50%, -50%);z-index:-1}.mdc-switch:disabled .mdc-switch__ripple{display:none}.mdc-switch__icons{height:100%;position:relative;width:100%;z-index:1}.mdc-switch__icon{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0;opacity:0;transition:opacity 30ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-switch--selected .mdc-switch__icon--on,.mdc-switch--unselected .mdc-switch__icon--off{opacity:1;transition:opacity 45ms 30ms cubic-bezier(0, 0, 0.2, 1)}.mdc-switch{width:var(--mdc-switch-track-width);--mdc-switch-disabled-handle-opacity:0.38;--mdc-switch-disabled-selected-icon-opacity:0.38;--mdc-switch-disabled-track-opacity:0.12;--mdc-switch-disabled-unselected-icon-opacity:0.38;--mdc-switch-handle-height:20px;--mdc-switch-handle-shape:10px;--mdc-switch-handle-width:20px;--mdc-switch-selected-icon-size:18px;--mdc-switch-track-height:14px;--mdc-switch-track-shape:7px;--mdc-switch-track-width:36px;--mdc-switch-unselected-icon-size:18px;--mdc-switch-state-layer-size:40px;--mdc-switch-selected-focus-state-layer-opacity:0.12;--mdc-switch-selected-hover-state-layer-opacity:0.04;--mdc-switch-selected-pressed-state-layer-opacity:0.1;--mdc-switch-unselected-focus-state-layer-opacity:0.12;--mdc-switch-unselected-hover-state-layer-opacity:0.04;--mdc-switch-unselected-pressed-state-layer-opacity:0.1}.mdc-switch.mdc-switch--selected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-selected-handle-color)}.mdc-switch.mdc-switch--selected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-hover-handle-color)}.mdc-switch.mdc-switch--selected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-focus-handle-color)}.mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-selected-pressed-handle-color)}.mdc-switch.mdc-switch--selected:disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-selected-handle-color)}.mdc-switch.mdc-switch--unselected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-unselected-handle-color)}.mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-hover-handle-color)}.mdc-switch.mdc-switch--unselected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-focus-handle-color)}.mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-unselected-pressed-handle-color)}.mdc-switch.mdc-switch--unselected:disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-unselected-handle-color)}.mdc-switch .mdc-switch__handle::before{background:var(--mdc-switch-handle-surface-color)}.mdc-switch:enabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-handle-elevation)}.mdc-switch:disabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-disabled-handle-elevation)}.mdc-switch .mdc-switch__focus-ring-wrapper,.mdc-switch .mdc-switch__handle{height:var(--mdc-switch-handle-height)}.mdc-switch:disabled .mdc-switch__handle::after{opacity:var(--mdc-switch-disabled-handle-opacity)}.mdc-switch .mdc-switch__handle{border-radius:var(--mdc-switch-handle-shape)}.mdc-switch .mdc-switch__handle{width:var(--mdc-switch-handle-width)}.mdc-switch .mdc-switch__handle-track{width:calc(100% - var(--mdc-switch-handle-width))}.mdc-switch.mdc-switch--selected:enabled .mdc-switch__icon{fill:var(--mdc-switch-selected-icon-color)}.mdc-switch.mdc-switch--selected:disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-selected-icon-color)}.mdc-switch.mdc-switch--unselected:enabled .mdc-switch__icon{fill:var(--mdc-switch-unselected-icon-color)}.mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-unselected-icon-color)}.mdc-switch.mdc-switch--selected:disabled .mdc-switch__icons{opacity:var(--mdc-switch-disabled-selected-icon-opacity)}.mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icons{opacity:var(--mdc-switch-disabled-unselected-icon-opacity)}.mdc-switch.mdc-switch--selected .mdc-switch__icon{width:var(--mdc-switch-selected-icon-size);height:var(--mdc-switch-selected-icon-size)}.mdc-switch.mdc-switch--unselected .mdc-switch__icon{width:var(--mdc-switch-unselected-icon-size);height:var(--mdc-switch-unselected-icon-size)}.mdc-switch.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::before,.mdc-switch.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-hover-state-layer-color)}.mdc-switch.mdc-switch--selected:enabled:focus .mdc-switch__ripple::before,.mdc-switch.mdc-switch--selected:enabled:focus .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-focus-state-layer-color)}.mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__ripple::before,.mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-pressed-state-layer-color)}.mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::before,.mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-hover-state-layer-color)}.mdc-switch.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::before,.mdc-switch.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-focus-state-layer-color)}.mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__ripple::before,.mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-pressed-state-layer-color)}.mdc-switch.mdc-switch--selected:enabled:hover:not(:focus):hover .mdc-switch__ripple::before,.mdc-switch.mdc-switch--selected:enabled:hover:not(:focus).mdc-ripple-surface--hover .mdc-switch__ripple::before{opacity:var(--mdc-switch-selected-hover-state-layer-opacity)}.mdc-switch.mdc-switch--selected:enabled:focus.mdc-ripple-upgraded--background-focused .mdc-switch__ripple::before,.mdc-switch.mdc-switch--selected:enabled:focus:not(.mdc-ripple-upgraded):focus .mdc-switch__ripple::before{transition-duration:75ms;opacity:var(--mdc-switch-selected-focus-state-layer-opacity)}.mdc-switch.mdc-switch--selected:enabled:active:not(.mdc-ripple-upgraded) .mdc-switch__ripple::after{transition:opacity 150ms linear}.mdc-switch.mdc-switch--selected:enabled:active:not(.mdc-ripple-upgraded):active .mdc-switch__ripple::after{transition-duration:75ms;opacity:var(--mdc-switch-selected-pressed-state-layer-opacity)}.mdc-switch.mdc-switch--selected:enabled:active.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-switch-selected-pressed-state-layer-opacity)}.mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus):hover .mdc-switch__ripple::before,.mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus).mdc-ripple-surface--hover .mdc-switch__ripple::before{opacity:var(--mdc-switch-unselected-hover-state-layer-opacity)}.mdc-switch.mdc-switch--unselected:enabled:focus.mdc-ripple-upgraded--background-focused .mdc-switch__ripple::before,.mdc-switch.mdc-switch--unselected:enabled:focus:not(.mdc-ripple-upgraded):focus .mdc-switch__ripple::before{transition-duration:75ms;opacity:var(--mdc-switch-unselected-focus-state-layer-opacity)}.mdc-switch.mdc-switch--unselected:enabled:active:not(.mdc-ripple-upgraded) .mdc-switch__ripple::after{transition:opacity 150ms linear}.mdc-switch.mdc-switch--unselected:enabled:active:not(.mdc-ripple-upgraded):active .mdc-switch__ripple::after{transition-duration:75ms;opacity:var(--mdc-switch-unselected-pressed-state-layer-opacity)}.mdc-switch.mdc-switch--unselected:enabled:active.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-switch-unselected-pressed-state-layer-opacity)}.mdc-switch .mdc-switch__ripple{height:var(--mdc-switch-state-layer-size);width:var(--mdc-switch-state-layer-size)}.mdc-switch .mdc-switch__track{height:var(--mdc-switch-track-height)}.mdc-switch:disabled .mdc-switch__track{opacity:var(--mdc-switch-disabled-track-opacity)}.mdc-switch:enabled .mdc-switch__track::after{background:var(--mdc-switch-selected-track-color)}.mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-hover-track-color)}.mdc-switch:enabled:focus:not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-focus-track-color)}.mdc-switch:enabled:active .mdc-switch__track::after{background:var(--mdc-switch-selected-pressed-track-color)}.mdc-switch:disabled .mdc-switch__track::after{background:var(--mdc-switch-disabled-selected-track-color)}.mdc-switch:enabled .mdc-switch__track::before{background:var(--mdc-switch-unselected-track-color)}.mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-hover-track-color)}.mdc-switch:enabled:focus:not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-focus-track-color)}.mdc-switch:enabled:active .mdc-switch__track::before{background:var(--mdc-switch-unselected-pressed-track-color)}.mdc-switch:disabled .mdc-switch__track::before{background:var(--mdc-switch-disabled-unselected-track-color)}.mdc-switch .mdc-switch__track{border-radius:var(--mdc-switch-track-shape)}.mdc-switch:enabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-handle-elevation-shadow)}.mdc-switch:disabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-disabled-handle-elevation-shadow)}.mat-mdc-slide-toggle .mdc-label{font-family:var(--mat-slide-toggle-label-text-font);font-size:var(--mat-slide-toggle-label-text-size);letter-spacing:var(--mat-slide-toggle-label-text-tracking);line-height:var(--mat-slide-toggle-label-text-line-height);font-weight:var(--mat-slide-toggle-label-text-weight)}.mat-mdc-slide-toggle{display:inline-block;-webkit-tap-highlight-color:rgba(0,0,0,0);outline:0}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple,.mat-mdc-slide-toggle .mdc-switch__ripple::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple:not(:empty),.mat-mdc-slide-toggle .mdc-switch__ripple::after:not(:empty){transform:translateZ(0)}.mat-mdc-slide-toggle .mdc-switch__ripple::after{content:"";opacity:0}.mat-mdc-slide-toggle .mdc-switch:hover .mdc-switch__ripple::after{opacity:.04;transition:opacity 75ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mdc-switch .mdc-switch__ripple::after{opacity:.12}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mat-mdc-focus-indicator::before{content:""}.mat-mdc-slide-toggle .mat-ripple-element{opacity:.12}.mat-mdc-slide-toggle .mat-mdc-focus-indicator::before{border-radius:50%}.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle-track,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-elevation-overlay,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__icon,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::after,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::after{transition:none}.mat-mdc-slide-toggle .mdc-switch:enabled+.mdc-label{cursor:pointer}'
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				cY = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				lY = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [cY, Yi, Vh, Ot, cY, Yi] })
						}
					}
					return t
				})()
			function PTe(t, n) {
				if ((1 & t && (F(0, "mat-error"), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1), cr(e.scenarioName.getError("Error"))
				}
			}
			function OTe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-slide-toggle", 9),
						Le("change", function () {
							const o = rn(e).$implicit
							return on(Te().handleScenarioMetricPropertySelectionChange(o))
						}),
						ge(1),
						L()
				}
				if (2 & t) {
					const e = n.$implicit
					U("checked", e.isSelected), T(1), Vt(" ", e.metricName ? e.metricType + " (" + e.metricName + ")" : e.metricType, " ")
				}
			}
			function NTe(t, n) {
				1 & t && (F(0, "mat-error"), ge(1, "You cannot create an empty Scenario"), L())
			}
			let UTe = (() => {
					class t {
						constructor(e, i, r) {
							;(this.state = e),
								(this.scenarioName = new y8("", [
									t =>
										0 === t.value.length
											? { Error: "Scenario name is required" }
											: Wu.isScenarioExisting(t.value)
											? { Error: "A Scenario with this name already exists" }
											: null
								])),
								(this.scenarioNameErrorField = "Scenario name is required"),
								(this.areAnyScenarioMetricPropertiesSelected = !0),
								(this.scenarioContent = ((t, n) => {
									const { dynamicSettings: e, appSettings: i, fileSettings: r } = t,
										o = [
											{
												metricType: "Camera-Position",
												metricName: "",
												savedValues: { ...n },
												isSelected: !0,
												isDisabled: !1
											},
											{
												metricType: "Area-Metric",
												metricName: e.areaMetric,
												savedValues: e.margin,
												isSelected: !0,
												isDisabled: !1
											},
											{
												metricType: "Height-Metric",
												metricName: e.heightMetric,
												savedValues: { heightSlider: i.scaling, labelSlider: i.amountOfTopLabels },
												isSelected: !0,
												isDisabled: !1
											},
											{
												metricType: "Color-Metric",
												metricName: e.colorMetric,
												savedValues: { colorRange: e.colorRange, mapColors: i.mapColors },
												isSelected: !0,
												isDisabled: !1
											}
										]
									return (
										r.edges.length > 0 &&
											o.push({
												metricType: "Edge-Metric",
												metricName: e.edgeMetric,
												savedValues: { edgePreview: i.amountOfEdgePreviews, edgeHeight: i.edgeHeight },
												isSelected: !0,
												isDisabled: !1
											}),
										o
									)
								})(this.state.getValue(), { camera: i.camera.position, cameraTarget: r.controls.target }))
						}
						handleScenarioMetricPropertySelectionChange(e) {
							;(e.isSelected = !e.isSelected),
								(this.areAnyScenarioMetricPropertiesSelected = this.scenarioContent.some(i => i.isSelected))
						}
						addCustomScenario() {
							Wu.addScenario(this.scenarioName.value, this.scenarioContent)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Sr), P(Td), P(El))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["ng-component"]],
								decls: 16,
								vars: 5,
								consts: [
									["color", "primary"],
									[1, "cc-add-custom-scenario-content"],
									[1, "cc-add-custom-scenario-name-field"],
									["matInput", "", 3, "formControl"],
									[4, "ngIf"],
									[1, "cc-add-custon-scenario-toggles"],
									[3, "checked", "change", 4, "ngFor", "ngForOf"],
									[1, "cc-add-custom-scenario-buttons"],
									["mat-button", "", "mat-dialog-close", "", 3, "disabled", "click"],
									[3, "checked", "change"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "mat-toolbar", 0),
										ge(1, "Add Scenario"),
										L(),
										F(2, "div", 1)(3, "mat-form-field", 2)(4, "label"),
										ge(5, "Scenario Name"),
										L(),
										fe(6, "input", 3),
										Ee(7, PTe, 2, 1, "mat-error", 4),
										L(),
										F(8, "p"),
										ge(9, "The scenario includes:"),
										L(),
										F(10, "div", 5),
										Ee(11, OTe, 2, 2, "mat-slide-toggle", 6),
										Ee(12, NTe, 2, 0, "mat-error", 4),
										L(),
										F(13, "div", 7)(14, "button", 8),
										Le("click", function () {
											return r.addCustomScenario()
										}),
										ge(15, " ADD "),
										L()()()),
										2 & i &&
											(T(6),
											U("formControl", r.scenarioName),
											T(1),
											U("ngIf", r.scenarioName.invalid),
											T(4),
											U("ngForOf", r.scenarioContent),
											T(1),
											U("ngIf", !r.areAnyScenarioMetricPropertiesSelected),
											T(2),
											U("disabled", r.scenarioName.invalid || !r.areAnyScenarioMetricPropertiesSelected))
								},
								dependencies: [_o, En, km, T0, UC, Bd, jX, Qs, md, Mb, kp, sk],
								styles: [
									".cc-add-custom-scenario .mat-mdc-dialog-container{width:50vw;padding:0}.cc-add-custom-scenario .mat-mdc-dialog-container .cc-add-custom-scenario-content .cc-add-custon-scenario-toggles{display:flex;flex-direction:column;gap:8px}.cc-add-custom-scenario .mat-mdc-dialog-container .cc-add-custom-scenario-content .cc-add-custon-scenario-toggles mat-slide-toggle{display:block}.cc-add-custom-scenario .mat-mdc-dialog-container .cc-add-custom-scenario-content .cc-add-custom-scenario-name-field{width:75%}.cc-add-custom-scenario .mat-mdc-dialog-container .cc-add-custom-scenario-content .cc-add-custom-scenario-buttons{display:flex;justify-content:flex-end}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				SO = (() => {
					class t {
						constructor() {
							;(this._vertical = !1), (this._inset = !1)
						}
						get vertical() {
							return this._vertical
						}
						set vertical(e) {
							this._vertical = Mn(e)
						}
						get inset() {
							return this._inset
						}
						set inset(e) {
							this._inset = Mn(e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-divider"]],
								hostAttrs: ["role", "separator", 1, "mat-divider"],
								hostVars: 7,
								hostBindings: function (i, r) {
									2 & i &&
										(qn("aria-orientation", r.vertical ? "vertical" : "horizontal"),
										Zt("mat-divider-vertical", r.vertical)("mat-divider-horizontal", !r.vertical)(
											"mat-divider-inset",
											r.inset
										))
								},
								inputs: { vertical: "vertical", inset: "inset" },
								decls: 0,
								vars: 0,
								template: function (i, r) {},
								styles: [
									".mat-divider{--mat-divider-width:1px;display:block;margin:0;border-top-style:solid;border-top-color:var(--mat-divider-color);border-top-width:var(--mat-divider-width)}.mat-divider.mat-divider-vertical{border-top:0;border-right-style:solid;border-right-color:var(--mat-divider-color);border-right-width:var(--mat-divider-width)}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}"
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				kO = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Yi] })
						}
					}
					return t
				})()
			function HTe(t, n) {
				if ((1 & t && (F(0, "span", 9), fe(1, "i"), L()), 2 & t)) {
					const e = n.$implicit
					U("title", e.tooltip), T(1), du("fa ", e.faIconClass, ""), Zt("cc-is-saved", e.isSaved)
				}
			}
			function VTe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div", 0)(1, "button", 5),
						Le("click", function () {
							const o = rn(e).$implicit
							return on(Te().scenarioService.applyScenario(o.scenarioName))
						}),
						ge(2),
						L(),
						Ee(3, HTe, 2, 6, "span", 6),
						F(4, "button", 7),
						Le("click", function () {
							const o = rn(e).$implicit
							return on(Te().scenarioService.removeScenario(o.scenarioName))
						}),
						fe(5, "i", 8),
						L()()
				}
				if (2 & t) {
					const e = n.$implicit
					T(1), U("disabled", !e.isScenarioApplicable), T(1), Vt(" ", e.scenarioName, " "), T(1), U("ngForOf", e.icons)
				}
			}
			let QTe = (() => {
					class t {
						constructor(e, i) {
							;(this.scenarioService = e), (this.dialog = i), (this.scenarios = [])
						}
						addScenario() {
							this.dialog.open(UTe, { panelClass: "cc-add-custom-scenario" })
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wO), P(la))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-scenarios"]],
								inputs: { scenarios: "scenarios" },
								decls: 7,
								vars: 1,
								consts: [
									[1, "cc-row"],
									["disabled", "", 1, "cc-apply-scenario-button"],
									["title", "Create a custom scenario", 1, "cc-action-button", "cc-add", 3, "click"],
									[1, "fa", "fa-plus"],
									["class", "cc-row", 4, "ngFor", "ngForOf"],
									["title", "Apply scenario", 1, "cc-apply-scenario-button", 3, "disabled", "click"],
									["class", "cc-scenario-content-icons", 3, "title", 4, "ngFor", "ngForOf"],
									["title", "Remove custom scenario", 1, "cc-action-button", "cc-remove", 3, "click"],
									[1, "fa", "fa-minus-square"],
									[1, "cc-scenario-content-icons", 3, "title"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div", 0)(1, "button", 1),
										ge(2, "Metric Scenarios"),
										L(),
										F(3, "button", 2),
										Le("click", function () {
											return r.addScenario()
										}),
										fe(4, "i", 3),
										L()(),
										fe(5, "mat-divider"),
										Ee(6, VTe, 6, 3, "div", 4)),
										2 & i && (T(6), U("ngForOf", r.scenarios))
								},
								dependencies: [_o, SO],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}.mat-mdc-menu-panel.cc-scenarios-menu{width:420px;max-width:unset}.mat-mdc-menu-panel.cc-scenarios-menu .mat-mdc-menu-content{padding:0}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row{display:flex;height:48px;align-items:center}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row [disabled]{color:#00000061}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row .cc-apply-scenario-button{padding-left:16px;padding-right:16px;height:100%;flex:1;text-align:left;background-color:unset}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row .cc-apply-scenario-button:hover:not([disabled]){background-color:#9e9e9e33}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row .cc-action-button{width:52px;height:100%;display:inline-flex;justify-content:center;align-items:center}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row .cc-action-button.cc-add{background-color:#1b9cfc}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row .cc-action-button.cc-remove{border-left:1px solid rgba(0,0,0,.12);color:#b30000;background-color:unset}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row .cc-action-button.cc-remove:hover:not([disabled]){background-color:#9e9e9e33}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row i.fa{font-size:x-small}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row .cc-scenario-content-icons{padding:0 8px;color:#d3d3d3}.mat-mdc-menu-panel.cc-scenarios-menu .cc-row .cc-scenario-content-icons i.fa.cc-is-saved{color:#000}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				zTe = (() => {
					class t {
						constructor(e) {
							;(this.scenarioService = e), (this.scenarios = [])
						}
						loadScenarios() {
							this.scenarios = this.scenarioService.getScenarios()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wO))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-show-scenarios-button"]],
								decls: 5,
								vars: 2,
								consts: [
									["title", "Open the scenario list", 1, "cc-ribbon-bar-menu-button", 3, "matMenuTriggerFor", "click"],
									[1, "fa", "fa-star"],
									[1, "cc-scenarios-menu"],
									["menu", "matMenu"],
									[3, "scenarios"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.loadScenarios()
										}),
										fe(1, "i", 1),
										L(),
										F(2, "mat-menu", 2, 3),
										fe(4, "cc-scenarios", 4),
										L()),
										2 & i && (U("matMenuTriggerFor", br(3)), T(4), U("scenarios", r.scenarios))
								},
								dependencies: [vw, yw, QTe],
								styles: ["cc-show-scenarios-button{display:flex;justify-content:center}\n"],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			class TO {
				static downloadCurrentMap(n, e, i, r, o) {
					const s = this.getProjectDataAsCCJsonFormat(n, e, i, r),
						a = o + wg.CC_FILE_EXTENSION
					this.downloadData(JSON.stringify(s), a)
				}
				static getProjectDataAsCCJsonFormat(n, e, i, r) {
					return {
						projectName: e.projectName,
						apiVersion: e.apiVersion,
						fileChecksum: e.fileChecksum,
						nodes: [this.undecorateMap(n)],
						attributeTypes: r.includes("AttributeTypes") ? this.getAttributeTypesForJSON(i.attributeTypes) : {},
						attributeDescriptors: r.includes("AttributeDescriptors")
							? this.getAttributeDescriptorsForJSON(i.attributeDescriptors)
							: {},
						edges: r.includes("Edges") ? this.undecorateEdges(i.edges) : [],
						markedPackages: r.includes("MarkedPackages") ? i.markedPackages : [],
						blacklist: this.getBlacklistToDownload(r, i.blacklist)
					}
				}
				static getBlacklistToDownload(n, e) {
					const i = []
					return (
						n.includes("Flattens") &&
							i.push(...this.getFilteredBlacklist(e, "flatten").map(r => ({ path: r.path, type: "hide" }))),
						n.includes("Excludes") && i.push(...this.getFilteredBlacklist(e, "exclude")),
						i
					)
				}
				static getAttributeTypesForJSON(n) {
					return 0 === Object.keys(n.edges).length && 0 === Object.keys(n.nodes).length ? {} : n
				}
				static getAttributeDescriptorsForJSON(n) {
					return 0 === Object.keys(n).length ? {} : n
				}
				static getFilteredBlacklist(n, e) {
					return n.filter(i => i.type === e)
				}
				static undecorateMap(n) {
					const e = dd(n)
					for (const { data: i } of $r(e))
						delete i.isExcluded,
							delete i.isFlattened,
							delete i.edgeAttributes,
							delete i.path,
							i.type === Da.FOLDER ? (i.attributes = {}) : delete i.attributes[xE]
					return e
				}
				static undecorateEdges(n) {
					const e = dd(n)
					for (const i of e) delete i.visible
					return e
				}
				static downloadData(n, e) {
					const i = new Blob([n], { type: "text/json" }),
						r = document.createEvent("MouseEvents"),
						o = document.createElement("a")
					;(o.download = e),
						(o.href = window.URL.createObjectURL(i)),
						(o.dataset.downloadurl = ["text/json", o.download, o.href].join(":")),
						r.initMouseEvent("click", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null),
						o.dispatchEvent(r)
				}
			}
			const dY = ".cc.config.json",
				uY = "CodeCharta::customConfigs"
			class ki {
				static {
					this.customConfigs = ki.loadCustomConfigsFromLocalStorage()
				}
				static {
					this.customConfigChange$ = new zr(null)
				}
				static setCustomConfigsToLocalStorage() {
					const n = { version: "1.0.1", customConfigs: [...ki.customConfigs] }
					localStorage.setItem(uY, JSON.stringify(n, YE)), ki.customConfigChange$.next(null)
				}
				static loadCustomConfigsFromLocalStorage() {
					const n = this.getCcLocalStorage()
					return new Map(n?.customConfigs)
				}
				static getCcLocalStorage() {
					return JSON.parse(localStorage.getItem(uY), M9)
				}
				static addCustomConfig(n) {
					ki.customConfigs.set(n.id, n), ki.setCustomConfigsToLocalStorage()
				}
				static editCustomConfigNote(n, e) {
					const i = ki.customConfigs.get(n)
					;(i.note = e), ki.customConfigs.set(n, i), ki.setCustomConfigsToLocalStorage()
				}
				static getCustomConfigSettings(n) {
					return ki.customConfigs.get(n)
				}
				static hasCustomConfigByName(n, e, i) {
					for (const r of ki.customConfigs.values())
						if (r.name === i && r.mapSelectionMode === n && this.areEqual(e, r.assignedMaps)) return !0
					return !1
				}
				static areEqual(n, e) {
					return n.size === e.size && [...n.entries()].every(([i, r]) => e.has(i) && e.get(i) === r)
				}
				static getCustomConfigs() {
					return ki.customConfigs
				}
				static importCustomConfigs(n) {
					const e = JSON.parse(n, M9)
					for (const i of e.customConfigs.values()) {
						if (ki.getCustomConfigSettings(i.id)) continue
						ki.hasCustomConfigByName(i.mapSelectionMode, i.assignedMaps, i.name) &&
							(i.name += ` (${pf.getFormattedTimestamp(new Date(i.creationTime))})`)
						const o = {
							id: i.id,
							name: i.name,
							creationTime: i.creationTime,
							assignedMaps: i.assignedMaps,
							customConfigVersion: i.customConfigVersion,
							mapSelectionMode: i.mapSelectionMode,
							stateSettings: i.stateSettings,
							camera: i.camera,
							...(i.note && { note: i.note })
						}
						ki.addCustomConfig(o)
					}
				}
				static downloadCustomConfigs(n) {
					const e = { downloadApiVersion: "1.0.1", timestamp: Date.now(), customConfigs: n },
						i = pf.getNewTimestamp() + dY
					TO.downloadData(JSON.stringify(e, YE), i)
				}
				static createExportCustomConfigFromConfig(n) {
					return { ...n }
				}
				static getCustomConfigsAmountByMapAndMode(n, e) {
					let i = 0
					for (const r of ki.customConfigs.values())
						[...r.assignedMaps.values()].join(" ") === n && r.mapSelectionMode === e && i++
					return i
				}
				static getConfigNameSuggestionByFileState({ mapSelectionMode: n, assignedMaps: e }) {
					const i = [...e.values()].join(" ")
					return `${i} #${ki.getCustomConfigsAmountByMapAndMode(i, n) + 1}`
				}
				static deleteCustomConfigs(n) {
					for (const e of n) ki.customConfigs.delete(e.id)
					ki.setCustomConfigsToLocalStorage()
				}
				static deleteCustomConfig(n) {
					ki.customConfigs.delete(n), ki.setCustomConfigsToLocalStorage()
				}
				static sortCustomConfigDropDownGroupList(n, e) {
					if (!e.hasApplicableItems) {
						if (n.hasApplicableItems || n.mapSelectionMode < e.mapSelectionMode) return -1
						if (n.mapSelectionMode === e.mapSelectionMode) return 0
					}
					return 1
				}
				static applyCustomConfig(n, e, i, r) {
					const o = this.getCustomConfigSettings(n)
					e.dispatch(Sp({ value: o.stateSettings })),
						o.camera &&
							setTimeout(() => {
								r.setControlTarget(o.camera.cameraTarget), i.setPosition(o.camera.camera)
							}, 100)
				}
			}
			function jTe(t, n) {
				return [...t.keys()].some(i => n.has(i))
			}
			var ak = (function (t) {
				return (t.MULTIPLE = "STANDARD"), (t.DELTA = "DELTA"), t
			})(ak || {})
			const xw = Mt(ld, t => {
				const n = new Map()
				let e
				for (const { selectedAs: i, file: r } of t)
					(e = i === Fi.Partial ? ak.MULTIPLE : ak.DELTA), n.set(r.fileMeta.fileChecksum, r.fileMeta.fileName)
				return { mapSelectionMode: e, assignedMaps: n }
			})
			let FO = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.downloadableCustomConfigs$ = xu([this.store.select(xw), ki.customConfigChange$]).pipe(
								Ke(([i]) =>
									(({ assignedMaps: t }) => {
										const n = new Map(),
											e = ki.getCustomConfigs()
										for (const [i, r] of e.entries())
											jTe(r.assignedMaps, t) && n.set(i, ki.createExportCustomConfigFromConfig(r))
										return n
									})(i)
								)
							)),
							(this.customConfigItemGroups$ = xu([this.store.select(xw), ki.customConfigChange$]).pipe(
								Ke(([i]) =>
									(function KTe({ assignedMaps: t }) {
										const n = { applicableItems: new Map(), nonApplicableItems: new Map() },
											e = new Map()
										for (const i of ki.loadCustomConfigsFromLocalStorage().values()) {
											const r = [...i.assignedMaps.values()],
												o = `${r.join("_")}_${i.mapSelectionMode}`,
												s = [...i.assignedMaps.keys()].some(x => t.has(x))
											e.has(o) ||
												e.set(o, {
													mapNames: r.join(" "),
													mapSelectionMode: i.mapSelectionMode,
													hasApplicableItems: s,
													customConfigItems: []
												})
											const {
													positive: a,
													neutral: c,
													negative: l,
													selected: d,
													positiveDelta: u,
													negativeDelta: h
												} = i.stateSettings.appSettings.mapColors,
												{
													areaMetric: f,
													heightMetric: _,
													colorMetric: y,
													edgeMetric: C
												} = i.stateSettings.dynamicSettings
											e
												.get(o)
												.customConfigItems.push({
													id: i.id,
													name: i.name,
													assignedMaps: i.assignedMaps,
													mapSelectionMode: i.mapSelectionMode,
													metrics: { areaMetric: f, heightMetric: _, colorMetric: y, edgeMetric: C },
													mapColors: {
														positive: a,
														neutral: c,
														negative: l,
														selected: d,
														positiveDelta: u,
														negativeDelta: h
													},
													isApplicable: s,
													...(i.note && { note: i.note })
												}),
												e.get(o).hasApplicableItems
													? n.applicableItems.set(o, e.get(o))
													: n.nonApplicableItems.set(o, e.get(o))
										}
										return n
									})(i)
								)
							))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Ct))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			function XTe(t, n) {
				1 & t && (F(0, "div", 10), ge(1, " It is time to add your first Custom View! "), L())
			}
			function YTe(t, n) {
				if ((1 & t && fe(0, "cc-custom-config-item-group", 15), 2 & t)) {
					const e = Te(2).$implicit,
						i = Te()
					U("customConfigItemGroups", e.nonApplicableItems)("searchTerm", i.searchTerm)
				}
			}
			function qTe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "button", 18),
						Le("click", function () {
							return rn(e), on(Te(3).toggleNonApplicableCustomConfigsList())
						}),
						ge(1),
						fe(2, "i", 19),
						L()
				}
				if (2 & t) {
					const e = Te(3)
					T(1),
						Vt(
							" ",
							e.isNonApplicableListCollapsed ? "Show non-applicable Custom Views" : "Hide non-applicable Custom Views",
							" "
						),
						T(1),
						U("ngClass", e.isNonApplicableListCollapsed ? "fa fa-angle-down" : "fa fa-angle-up")
				}
			}
			function ZTe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-accordion", 11)(1, "mat-form-field", 12),
						fe(2, "i", 13),
						F(3, "mat-label"),
						ge(4),
						L(),
						F(5, "input", 14),
						Le("input", function (r) {
							return rn(e), on(Te(2).setSearchTermDebounced(r))
						}),
						L()(),
						fe(6, "cc-custom-config-item-group", 15),
						Ee(7, YTe, 1, 2, "cc-custom-config-item-group", 16),
						Ee(8, qTe, 3, 2, "button", 17),
						L()
				}
				if (2 & t) {
					const e = Te().$implicit,
						i = Te()
					U("multi", !0),
						T(4),
						Vt("", i.searchPlaceholder, " "),
						T(1),
						U("value", i.searchTerm),
						T(1),
						U("customConfigItemGroups", e.applicableItems)("searchTerm", i.searchTerm),
						T(1),
						U("ngIf", !i.isNonApplicableListCollapsed),
						T(1),
						U("ngIf", e.nonApplicableItems.size > 0)
				}
			}
			function JTe(t, n) {
				if (
					(1 & t &&
						(F(0, "mat-dialog-content", 5)(1, "p", 6),
						ge(
							2,
							" Custom Views allow you to save and upload your individual configurations for certain maps. Find out more about Custom Views in the "
						),
						F(3, "a", 7),
						ge(4, "documentation"),
						L(),
						ge(5, ". "),
						L(),
						Ee(6, XTe, 2, 0, "div", 8),
						Ee(7, ZTe, 9, 7, "mat-accordion", 9),
						L()),
					2 & t)
				) {
					const e = n.$implicit
					T(6),
						U("ngIf", 0 === e.applicableItems.size && 0 === e.nonApplicableItems.size),
						T(1),
						U("ngIf", 0 !== e.applicableItems.size || 0 !== e.nonApplicableItems.size)
				}
			}
			let hY = (() => {
					class t {
						constructor(e) {
							;(this.customConfigService = e),
								(this.searchTerm = ""),
								(this.isNonApplicableListCollapsed = !0),
								(this.searchPlaceholder = "Search by name, mode and metrics..."),
								(this.setSearchTermDebounced = Fd(i => (this.searchTerm = i.target.value), 400))
						}
						toggleNonApplicableCustomConfigsList() {
							this.isNonApplicableListCollapsed = !this.isNonApplicableListCollapsed
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(FO))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["ng-component"]],
								decls: 9,
								vars: 3,
								consts: [
									["color", "primary"],
									[1, "row"],
									[1, "action-buttons"],
									[1, "custom-configs-button-in-custom-views"],
									["class", "content", 4, "ngIf"],
									[1, "content"],
									[1, "custom-config-documentation-hint"],
									[
										"href",
										"https://maibornwolff.github.io/codecharta/docs/custom-view/",
										"target",
										"_blank",
										"rel",
										"noopener noreferrer"
									],
									["class", "no-custom-configs-box", 4, "ngIf"],
									["class", "custom-config-container", 3, "multi", 4, "ngIf"],
									[1, "no-custom-configs-box"],
									[1, "custom-config-container", 3, "multi"],
									[1, "cc-custom-configs-search-field"],
									["matPrefix", "", 1, "fa", "fa-search", "custom-config-search-icon"],
									["matInput", "", "type", "text", 3, "value", "input"],
									[3, "customConfigItemGroups", "searchTerm"],
									[3, "customConfigItemGroups", "searchTerm", 4, "ngIf"],
									["class", "toggle-non-applicable-configs-button", 3, "click", 4, "ngIf"],
									[1, "toggle-non-applicable-configs-button", 3, "click"],
									[3, "ngClass"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "mat-toolbar", 0),
										ge(1, "Custom Views "),
										F(2, "div", 1)(3, "div", 2),
										fe(4, "cc-upload-custom-config-button")(5, "cc-download-custom-configs-button")(
											6,
											"cc-add-custom-config-button",
											3
										),
										L()()(),
										Ee(7, JTe, 8, 2, "mat-dialog-content", 4),
										Me(8, "async")),
										2 & i && (T(7), U("ngIf", De(8, 1, r.customConfigService.customConfigItemGroups$)))
								},
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}.cc-custom-config-list{width:850px}.cc-custom-config-list .mat-mdc-dialog-content{padding:16px;max-height:90vh}.cc-custom-config-list .cc-custom-configs-search-field{width:100%;font-size:14px}.cc-custom-config-list .cc-custom-configs-search-field .custom-config-search-icon{color:gray;margin-left:8px;font-size:18px}.cc-custom-config-list .cc-custom-configs-search-field .clear-icon{position:absolute;right:0;margin:0;height:24px;width:24px;display:flex;justify-content:center;align-items:center;top:0}.cc-custom-config-list .cc-custom-configs-search-field .mat-mdc-form-field-subscript-wrapper.mat-mdc-form-field-bottom-align{display:none}.cc-custom-config-list .cc-custom-configs-search-field .mat-mdc-form-field-infix{margin-left:6px;display:flex}.cc-custom-config-list .row{display:flex;justify-content:space-between;align-items:center;margin-left:auto}.cc-custom-config-list .custom-config-documentation-hint{margin:10px 0 20px;font-size:1.4em;line-height:1.4em;color:#000000de}.cc-custom-config-list .action-buttons button{margin:0 3px;min-width:12%;height:48px;width:48px;border-radius:100%;line-height:48px;background-color:#fff;color:#1b9cfc}.cc-custom-config-list .action-buttons button:disabled,.cc-custom-config-list .action-buttons button[disabled]{background-color:#e6e6e6;color:#ccc}.cc-custom-config-list .action-buttons button i.fa{font-size:12px;margin-left:0}.cc-custom-config-list .no-custom-configs-box{text-align:center;padding:50px 0}.cc-custom-config-list cc-custom-config-item-group .mat-expansion-panel-spacing{margin:0}.cc-custom-config-list cc-custom-config-item-group .mat-expansion-panel-body{padding:0 16px}.cc-custom-config-list cc-custom-config-item-group .mat-expansion-panel-header:not([aria-disabled=true]){border-bottom:1px solid black;padding:15px 2px}.cc-custom-config-list cc-custom-config-item-group .mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:none}.cc-custom-config-list cc-custom-config-item-group.non-applicable-group .mat-expansion-panel-header-title{color:#0000004d}.cc-custom-config-list cc-custom-config-item-group .mdc-list-item__content{width:100%;border-bottom:1px solid #000000;padding:0 5px}.cc-custom-config-list cc-custom-config-item-group .mdc-list-item__content .mdc-list-item__primary-text{display:flex;flex-direction:column;width:100%}.cc-custom-config-list cc-custom-config-item-group .mdc-list-item__content:hover{background-color:#0000000a}.cc-custom-config-list cc-custom-config-item-group .mdc-list-item__content button{background-color:transparent}.cc-custom-config-list cc-custom-config-item-group .mdc-list-item__content button.remove-button,.cc-custom-config-list cc-custom-config-item-group .mdc-list-item__content button.custom-config-note-dialog-button{font-size:16px;padding:8px 10px;margin:0}.cc-custom-config-list cc-custom-config-item-group .mdc-list-item__content button.remove-button:hover,.cc-custom-config-list cc-custom-config-item-group .mdc-list-item__content button.custom-config-note-dialog-button:hover{background-color:#0000000d;color:#1b9cfc;border-radius:50%}.cc-custom-config-list .toggle-non-applicable-configs-button{width:100%;height:30px;margin:5px 0}.cc-custom-config-list .mat-mdc-list-base{padding:0}.cc-custom-config-list .mat-mdc-list-item{height:max-content}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				fY = (() => {
					class t {
						constructor(e) {
							this.dialog = e
						}
						openCustomConfigDialog() {
							this.dialog.open(hY, { panelClass: "cc-custom-config-list" })
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(la))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-custom-configs"]],
								decls: 4,
								vars: 0,
								consts: [
									[1, "custom-configs-panel-buttons"],
									["title", "Open your saved Custom Views", 1, "cc-ribbon-bar-menu-button", 3, "click"],
									[1, "fa", "fa-cogs"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div", 0)(1, "button", 1),
										Le("click", function () {
											return r.openCustomConfigDialog()
										}),
										fe(2, "i", 2),
										L(),
										fe(3, "cc-add-custom-config-button"),
										L())
								},
								styles: ["cc-custom-configs .custom-configs-panel-buttons{display:flex;justify-content:center;gap:4px}\n"],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function BO(t, n) {
				if ((n || (n = 0), !Array.isArray(t))) throw new Error("percentRound input should be an Array")
				const e = t.slice(),
					i = t.length,
					r = new Array(i)
				let o = 0
				for (let s = i - 1; s >= 0; s--) "string" == typeof e[s] && (e[s] = Number.parseFloat(e[s])), (o += 1 * e[s])
				if (isNaN(o)) throw new Error("percentRound invalid input")
				if (0 === o) r.fill(0)
				else {
					const s = Math.pow(10, n),
						a = 100 * s
					let c = 0
					for (let l = i - 1; l >= 0; l--) (e[l] = (100 * e[l]) / o), (c += r[l] = Math.round(e[l] * s))
					if (c !== a) {
						const d = 1
						let u = Math.abs(c - a)
						const h = new Array(i)
						for (let f = 0; f < i; f++) h[f] = Math.abs(r[f] - e[f] * s)
						for (; u > 0; ) {
							let f = 0,
								_ = h[0]
							for (let y = 1; y < i; y++)
								if (_ < h[y]) {
									if (c > a && r[y] - d < 0) continue
									;(f = y), (_ = h[y])
								}
							c > a ? (r[f] -= d) : (r[f] += d), (h[f] -= d), u--
						}
					}
					if (s > 1) for (let l = 0; l < i; l++) r[l] = r[l] / s
				}
				return r
			}
			BO.default = BO
			const eFe = BO,
				mY = {
					java: {
						mcc: { percentile70: 48, percentile80: 71, percentile90: 117, percentile95: 191 },
						rloc: { percentile70: 365, percentile80: 554, percentile90: 1001, percentile95: 1665 },
						loc: { percentile70: 365, percentile80: 554, percentile90: 1001, percentile95: 1665 },
						cognitive_complexity: { percentile70: 30, percentile80: 56, percentile90: 124, percentile95: 226 },
						code_smell: { percentile70: 5, percentile80: 9, percentile90: 22, percentile95: 50 },
						comment_lines: { percentile70: 35, percentile80: 62, percentile90: 135, percentile95: 273 },
						max_nesting_level: { percentile70: 2, percentile80: 3, percentile90: 4, percentile95: 5 },
						functions: { percentile70: 29, percentile80: 44, percentile90: 75, percentile95: 126 },
						statements: { percentile70: 157, percentile80: 245, percentile90: 439, percentile95: 727 }
					},
					miscellaneous: {
						mcc: { percentile70: 50, percentile80: 70, percentile90: 120, percentile95: 190 },
						rloc: { percentile70: 370, percentile80: 560, percentile90: 1011, percentile95: 1670 },
						loc: { percentile70: 370, percentile80: 560, percentile90: 1010, percentile95: 1670 },
						cognitive_complexity: { percentile70: 35, percentile80: 60, percentile90: 130, percentile95: 230 },
						code_smell: { percentile70: 6, percentile80: 10, percentile90: 25, percentile95: 55 },
						comment_lines: { percentile70: 40, percentile80: 65, percentile90: 140, percentile95: 275 },
						max_nesting_level: { percentile70: 3, percentile80: 4, percentile90: 5, percentile95: 6 },
						functions: { percentile70: 30, percentile80: 50, percentile90: 80, percentile95: 130 },
						statements: { percentile70: 160, percentile80: 260, percentile90: 440, percentile95: 730 }
					}
				}
			function pY(t) {
				return "java" === t ? mY.java : mY.miscellaneous
			}
			const ck = "mcc",
				lk = "rloc",
				tFe = new Set(["html", "sass", "css", "scss", "txt", "md", "json", void 0])
			function nFe(t, n, e) {
				const r = pY(e)[ck],
					o = t.attributes[ck],
					s = t.attributes[lk]
				o <= r.percentile70
					? (n.lowRisk += s)
					: o <= r.percentile80
					? (n.moderateRisk += s)
					: o <= r.percentile90
					? (n.highRisk += s)
					: (n.veryHighRisk += s)
			}
			function oFe(t, n, e) {
				for (const [i, r] of Object.entries(t.attributes)) 0 !== r && ((n[e] ??= {}), (n[e][i] ??= []), n[e][i].push(r))
			}
			function sFe(t, n) {
				return t.isOutlier && !n.isOutlier ? -1 : !t.isOutlier && n.isOutlier ? 1 : 0
			}
			function aFe(t) {
				const n = dO.get(t)
				return n ? `${t} (${n})` : `${t}`
			}
			function uFe(t) {
				return t.includes(".") ? t.slice(t.lastIndexOf(".") + 1) : void 0
			}
			function hFe(t, n) {
				return void 0 !== t.attributes[ck] && void 0 !== t.attributes[lk] && !tFe.has(n)
			}
			const fFe = Mt(Vc, cd, (t, n) => {
				if (!t.unifiedMapNode) return
				const e = {
						analyzedProgrammingLanguage: void 0,
						suspiciousMetricSuggestionLinks: [],
						unsuspiciousMetrics: [],
						untrackedMetrics: [],
						riskProfile: void 0
					},
					i = new Map(),
					r = { lowRisk: 0, moderateRisk: 0, highRisk: 0, veryHighRisk: 0 }
				let o = 0,
					s = 0
				const a = {}
				for (const { data: l } of $r(t.unifiedMapNode)) {
					const d = uFe(l.name)
					if (l.type === Da.FILE && void 0 !== d && !vu(l.path, n, "exclude")) {
						const u = i.get(d) ?? 0
						i.set(d, u + 1), oFe(l, a, d), hFe(l, d) && ((o += l.attributes[lk]), (s += l.attributes[ck]), nFe(l, r, d))
					}
				}
				o > 0 &&
					s > 0 &&
					(e.riskProfile = (function iFe(t) {
						const [n, e, i, r] = eFe([t.lowRisk, t.moderateRisk, t.highRisk, t.veryHighRisk])
						return { lowRisk: n, moderateRisk: e, highRisk: i, veryHighRisk: r }
					})(r))
				const c = (function lFe(t) {
					let n,
						e = -1
					for (const [i, r] of t) e < r && ((e = r), (n = i))
					return n
				})(i)
				if (((e.analyzedProgrammingLanguage = c), void 0 !== c)) {
					const l = (function cFe(t, n) {
						const e = {
								suspiciousMetrics: new Map(),
								unsuspiciousMetrics: [],
								outliersThresholds: new Map(),
								untrackedMetrics: []
							},
							i = pY(n)
						for (const r of Object.keys(i)) {
							const o = t[n]?.[r]
							if (void 0 === o) continue
							const s = i[r],
								a = Math.max(...o)
							a <= s.percentile70
								? e.unsuspiciousMetrics.push(aFe(r))
								: a > s.percentile70 &&
								  (e.suspiciousMetrics.set(r, { from: s.percentile70, to: s.percentile80 }),
								  a > s.percentile90 && e.outliersThresholds.set(r, s.percentile90))
						}
						for (const r in t[n]) !Object.keys(i).includes(r) && !e.untrackedMetrics.includes(r) && e.untrackedMetrics.push(r)
						return e
					})(a, c)
					;(e.unsuspiciousMetrics = l.unsuspiciousMetrics),
						(e.untrackedMetrics = l.untrackedMetrics),
						(e.suspiciousMetricSuggestionLinks = (function rFe(t) {
							const n = new Map()
							for (const [e, i] of t.suspiciousMetrics)
								n.set(e, { metric: e, ...i }),
									t.outliersThresholds.has(e) &&
										((n.get(e).isOutlier = !0), (n.get(e).outlierThreshold = t.outliersThresholds.get(e)))
							return [...n.values()].sort(sFe)
						})(l))
				}
				return e
			})
			let mFe = (() => {
				class t {
					constructor(e) {
						;(this.element = e), (this.ccRiskProfileBar = 0)
					}
					ngOnChanges(e) {
						e.ccRiskProfileBar &&
							((this.element.nativeElement.style.display = this.ccRiskProfileBar > 0 ? "flex" : "none"),
							(this.element.nativeElement.style.width = `${this.ccRiskProfileBar}%`),
							(this.element.nativeElement.style.color = this.ccRiskProfileBar > 5 ? "black" : "rgba(0,0,0,0)"))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(wn))
						}
					}
					static {
						this.ɵdir = yt({
							type: t,
							selectors: [["", "ccRiskProfileBar", ""]],
							inputs: { ccRiskProfileBar: "ccRiskProfileBar" },
							features: [Ar]
						})
					}
				}
				return t
			})()
			function pFe(t, n) {
				if (
					(1 & t &&
						(Cr(0),
						F(1, "div", 5)(2, "div"),
						ge(3, "Risk Profile"),
						L()(),
						F(4, "div", 6),
						ge(
							5,
							" The Risk Profile gives a quick overview about the complexity and risk structure of the code base. It tells you how much of the code is placed in files associated with low/high risk in means of maintainability. The separation of code in risk classes like low or high complexity is based on Java reference metric values and therefore may be inaccurate for other programming languages. More information can be found here: "
						),
						F(6, "a", 7),
						ge(7, "link"),
						L(),
						ge(8, " to How-To article. "),
						L(),
						F(9, "div", 5)(10, "div"),
						ge(11, "Calculations are always based on mcc (cyclomatic complexity)"),
						L()(),
						F(12, "div", 6)(13, "ul")(14, "li"),
						ge(15),
						L(),
						F(16, "li"),
						ge(17),
						L(),
						F(18, "li"),
						ge(19),
						L(),
						F(20, "li"),
						ge(21),
						L()()(),
						F(22, "div", 8)(23, "div", 9),
						ge(24),
						L(),
						F(25, "div", 10),
						ge(26),
						L(),
						F(27, "div", 11),
						ge(28),
						L(),
						F(29, "div", 12),
						ge(30),
						L()(),
						Er()),
					2 & t)
				) {
					const e = Te()
					T(15),
						Vt("", e.data.riskProfile.lowRisk, "% of overall code is in files with low complexity"),
						T(2),
						Vt("", e.data.riskProfile.moderateRisk, "% of overall code is in files with moderate complexity"),
						T(2),
						Vt("", e.data.riskProfile.highRisk, "% of overall code is in files with high complexity"),
						T(2),
						Vt("", e.data.riskProfile.veryHighRisk, "% of overall code is in files with extreme complexity"),
						T(2),
						lu("title", "Low Risk (", e.data.riskProfile.lowRisk, "% of code)"),
						U("ccRiskProfileBar", e.data.riskProfile.lowRisk),
						T(1),
						Vt(" ", e.data.riskProfile.lowRisk, "% "),
						T(1),
						lu("title", "Moderate Risk (", e.data.riskProfile.moderateRisk, "% of code)"),
						U("ccRiskProfileBar", e.data.riskProfile.moderateRisk),
						T(1),
						Vt(" ", e.data.riskProfile.moderateRisk, "% "),
						T(1),
						lu("title", "High Risk (", e.data.riskProfile.highRisk, "% of code)"),
						U("ccRiskProfileBar", e.data.riskProfile.highRisk),
						T(1),
						Vt(" ", e.data.riskProfile.highRisk, "% "),
						T(1),
						lu("title", "Very High Risk (", e.data.riskProfile.veryHighRisk, "% of code)"),
						U("ccRiskProfileBar", e.data.riskProfile.veryHighRisk),
						T(1),
						Vt(" ", e.data.riskProfile.veryHighRisk, "% ")
				}
			}
			function AFe(t, n) {
				1 & t &&
					(Cr(0),
					ge(
						1,
						" Could not calculate Risk Profile. Metrics rloc(Real lines of code) and mcc(Cyclomatic complexity) not available. "
					),
					Er())
			}
			let gFe = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-high-risk-profile"]],
							inputs: { data: "data" },
							decls: 6,
							vars: 3,
							consts: [
								["title", "Open High Risk Profile", 1, "cc-ribbon-bar-menu-button", 3, "matMenuTriggerFor"],
								[1, "fa", "fa-bar-chart"],
								[1, "ai-drop-down", "high-risk-profile"],
								["menu", "matMenu"],
								[4, "ngIf"],
								[1, "title"],
								[1, "suspicious-metrics-summary"],
								["href", "https://maibornwolff.github.io/codecharta/docs/risk-profile/"],
								[1, "risk-profiles"],
								[1, "risk-profile", "low-risk", 3, "ccRiskProfileBar", "title"],
								[1, "risk-profile", "moderate-risk", 3, "ccRiskProfileBar", "title"],
								[1, "risk-profile", "high-risk", 3, "ccRiskProfileBar", "title"],
								[1, "risk-profile", "very-high-risk", 3, "ccRiskProfileBar", "title"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "button", 0),
									fe(1, "i", 1),
									L(),
									F(2, "mat-menu", 2, 3),
									Ee(4, pFe, 31, 16, "ng-container", 4),
									Ee(5, AFe, 2, 0, "ng-container", 4),
									L()),
									2 & i &&
										(U("matMenuTriggerFor", br(3)),
										T(4),
										U("ngIf", void 0 !== r.data.riskProfile),
										T(1),
										U("ngIf", void 0 === r.data.riskProfile))
							},
							dependencies: [En, vw, yw, mFe],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			var AY = Object.prototype.hasOwnProperty
			function gY(t, n, e) {
				for (e of t.keys()) if (Tp(e, n)) return e
			}
			function Tp(t, n) {
				var e, i, r
				if (t === n) return !0
				if (t && n && (e = t.constructor) === n.constructor) {
					if (e === Date) return t.getTime() === n.getTime()
					if (e === RegExp) return t.toString() === n.toString()
					if (e === Array) {
						if ((i = t.length) === n.length) for (; i-- && Tp(t[i], n[i]); );
						return -1 === i
					}
					if (e === Set) {
						if (t.size !== n.size) return !1
						for (i of t) if (((r = i) && "object" == typeof r && !(r = gY(n, r))) || !n.has(r)) return !1
						return !0
					}
					if (e === Map) {
						if (t.size !== n.size) return !1
						for (i of t) if (((r = i[0]) && "object" == typeof r && !(r = gY(n, r))) || !Tp(i[1], n.get(r))) return !1
						return !0
					}
					if (e === ArrayBuffer) (t = new Uint8Array(t)), (n = new Uint8Array(n))
					else if (e === DataView) {
						if ((i = t.byteLength) === n.byteLength) for (; i-- && t.getInt8(i) === n.getInt8(i); );
						return -1 === i
					}
					if (ArrayBuffer.isView(t)) {
						if ((i = t.byteLength) === n.byteLength) for (; i-- && t[i] === n[i]; );
						return -1 === i
					}
					if (!e || "object" == typeof t) {
						for (e in ((i = 0), t)) if ((AY.call(t, e) && ++i && !AY.call(n, e)) || !(e in n) || !Tp(t[e], n[e])) return !1
						return Object.keys(n).length === i
					}
				}
				return t != t && n != n
			}
			function bFe(t, n) {
				if ((1 & t && (F(0, "span", 13), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1), Vt(" ", e.data.suspiciousMetricSuggestionLinks.length, " ")
				}
			}
			function _Fe(t, n) {
				if ((1 & t && (F(0, "div", 5), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1),
						Vt(
							" ",
							null != e.data.analyzedProgrammingLanguage && e.data.analyzedProgrammingLanguage.length
								? "Unsuspicious Metrics in " + e.data.analyzedProgrammingLanguage + " code"
								: "Unsuspicious Metrics",
							" "
						)
				}
			}
			function vFe(t, n) {
				if ((1 & t && (F(0, "li"), ge(1), L()), 2 & t)) {
					const e = n.$implicit
					T(1), cr(e)
				}
			}
			function yFe(t, n) {
				if ((1 & t && (F(0, "div", 14), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1), Vt(" Suspicious Metrics in ", e.data.analyzedProgrammingLanguage, " code ")
				}
			}
			function wFe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "button", 17),
						Le("click", function () {
							rn(e)
							const r = Te().$implicit
							return on(Te().applySuspiciousMetric(r, !0))
						}),
						fe(1, "i", 1),
						L()
				}
			}
			function xFe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div", 6)(1, "button", 15),
						Le("click", function () {
							const o = rn(e).$implicit
							return on(Te().applySuspiciousMetric(o, !1))
						}),
						ge(2),
						Me(3, "uppercase"),
						L(),
						Ee(4, wFe, 2, 0, "button", 16),
						L()
				}
				if (2 & t) {
					const e = n.$implicit
					T(1),
						lu(
							"title",
							"Apply Map Configuration to show files with suspicious metric ",
							e.metric,
							" and high risk or very high risk depending on selection"
						),
						T(1),
						Vt(" Suspicious ", De(3, 3, e.metric), " Files "),
						T(2),
						U("ngIf", e.isOutlier)
				}
			}
			function CFe(t, n) {
				if ((1 & t && (F(0, "div", 5), ge(1), L()), 2 & t)) {
					const e = Te(2)
					T(1), Vt(" Untracked metrics in ", e.data.analyzedProgrammingLanguage, " code ")
				}
			}
			function EFe(t, n) {
				if ((1 & t && (F(0, "li"), ge(1), L()), 2 & t)) {
					const e = n.$implicit
					T(1), cr(e)
				}
			}
			function MFe(t, n) {
				if ((1 & t && (F(0, "div"), Ee(1, CFe, 2, 1, "div", 8), F(2, "ul"), Ee(3, EFe, 2, 1, "li", 9), L()()), 2 & t)) {
					const e = Te()
					T(1), U("ngIf", e.data.analyzedProgrammingLanguage.length), T(2), U("ngForOf", e.data.untrackedMetrics)
				}
			}
			function SFe(t, n) {
				1 & t && (F(0, "div"), ge(1, "No programming language was found for analyzing suspicious metrics."), L())
			}
			let kFe = (() => {
				class t {
					constructor(e) {
						;(this.store = e), (this.hideBadge = !1)
					}
					ngOnChanges(e) {
						e.data && !Tp(e.data.previousValue, e.data.currentValue) && (this.hideBadge = !1)
					}
					applySuspiciousMetric(e, i) {
						this.store.dispatch(gu({ value: lk })),
							this.store.dispatch(bu({ value: e.metric })),
							this.store.dispatch(hl({ value: e.metric })),
							this.store.dispatch(sd({ value: { from: e.from, to: i ? e.outlierThreshold : e.to } })),
							this.store.dispatch(
								Au({
									value: {
										positive: i ? "#ffffff" : Vu.positive,
										neutral: i ? "#ffffff" : Vu.neutral,
										negative: i ? "#A900C0" : Vu.negative
									}
								})
							)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-suspicious-metrics"]],
							inputs: { data: "data" },
							features: [Ar],
							decls: 21,
							vars: 8,
							consts: [
								["title", "Open Suspicious Metrics Panel", 1, "cc-ribbon-bar-menu-button", 3, "matMenuTriggerFor", "click"],
								[1, "fa", "fa-exclamation-triangle"],
								["class", "suspicious-metrics-badge", 4, "ngIf"],
								[1, "ai-drop-down", "suspicious-metric-panel"],
								["menu", "matMenu"],
								[1, "title"],
								[1, "suspicious-metric"],
								["href", "https://maibornwolff.github.io/codecharta/docs/suspicious-metrics/"],
								["class", "title", 4, "ngIf"],
								[4, "ngFor", "ngForOf"],
								["class", "title new-section", 4, "ngIf"],
								["class", "suspicious-metric", 4, "ngFor", "ngForOf"],
								[4, "ngIf"],
								[1, "suspicious-metrics-badge"],
								[1, "title", "new-section"],
								[1, "metric-button", 3, "title", "click"],
								["class", "risk-button", "title", "Show very high risk files (90th percentile)", 3, "click", 4, "ngIf"],
								["title", "Show very high risk files (90th percentile)", 1, "risk-button", 3, "click"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "button", 0),
									Le("click", function () {
										return (r.hideBadge = !0)
									}),
									fe(1, "i", 1),
									Ee(2, bFe, 2, 1, "span", 2),
									L(),
									F(3, "mat-menu", 3, 4)(5, "div")(6, "div", 5)(7, "div"),
									ge(8, "Suspicious Metrics"),
									L()(),
									F(9, "div", 6),
									ge(
										10,
										" This feature compares the values of certain metrics from the loaded cc.json file with metric values of 241 Open Source Java projects. Based on this data suspicious and inconspicuous metrics are identified and corresponding suggestions can be clicked to view them. Be aware that metrics for other programming languages might not be comparable to Java Reference metric values. More information can be found here: "
									),
									F(11, "a", 7),
									ge(12, "link"),
									L(),
									ge(13, " to How-To article. "),
									L(),
									Ee(14, _Fe, 2, 1, "div", 8),
									F(15, "ul"),
									Ee(16, vFe, 2, 1, "li", 9),
									L()(),
									Ee(17, yFe, 2, 1, "div", 10),
									Ee(18, xFe, 5, 5, "div", 11),
									Ee(19, MFe, 4, 2, "div", 12),
									Ee(20, SFe, 2, 0, "div", 12),
									L()),
									2 & i &&
										(U("matMenuTriggerFor", br(4)),
										T(2),
										U(
											"ngIf",
											!r.hideBadge &&
												(void 0 !== r.data.analyzedProgrammingLanguage ||
													r.data.suspiciousMetricSuggestionLinks.length ||
													r.data.unsuspiciousMetrics.length)
										),
										T(12),
										U("ngIf", r.data.unsuspiciousMetrics.length),
										T(2),
										U("ngForOf", r.data.unsuspiciousMetrics),
										T(1),
										U("ngIf", r.data.suspiciousMetricSuggestionLinks.length),
										T(1),
										U("ngForOf", r.data.suspiciousMetricSuggestionLinks),
										T(1),
										U("ngIf", r.data.untrackedMetrics.length),
										T(1),
										U("ngIf", void 0 === r.data.analyzedProgrammingLanguage))
							},
							dependencies: [_o, En, vw, yw, qQ],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function TFe(t, n) {
				if ((1 & t && (Cr(0), fe(1, "cc-suspicious-metrics", 1)(2, "cc-high-risk-profile", 1), Er()), 2 & t)) {
					const e = n.$implicit
					T(1), U("data", e), T(1), U("data", e)
				}
			}
			let FFe = (() => {
				class t {
					constructor(e) {
						;(this.store = e), (this.data$ = this.store.select(fFe))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-artificial-intelligence"]],
							decls: 2,
							vars: 3,
							consts: [
								[4, "ngIf"],
								[3, "data"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, TFe, 3, 2, "ng-container", 0), Me(1, "async")), 2 & i && U("ngIf", De(1, 1, r.data$))
							},
							dependencies: [En, gFe, kFe, Bn],
							styles: [
								"cc-artificial-intelligence{display:flex;justify-content:center;gap:4px}cc-artificial-intelligence .suspicious-metrics-badge{position:absolute;bottom:10px;padding:4px 6px;border-radius:50%;background:red;color:#fff;font-size:10px;line-height:10px}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down{padding:8px 16px;max-width:33em}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down .title{margin-bottom:8px;font-weight:700}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down .new-section{margin-top:16px}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down ul{margin-block:0;padding-inline:32px}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.suspicious-metric-panel .suspicious-metric:not(:last-child){margin-bottom:12px}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.suspicious-metric-panel .suspicious-metric button{height:36px;background-color:#e6e6e6f5}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.suspicious-metric-panel .suspicious-metric button:hover{background-color:#c8c8c8}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.suspicious-metric-panel .suspicious-metric .metric-button{border-radius:5px;padding:0 12px}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.suspicious-metric-panel .suspicious-metric .risk-button{border-radius:0 5px 5px 0;margin-left:4px;width:36px;color:#9c0e6a}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.high-risk-profile .suspicious-metrics-summary{padding:8px 0 16px}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.high-risk-profile .risk-profiles{display:flex}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.high-risk-profile .risk-profiles .risk-profile{height:36px;text-align:center;justify-content:center;align-items:center;overflow:hidden}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.high-risk-profile .risk-profiles .low-risk{background-color:#5cb34d}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.high-risk-profile .risk-profiles .moderate-risk{background-color:#eef432}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.high-risk-profile .risk-profiles .high-risk{background-color:#cc2900}.mat-mdc-menu-panel.mat-mdc-menu-panel.ai-drop-down.high-risk-profile .risk-profiles .very-high-risk{background-color:#9c0e6a}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const BFe = ["trigger"],
				IFe = ["panel"]
			function DFe(t, n) {
				if ((1 & t && (F(0, "span", 10), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1), cr(e.placeholder)
				}
			}
			function LFe(t, n) {
				if ((1 & t && (F(0, "span", 14), ge(1), L()), 2 & t)) {
					const e = Te(2)
					T(1), cr(e.triggerValue)
				}
			}
			function RFe(t, n) {
				1 & t && Ln(0, 0, ["*ngSwitchCase", "true"])
			}
			function PFe(t, n) {
				1 & t && (F(0, "span", 11), Ee(1, LFe, 2, 1, "span", 12), Ee(2, RFe, 1, 0, "ng-content", 13), L()),
					2 & t && (U("ngSwitch", !!Te().customTrigger), T(2), U("ngSwitchCase", !0))
			}
			function OFe(t, n) {
				if (1 & t) {
					const e = ri()
					Xa(),
						ph(),
						F(0, "div", 15, 16),
						Le("@transformPanel.done", function (r) {
							return rn(e), on(Te()._panelDoneAnimatingStream.next(r.toState))
						})("keydown", function (r) {
							return rn(e), on(Te()._handleKeydown(r))
						}),
						Ln(2, 1),
						L()
				}
				if (2 & t) {
					const e = Te()
					du("mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ", e._getPanelTheme(), ""),
						U("ngClass", e.panelClass)("@transformPanel", "showing"),
						qn("id", e.id + "-panel")("aria-multiselectable", e.multiple)("aria-label", e.ariaLabel || null)(
							"aria-labelledby",
							e._getPanelAriaLabelledby()
						)
				}
			}
			const NFe = [[["mat-select-trigger"]], "*"],
				UFe = ["mat-select-trigger", "*"],
				HFe = {
					transformPanelWrap: Mu("transformPanelWrap", [tc("* => void", oL("@transformPanel", [rL()], { optional: !0 }))]),
					transformPanel: Mu("transformPanel", [
						Pc("void", wo({ opacity: 0, transform: "scale(1, 0.8)" })),
						tc("void => showing", Rc("120ms cubic-bezier(0, 0, 0.2, 1)", wo({ opacity: 1, transform: "scale(1, 1)" }))),
						tc("* => void", Rc("100ms linear", wo({ opacity: 0 })))
					])
				}
			let bY = 0
			const _Y = new He("mat-select-scroll-strategy"),
				QFe = new He("MAT_SELECT_CONFIG"),
				zFe = {
					provide: _Y,
					deps: [ec],
					useFactory: function VFe(t) {
						return () => t.scrollStrategies.reposition()
					}
				},
				vY = new He("MatSelectTrigger")
			class GFe {
				constructor(n, e) {
					;(this.source = n), (this.value = e)
				}
			}
			const $Fe = Um(
				GE(
					Sv(
						KG(
							class {
								constructor(t, n, e, i, r) {
									;(this._elementRef = t),
										(this._defaultErrorStateMatcher = n),
										(this._parentForm = e),
										(this._parentFormGroup = i),
										(this.ngControl = r),
										(this.stateChanges = new vt())
								}
							}
						)
					)
				)
			)
			let WFe = (() => {
					class t extends $Fe {
						get focused() {
							return this._focused || this._panelOpen
						}
						get placeholder() {
							return this._placeholder
						}
						set placeholder(e) {
							;(this._placeholder = e), this.stateChanges.next()
						}
						get required() {
							return this._required ?? this.ngControl?.control?.hasValidator(nI.required) ?? !1
						}
						set required(e) {
							;(this._required = Mn(e)), this.stateChanges.next()
						}
						get multiple() {
							return this._multiple
						}
						set multiple(e) {
							this._multiple = Mn(e)
						}
						get disableOptionCentering() {
							return this._disableOptionCentering
						}
						set disableOptionCentering(e) {
							this._disableOptionCentering = Mn(e)
						}
						get compareWith() {
							return this._compareWith
						}
						set compareWith(e) {
							;(this._compareWith = e), this._selectionModel && this._initializeSelection()
						}
						get value() {
							return this._value
						}
						set value(e) {
							this._assignValue(e) && this._onChange(e)
						}
						get typeaheadDebounceInterval() {
							return this._typeaheadDebounceInterval
						}
						set typeaheadDebounceInterval(e) {
							this._typeaheadDebounceInterval = to(e)
						}
						get id() {
							return this._id
						}
						set id(e) {
							;(this._id = e || this._uid), this.stateChanges.next()
						}
						constructor(e, i, r, o, s, a, c, l, d, u, h, f, _, y) {
							super(s, o, c, l, u),
								(this._viewportRuler = e),
								(this._changeDetectorRef = i),
								(this._ngZone = r),
								(this._dir = a),
								(this._parentFormField = d),
								(this._liveAnnouncer = _),
								(this._defaultOptions = y),
								(this._panelOpen = !1),
								(this._compareWith = (C, x) => C === x),
								(this._uid = "mat-select-" + bY++),
								(this._triggerAriaLabelledBy = null),
								(this._destroy = new vt()),
								(this._onChange = () => {}),
								(this._onTouched = () => {}),
								(this._valueId = "mat-select-value-" + bY++),
								(this._panelDoneAnimatingStream = new vt()),
								(this._overlayPanelClass = this._defaultOptions?.overlayPanelClass || ""),
								(this._focused = !1),
								(this.controlType = "mat-select"),
								(this._multiple = !1),
								(this._disableOptionCentering = this._defaultOptions?.disableOptionCentering ?? !1),
								(this.ariaLabel = ""),
								(this.optionSelectionChanges = JD(() => {
									const C = this.options
									return C
										? C.changes.pipe(
												hd(C),
												ya(() => oo(...C.map(x => x.onSelectionChange)))
										  )
										: this._ngZone.onStable.pipe(
												Do(1),
												ya(() => this.optionSelectionChanges)
										  )
								})),
								(this.openedChange = new _n()),
								(this._openedStream = this.openedChange.pipe(
									xi(C => C),
									Ke(() => {})
								)),
								(this._closedStream = this.openedChange.pipe(
									xi(C => !C),
									Ke(() => {})
								)),
								(this.selectionChange = new _n()),
								(this.valueChange = new _n()),
								(this._trackedModal = null),
								this.ngControl && (this.ngControl.valueAccessor = this),
								null != y?.typeaheadDebounceInterval && (this._typeaheadDebounceInterval = y.typeaheadDebounceInterval),
								(this._scrollStrategyFactory = f),
								(this._scrollStrategy = this._scrollStrategyFactory()),
								(this.tabIndex = parseInt(h) || 0),
								(this.id = this.id)
						}
						ngOnInit() {
							;(this._selectionModel = new ZS(this.multiple)),
								this.stateChanges.next(),
								this._panelDoneAnimatingStream
									.pipe(Ys(), kr(this._destroy))
									.subscribe(() => this._panelDoneAnimating(this.panelOpen))
						}
						ngAfterContentInit() {
							this._initKeyManager(),
								this._selectionModel.changed.pipe(kr(this._destroy)).subscribe(e => {
									e.added.forEach(i => i.select()), e.removed.forEach(i => i.deselect())
								}),
								this.options.changes.pipe(hd(null), kr(this._destroy)).subscribe(() => {
									this._resetOptions(), this._initializeSelection()
								})
						}
						ngDoCheck() {
							const e = this._getTriggerAriaLabelledby(),
								i = this.ngControl
							if (e !== this._triggerAriaLabelledBy) {
								const r = this._elementRef.nativeElement
								;(this._triggerAriaLabelledBy = e),
									e ? r.setAttribute("aria-labelledby", e) : r.removeAttribute("aria-labelledby")
							}
							i &&
								(this._previousControl !== i.control &&
									(void 0 !== this._previousControl &&
										null !== i.disabled &&
										i.disabled !== this.disabled &&
										(this.disabled = i.disabled),
									(this._previousControl = i.control)),
								this.updateErrorState())
						}
						ngOnChanges(e) {
							;(e.disabled || e.userAriaDescribedBy) && this.stateChanges.next(),
								e.typeaheadDebounceInterval &&
									this._keyManager &&
									this._keyManager.withTypeAhead(this._typeaheadDebounceInterval)
						}
						ngOnDestroy() {
							this._keyManager?.destroy(),
								this._destroy.next(),
								this._destroy.complete(),
								this.stateChanges.complete(),
								this._clearFromModal()
						}
						toggle() {
							this.panelOpen ? this.close() : this.open()
						}
						open() {
							this._canOpen() &&
								(this._applyModalPanelOwnership(),
								(this._panelOpen = !0),
								this._keyManager.withHorizontalOrientation(null),
								this._highlightCorrectOption(),
								this._changeDetectorRef.markForCheck())
						}
						_applyModalPanelOwnership() {
							const e = this._elementRef.nativeElement.closest('body > .cdk-overlay-container [aria-modal="true"]')
							if (!e) return
							const i = `${this.id}-panel`
							this._trackedModal && GD(this._trackedModal, "aria-owns", i), DG(e, "aria-owns", i), (this._trackedModal = e)
						}
						_clearFromModal() {
							this._trackedModal && (GD(this._trackedModal, "aria-owns", `${this.id}-panel`), (this._trackedModal = null))
						}
						close() {
							this._panelOpen &&
								((this._panelOpen = !1),
								this._keyManager.withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr"),
								this._changeDetectorRef.markForCheck(),
								this._onTouched())
						}
						writeValue(e) {
							this._assignValue(e)
						}
						registerOnChange(e) {
							this._onChange = e
						}
						registerOnTouched(e) {
							this._onTouched = e
						}
						setDisabledState(e) {
							;(this.disabled = e), this._changeDetectorRef.markForCheck(), this.stateChanges.next()
						}
						get panelOpen() {
							return this._panelOpen
						}
						get selected() {
							return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0]
						}
						get triggerValue() {
							if (this.empty) return ""
							if (this._multiple) {
								const e = this._selectionModel.selected.map(i => i.viewValue)
								return this._isRtl() && e.reverse(), e.join(", ")
							}
							return this._selectionModel.selected[0].viewValue
						}
						_isRtl() {
							return !!this._dir && "rtl" === this._dir.value
						}
						_handleKeydown(e) {
							this.disabled || (this.panelOpen ? this._handleOpenKeydown(e) : this._handleClosedKeydown(e))
						}
						_handleClosedKeydown(e) {
							const i = e.keyCode,
								r = 40 === i || 38 === i || 37 === i || 39 === i,
								o = 13 === i || 32 === i,
								s = this._keyManager
							if ((!s.isTyping() && o && !fl(e)) || ((this.multiple || e.altKey) && r)) e.preventDefault(), this.open()
							else if (!this.multiple) {
								const a = this.selected
								s.onKeydown(e)
								const c = this.selected
								c && a !== c && this._liveAnnouncer.announce(c.viewValue, 1e4)
							}
						}
						_handleOpenKeydown(e) {
							const i = this._keyManager,
								r = e.keyCode,
								o = 40 === r || 38 === r,
								s = i.isTyping()
							if (o && e.altKey) e.preventDefault(), this.close()
							else if (s || (13 !== r && 32 !== r) || !i.activeItem || fl(e))
								if (!s && this._multiple && 65 === r && e.ctrlKey) {
									e.preventDefault()
									const a = this.options.some(c => !c.disabled && !c.selected)
									this.options.forEach(c => {
										c.disabled || (a ? c.select() : c.deselect())
									})
								} else {
									const a = i.activeItemIndex
									i.onKeydown(e),
										this._multiple &&
											o &&
											e.shiftKey &&
											i.activeItem &&
											i.activeItemIndex !== a &&
											i.activeItem._selectViaInteraction()
								}
							else e.preventDefault(), i.activeItem._selectViaInteraction()
						}
						_onFocus() {
							this.disabled || ((this._focused = !0), this.stateChanges.next())
						}
						_onBlur() {
							;(this._focused = !1),
								this._keyManager?.cancelTypeahead(),
								!this.disabled &&
									!this.panelOpen &&
									(this._onTouched(), this._changeDetectorRef.markForCheck(), this.stateChanges.next())
						}
						_onAttached() {
							this._overlayDir.positionChange.pipe(Do(1)).subscribe(() => {
								this._changeDetectorRef.detectChanges(), this._positioningSettled()
							})
						}
						_getPanelTheme() {
							return this._parentFormField ? `mat-${this._parentFormField.color}` : ""
						}
						get empty() {
							return !this._selectionModel || this._selectionModel.isEmpty()
						}
						_initializeSelection() {
							Promise.resolve().then(() => {
								this.ngControl && (this._value = this.ngControl.value),
									this._setSelectionByValue(this._value),
									this.stateChanges.next()
							})
						}
						_setSelectionByValue(e) {
							if ((this.options.forEach(i => i.setInactiveStyles()), this._selectionModel.clear(), this.multiple && e))
								Array.isArray(e), e.forEach(i => this._selectOptionByValue(i)), this._sortValues()
							else {
								const i = this._selectOptionByValue(e)
								i ? this._keyManager.updateActiveItem(i) : this.panelOpen || this._keyManager.updateActiveItem(-1)
							}
							this._changeDetectorRef.markForCheck()
						}
						_selectOptionByValue(e) {
							const i = this.options.find(r => {
								if (this._selectionModel.isSelected(r)) return !1
								try {
									return null != r.value && this._compareWith(r.value, e)
								} catch {
									return !1
								}
							})
							return i && this._selectionModel.select(i), i
						}
						_assignValue(e) {
							return (
								!!(e !== this._value || (this._multiple && Array.isArray(e))) &&
								(this.options && this._setSelectionByValue(e), (this._value = e), !0)
							)
						}
						_skipPredicate(e) {
							return e.disabled
						}
						_initKeyManager() {
							;(this._keyManager = new AAe(this.options)
								.withTypeAhead(this._typeaheadDebounceInterval)
								.withVerticalOrientation()
								.withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr")
								.withHomeAndEnd()
								.withPageUpDown()
								.withAllowedModifierKeys(["shiftKey"])
								.skipPredicate(this._skipPredicate)),
								this._keyManager.tabOut.subscribe(() => {
									this.panelOpen &&
										(!this.multiple &&
											this._keyManager.activeItem &&
											this._keyManager.activeItem._selectViaInteraction(),
										this.focus(),
										this.close())
								}),
								this._keyManager.change.subscribe(() => {
									this._panelOpen && this.panel
										? this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0)
										: !this._panelOpen &&
										  !this.multiple &&
										  this._keyManager.activeItem &&
										  this._keyManager.activeItem._selectViaInteraction()
								})
						}
						_resetOptions() {
							const e = oo(this.options.changes, this._destroy)
							this.optionSelectionChanges.pipe(kr(e)).subscribe(i => {
								this._onSelect(i.source, i.isUserInput),
									i.isUserInput && !this.multiple && this._panelOpen && (this.close(), this.focus())
							}),
								oo(...this.options.map(i => i._stateChanges))
									.pipe(kr(e))
									.subscribe(() => {
										this._changeDetectorRef.detectChanges(), this.stateChanges.next()
									})
						}
						_onSelect(e, i) {
							const r = this._selectionModel.isSelected(e)
							null != e.value || this._multiple
								? (r !== e.selected && (e.selected ? this._selectionModel.select(e) : this._selectionModel.deselect(e)),
								  i && this._keyManager.setActiveItem(e),
								  this.multiple && (this._sortValues(), i && this.focus()))
								: (e.deselect(), this._selectionModel.clear(), null != this.value && this._propagateChanges(e.value)),
								r !== this._selectionModel.isSelected(e) && this._propagateChanges(),
								this.stateChanges.next()
						}
						_sortValues() {
							if (this.multiple) {
								const e = this.options.toArray()
								this._selectionModel.sort((i, r) =>
									this.sortComparator ? this.sortComparator(i, r, e) : e.indexOf(i) - e.indexOf(r)
								),
									this.stateChanges.next()
							}
						}
						_propagateChanges(e) {
							let i = null
							;(i = this.multiple ? this.selected.map(r => r.value) : this.selected ? this.selected.value : e),
								(this._value = i),
								this.valueChange.emit(i),
								this._onChange(i),
								this.selectionChange.emit(this._getChangeEvent(i)),
								this._changeDetectorRef.markForCheck()
						}
						_highlightCorrectOption() {
							if (this._keyManager)
								if (this.empty) {
									let e = -1
									for (let i = 0; i < this.options.length; i++)
										if (!this.options.get(i).disabled) {
											e = i
											break
										}
									this._keyManager.setActiveItem(e)
								} else this._keyManager.setActiveItem(this._selectionModel.selected[0])
						}
						_canOpen() {
							return !this._panelOpen && !this.disabled && this.options?.length > 0
						}
						focus(e) {
							this._elementRef.nativeElement.focus(e)
						}
						_getPanelAriaLabelledby() {
							if (this.ariaLabel) return null
							const e = this._parentFormField?.getLabelId()
							return this.ariaLabelledby ? (e ? e + " " : "") + this.ariaLabelledby : e
						}
						_getAriaActiveDescendant() {
							return this.panelOpen && this._keyManager && this._keyManager.activeItem ? this._keyManager.activeItem.id : null
						}
						_getTriggerAriaLabelledby() {
							if (this.ariaLabel) return null
							const e = this._parentFormField?.getLabelId()
							let i = (e ? e + " " : "") + this._valueId
							return this.ariaLabelledby && (i += " " + this.ariaLabelledby), i
						}
						_panelDoneAnimating(e) {
							this.openedChange.emit(e)
						}
						setDescribedByIds(e) {
							e.length
								? this._elementRef.nativeElement.setAttribute("aria-describedby", e.join(" "))
								: this._elementRef.nativeElement.removeAttribute("aria-describedby")
						}
						onContainerClick() {
							this.focus(), this.open()
						}
						get shouldLabelFloat() {
							return this._panelOpen || !this.empty || (this._focused && !!this._placeholder)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(
									P(OD),
									P(Jr),
									P(mn),
									P(XG),
									P(wn),
									P(wu, 8),
									P(R0, 8),
									P(O0, 8),
									P(EO, 8),
									P(rd, 10),
									Ma("tabindex"),
									P(_Y),
									P(RAe),
									P(QFe, 8)
								)
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								viewQuery: function (i, r) {
									if ((1 & i && (_i(BFe, 5), _i(IFe, 5), _i(MG, 5)), 2 & i)) {
										let o
										sn((o = an())) && (r.trigger = o.first),
											sn((o = an())) && (r.panel = o.first),
											sn((o = an())) && (r._overlayDir = o.first)
									}
								},
								inputs: {
									userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"],
									panelClass: "panelClass",
									placeholder: "placeholder",
									required: "required",
									multiple: "multiple",
									disableOptionCentering: "disableOptionCentering",
									compareWith: "compareWith",
									value: "value",
									ariaLabel: ["aria-label", "ariaLabel"],
									ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
									errorStateMatcher: "errorStateMatcher",
									typeaheadDebounceInterval: "typeaheadDebounceInterval",
									sortComparator: "sortComparator",
									id: "id"
								},
								outputs: {
									openedChange: "openedChange",
									_openedStream: "opened",
									_closedStream: "closed",
									selectionChange: "selectionChange",
									valueChange: "valueChange"
								},
								features: [pn, Ar]
							})
						}
					}
					return t
				})(),
				jFe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["mat-select-trigger"]],
								features: [Xn([{ provide: vY, useExisting: t }])]
							})
						}
					}
					return t
				})(),
				Fp = (() => {
					class t extends WFe {
						constructor() {
							super(...arguments),
								(this.panelWidth =
									this._defaultOptions && typeof this._defaultOptions.panelWidth < "u"
										? this._defaultOptions.panelWidth
										: "auto"),
								(this._positions = [
									{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" },
									{ originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" },
									{
										originX: "start",
										originY: "top",
										overlayX: "start",
										overlayY: "bottom",
										panelClass: "mat-mdc-select-panel-above"
									},
									{
										originX: "end",
										originY: "top",
										overlayX: "end",
										overlayY: "bottom",
										panelClass: "mat-mdc-select-panel-above"
									}
								]),
								(this._hideSingleSelectionIndicator = this._defaultOptions?.hideSingleSelectionIndicator ?? !1),
								(this._skipPredicate = e => !this.panelOpen && e.disabled)
						}
						get shouldLabelFloat() {
							return this.panelOpen || !this.empty || (this.focused && !!this.placeholder)
						}
						ngOnInit() {
							super.ngOnInit(),
								this._viewportRuler
									.change()
									.pipe(kr(this._destroy))
									.subscribe(() => {
										this.panelOpen &&
											((this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin)),
											this._changeDetectorRef.detectChanges())
									})
						}
						open() {
							this._parentFormField && (this._preferredOverlayOrigin = this._parentFormField.getConnectedOverlayOrigin()),
								(this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin)),
								super.open(),
								this.stateChanges.next()
						}
						close() {
							super.close(), this.stateChanges.next()
						}
						_scrollOptionIntoView(e) {
							const i = this.options.toArray()[e]
							if (i) {
								const r = this.panel.nativeElement,
									o = (function age(t, n, e) {
										if (e.length) {
											let i = n.toArray(),
												r = e.toArray(),
												o = 0
											for (let s = 0; s < t + 1; s++) i[s].group && i[s].group === r[o] && o++
											return o
										}
										return 0
									})(e, this.options, this.optionGroups),
									s = i._getHostElement()
								r.scrollTop =
									0 === e && 1 === o
										? 0
										: (function cge(t, n, e, i) {
												return t < e ? t : t + n > e + i ? Math.max(0, t - i + n) : e
										  })(s.offsetTop, s.offsetHeight, r.scrollTop, r.offsetHeight)
							}
						}
						_positioningSettled() {
							this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0)
						}
						_getChangeEvent(e) {
							return new GFe(this, e)
						}
						_getOverlayWidth(e) {
							return "auto" === this.panelWidth
								? (e instanceof QD ? e.elementRef : e || this._elementRef).nativeElement.getBoundingClientRect().width
								: null === this.panelWidth
								? ""
								: this.panelWidth
						}
						get hideSingleSelectionIndicator() {
							return this._hideSingleSelectionIndicator
						}
						set hideSingleSelectionIndicator(e) {
							;(this._hideSingleSelectionIndicator = Mn(e)), this._syncParentProperties()
						}
						_syncParentProperties() {
							if (this.options) for (const e of this.options) e._changeDetectorRef.markForCheck()
						}
						static {
							this.ɵfac = (function () {
								let e
								return function (r) {
									return (e || (e = gr(t)))(r || t)
								}
							})()
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-select"]],
								contentQueries: function (i, r, o) {
									if ((1 & i && (yr(o, vY, 5), yr(o, Qh, 5), yr(o, i9, 5)), 2 & i)) {
										let s
										sn((s = an())) && (r.customTrigger = s.first),
											sn((s = an())) && (r.options = s),
											sn((s = an())) && (r.optionGroups = s)
									}
								},
								hostAttrs: [
									"role",
									"combobox",
									"aria-autocomplete",
									"none",
									"aria-haspopup",
									"listbox",
									"ngSkipHydration",
									"",
									1,
									"mat-mdc-select"
								],
								hostVars: 19,
								hostBindings: function (i, r) {
									1 & i &&
										Le("keydown", function (s) {
											return r._handleKeydown(s)
										})("focus", function () {
											return r._onFocus()
										})("blur", function () {
											return r._onBlur()
										}),
										2 & i &&
											(qn("id", r.id)("tabindex", r.tabIndex)("aria-controls", r.panelOpen ? r.id + "-panel" : null)(
												"aria-expanded",
												r.panelOpen
											)("aria-label", r.ariaLabel || null)("aria-required", r.required.toString())(
												"aria-disabled",
												r.disabled.toString()
											)("aria-invalid", r.errorState)("aria-activedescendant", r._getAriaActiveDescendant()),
											Zt("mat-mdc-select-disabled", r.disabled)("mat-mdc-select-invalid", r.errorState)(
												"mat-mdc-select-required",
												r.required
											)("mat-mdc-select-empty", r.empty)("mat-mdc-select-multiple", r.multiple))
								},
								inputs: {
									disabled: "disabled",
									disableRipple: "disableRipple",
									tabIndex: "tabIndex",
									panelWidth: "panelWidth",
									hideSingleSelectionIndicator: "hideSingleSelectionIndicator"
								},
								exportAs: ["matSelect"],
								features: [
									Xn([
										{ provide: CO, useExisting: t },
										{ provide: n9, useExisting: t }
									]),
									pn
								],
								ngContentSelectors: UFe,
								decls: 11,
								vars: 10,
								consts: [
									["cdk-overlay-origin", "", 1, "mat-mdc-select-trigger", 3, "click"],
									["fallbackOverlayOrigin", "cdkOverlayOrigin", "trigger", ""],
									[1, "mat-mdc-select-value", 3, "ngSwitch"],
									["class", "mat-mdc-select-placeholder mat-mdc-select-min-line", 4, "ngSwitchCase"],
									["class", "mat-mdc-select-value-text", 3, "ngSwitch", 4, "ngSwitchCase"],
									[1, "mat-mdc-select-arrow-wrapper"],
									[1, "mat-mdc-select-arrow"],
									[
										"viewBox",
										"0 0 24 24",
										"width",
										"24px",
										"height",
										"24px",
										"focusable",
										"false",
										"aria-hidden",
										"true"
									],
									["d", "M7 10l5 5 5-5z"],
									[
										"cdk-connected-overlay",
										"",
										"cdkConnectedOverlayLockPosition",
										"",
										"cdkConnectedOverlayHasBackdrop",
										"",
										"cdkConnectedOverlayBackdropClass",
										"cdk-overlay-transparent-backdrop",
										3,
										"cdkConnectedOverlayPanelClass",
										"cdkConnectedOverlayScrollStrategy",
										"cdkConnectedOverlayOrigin",
										"cdkConnectedOverlayOpen",
										"cdkConnectedOverlayPositions",
										"cdkConnectedOverlayWidth",
										"backdropClick",
										"attach",
										"detach"
									],
									[1, "mat-mdc-select-placeholder", "mat-mdc-select-min-line"],
									[1, "mat-mdc-select-value-text", 3, "ngSwitch"],
									["class", "mat-mdc-select-min-line", 4, "ngSwitchDefault"],
									[4, "ngSwitchCase"],
									[1, "mat-mdc-select-min-line"],
									["role", "listbox", "tabindex", "-1", 3, "ngClass", "keydown"],
									["panel", ""]
								],
								template: function (i, r) {
									if (
										(1 & i &&
											(co(NFe),
											F(0, "div", 0, 1),
											Le("click", function () {
												return r.toggle()
											}),
											F(3, "div", 2),
											Ee(4, DFe, 2, 1, "span", 3),
											Ee(5, PFe, 3, 2, "span", 4),
											L(),
											F(6, "div", 5)(7, "div", 6),
											Xa(),
											F(8, "svg", 7),
											fe(9, "path", 8),
											L()()()(),
											Ee(10, OFe, 3, 9, "ng-template", 9),
											Le("backdropClick", function () {
												return r.close()
											})("attach", function () {
												return r._onAttached()
											})("detach", function () {
												return r.close()
											})),
										2 & i)
									) {
										const o = br(1)
										T(3),
											U("ngSwitch", r.empty),
											qn("id", r._valueId),
											T(1),
											U("ngSwitchCase", !0),
											T(1),
											U("ngSwitchCase", !1),
											T(5),
											U("cdkConnectedOverlayPanelClass", r._overlayPanelClass)(
												"cdkConnectedOverlayScrollStrategy",
												r._scrollStrategy
											)("cdkConnectedOverlayOrigin", r._preferredOverlayOrigin || o)(
												"cdkConnectedOverlayOpen",
												r.panelOpen
											)("cdkConnectedOverlayPositions", r._positions)("cdkConnectedOverlayWidth", r._overlayWidth)
									}
								},
								dependencies: [Em, w0, R2, KQ, MG, QD],
								styles: [
									'.mat-mdc-select{display:inline-block;width:100%;outline:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-select-enabled-trigger-text-color);font-family:var(--mat-select-trigger-text-font);line-height:var(--mat-select-trigger-text-line-height);font-size:var(--mat-select-trigger-text-size);font-weight:var(--mat-select-trigger-text-weight);letter-spacing:var(--mat-select-trigger-text-tracking)}.mat-mdc-select-disabled{color:var(--mat-select-disabled-trigger-text-color)}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:translateY(-8px)}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-select-arrow{width:10px;height:5px;position:relative;color:var(--mat-select-enabled-arrow-color)}.mat-mdc-form-field.mat-focused .mat-mdc-select-arrow{color:var(--mat-select-focused-arrow-color)}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-invalid .mat-mdc-select-arrow{color:var(--mat-select-invalid-arrow-color)}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-disabled .mat-mdc-select-arrow{color:var(--mat-select-disabled-arrow-color)}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:GrayText}div.mat-mdc-select-panel{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);width:100%;max-height:275px;outline:0;overflow:auto;padding:8px 0;border-radius:4px;box-sizing:border-box;position:static;background-color:var(--mat-select-panel-background-color)}.cdk-high-contrast-active div.mat-mdc-select-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) div.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above div.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1);color:var(--mat-select-placeholder-text-color)}._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper{cursor:pointer}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}'
								],
								encapsulation: 2,
								data: { animation: [HFe.transformPanel] },
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				yY = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [zFe], imports: [Ot, Ev, r9, Yi, _v, ww, r9, Yi] })
						}
					}
					return t
				})(),
				KFe = (() => {
					class t {
						transform(e, i) {
							const r = i.toLocaleLowerCase()
							return e.filter(o => o.name.toLocaleLowerCase().includes(r))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "filterMetricDataBySearchTerm", type: t, pure: !0 })
						}
					}
					return t
				})()
			const XFe = ["searchTermInput"]
			function YFe(t, n) {
				if ((1 & t && (F(0, "span", 13), ge(1), L()), 2 & t)) {
					const e = n.ngIf
					T(1), Vt(" ", e, " ")
				}
			}
			function qFe(t, n) {
				if (
					(1 & t &&
						(F(0, "mat-option", 10),
						Me(1, "attributeDescriptorTooltip"),
						ge(2),
						F(3, "span", 11),
						ge(4),
						L(),
						fe(5, "br"),
						Ee(6, YFe, 2, 1, "span", 12),
						L()),
					2 & t)
				) {
					const e = n.$implicit,
						i = Te().ngIf
					U("value", e.name)("title", lo(1, 5, i[e.name], e.name)),
						T(2),
						Vt(" ", e.name, " "),
						T(2),
						Vt("(", e.maxValue, ")"),
						T(2),
						U("ngIf", null == i[e.name] ? null : i[e.name].description)
				}
			}
			function ZFe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-select", 3),
						Le("selectionChange", function (r) {
							return rn(e), on(Te().handleMetricChanged(r.value))
						})("openedChange", function (r) {
							return rn(e), on(Te().handleOpenedChanged(r))
						}),
						F(1, "mat-select-trigger"),
						ge(2),
						L(),
						F(3, "mat-form-field", 4),
						fe(4, "i", 5),
						F(5, "input", 6, 7),
						Le("ngModelChange", function (r) {
							return rn(e), on((Te().searchTerm = r))
						}),
						L()(),
						F(7, "div", 8),
						Ee(8, qFe, 7, 8, "mat-option", 9),
						Me(9, "filterMetricDataBySearchTerm"),
						Me(10, "async"),
						L()()
				}
				if (2 & t) {
					const e = Te()
					U("panelClass", "cc-metric-chooser")("value", e.selectedMetricName)("disabled", e.isDisabled),
						T(2),
						cr(e.selectedMetricName),
						T(3),
						U("placeholder", e.searchPlaceholder)("ngModel", e.searchTerm),
						T(3),
						U("ngForOf", lo(9, 7, De(10, 10, e.metricData$), e.searchTerm))
				}
			}
			function JFe(t, n) {
				1 & t && Ln(0, 0, ["*ngIf", "!isHovered"])
			}
			const eBe = [[["", "hoveredInformation", ""]]],
				tBe = ["[hoveredInformation]"]
			let Cw = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.type = "node"),
							(this.isDisabled = !1),
							(this.searchTerm = ""),
							(this.attributeDescriptors$ = this.store.select(qS)),
							(this.isHovered = !1),
							(this.isOpened = !1)
					}
					ngOnInit() {
						this.metricData$ = this.store.select(Fs).pipe(Ke(e => ("node" === this.type ? e.nodeMetricData : e.edgeMetricData)))
					}
					handleOpenedChanged(e) {
						e ? this.searchTermInput.nativeElement.focus() : (this.searchTerm = ""), (this.isOpened = e)
					}
					onMouseEnter() {
						this.isHovered = !0
					}
					onMouseLeave() {
						this.isOpened || (this.isHovered = !1)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-metric-chooser"]],
							viewQuery: function (i, r) {
								if ((1 & i && _i(XFe, 5), 2 & i)) {
									let o
									sn((o = an())) && (r.searchTermInput = o.first)
								}
							},
							inputs: {
								selectedMetricName: "selectedMetricName",
								searchPlaceholder: "searchPlaceholder",
								handleMetricChanged: "handleMetricChanged",
								type: "type",
								isDisabled: "isDisabled"
							},
							ngContentSelectors: tBe,
							decls: 4,
							vars: 4,
							consts: [
								[3, "mouseenter", "mouseleave"],
								[3, "panelClass", "value", "disabled", "selectionChange", "openedChange", 4, "ngIf"],
								[4, "ngIf"],
								[3, "panelClass", "value", "disabled", "selectionChange", "openedChange"],
								[1, "cc-metric-chooser-search-field"],
								["matPrefix", "", 1, "fa", "fa-search", "search-icon"],
								["matInput", "", "type", "text", 3, "placeholder", "ngModel", "ngModelChange"],
								["searchTermInput", ""],
								[1, "cc-metric-chooser-option-container"],
								[3, "value", "title", 4, "ngFor", "ngForOf"],
								[3, "value", "title"],
								[1, "metric-max-value"],
								["class", "metric-subtitle", 4, "ngIf"],
								[1, "metric-subtitle"]
							],
							template: function (i, r) {
								1 & i &&
									(co(eBe),
									F(0, "div", 0),
									Le("mouseenter", function () {
										return r.onMouseEnter()
									})("mouseleave", function () {
										return r.onMouseLeave()
									}),
									Ee(1, ZFe, 11, 12, "mat-select", 1),
									Me(2, "async"),
									Ee(3, JFe, 1, 0, "ng-content", 2),
									L()),
									2 & i && (T(1), U("ngIf", De(2, 2, r.attributeDescriptors$)), T(2), U("ngIf", !r.isHovered))
							},
							dependencies: [_o, En, Bd, XX, Fp, jFe, Qh, kp, km, T0, P0, Bn, JS, KFe],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-metric-chooser{width:100%}cc-metric-chooser cc-metric-chooser-value,cc-metric-chooser .cc-metric-chooser-container{position:absolute;top:10%;right:28px}cc-metric-chooser cc-metric-chooser-value .metric-value,cc-metric-chooser .cc-metric-chooser-container .metric-value{height:25px}cc-metric-chooser cc-metric-chooser-value .metric-value .rounded-box,cc-metric-chooser .cc-metric-chooser-container .metric-value .rounded-box{background-color:#e6e6e6;border-radius:2px;padding:2px 5px;display:inline-block}cc-metric-chooser .mat-mdc-select{border-bottom:none}.mat-mdc-select-panel.cc-metric-chooser{margin-top:16px;overflow:hidden}.mat-mdc-select-panel.cc-metric-chooser .cc-metric-chooser-search-field{width:100%;font-size:14px;padding:0 6px}.mat-mdc-select-panel.cc-metric-chooser .cc-metric-chooser-search-field .search-icon{color:#1b9cfc;margin-left:8px;font-size:18px}.mat-mdc-select-panel.cc-metric-chooser .cc-metric-chooser-search-field .mat-mdc-form-field-subscript-wrapper.mat-mdc-form-field-bottom-align{display:none}.mat-mdc-select-panel.cc-metric-chooser .cc-metric-chooser-search-field .mat-mdc-form-field-infix{margin-left:6px;display:flex}.mat-mdc-select-panel.cc-metric-chooser .cc-metric-chooser-option-container{max-height:216px;overflow-y:auto;font-size:16px;padding:0 6px}.mat-mdc-select-panel.cc-metric-chooser .cc-metric-chooser-option-container mat-option .metric-max-value{color:#ccc}.mat-mdc-select-panel.cc-metric-chooser .cc-metric-chooser-option-container mat-option .metric-subtitle{color:#999;font-size:11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) .mdc-menu-surface.mat-mdc-select-panel{min-width:300px;position:absolute;right:0}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const wY = Mt(_b, mw, (t, n) => t.get(n))
			class nBe {
				constructor() {
					;(this.vertexShaderCode = A(4902)), (this.fragmentShaderCode = A(1204))
				}
			}
			class iBe {
				constructor(n) {
					;(this._buildings = new Array()), (this.mapSize = n), (this.scales = new K(1, 1, 1))
				}
				add(n) {
					this._buildings.push(n)
				}
				get buildings() {
					return this._buildings
				}
				setScales(n) {
					this.scales = new K(n.x, n.y, n.z)
				}
				getBuildingByPath(n) {
					return this.buildings.find(e => e.node.path === n)
				}
				intersect(n) {
					let e,
						i = Number.POSITIVE_INFINITY
					const r = this.scales.clone().multiplyScalar(this.mapSize).multiply(new K(-1, 0, -1))
					for (const o of this._buildings) {
						const s = o.boundingBox.clone()
						if (
							(s.min.multiply(this.scales),
							s.max.multiply(this.scales),
							s.translate(r),
							this.rayIntersectsAxisAlignedBoundingBox(n, s))
						) {
							const a = n.intersectBox(s, new K())
							if (a) {
								const c = a.distanceTo(n.origin)
								c < i && ((i = c), (e = o))
							}
						}
					}
					return e
				}
				rayIntersectsAxisAlignedBoundingBox(n, e) {
					const i = (1 / n.direction.x) * (e.min.x - n.origin.x),
						r = (1 / n.direction.x) * (e.max.x - n.origin.x)
					let o = Math.min(i, r),
						s = Math.max(i, r)
					const a = (1 / n.direction.y) * (e.min.y - n.origin.y),
						c = (1 / n.direction.y) * (e.max.y - n.origin.y)
					return (o = Math.max(o, Math.min(a, c))), (s = Math.min(s, Math.max(a, c))), s >= o
				}
			}
			class rBe {
				constructor(n, e, i, r) {
					;(this._id = n),
						(this._boundingBox = e),
						(this._color = r),
						(this._defaultColor = r),
						(this._deltaColor = "#000000"),
						(this._defaultDeltaColor = "#000000"),
						(this._node = i)
				}
				getCenterPoint(n) {
					return new K(
						this._node.x0 - n + this._node.width / 2,
						this._node.z0 + this._node.height,
						this._node.y0 - n + this._node.length / 2
					)
				}
				decreaseLightness(n) {
					;(this._color = this._decreaseLightnessForColor(this._defaultColor, n)),
						this._node.deltas && (this._deltaColor = this._decreaseLightnessForColor(this._defaultDeltaColor, n))
				}
				_decreaseLightnessForColor(n, e) {
					const i = Li.hexToHSL(n)
					return i.decreaseLightness(e), i.getLightness() < 10 ? i.setLightness(10) : i.setLightness(i.getLightness()), i.toHex()
				}
				getColorVector() {
					return Li.getVector3(this._color)
				}
				getDefaultColorVector() {
					return Li.getVector3(this._defaultColor)
				}
				getDeltaColorVector() {
					return Li.getVector3(this._deltaColor)
				}
				getDefaultDeltaColorVector() {
					return Li.getVector3(this._defaultDeltaColor)
				}
				resetColor() {
					;(this._color = this._defaultColor), (this._deltaColor = this._defaultDeltaColor)
				}
				equals(n) {
					return this._id === n._id
				}
				get id() {
					return this._id
				}
				get boundingBox() {
					return this._boundingBox
				}
				get color() {
					return this._color
				}
				get node() {
					return this._node
				}
				get deltaColor() {
					return this._deltaColor
				}
				get defaultDeltaColor() {
					return this._defaultDeltaColor
				}
				setColor(n) {
					this._color = n
				}
				setNode(n) {
					this._node = n
				}
				setInitialDeltaColor(n) {
					;(this._defaultDeltaColor = n), (this._deltaColor = n)
				}
				setDeltaColor(n) {
					this._deltaColor = n
				}
			}
			var dk = (function (t) {
				return (
					(t[(t.left = 0)] = "left"),
					(t[(t.right = 1)] = "right"),
					(t[(t.bottom = 2)] = "bottom"),
					(t[(t.top = 3)] = "top"),
					(t[(t.back = 4)] = "back"),
					(t[(t.front = 5)] = "front"),
					t
				)
			})(dk || {})
			const oBe = [
					[-1, 0, 0],
					[1, 0, 0],
					[0, -1, 0],
					[0, 1, 0],
					[0, 0, -1],
					[0, 0, 1]
				],
				xY = [
					1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1,
					1, 0, 0, 0, 0, 1, 1, 1
				]
			function CY(t, n, e, i, r, o, s) {
				o.add(new rBe(r, new is(new K(e.x, e.y, e.z), new K(e.x + e.width, e.y + e.height, e.z + e.depth)), n, i)),
					t.uvs.set(xY, r * xY.length),
					(function sBe(t, n, e) {
						const { x: i, y: r, z: o, width: s, height: a, depth: c } = n,
							l = i + s,
							d = r + a,
							u = o + c
						let h = 4 * e * 6 * 3
						;(t[h++] = i),
							(t[h++] = r),
							(t[h++] = o),
							(t[h++] = i),
							(t[h++] = d),
							(t[h++] = o),
							(t[h++] = i),
							(t[h++] = d),
							(t[h++] = u),
							(t[h++] = i),
							(t[h++] = r),
							(t[h++] = u),
							(t[h++] = l),
							(t[h++] = r),
							(t[h++] = o),
							(t[h++] = l),
							(t[h++] = d),
							(t[h++] = o),
							(t[h++] = l),
							(t[h++] = d),
							(t[h++] = u),
							(t[h++] = l),
							(t[h++] = r),
							(t[h++] = u),
							(t[h++] = i),
							(t[h++] = r),
							(t[h++] = o),
							(t[h++] = i),
							(t[h++] = r),
							(t[h++] = u),
							(t[h++] = l),
							(t[h++] = r),
							(t[h++] = u),
							(t[h++] = l),
							(t[h++] = r),
							(t[h++] = o),
							(t[h++] = i),
							(t[h++] = d),
							(t[h++] = o),
							(t[h++] = i),
							(t[h++] = d),
							(t[h++] = u),
							(t[h++] = l),
							(t[h++] = d),
							(t[h++] = u),
							(t[h++] = l),
							(t[h++] = d),
							(t[h++] = o),
							(t[h++] = l),
							(t[h++] = r),
							(t[h++] = u),
							(t[h++] = i),
							(t[h++] = r),
							(t[h++] = u),
							(t[h++] = i),
							(t[h++] = d),
							(t[h++] = u),
							(t[h++] = l),
							(t[h++] = d),
							(t[h++] = u),
							(t[h++] = l),
							(t[h++] = r),
							(t[h++] = o),
							(t[h++] = i),
							(t[h++] = r),
							(t[h++] = o),
							(t[h++] = i),
							(t[h++] = d),
							(t[h++] = o),
							(t[h++] = l),
							(t[h++] = d),
							(t[h++] = o)
					})(t.positions, e, r),
					(function cBe(t, n, e, i, r, o) {
						const { y: s, height: a } = n,
							l = i / (s + a - s)
						let d = 6 * r * 4,
							u = 3 * d,
							h = 6 * r * 6
						const f = Li.getVector3Array(e)
						for (let _ = 0; _ < 6; _++) {
							const y = aBe(_, t),
								C = oBe[_],
								x = d,
								w = d + 1,
								S = d + 2,
								M = d + 3
							o.isHeight.set(y, d)
							for (const j = d + 4; d < j; d++)
								o.normals.set(C, u), o.colors.set(f, u), (u += 3), (o.ids[d] = r), (o.deltas[d] = l)
							const O = Math.floor(_ / 2)
							o.indices.set(1 === C[O] ? [x, w, S, x, S, M] : [x, S, w, x, M, S], h), (h += 6)
						}
					})(n, e, i, s, r, t)
			}
			function aBe(t, n) {
				return n.isLeaf && t !== dk.bottom
					? t === dk.top
						? [1, 1, 1, 1]
						: t <= dk.right
						? [0, 1, 1, 0]
						: [0, 0, 1, 1]
					: [0, 0, 0, 0]
			}
			let lBe = (() => {
					class t {
						static {
							this.MINIMAL_BUILDING_HEIGHT = 1
						}
						build(e, i, r, o) {
							const s = new iBe(Oo)
							;(this.floorGradient = Li.gradient("#333333", "#DDDDDD", this.getMaxNodeDepth(e))), (this.materials = [i])
							const a = e.length,
								h = 4 * a * 6,
								f = {
									positions: new Float32Array(3 * h),
									uvs: new Float32Array(2 * h),
									normals: new Float32Array(3 * h),
									colors: new Float32Array(3 * h),
									indices: new Uint32Array(6 * a * 6),
									ids: new Float32Array(h),
									deltas: new Float32Array(h),
									isHeight: new Float32Array(h)
								}
							for (const [_, y] of e.entries()) y.isLeaf ? this.addBuilding(f, y, _, s, r, o) : this.addFloor(f, y, _, s)
							return { mesh: this.buildMeshFromIntermediateVertexData(f), desc: s }
						}
						getMaxNodeDepth(e) {
							return e.reduce((i, { depth: r }) => Math.max(r, i), 0)
						}
						mapNodeToLocalBox(e) {
							return { x: e.x0, y: e.z0, z: e.y0, width: e.width, height: e.height, depth: e.length }
						}
						ensureMinHeightUnlessDeltaIsNegative(e, i) {
							return i <= 0 ? e : Math.max(e, t.MINIMAL_BUILDING_HEIGHT)
						}
						addFloor(e, i, r, o) {
							const s = this.getMarkingColorWithGradient(i)
							CY(e, i, this.mapNodeToLocalBox(i), s, r, o, 0)
						}
						getMarkingColorWithGradient(e) {
							if (e.markingColor) {
								const r = Li.getNumber(e.markingColor) & (e.depth % 2 == 0 ? 14540253 : 16777215)
								return Li.convertNumberToHex(r)
							}
							return this.floorGradient[e.depth]
						}
						addBuilding(e, i, r, o, s, a) {
							const c = this.mapNodeToLocalBox(i)
							c.height = this.ensureMinHeightUnlessDeltaIsNegative(i.height, i.heightDelta)
							let l = 0
							a &&
								i.deltas &&
								i.deltas[s.dynamicSettings.heightMetric] &&
								i.heightDelta &&
								((l = i.heightDelta), !i.flat && l < 0 && (c.height += Math.abs(l))),
								CY(e, i, c, i.color, r, o, l)
						}
						buildMeshFromIntermediateVertexData(e) {
							const o = new Float32Array(e.colors),
								s = new vn()
							return (
								s.setAttribute("position", new xn(e.positions, 3)),
								s.setAttribute("normal", new xn(e.normals, 3)),
								s.setAttribute("isHeight", new xn(e.isHeight, 1)),
								s.setAttribute("uv", new xn(e.uvs, 2)),
								s.setAttribute("color", new xn(e.colors, 3)),
								s.setAttribute("deltaColor", new xn(o, 3)),
								s.setAttribute("subGeomIdx", new xn(e.ids, 1)),
								s.setAttribute("delta", new xn(e.deltas, 1)),
								s.setIndex(new xn(e.indices, 1)),
								s.addGroup(0, Number.POSITIVE_INFINITY, 0),
								new Mi(s, this.materials)
							)
						}
					}
					return t
				})(),
				dBe = (() => {
					class t {
						static {
							this.NUM_OF_COLOR_VECTOR_FIELDS = 3
						}
						static {
							this.NUM_OF_VERTICES = 24
						}
						static {
							this.LIGHTNESS_INCREASE = -10
						}
						static {
							this.LIGHTNESS_DECREASE = 20
						}
						constructor(e, i, r) {
							this.initMaterial(), (this.geomGen = new lBe()), (this.material.precision = "lowp")
							const o = this.geomGen.build(e, this.material, i, r)
							;(this.threeMesh = o.mesh), (this.mapGeomDesc = o.desc), (this.nodes = e), this.initDeltaColorsOnMesh(i)
						}
						getThreeMesh() {
							return this.threeMesh
						}
						getNodes() {
							return this.nodes
						}
						selectBuilding(e, i) {
							e.setColor(i),
								e.setDeltaColor(i),
								this.setVertexColor(e.id, e.getColorVector(), e.getDeltaColorVector()),
								this.updateVertices()
						}
						clearSelection(e) {
							e.resetColor(),
								this.setVertexColor(e.id, e.getDefaultColorVector(), e.getDefaultDeltaColorVector()),
								this.updateVertices()
						}
						getMeshDescription() {
							return this.mapGeomDesc
						}
						getBuildingByPath(e) {
							return this.mapGeomDesc.getBuildingByPath(e)
						}
						checkMouseRayMeshIntersection(e, i) {
							const r = this.calculatePickingRay(e, i)
							return this.getMeshDescription().intersect(r)
						}
						setScale(e) {
							this.mapGeomDesc.setScales(e)
						}
						highlightBuilding(e, i, r, o) {
							const s = $s.buildingArrayToMap(e)
							for (const a of this.mapGeomDesc.buildings)
								this.isBuildingSelected(i, a) ||
									(s.get(a.id) || o.get(a.id)
										? a.decreaseLightness(t.LIGHTNESS_INCREASE)
										: this.adjustSurroundingBuildingColors(e, a, r),
									this.setVertexColor(a.id, a.getColorVector(), a.getDeltaColorVector()))
							this.updateVertices()
						}
						clearHighlight(e) {
							for (const i of this.mapGeomDesc.buildings)
								this.isBuildingSelected(e, i) ||
									this.setVertexColor(i.id, i.getDefaultColorVector(), i.getDefaultDeltaColorVector())
							this.updateVertices()
						}
						adjustSurroundingBuildingColors(e, i, r) {
							if (r.appSettings.isPresentationMode) {
								const o = e[0].getCenterPoint(Oo).distanceTo(i.getCenterPoint(Oo))
								this.decreaseLightnessByDistance(i, o)
							} else i.decreaseLightness(t.LIGHTNESS_DECREASE)
						}
						initDeltaColorsOnMesh(e) {
							if (this.mapGeomDesc.buildings[0]?.node.deltas) {
								for (const i of this.mapGeomDesc.buildings)
									this.setNewDeltaColor(i, e), this.setVertexColor(i.id, i.getColorVector(), i.getDeltaColorVector())
								this.updateVertices()
							}
						}
						setNewDeltaColor(e, i) {
							const {
									appSettings: { mapColors: r },
									dynamicSettings: { heightMetric: o }
								} = i,
								{ node: s } = e
							if (s.flat) e.setInitialDeltaColor(r.flat)
							else if (s.deltas) {
								const a = s.deltas[o]
								a > 0 && e.setInitialDeltaColor(r.positiveDelta), a < 0 && e.setInitialDeltaColor(r.negativeDelta)
							}
						}
						isBuildingSelected(e, i) {
							return e && i.equals(e)
						}
						decreaseLightnessByDistance(e, i) {
							i > 800
								? e.decreaseLightness(40)
								: i > 400
								? e.decreaseLightness(30)
								: i > 250
								? e.decreaseLightness(20)
								: i > 100
								? e.decreaseLightness(15)
								: i > 50 && e.decreaseLightness(10)
						}
						setVertexColor(e, i, r) {
							const o = t.NUM_OF_VERTICES,
								s = e * o,
								a = this.threeMesh.geometry.getAttribute("color"),
								c = this.threeMesh.geometry.getAttribute("deltaColor")
							for (let l = s; l < s + o; l += 1) a.setXYZ(l, i.x, i.y, i.z), c.setXYZ(l, r.x, r.y, r.z)
						}
						updateVertices() {
							;(this.threeMesh.geometry.getAttribute("color").needsUpdate = !0),
								(this.threeMesh.geometry.getAttribute("deltaColor").needsUpdate = !0)
						}
						dispose() {
							this.disposeMesh(), this.disposeMaterial()
						}
						disposeMesh() {
							this.threeMesh?.geometry?.dispose()
						}
						disposeMaterial() {
							this.material?.dispose()
						}
						initMaterial() {
							const e = UM.merge([Ht.lights]),
								i = new nBe()
							this.material = new Ds({
								vertexShader: i.vertexShaderCode,
								fragmentShader: i.fragmentShaderCode,
								lights: !0,
								uniforms: e
							})
						}
						calculatePickingRay(e, i) {
							const r = new Ru()
							return (
								r.origin.setFromMatrixPosition(i.matrixWorld),
								r.direction.set(e.x, e.y, 0.5).unproject(i).sub(r.origin).normalize(),
								r
							)
						}
					}
					return t
				})()
			function uBe(t) {
				;(t.x0 = Math.round(t.x0)), (t.y0 = Math.round(t.y0)), (t.x1 = Math.round(t.x1)), (t.y1 = Math.round(t.y1))
			}
			function hBe(t, n, e, i, r) {
				for (var s, o = t.children, a = -1, c = o.length, l = t.value && (i - n) / t.value; ++a < c; )
					((s = o[a]).y0 = e), (s.y1 = r), (s.x0 = n), (s.x1 = n += s.value * l)
			}
			function fBe(t, n, e, i, r) {
				for (var s, o = t.children, a = -1, c = o.length, l = t.value && (r - e) / t.value; ++a < c; )
					((s = o[a]).x0 = n), (s.x1 = i), (s.y0 = e), (s.y1 = e += s.value * l)
			}
			const ABe = (function t(n) {
				function e(i, r, o, s, a) {
					!(function pBe(t, n, e, i, r, o) {
						for (
							var c, l, f, _, C, x, w, S, M, O, N, s = [], a = n.children, d = 0, u = 0, h = a.length, y = n.value;
							d < h;

						) {
							;(f = r - e), (_ = o - i)
							do {
								C = a[u++].value
							} while (!C && u < h)
							for (x = w = C, N = C * C * (O = Math.max(_ / f, f / _) / (y * t)), M = Math.max(w / N, N / x); u < h; ++u) {
								if (
									((C += l = a[u].value),
									l < x && (x = l),
									l > w && (w = l),
									(N = C * C * O),
									(S = Math.max(w / N, N / x)) > M)
								) {
									C -= l
									break
								}
								M = S
							}
							s.push((c = { value: C, dice: f < _, children: a.slice(d, u) })),
								c.dice ? hBe(c, e, i, r, y ? (i += (_ * C) / y) : o) : fBe(c, e, i, y ? (e += (f * C) / y) : r, o),
								(y -= C),
								(d = u)
						}
					})(n, i, r, o, s, a)
				}
				return (
					(e.ratio = function (i) {
						return t((i = +i) > 1 ? i : 1)
					}),
					e
				)
			})((1 + Math.sqrt(5)) / 2)
			function Ew() {
				return 0
			}
			function Mw(t) {
				return function () {
					return t
				}
			}
			function gBe() {
				var t = ABe,
					n = !1,
					e = 1,
					i = 1,
					r = [0],
					o = Ew,
					s = Ew,
					a = Ew,
					c = Ew,
					l = Ew
				function d(h) {
					return (h.x0 = h.y0 = 0), (h.x1 = e), (h.y1 = i), h.eachBefore(u), (r = [0]), n && h.eachBefore(uBe), h
				}
				function u(h) {
					var f = r[h.depth],
						_ = h.x0 + f,
						y = h.y0 + f,
						C = h.x1 - f,
						x = h.y1 - f
					C < _ && (_ = C = (_ + C) / 2),
						x < y && (y = x = (y + x) / 2),
						(h.x0 = _),
						(h.y0 = y),
						(h.x1 = C),
						(h.y1 = x),
						h.children &&
							((f = r[h.depth + 1] = o(h) / 2),
							(_ += l(h) - f),
							(y += s(h) - f),
							(C -= a(h) - f) < _ && (_ = C = (_ + C) / 2),
							(x -= c(h) - f) < y && (y = x = (y + x) / 2),
							t(h, _, y, C, x))
				}
				return (
					(d.round = function (h) {
						return arguments.length ? ((n = !!h), d) : n
					}),
					(d.size = function (h) {
						return arguments.length ? ((e = +h[0]), (i = +h[1]), d) : [e, i]
					}),
					(d.tile = function (h) {
						return arguments.length
							? ((t = (function EY(t) {
									if ("function" != typeof t) throw new Error()
									return t
							  })(h)),
							  d)
							: t
					}),
					(d.padding = function (h) {
						return arguments.length ? d.paddingInner(h).paddingOuter(h) : d.paddingInner()
					}),
					(d.paddingInner = function (h) {
						return arguments.length ? ((o = "function" == typeof h ? h : Mw(+h)), d) : o
					}),
					(d.paddingOuter = function (h) {
						return arguments.length ? d.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h) : d.paddingTop()
					}),
					(d.paddingTop = function (h) {
						return arguments.length ? ((s = "function" == typeof h ? h : Mw(+h)), d) : s
					}),
					(d.paddingRight = function (h) {
						return arguments.length ? ((a = "function" == typeof h ? h : Mw(+h)), d) : a
					}),
					(d.paddingBottom = function (h) {
						return arguments.length ? ((c = "function" == typeof h ? h : Mw(+h)), d) : c
					}),
					(d.paddingLeft = function (h) {
						return arguments.length ? ((l = "function" == typeof h ? h : Mw(+h)), d) : l
					}),
					d
				)
			}
			const MY = 0.4,
				SY = 120,
				kY = 95,
				bBe = 0.035,
				_Be = 0.028
			function TY(t, n, e, i, r, o, s, a, c, l, d) {
				const u = []
				for (const h of t.children) {
					const f = h.data.fixedPosition,
						_ = BY(h.data, n, d, c)
					for (const y of _.treeMap.descendants()) {
						const C = f.width / _.width,
							x = f.height / _.height
						;(y.x0 = (y.x0 * C + f.left) * i),
							(y.x1 = (y.x1 * C + f.left) * i),
							(y.y0 = (y.y0 * x + f.top) * e),
							(y.y1 = (y.y1 * x + f.top) * e),
							(y.x0 += r),
							(y.x1 += r),
							(y.y0 += o),
							(y.y1 += o)
						const w = $s.buildNodeFrom(y, s, a, n, l)
						if ((u.push(w), FY(h.data))) {
							Array.prototype.push.apply(u, TY(h, n, w.length / 100, w.width / 100, y.x0, y.y0, s, a, c, l, d))
							break
						}
					}
				}
				return u
			}
			function FY(t) {
				return !!t.children[0]?.fixedPosition
			}
			function BY(t, n, e, i) {
				const r = $r(t),
					o = IY(r),
					{ enableFloorLabels: s } = n.appSettings,
					{ margin: a } = n.dynamicSettings,
					c = a * MY * e
				let l, d
				void 0 !== t.fixedPosition ? ((l = t.fixedPosition.width), (d = t.fixedPosition.height)) : ((l = 2 * Oo), (d = 2 * Oo))
				let u = 0
				r.eachAfter(C => {
					!uo(C) && s && (0 === C.depth && (u += SY), C.depth > 0 && C.depth < 3 && (u += kY))
				})
				const h = (l + o * a + u) * e,
					f = (d + o * a + u) * e
				let _
				return {
					treeMap: gBe()
						.size([h, f])
						.paddingOuter(c)
						.paddingInner(c)
						.paddingRight(C => {
							if ((!_ && null === C.parent && (_ = C), _ && s)) {
								if (0 === C.depth) return Math.max((_.x1 - _.x0) * bBe, SY)
								if (C.depth > 0 && C.depth < 3) return Math.max((_.x1 - _.x0) * _Be, kY)
							}
							return c
						})(
						r.sum(
							C =>
								(function xBe(t, { dynamicSettings: n, appSettings: e, fileSettings: i }, r) {
									if (t.isExcluded) return 0
									if (
										t.deltas &&
										(function wBe(t, n) {
											return 0 === t.attributes[n.areaMetric] && t.deltas[n.heightMetric] < 0
										})(t, n)
									)
										return Math.abs(t.deltas[n.areaMetric])
									if (uo(t) && t.attributes?.[n.areaMetric]) {
										const o = n.areaMetric
										return 1 === i.attributeDescriptors[o]?.direction
											? e.invertArea
												? t.attributes[n.areaMetric]
												: r - t.attributes[n.areaMetric]
											: e.invertArea
											? r - t.attributes[n.areaMetric]
											: t.attributes[n.areaMetric]
									}
									return 0
								})(C, n, i) * e
						)
					),
					height: f,
					width: h
				}
			}
			function IY(t) {
				let n = 0,
					e = 0
				return (
					t.each(({ data: i }) => {
						;(i.isExcluded || i.isFlattened) && e++, n++
					}),
					2 * Math.sqrt(n - e)
				)
			}
			class wf {
				constructor(n, e, i) {
					;(this.topLeft = n), (this.bottomRight = n.clone().add(new lt(e, i))), (this.width = e), (this.height = i)
				}
				shorterSide() {
					return this.width > this.height ? this.height : this.width
				}
				isVertical() {
					return this.height > this.width
				}
				area() {
					return this.width * this.height
				}
				getBottomRight() {
					return this.bottomRight
				}
			}
			class LO {
				constructor(n) {
					;(this.height = 0), (this.width = 0), (this.FIXED_MARGIN = 0.5), (this.node = n)
				}
				createMarginatedRectangle(n) {
					const e = new lt(n.x + this.FIXED_MARGIN, n.y + this.FIXED_MARGIN)
					return new wf(e, this.width - 2 * this.FIXED_MARGIN, this.height - 2 * this.FIXED_MARGIN)
				}
			}
			var RO = (function (t) {
				return (t[(t.Horizontal = 0)] = "Horizontal"), (t[(t.Vertical = 1)] = "Vertical"), t
			})(RO || {})
			class DY extends LO {
				constructor() {
					super(...arguments), (this.spacer = 2), (this.maxStreetThickness = 10)
				}
				getStreetThickness() {
					return this.maxStreetThickness / (this.depth + 1)
				}
			}
			function uk(t, n) {
				let e = t.attributes[n] || 0
				if (0 === e && t.children && t.children.length > 0) for (const i of t.children) e += uk(i, n)
				return e
			}
			const kb = {
				calculateSize: uk,
				mergeDirectories: function CBe(t, n) {
					let e = t
					const i = uk(t, n)
					for (const r of t.children)
						if (!uo(r) && i === uk(r, n)) {
							const s = e.name
							;(e = r), (e.name = `${s}/${r.name}`)
							break
						}
					return e
				},
				buildNodeFrom: function EBe(t, n, e, i, r) {
					const o = !(t.children && t.children.length > 0),
						s = WS(t, i),
						a = $s.getHeightValue(i, t, e, s),
						c = Math.abs(o ? Math.max(n * a, $s.MIN_BUILDING_HEIGHT) : $s.FOLDER_HEIGHT),
						l = t.rect.height,
						d = t.rect.topLeft.x,
						u = t.rect.topLeft.y,
						h = t.zOffset * $s.FOLDER_HEIGHT
					return {
						name: t.name,
						id: t.id,
						width: t.rect.width,
						height: c,
						length: l,
						depth: t.zOffset,
						mapNodeDepth: 100,
						x0: d,
						z0: h,
						y0: u,
						isLeaf: o,
						attributes: t.attributes,
						edgeAttributes: t.edgeAttributes,
						deltas: t.deltas,
						heightDelta: t.deltas?.[i.dynamicSettings.heightMetric] ? n * t.deltas[i.dynamicSettings.heightMetric] : 0,
						visible: ZP(t, o, i, s),
						path: t.path,
						link: t.link,
						markingColor: vE(t, i.fileSettings.markedPackages),
						flat: s,
						color: JP(t, i, gf(i), r, s),
						incomingEdgePoint: $S(t.rect.width, c, l, new K(d, h, u), Oo),
						outgoingEdgePoint: $S(t.rect.width, c, l, new K(d, h, u), Oo)
					}
				}
			}
			var xf = (function (t) {
				return (t[(t.RIGHT = 0)] = "RIGHT"), (t[(t.LEFT = 1)] = "LEFT"), t
			})(xf || {})
			class Bp extends DY {
				constructor(n, e, i, r = xf.RIGHT) {
					super(n),
						(this.children = []),
						(this.topRow = []),
						(this.bottomRow = []),
						(this.children = e),
						(this.depth = i),
						(this.orientation = r)
				}
				calculateDimension(n) {
					for (const e of this.children) e.calculateDimension(n)
					this.splitChildrenToRows(this.children),
						this.rearrangeRows(),
						(this.metricValue = kb.calculateSize(this.node, n)),
						(this.width = Math.max(this.getLength(this.topRow), this.getLength(this.bottomRow))),
						(this.height =
							this.getMaxHeight(this.topRow) +
							this.getStreetThickness() +
							this.getMaxHeight(this.bottomRow) +
							2 * this.spacer)
				}
				layout(n, e) {
					const i = this.getMaxHeight(this.topRow),
						r = this.layoutTopRow(e, i, n),
						o = this.layoutBottomRow(e, i, n)
					return [...r, this.layoutStreet(e, i), ...o]
				}
				layoutTopRow(n, e, i) {
					const r = new lt(n.x, n.y),
						o = []
					if (this.orientation === xf.LEFT) {
						const s = this.getLength(this.topRow)
						r.x += this.width - s
					}
					for (let s = 0; s < this.topRow.length; s++) {
						const a = this.calculateChildOriginX(r, s, this.topRow),
							c = this.calculateStreetOffsetY(r, e) - this.topRow[s].height,
							l = new lt(a, c)
						o.push(...this.topRow[s].layout(i, l))
					}
					return o
				}
				layoutStreet(n, e) {
					const i = this.calculateStreetOffsetY(n, e),
						r = new lt(n.x, i),
						o = this.calculateStreetOverhang(r),
						s = this.width - o
					return (
						(r.x += this.orientation === xf.LEFT ? o : 0),
						(this.streetRect = new wf(r, s, this.getStreetThickness())),
						{ ...this.node, value: this.metricValue, rect: this.streetRect, zOffset: 0 }
					)
				}
				layoutBottomRow(n, e, i) {
					const r = new lt(n.x, n.y),
						o = []
					if (this.orientation === xf.LEFT) {
						const s = this.getLength(this.bottomRow)
						r.x += this.width - s
					}
					for (let s = 0; s < this.bottomRow.length; s++) {
						const a = this.calculateChildOriginX(r, s, this.bottomRow),
							c = this.calculateStreetOffsetY(r, e) + this.getStreetThickness(),
							l = new lt(a, c)
						o.push(...this.bottomRow[s].layout(i, l))
					}
					return o
				}
				calculateChildOriginX(n, e, i) {
					return n.x + this.getLengthUntil(i, e)
				}
				calculateStreetOffsetY(n, e) {
					return n.y + this.spacer + e
				}
				getLength(n) {
					return this.getLengthUntil(n, n.length)
				}
				getLengthUntil(n, e) {
					let i = 0
					for (let r = 0; r < e; r++) i += n[r].width
					return i
				}
				splitChildrenToRows(n) {
					const e = this.getLength(n)
					let i = 0
					for (const r of n)
						i < e / 2
							? (this.topRow.push(r), (i += r.width))
							: (r instanceof Tb && (r.orientation = Cf.DOWN), this.bottomRow.push(r))
				}
				rearrangeRows() {
					this.orientation === xf.RIGHT ? this.bottomRow.reverse() : this.topRow.reverse()
				}
				getMaxHeight(n) {
					return n.reduce((e, i) => Math.max(e, i.height), Number.MIN_VALUE)
				}
				calculateStreetOverhang(n) {
					return this.orientation === xf.LEFT ? this.calculateLeftStreetOverhang(n) : this.calculateRightStreetOverhang(n)
				}
				calculateLeftStreetOverhang(n) {
					const e = this.topRow[0],
						i = this.bottomRow[0],
						r = e instanceof Tb && e.streetRect ? e.streetRect.topLeft.x - n.x : this.width - this.getLength(this.topRow),
						o = i instanceof Tb && i.streetRect ? i.streetRect.topLeft.x - n.x : this.width - this.getLength(this.bottomRow)
					return r > 0 && o > 0 ? Math.min(r, o) : 0
				}
				calculateRightStreetOverhang(n) {
					const e = this.topRow.at(-1),
						i = this.bottomRow.at(-1),
						r = n.x + this.width,
						o =
							e instanceof Tb && e.streetRect
								? r - e.streetRect.getBottomRight().x
								: this.width - this.getLength(this.topRow),
						s =
							i instanceof Tb && i.streetRect
								? r - i.streetRect.getBottomRight().x
								: this.width - this.getLength(this.bottomRow)
					return o > 0 && s > 0 ? Math.min(o, s) : 0
				}
			}
			var Cf = (function (t) {
				return (t[(t.UP = 0)] = "UP"), (t[(t.DOWN = 1)] = "DOWN"), t
			})(Cf || {})
			class Tb extends DY {
				constructor(n, e, i, r = Cf.UP) {
					super(n),
						(this.children = []),
						(this.leftRow = []),
						(this.rightRow = []),
						(this.children = e),
						(this.depth = i),
						(this.orientation = r)
				}
				calculateDimension(n) {
					for (const e of this.children) e.calculateDimension(n)
					this.splitChildrenToRows(this.children),
						this.rearrangeRows(),
						(this.metricValue = kb.calculateSize(this.node, n)),
						(this.width =
							this.getMaxWidth(this.leftRow) + this.getStreetThickness() + this.getMaxWidth(this.rightRow) + 2 * this.spacer),
						(this.height = Math.max(this.getLength(this.leftRow), this.getLength(this.rightRow)))
				}
				layout(n, e) {
					const i = this.getMaxWidth(this.leftRow),
						r = this.layoutLeftRow(e, i, n),
						o = this.layoutRightRow(e, i, n)
					return [...r, this.layoutStreet(e, i), ...o]
				}
				layoutLeftRow(n, e, i) {
					const r = new lt(n.x, n.y),
						o = []
					if (this.orientation === Cf.UP) {
						const s = this.getLength(this.leftRow)
						r.y += this.height - s
					}
					for (let s = 0; s < this.leftRow.length; s++) {
						const a = this.calculateStreetOffsetX(r, e) - this.leftRow[s].width,
							c = this.calculateChildOriginY(r, s, this.leftRow),
							l = new lt(a, c)
						o.push(...this.leftRow[s].layout(i, l))
					}
					return o
				}
				layoutStreet(n, e) {
					const i = this.calculateStreetOffsetX(n, e),
						r = new lt(i, n.y),
						o = this.calculateStreetOverhang(r),
						s = this.height - o,
						a = this.metricValue
					return (
						(r.y += this.orientation === Cf.UP ? o : 0),
						(this.streetRect = new wf(r, this.getStreetThickness(), s)),
						{ ...this.node, value: a, rect: this.streetRect, zOffset: 0 }
					)
				}
				layoutRightRow(n, e, i) {
					const r = new lt(n.x, n.y),
						o = []
					if (this.orientation === Cf.UP) {
						const s = this.getLength(this.rightRow)
						r.y += this.height - s
					}
					for (let s = 0; s < this.rightRow.length; s++) {
						const a = this.calculateStreetOffsetX(r, e) + this.getStreetThickness(),
							c = this.calculateChildOriginY(r, s, this.rightRow),
							l = new lt(a, c)
						o.push(...this.rightRow[s].layout(i, l))
					}
					return o
				}
				calculateStreetOffsetX(n, e) {
					return n.x + this.spacer + e
				}
				calculateChildOriginY(n, e, i) {
					return n.y + this.getLengthUntil(i, e)
				}
				getLength(n) {
					return this.getLengthUntil(n, n.length)
				}
				getLengthUntil(n, e) {
					let i = 0
					for (let r = 0; r < e; r++) i += n[r].height
					return i
				}
				splitChildrenToRows(n) {
					const e = this.getLength(n)
					let i = 0
					for (const r of n)
						i < e / 2
							? (r instanceof Bp && (r.orientation = xf.LEFT), this.leftRow.push(r), (i += r.height))
							: this.rightRow.push(r)
				}
				rearrangeRows() {
					this.orientation === Cf.UP ? this.leftRow.reverse() : this.rightRow.reverse()
				}
				getMaxWidth(n) {
					return n.reduce((e, i) => Math.max(e, i.width), Number.MIN_VALUE)
				}
				calculateStreetOverhang(n) {
					return this.orientation === Cf.UP ? this.calculateTopStreetOverhang(n) : this.calculateBottomStreetOverhang(n)
				}
				calculateTopStreetOverhang(n) {
					const e = this.leftRow[0],
						i = this.rightRow[0],
						r = e instanceof Bp && e.streetRect ? e.streetRect.topLeft.y - n.y : this.height - this.getLength(this.leftRow),
						o = i instanceof Bp && i.streetRect ? i.streetRect.topLeft.y - n.y : this.height - this.getLength(this.rightRow)
					return r > 0 && o > 0 ? Math.min(r, o) : 0
				}
				calculateBottomStreetOverhang(n) {
					const e = this.leftRow.at(-1),
						i = this.rightRow.at(-1),
						r = n.y + this.height,
						o =
							e instanceof Bp && e.streetRect
								? r - e.streetRect.getBottomRight().y
								: this.height - this.getLength(this.leftRow),
						s =
							i instanceof Bp && i.streetRect
								? r - i.streetRect.getBottomRight().y
								: this.height - this.getLength(this.rightRow)
					return o > 0 && s > 0 ? Math.min(o, s) : 0
				}
			}
			class MBe extends LO {
				constructor(n) {
					super(n)
				}
				calculateDimension(n) {
					this.metricValue = kb.calculateSize(this.node, n)
					const e = Math.sqrt(this.metricValue)
					this.width = this.height = e
				}
				layout(n, e) {
					return [{ ...this.node, value: this.metricValue, rect: this.createMarginatedRectangle(e), zOffset: 0 }]
				}
			}
			class SBe extends LO {
				constructor(n) {
					super(n), (this.treeMapNodes = [])
				}
				calculateDimension(n) {
					;(this.metricName = n),
						(this.metricValue = $s.calculateSize(this.node, n)),
						(this.width = Math.sqrt(this.metricValue)),
						(this.height = Math.sqrt(this.metricValue))
				}
			}
			class LY {
				constructor(n) {
					;(this.nodes = []), (this.nodes = n)
				}
				totalScaledSize(n, e, i, r) {
					return n.reduce((o, s) => o + this.scaledSize(s, i, r, e), 0)
				}
				totalSize(n) {
					return this.nodes.reduce((e, i) => e + $s.calculateSize(i, n), 0)
				}
				min(n, e, i, r) {
					return n.reduce((o, s) => Math.min(o, this.scaledSize(s, i, r, e)), Number.MAX_VALUE)
				}
				max(n, e, i, r) {
					return n.reduce((o, s) => Math.max(o, this.scaledSize(s, i, r, e)), Number.MIN_VALUE)
				}
				populate(n, e, i, r) {
					for (const o of n) {
						const s = this.worstAspectRatio(this.nodes, e, i, r)
						if (!(this.worstAspectRatio([...this.nodes, o], e, i, r) < s)) break
						this.nodes.push(o)
					}
				}
				scaledSize(n, e, i, r) {
					return (i / e) * $s.calculateSize(n, r)
				}
				applyNodeMargin(n, e) {
					const i = new lt(n.topLeft.x + e, n.topLeft.y + e)
					return new wf(i, n.width - 2 * e, n.height - 2 * e)
				}
			}
			var PO = (function (t) {
				return (t[(t.leftToRight = 0)] = "leftToRight"), (t[(t.rightToLeft = 1)] = "rightToLeft"), t
			})(PO || {})
			class RY extends LY {
				constructor(n) {
					super(n)
				}
				layout(n, e, i, r, o, s = PO.leftToRight) {
					let a = n.topLeft.x
					s !== PO.leftToRight && this.nodes.reverse()
					const c = this.nodes,
						l = n.area(),
						d = n.width,
						u = this.totalScaledSize(c, i, e, l) / d,
						h = []
					for (const f of c) {
						const _ = this.scaledSize(f, e, l, i),
							y = u > 0 ? _ / u : 0,
							C = new wf(new lt(a, n.topLeft.y), y, u)
						h.push({ ...f, value: "File" === f.type ? e : 0, rect: this.applyNodeMargin(C, o), zOffset: r }), (a += y)
					}
					return h
				}
				worstAspectRatio(n, e, i, r) {
					const o = e.width,
						s = e.area(),
						a = this.totalScaledSize(n, r, i, s),
						c = this.min(n, r, i, s),
						l = this.max(n, r, i, s),
						d = Math.pow(o, 2),
						u = Math.pow(a, 2)
					return Math.max((d * l) / u, u / (d * c))
				}
			}
			var OO = (function (t) {
				return (t[(t.topToBottom = 0)] = "topToBottom"), (t[(t.bottomToTop = 1)] = "bottomToTop"), t
			})(OO || {})
			class kBe extends LY {
				constructor(n) {
					super(n)
				}
				layout(n, e, i, r, o, s = OO.topToBottom) {
					let a = n.topLeft.y
					s !== OO.topToBottom && this.nodes.reverse()
					const c = this.nodes,
						l = n.area(),
						d = n.height,
						u = this.totalScaledSize(c, i, e, l) / d,
						h = []
					for (const f of c) {
						const _ = this.scaledSize(f, e, l, i),
							y = u > 0 ? _ / u : 0,
							C = new wf(new lt(n.topLeft.x, a), u, y)
						h.push({ ...f, value: "File" === f.type ? e : 0, rect: this.applyNodeMargin(C, o), zOffset: r }), (a += y)
					}
					return h
				}
				worstAspectRatio(n, e, i, r) {
					const o = e.height,
						s = e.area(),
						a = this.totalScaledSize(n, r, i, s),
						c = this.min(n, r, i, s),
						l = this.max(n, r, i, s),
						d = o ** 2,
						u = a ** 2
					return Math.max((d * l) / u, u / (d * c))
				}
			}
			class TBe extends SBe {
				constructor(n) {
					super(n)
				}
				layout(n, e = new lt(0, 0)) {
					const i = this.createMarginatedRectangle(e),
						r = { ...this.node, value: this.metricValue, rect: i, zOffset: 0 },
						o = this.node.children.filter(s => $s.calculateSize(s, this.metricName) > 0)
					return this.treeMapNodes.push(r), o.length > 0 && this.createNodes(o, i, this.metricValue, 1, n), this.treeMapNodes
				}
				createNodes(n, e, i, r, o) {
					let s = 0,
						a = new wf(new lt(e.topLeft.x, e.topLeft.y), e.width, e.height),
						c = i
					const l = this.orderBySizeDescending(n)
					do {
						const d = this.createStrip(a, l.slice(s), c),
							u = d.totalSize(this.metricName)
						if (u > 0) {
							const h = this.createStripNodes(d, a, c, r, o)
							this.createChildrenNodes(h, r, o), (a = this.remainingRectangle(a, d, c, a.area())), (c -= u)
						}
						s += d.nodes.length
					} while (s < l.length)
				}
				createStrip(n, e, i) {
					const r = e[0],
						o = n.isVertical() ? new RY([r]) : new kBe([r])
					return o.populate(e.slice(1), n, i, this.metricName), o
				}
				remainingRectangle(n, e, i, r) {
					const o = e.totalScaledSize(e.nodes, this.metricName, i, r)
					let s,
						a = n.width,
						c = n.height
					if (e instanceof RY) {
						const l = o / n.width
						;(c -= l), (s = new lt(n.topLeft.x, n.topLeft.y + l))
					} else {
						const l = o / n.height
						;(a -= l), (s = new lt(n.topLeft.x + l, n.topLeft.y))
					}
					return new wf(s, a, c)
				}
				createStripNodes(n, e, i, r, o, s) {
					const a = n.layout(e, i, this.metricName, r, o, s)
					return this.treeMapNodes.push(...a), a
				}
				createChildrenNodes(n, e, i) {
					for (const r of n)
						if (r.children && r.children.length > 0) {
							const o = r.children.filter(s => $s.calculateSize(s, this.metricName) > 0)
							if (o.length > 0) {
								const s = $s.calculateSize(r, this.metricName)
								this.createNodes(o, r.rect, s, e + 1, i)
							}
						}
				}
				orderBySizeDescending(n) {
					return n.sort((e, i) => $s.calculateSize(i, this.metricName) - $s.calculateSize(e, this.metricName))
				}
			}
			class Ip {
				static createStreetLayoutNodes(n, e, i, r) {
					const o = wE(e.files),
						s = i.find(y => y.name === e.dynamicSettings.heightMetric).maxValue * o,
						a = ((2 * Oo) / s) * 0.1,
						c = e.dynamicSettings.areaMetric,
						l = kb.mergeDirectories(n, c),
						u = this.createBoxes(l, c, e, RO.Vertical, 0, e.appSettings.maxTreeMapFiles),
						h = new Bp(l, u, 0)
					return (
						h.calculateDimension(c),
						h.layout(0.02 * e.dynamicSettings.margin, new lt(0, 0)).map(y => kb.buildNodeFrom(y, a, s, e, r))
					)
				}
				static createBoxes(n, e, i, r, o, s) {
					const a = [],
						c = i.dynamicSettings.areaMetric
					for (let l of n.children) {
						if (vu(l.path, i.fileSettings.blacklist, "exclude")) continue
						if (uo(l)) {
							a.push(new MBe(l))
							continue
						}
						const d = i.appSettings.layoutAlgorithm,
							u = Ip.countFileDescendants(l)
						if (d === Ad.TreeMapStreet && u <= s) {
							const h = Ip.createTreeMap(l)
							a.push(h)
						} else {
							l = kb.mergeDirectories(l, c)
							const h = Ip.createBoxes(l, e, i, 1 - r, o + 1, s),
								f = Ip.createStreet(l, r, h, o)
							a.push(f)
						}
					}
					return a
				}
				static createStreet(n, e, i, r) {
					return e === RO.Horizontal ? new Bp(n, i, r) : new Tb(n, i, r)
				}
				static createTreeMap(n) {
					return new TBe(n)
				}
				static countFileDescendants(n) {
					let e = 0
					for (const i of n.children) e += uo(i) ? 1 : Ip.countFileDescendants(i)
					return e
				}
			}
			const PY = Mt(Tr, t => t.amountOfEdgePreviews),
				IBe = Mt(Fs, zu, PY, (t, n, e) => new Set(DBe(t.nodeEdgeMetricsMap, n, e))),
				DBe = (t, n, e) => {
					const i = []
					if (0 === e) return i
					const r = t.get(n)
					if (void 0 === r) return i
					for (const o of r.keys()) if ((i.push(o), i.length === e)) break
					return i
				},
				LBe = Mt(fv, t => t.edges),
				PBe = Mt(IBe, LBe, zu, (t, n, e) => {
					const i = dd(n)
					return (
						((t, n, e) => {
							for (const i of n)
								if (((i.visible = gd.none), void 0 !== i.attributes[e])) {
									const r = t.has(i.fromNodeName),
										o = t.has(i.toNodeName)
									r && o ? (i.visible = gd.both) : r ? (i.visible = gd.from) : o && (i.visible = gd.to)
								}
						})(t, i, e),
						i
					)
				})
			let OBe = (() => {
					class t {
						constructor(e, i, r, o) {
							;(this.store = e),
								(this.state = i),
								(this.threeSceneService = r),
								(this.idToBuildingService = o),
								(this.VERTICES_PER_LINE = 5),
								(this.arrows = new Array()),
								(this.HIGHLIGHT_BUILDING_DELAY = 1),
								(this.debounceCalculation = Fd(s => this.resetEdgesOfBuildings(s), this.HIGHLIGHT_BUILDING_DELAY)),
								(this.subscription = this.store
									.select(mw)
									.pipe(
										eo(s => {
											if (null !== s) {
												const a = this.idToBuildingService.get(s)
												this.onBuildingHovered(a)
											} else this.onBuildingUnhovered()
										})
									)
									.subscribe()),
								(this.resetEdgesOfBuildings = s => {
									this.isEdgeApplicableForBuilding(s) && (this.clearArrows(), this.showEdgesOfBuildings(s)), this.scale()
								}),
								(this.onBuildingSelected = s => {
									this.isEdgeApplicableForBuilding(s.building) && (this.clearArrows(), this.showEdgesOfBuildings()),
										this.scale()
								}),
								(this.onBuildingDeselected = () => {
									this.clearArrows(), this.addEdgePreview()
								}),
								this.threeSceneService.subscribe("onBuildingSelected", this.onBuildingSelected),
								this.threeSceneService.subscribe("onBuildingDeselected", this.onBuildingDeselected)
						}
						ngOnDestroy() {
							this.subscription.unsubscribe()
						}
						onBuildingHovered(e) {
							this.debounceCalculation(e)
						}
						onBuildingUnhovered() {
							const { isEdgeMetricVisible: e } = this.state.getValue().appSettings
							e && (this.clearArrows(), this.showEdgesOfBuildings()), this.scale()
						}
						clearArrows() {
							;(this.arrows = []), (this.threeSceneService.edgeArrows.children.length = 0)
						}
						addArrow(e, i, r) {
							const { appSettings: o, dynamicSettings: s } = this.state.getValue(),
								a = 100 * o.edgeHeight
							if (e.attributes?.[s.heightMetric] && i.attributes?.[s.heightMetric]) {
								const c = this.createCurve(i, e, a),
									l = Li.getNumber(o.mapColors[r ? "outgoingEdge" : "incomingEdge"])
								this.highlightBuilding(r ? e : i), this.setCurveColor(c, l)
							}
						}
						addEdgePreview() {
							const e = PBe(this.state.getValue())
							for (const i of e) {
								const r = this.map.get(i.fromNodeName),
									o = this.map.get(i.toNodeName)
								if (r && o && i.visible !== gd.none && i.visible) {
									const s = 100 * this.state.getValue().appSettings.edgeHeight,
										a = this.createCurve(r, o, s)
									this.previewMode(a, i.visible)
								}
							}
						}
						addEdgeMapBasedOnNodes(e) {
							this.map = this.getNodesAsMap(e)
						}
						scale() {
							const { scaling: e } = this.state.getValue().appSettings
							for (const i of this.arrows) (i.scale.x = e.x), (i.scale.y = e.y), (i.scale.z = e.z)
						}
						isEdgeApplicableForBuilding(e) {
							return this.state.getValue().appSettings.isEdgeMetricVisible && e && !e.node.flat
						}
						showEdgesOfBuildings(e) {
							const i = new Map(),
								r = this.threeSceneService.getSelectedBuilding()
							if (r) {
								const { node: o } = r
								i.set(o.path, o)
							}
							if (e) {
								const { node: o } = e
								i.set(o.path, o)
							}
							i.size > 0 ? this.buildPairingEdges(i) : this.addEdgePreview()
						}
						buildPairingEdges(e) {
							const { edges: i } = this.state.getValue().fileSettings
							for (const r of i) {
								const o = this.map.get(r.fromNodeName)
								if (void 0 === o) continue
								const s = this.map.get(r.toNodeName)
								void 0 !== s &&
									(e.has(o.path)
										? (this.addArrow(s, o, !0), this.threeSceneService.highlightBuildings())
										: e.has(s.path) && (this.addArrow(s, o, !1), this.threeSceneService.highlightBuildings()))
							}
						}
						createCurve(e, i, r) {
							const o = e.outgoingEdgePoint.clone(),
								s = i.incomingEdgePoint.clone(),
								a = Math.max(o.y + i.height, s.y + 1) + r
							return o.setY(a), s.setY(a), new kS(e.outgoingEdgePoint, o, s, i.incomingEdgePoint)
						}
						highlightBuilding(e) {
							const i = this.threeSceneService.getMapMesh().getMeshDescription().getBuildingByPath(e.path)
							this.threeSceneService.addBuildingToHighlightingList(i)
						}
						setCurveColor(e, i, r = 50) {
							const o = e.getPoints(r),
								s = this.buildLine(o, i)
							s.add(this.buildArrow(o)), this.threeSceneService.edgeArrows.add(s), this.arrows.push(s)
						}
						previewMode(e, i) {
							if (i === gd.both || i === gd.from) {
								const r = this.makeArrowFromBezier(e, !1)
								this.threeSceneService.edgeArrows.add(r), this.arrows.push(r)
							}
							if (i === gd.both || i === gd.to) {
								const r = this.makeArrowFromBezier(e, !0)
								this.threeSceneService.edgeArrows.add(r), this.arrows.push(r)
							}
						}
						getNodesAsMap(e) {
							const i = new Map()
							for (const r of e) i.set(r.path, r)
							return i
						}
						makeArrowFromBezier(e, i, r = 50) {
							const o = e.getPoints(r),
								{ incomingEdge: s, outgoingEdge: a } = this.state.getValue().appSettings.mapColors,
								c = i ? s : a,
								l = i ? o.slice(r + 1 - this.VERTICES_PER_LINE) : o.slice(0, o.length - (r + 1 - this.VERTICES_PER_LINE))
							return this.buildEdge(l, Li.getNumber(c))
						}
						buildEdge(e, i) {
							const r = this.buildLine(e, i)
							return r.add(this.buildArrow(e)), r
						}
						buildLine(e, i = 0) {
							const r = new vn()
							return r.setFromPoints(e), new ma(r, new Go({ color: i, linewidth: 1 }))
						}
						buildArrow(e, i = 0, r = 10, o = 10) {
							const s = e.at(-1).clone().sub(e.at(-2).clone()).normalize(),
								a = e.at(-1).clone()
							return s.y < 0 && (a.y += r + 1), new BK(s, a, r + 1, i, r, o)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(Sr), re(Qc), re(lw))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				OY = (() => {
					class t {
						constructor(e, i, r, o, s, a, c) {
							;(this.store = e),
								(this.state = i),
								(this.threeSceneService = r),
								(this.codeMapLabelService = o),
								(this.codeMapArrowService = s),
								(this.threeStatsService = a),
								(this.codeMapMouseEventService = c),
								(this.nodesByColor = { positive: [], neutral: [], negative: [] }),
								(this.onIsLoadingFileChanged = l => {
									l ? this.threeSceneService?.dispose() : this.threeStatsService?.resetPanels()
								}),
								(this.subscription = this.store.select(jL).pipe(eo(this.onIsLoadingFileChanged)).subscribe())
						}
						ngOnDestroy() {
							this.subscription.unsubscribe()
						}
						render(e) {
							const i = this.getNodes(e),
								r = this.getVisibleNodes(i)
							;(this.unflattenedNodes = r.filter(({ flat: o }) => !o)),
								this.setNewMapMesh(i, r),
								this.getNodesMatchingColorSelector(this.unflattenedNodes),
								this.setLabels(this.unflattenedNodes),
								this.setArrows(r)
						}
						setNewMapMesh(e, i) {
							const r = this.state.getValue(),
								o = new dBe(i, r, ad(r.files))
							this.threeSceneService.setMapMesh(e, o)
						}
						scaleMap() {
							this.codeMapMouseEventService.unhoverNode(),
								this.codeMapLabelService.scale(),
								this.codeMapArrowService.scale(),
								this.threeSceneService.scaleHeight(),
								this.codeMapLabelService.clearLabels(),
								this.setLabels(this.unflattenedNodes)
						}
						getNodes(e) {
							const i = this.state.getValue(),
								r = Fs(i).nodeMetricData,
								{
									appSettings: { layoutAlgorithm: o },
									files: s
								} = i,
								a = ad(s)
							switch (o) {
								case Ad.StreetMap:
								case Ad.TreeMapStreet:
									return Ip.createStreetLayoutNodes(e, i, r, a)
								case Ad.SquarifiedTreeMap:
									return (function vBe(t, n, e, i) {
										const r = wE(n.files),
											o = e.find(d => d.name === n.dynamicSettings.heightMetric)?.maxValue * r,
											s = e.find(d => d.name === n.dynamicSettings.areaMetric)?.maxValue * r,
											a = (2 * Oo) / o
										if (FY(t)) {
											const d = $r(t),
												u = [$s.buildRootFolderForFixedFolders(d.data, a, n, i)],
												h = 2 * Oo + IY(d) * (n.dynamicSettings.margin / MY),
												f = h / u[0].width,
												_ = h / u[0].length
											return (
												(function yBe(t, n, e) {
													;(t.x0 *= e), (t.y0 *= n), (t.width *= e), (t.length *= n)
												})(u[0], f, _),
												[...u, ...TY(d, n, f, _, 0, 0, a, o, s, i, r)]
											)
										}
										const c = BY(t, n, r, s),
											l = []
										for (const d of c.treeMap) l.push($s.buildNodeFrom(d, a, o, n, i))
										return l
									})(e, i, r, a)
								default:
									return []
							}
						}
						getVisibleNodes(e) {
							return e.filter(i => i.visible && i.length > 0 && i.width > 0).sort((i, r) => r.height - i.height)
						}
						getNodesMatchingColorSelector(e) {
							const i = this.state.getValue().dynamicSettings
							this.nodesByColor = { positive: [], negative: [], neutral: [] }
							for (const r of e)
								if (r.isLeaf) {
									const o = r.attributes[i.colorMetric]
									"unary" === i.colorMetric
										? this.nodesByColor.positive.push(r)
										: null !== o &&
										  (o < i.colorRange.from
												? this.nodesByColor.positive.push(r)
												: o < i.colorRange.to
												? this.nodesByColor.neutral.push(r)
												: this.nodesByColor.negative.push(r))
								}
						}
						setBuildingLabel(e, i) {
							for (const r of e) this.codeMapLabelService.addLeafLabel(r, i)
						}
						setLabels(e) {
							if ((this.codeMapLabelService.clearLabels(), void 0 === e || 0 === e.length)) return
							const {
								showMetricLabelNodeName: i,
								showMetricLabelNameValue: r,
								colorLabels: o,
								amountOfTopLabels: s
							} = this.state.getValue().appSettings
							if (i || r) {
								const a = e[0].height
								for (const c of ["positive", "neutral", "negative"]) o[c] && this.setBuildingLabel(this.nodesByColor[c], a)
								if (!(o.negative || o.neutral || o.positive)) {
									const c = e.filter(l => l.isLeaf).slice(0, s)
									this.setBuildingLabel(c, a)
								}
							}
						}
						setArrows(e) {
							this.codeMapArrowService.clearArrows(),
								this.codeMapArrowService.addEdgeMapBasedOnNodes(e),
								this.codeMapArrowService.addEdgePreview()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(Sr), re(Qc), re(cX), re(OBe), re(sX), re(pw))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				hk = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e), (this.codeMapRenderService = i)
						}
						createNodeObservable() {
							return xu([this.store.select(wY), this.store.select(bf), this.createTopLevelNodeObservable()]).pipe(
								Ke(([o, s, a]) => o ?? s ?? a)
							)
						}
						createTopLevelNodeObservable() {
							return xu([this.store.select(Vc), this.store.select(cc)]).pipe(
								xi(([e]) => !!e.unifiedMapNode),
								Ke(([e]) => this.findTopLevelNode(e))
							)
						}
						findTopLevelNode(e) {
							const i = this.codeMapRenderService.getNodes(e.unifiedMapNode)
							return this.codeMapRenderService
								.getVisibleNodes(i)
								.reduce((o, s) => (o.attributes.unary > s.attributes.unary ? o : s))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(OY))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				NY = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e),
								(this.nodeSelectionService = i),
								(this.isNodeALeaf = r => {
									if (r) return this.isNode(r) ? r.isLeaf : uo(r)
								})
						}
						ngOnInit() {
							;(this.isNodeALeaf$ = this.nodeSelectionService.createNodeObservable().pipe(Ke(e => this.isNodeALeaf(e)))),
								(this.attributeType$ = this.store.select(
									((t, n) => Mt(YS, KP, (e, i) => ("relative" === i[t][e[n]] ? "x\u0342" : "\u03a3")))(
										this.attributeType,
										this.metricFor
									)
								))
						}
						isNode(e) {
							return "isLeaf" in e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct), P(hk))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-metric-chooser-type"]],
								inputs: { metricFor: "metricFor", attributeType: "attributeType" },
								decls: 4,
								vars: 6,
								consts: [[3, "hidden"]],
								template: function (i, r) {
									1 & i && (F(0, "span", 0), Me(1, "async"), ge(2), Me(3, "async"), L()),
										2 & i && (U("hidden", De(1, 2, r.isNodeALeaf$)), T(2), Vt(" ", De(3, 4, r.attributeType$), "\n"))
								},
								dependencies: [Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function UBe(t, n) {
				if ((1 & t && (F(0, "div", 6), Me(1, "async"), Me(2, "async"), ge(3), Me(4, "async"), L()), 2 & t)) {
					const e = Te().$implicit,
						i = Te()
					bi("margin-left", "2px")(
						"background-color",
						"heightMetric" === i.metricFor && e.deltas[De(1, 5, i.primaryMetricNames$)[i.metricFor]] > 0
							? "#b1d8a8"
							: e.deltas[De(2, 7, i.primaryMetricNames$)[i.metricFor]] < 0
							? "#ffcccc"
							: "#e6e6e6"
					),
						T(3),
						Vt(" \u0394", e.deltas[De(4, 9, i.primaryMetricNames$)[i.metricFor]], " ")
				}
			}
			function HBe(t, n) {
				if (
					(1 & t &&
						(F(0, "div", 1)(1, "div", 2),
						fe(2, "cc-metric-chooser-type", 3),
						F(3, "span", 4),
						ge(4),
						Me(5, "async"),
						L()(),
						Ee(6, UBe, 5, 11, "div", 5),
						L()),
					2 & t)
				) {
					const e = n.$implicit,
						i = Te()
					T(2),
						U("attributeType", "nodes")("metricFor", i.metricFor),
						T(2),
						cr(e.attributes[De(5, 4, i.primaryMetricNames$)[i.metricFor]]),
						T(2),
						U("ngIf", e.deltas)
				}
			}
			let NO = (() => {
					class t {
						constructor(e, i) {
							;(this.nodeSelectionService = e),
								(this.store = i),
								(this.node$ = this.nodeSelectionService.createNodeObservable()),
								(this.primaryMetricNames$ = this.store.select(YS))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(hk), P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-metric-chooser-value"]],
								inputs: { metricFor: "metricFor" },
								decls: 2,
								vars: 3,
								consts: [
									["class", "metric-value", 4, "ngIf"],
									[1, "metric-value"],
									[1, "rounded-box"],
									[3, "attributeType", "metricFor"],
									[1, "value"],
									["class", "rounded-box value", 3, "marginLeft", "backgroundColor", 4, "ngIf"],
									[1, "rounded-box", "value"]
								],
								template: function (i, r) {
									1 & i && (Ee(0, HBe, 7, 6, "div", 0), Me(1, "async")), 2 & i && U("ngIf", De(1, 1, r.node$))
								},
								dependencies: [En, NY, Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				VBe = (() => {
					class t {
						constructor(e) {
							;(this.store = e), (this.areaMetric$ = this.store.select(Cb))
						}
						handleAreaMetricChanged(e) {
							this.store.dispatch(gu({ value: e }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-area-metric-chooser"]],
								decls: 4,
								vars: 6,
								consts: [
									[1, "fa", "fa-arrows-alt"],
									["title", "Change area metric", 3, "selectedMetricName", "searchPlaceholder", "handleMetricChanged"],
									["hoveredInformation", "", 3, "metricFor"]
								],
								template: function (i, r) {
									1 & i &&
										(fe(0, "i", 0),
										F(1, "cc-metric-chooser", 1),
										Me(2, "async"),
										fe(3, "cc-metric-chooser-value", 2),
										L()),
										2 & i &&
											(T(1),
											U("selectedMetricName", De(2, 4, r.areaMetric$))(
												"searchPlaceholder",
												"Area Metric (highest value)"
											)("handleMetricChanged", r.handleAreaMetricChanged),
											T(2),
											U("metricFor", "areaMetric"))
								},
								dependencies: [Cw, NO, Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const QBe = Mt(cc, t => t.margin),
				zBe = Mt(Tr, t => t.enableFloorLabels),
				GBe = Mt(Tr, t => t.invertArea),
				$Be = ["input"],
				WBe = ["label"],
				jBe = ["*"],
				KBe = new He("mat-checkbox-default-options", { providedIn: "root", factory: UY })
			function UY() {
				return { color: "accent", clickAction: "check-indeterminate" }
			}
			const XBe = { provide: ds, useExisting: Kn(() => Fb), multi: !0 }
			class YBe {}
			let qBe = 0
			const HY = UY(),
				ZBe = GE(
					_g(
						Um(
							Sv(
								class {
									constructor(t) {
										this._elementRef = t
									}
								}
							)
						)
					)
				)
			let JBe = (() => {
					class t extends ZBe {
						get inputId() {
							return `${this.id || this._uniqueId}-input`
						}
						get required() {
							return this._required
						}
						set required(e) {
							this._required = Mn(e)
						}
						constructor(e, i, r, o, s, a, c) {
							super(i),
								(this._changeDetectorRef = r),
								(this._ngZone = o),
								(this._animationMode = a),
								(this._options = c),
								(this.ariaLabel = ""),
								(this.ariaLabelledby = null),
								(this.labelPosition = "after"),
								(this.name = null),
								(this.change = new _n()),
								(this.indeterminateChange = new _n()),
								(this._onTouched = () => {}),
								(this._currentAnimationClass = ""),
								(this._currentCheckState = 0),
								(this._controlValueAccessorChangeFn = () => {}),
								(this._checked = !1),
								(this._disabled = !1),
								(this._indeterminate = !1),
								(this._options = this._options || HY),
								(this.color = this.defaultColor = this._options.color || HY.color),
								(this.tabIndex = parseInt(s) || 0),
								(this.id = this._uniqueId = `${e}${++qBe}`)
						}
						ngAfterViewInit() {
							this._syncIndeterminate(this._indeterminate)
						}
						get checked() {
							return this._checked
						}
						set checked(e) {
							const i = Mn(e)
							i != this.checked && ((this._checked = i), this._changeDetectorRef.markForCheck())
						}
						get disabled() {
							return this._disabled
						}
						set disabled(e) {
							const i = Mn(e)
							i !== this.disabled && ((this._disabled = i), this._changeDetectorRef.markForCheck())
						}
						get indeterminate() {
							return this._indeterminate
						}
						set indeterminate(e) {
							const i = e != this._indeterminate
							;(this._indeterminate = Mn(e)),
								i &&
									(this._transitionCheckState(this._indeterminate ? 3 : this.checked ? 1 : 2),
									this.indeterminateChange.emit(this._indeterminate)),
								this._syncIndeterminate(this._indeterminate)
						}
						_isRippleDisabled() {
							return this.disableRipple || this.disabled
						}
						_onLabelTextChange() {
							this._changeDetectorRef.detectChanges()
						}
						writeValue(e) {
							this.checked = !!e
						}
						registerOnChange(e) {
							this._controlValueAccessorChangeFn = e
						}
						registerOnTouched(e) {
							this._onTouched = e
						}
						setDisabledState(e) {
							this.disabled = e
						}
						_transitionCheckState(e) {
							let i = this._currentCheckState,
								r = this._getAnimationTargetElement()
							if (
								i !== e &&
								r &&
								(this._currentAnimationClass && r.classList.remove(this._currentAnimationClass),
								(this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(i, e)),
								(this._currentCheckState = e),
								this._currentAnimationClass.length > 0)
							) {
								r.classList.add(this._currentAnimationClass)
								const o = this._currentAnimationClass
								this._ngZone.runOutsideAngular(() => {
									setTimeout(() => {
										r.classList.remove(o)
									}, 1e3)
								})
							}
						}
						_emitChangeEvent() {
							this._controlValueAccessorChangeFn(this.checked),
								this.change.emit(this._createChangeEvent(this.checked)),
								this._inputElement && (this._inputElement.nativeElement.checked = this.checked)
						}
						toggle() {
							;(this.checked = !this.checked), this._controlValueAccessorChangeFn(this.checked)
						}
						_handleInputClick() {
							const e = this._options?.clickAction
							this.disabled || "noop" === e
								? !this.disabled &&
								  "noop" === e &&
								  ((this._inputElement.nativeElement.checked = this.checked),
								  (this._inputElement.nativeElement.indeterminate = this.indeterminate))
								: (this.indeterminate &&
										"check" !== e &&
										Promise.resolve().then(() => {
											;(this._indeterminate = !1), this.indeterminateChange.emit(this._indeterminate)
										}),
								  (this._checked = !this._checked),
								  this._transitionCheckState(this._checked ? 1 : 2),
								  this._emitChangeEvent())
						}
						_onInteractionEvent(e) {
							e.stopPropagation()
						}
						_onBlur() {
							Promise.resolve().then(() => {
								this._onTouched(), this._changeDetectorRef.markForCheck()
							})
						}
						_getAnimationClassForCheckStateTransition(e, i) {
							if ("NoopAnimations" === this._animationMode) return ""
							switch (e) {
								case 0:
									if (1 === i) return this._animationClasses.uncheckedToChecked
									if (3 == i)
										return this._checked
											? this._animationClasses.checkedToIndeterminate
											: this._animationClasses.uncheckedToIndeterminate
									break
								case 2:
									return 1 === i
										? this._animationClasses.uncheckedToChecked
										: this._animationClasses.uncheckedToIndeterminate
								case 1:
									return 2 === i
										? this._animationClasses.checkedToUnchecked
										: this._animationClasses.checkedToIndeterminate
								case 3:
									return 1 === i
										? this._animationClasses.indeterminateToChecked
										: this._animationClasses.indeterminateToUnchecked
							}
							return ""
						}
						_syncIndeterminate(e) {
							const i = this._inputElement
							i && (i.nativeElement.indeterminate = e)
						}
						static {
							this.ɵfac = function (i) {
								Am()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								viewQuery: function (i, r) {
									if ((1 & i && (_i($Be, 5), _i(WBe, 5), _i(Cu, 5)), 2 & i)) {
										let o
										sn((o = an())) && (r._inputElement = o.first),
											sn((o = an())) && (r._labelElement = o.first),
											sn((o = an())) && (r.ripple = o.first)
									}
								},
								inputs: {
									ariaLabel: ["aria-label", "ariaLabel"],
									ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
									ariaDescribedby: ["aria-describedby", "ariaDescribedby"],
									id: "id",
									required: "required",
									labelPosition: "labelPosition",
									name: "name",
									value: "value",
									checked: "checked",
									disabled: "disabled",
									indeterminate: "indeterminate"
								},
								outputs: { change: "change", indeterminateChange: "indeterminateChange" },
								features: [pn]
							})
						}
					}
					return t
				})(),
				Fb = (() => {
					class t extends JBe {
						constructor(e, i, r, o, s, a) {
							super("mat-mdc-checkbox-", e, i, r, o, s, a),
								(this._animationClasses = {
									uncheckedToChecked: "mdc-checkbox--anim-unchecked-checked",
									uncheckedToIndeterminate: "mdc-checkbox--anim-unchecked-indeterminate",
									checkedToUnchecked: "mdc-checkbox--anim-checked-unchecked",
									checkedToIndeterminate: "mdc-checkbox--anim-checked-indeterminate",
									indeterminateToChecked: "mdc-checkbox--anim-indeterminate-checked",
									indeterminateToUnchecked: "mdc-checkbox--anim-indeterminate-unchecked"
								})
						}
						focus() {
							this._inputElement.nativeElement.focus()
						}
						_createChangeEvent(e) {
							const i = new YBe()
							return (i.source = this), (i.checked = e), i
						}
						_getAnimationTargetElement() {
							return this._inputElement?.nativeElement
						}
						_onInputClick() {
							super._handleInputClick()
						}
						_onTouchTargetClick() {
							super._handleInputClick(), this.disabled || this._inputElement.nativeElement.focus()
						}
						_preventBubblingFromLabel(e) {
							e.target && this._labelElement.nativeElement.contains(e.target) && e.stopPropagation()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(Jr), P(mn), Ma("tabindex"), P(Bo, 8), P(KBe, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-checkbox"]],
								hostAttrs: [1, "mat-mdc-checkbox"],
								hostVars: 12,
								hostBindings: function (i, r) {
									2 & i &&
										(td("id", r.id),
										qn("tabindex", null)("aria-label", null)("aria-labelledby", null),
										Zt("_mat-animation-noopable", "NoopAnimations" === r._animationMode)(
											"mdc-checkbox--disabled",
											r.disabled
										)("mat-mdc-checkbox-disabled", r.disabled)("mat-mdc-checkbox-checked", r.checked))
								},
								inputs: { disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex" },
								exportAs: ["matCheckbox"],
								features: [Xn([XBe]), pn],
								ngContentSelectors: jBe,
								decls: 15,
								vars: 20,
								consts: [
									[1, "mdc-form-field", 3, "click"],
									[1, "mdc-checkbox"],
									["checkbox", ""],
									[1, "mat-mdc-checkbox-touch-target", 3, "click"],
									[
										"type",
										"checkbox",
										1,
										"mdc-checkbox__native-control",
										3,
										"checked",
										"indeterminate",
										"disabled",
										"id",
										"required",
										"tabIndex",
										"blur",
										"click",
										"change"
									],
									["input", ""],
									[1, "mdc-checkbox__ripple"],
									[1, "mdc-checkbox__background"],
									["focusable", "false", "viewBox", "0 0 24 24", "aria-hidden", "true", 1, "mdc-checkbox__checkmark"],
									["fill", "none", "d", "M1.73,12.91 8.1,19.28 22.79,4.59", 1, "mdc-checkbox__checkmark-path"],
									[1, "mdc-checkbox__mixedmark"],
									[
										"mat-ripple",
										"",
										1,
										"mat-mdc-checkbox-ripple",
										"mat-mdc-focus-indicator",
										3,
										"matRippleTrigger",
										"matRippleDisabled",
										"matRippleCentered"
									],
									[1, "mdc-label", 3, "for"],
									["label", ""]
								],
								template: function (i, r) {
									if (
										(1 & i &&
											(co(),
											F(0, "div", 0),
											Le("click", function (s) {
												return r._preventBubblingFromLabel(s)
											}),
											F(1, "div", 1, 2)(3, "div", 3),
											Le("click", function () {
												return r._onTouchTargetClick()
											}),
											L(),
											F(4, "input", 4, 5),
											Le("blur", function () {
												return r._onBlur()
											})("click", function () {
												return r._onInputClick()
											})("change", function (s) {
												return r._onInteractionEvent(s)
											}),
											L(),
											fe(6, "div", 6),
											F(7, "div", 7),
											Xa(),
											F(8, "svg", 8),
											fe(9, "path", 9),
											L(),
											ph(),
											fe(10, "div", 10),
											L(),
											fe(11, "div", 11),
											L(),
											F(12, "label", 12, 13),
											Ln(14),
											L()()),
										2 & i)
									) {
										const o = br(2)
										Zt("mdc-form-field--align-end", "before" == r.labelPosition),
											T(4),
											Zt("mdc-checkbox--selected", r.checked),
											U("checked", r.checked)("indeterminate", r.indeterminate)("disabled", r.disabled)(
												"id",
												r.inputId
											)("required", r.required)("tabIndex", r.tabIndex),
											qn("aria-label", r.ariaLabel || null)("aria-labelledby", r.ariaLabelledby)(
												"aria-describedby",
												r.ariaDescribedby
											)("aria-checked", r.indeterminate ? "mixed" : null)("name", r.name)("value", r.value),
											T(7),
											U("matRippleTrigger", o)("matRippleDisabled", r.disableRipple || r.disabled)(
												"matRippleCentered",
												!0
											),
											T(1),
											U("for", r.inputId)
									}
								},
								dependencies: [Cu],
								styles: [
									'.mdc-touch-target-wrapper{display:inline}@keyframes mdc-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:29.7833385}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 1)}100%{stroke-dashoffset:0}}@keyframes mdc-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mdc-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);opacity:1;stroke-dashoffset:0}to{opacity:0;stroke-dashoffset:-29.7833385}}@keyframes mdc-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(45deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(45deg);opacity:0}to{transform:rotate(360deg);opacity:1}}@keyframes mdc-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:mdc-animation-deceleration-curve-timing-function;transform:rotate(-45deg);opacity:0}to{transform:rotate(0deg);opacity:1}}@keyframes mdc-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(315deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;transform:scaleX(1);opacity:1}32.8%,100%{transform:scaleX(0);opacity:0}}.mdc-checkbox{display:inline-block;position:relative;flex:0 0 18px;box-sizing:content-box;width:18px;height:18px;line-height:0;white-space:nowrap;cursor:pointer;vertical-align:bottom}.mdc-checkbox[hidden]{display:none}.mdc-checkbox.mdc-ripple-upgraded--background-focused .mdc-checkbox__focus-ring,.mdc-checkbox:not(.mdc-ripple-upgraded):focus .mdc-checkbox__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%}@media screen and (forced-colors: active){.mdc-checkbox.mdc-ripple-upgraded--background-focused .mdc-checkbox__focus-ring,.mdc-checkbox:not(.mdc-ripple-upgraded):focus .mdc-checkbox__focus-ring{border-color:CanvasText}}.mdc-checkbox.mdc-ripple-upgraded--background-focused .mdc-checkbox__focus-ring::after,.mdc-checkbox:not(.mdc-ripple-upgraded):focus .mdc-checkbox__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-checkbox.mdc-ripple-upgraded--background-focused .mdc-checkbox__focus-ring::after,.mdc-checkbox:not(.mdc-ripple-upgraded):focus .mdc-checkbox__focus-ring::after{border-color:CanvasText}}@media all and (-ms-high-contrast: none){.mdc-checkbox .mdc-checkbox__focus-ring{display:none}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-checkbox__mixedmark{margin:0 1px}}.mdc-checkbox--disabled{cursor:default;pointer-events:none}.mdc-checkbox__background{display:inline-flex;position:absolute;align-items:center;justify-content:center;box-sizing:border-box;width:18px;height:18px;border:2px solid currentColor;border-radius:2px;background-color:rgba(0,0,0,0);pointer-events:none;will-change:background-color,border-color;transition:background-color 90ms 0ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__checkmark{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;opacity:0;transition:opacity 180ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox--upgraded .mdc-checkbox__checkmark{opacity:1}.mdc-checkbox__checkmark-path{transition:stroke-dashoffset 180ms 0ms cubic-bezier(0.4, 0, 0.6, 1);stroke:currentColor;stroke-width:3.12px;stroke-dashoffset:29.7833385;stroke-dasharray:29.7833385}.mdc-checkbox__mixedmark{width:100%;height:0;transform:scaleX(0) rotate(0deg);border-width:1px;border-style:solid;opacity:0;transition:opacity 90ms 0ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__background,.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__background,.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__background,.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__background{animation-duration:180ms;animation-timing-function:linear}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-unchecked-checked-checkmark-path 180ms linear 0s;transition:none}.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-unchecked-indeterminate-mixedmark 90ms linear 0s;transition:none}.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-checked-unchecked-checkmark-path 90ms linear 0s;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__checkmark{animation:mdc-checkbox-checked-indeterminate-checkmark 90ms linear 0s;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-checked-indeterminate-mixedmark 90ms linear 0s;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__checkmark{animation:mdc-checkbox-indeterminate-checked-checkmark 500ms linear 0s;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-checked-mixedmark 500ms linear 0s;transition:none}.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-unchecked-mixedmark 300ms linear 0s;transition:none}.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background,.mdc-checkbox__native-control[data-indeterminate=true]~.mdc-checkbox__background{transition:border-color 90ms 0ms cubic-bezier(0, 0, 0.2, 1),background-color 90ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background .mdc-checkbox__checkmark-path,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background .mdc-checkbox__checkmark-path,.mdc-checkbox__native-control[data-indeterminate=true]~.mdc-checkbox__background .mdc-checkbox__checkmark-path{stroke-dashoffset:0}.mdc-checkbox__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit}.mdc-checkbox__native-control:disabled{cursor:default;pointer-events:none}.mdc-checkbox--touch{margin:calc((var(--mdc-checkbox-state-layer-size) - var(--mdc-checkbox-state-layer-size)) / 2)}.mdc-checkbox--touch .mdc-checkbox__native-control{top:calc((var(--mdc-checkbox-state-layer-size) - var(--mdc-checkbox-state-layer-size)) / 2);right:calc((var(--mdc-checkbox-state-layer-size) - var(--mdc-checkbox-state-layer-size)) / 2);left:calc((var(--mdc-checkbox-state-layer-size) - var(--mdc-checkbox-state-layer-size)) / 2);width:var(--mdc-checkbox-state-layer-size);height:var(--mdc-checkbox-state-layer-size)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background .mdc-checkbox__checkmark{transition:opacity 180ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 180ms 0ms cubic-bezier(0, 0, 0.2, 1);opacity:1}.mdc-checkbox__native-control:checked~.mdc-checkbox__background .mdc-checkbox__mixedmark{transform:scaleX(1) rotate(-45deg)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background .mdc-checkbox__checkmark,.mdc-checkbox__native-control[data-indeterminate=true]~.mdc-checkbox__background .mdc-checkbox__checkmark{transform:rotate(45deg);opacity:0;transition:opacity 90ms 0ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background .mdc-checkbox__mixedmark,.mdc-checkbox__native-control[data-indeterminate=true]~.mdc-checkbox__background .mdc-checkbox__mixedmark{transform:scaleX(1) rotate(0deg);opacity:1}.mdc-checkbox.mdc-checkbox--upgraded .mdc-checkbox__background,.mdc-checkbox.mdc-checkbox--upgraded .mdc-checkbox__checkmark,.mdc-checkbox.mdc-checkbox--upgraded .mdc-checkbox__checkmark-path,.mdc-checkbox.mdc-checkbox--upgraded .mdc-checkbox__mixedmark{transition:none}.mdc-form-field{display:inline-flex;align-items:center;vertical-align:middle}.mdc-form-field[hidden]{display:none}.mdc-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{margin-left:auto;margin-right:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{padding-left:0;padding-right:4px}.mdc-form-field--nowrap>label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{padding-left:4px;padding-right:0}.mdc-form-field--space-between{justify-content:space-between}.mdc-form-field--space-between>label{margin:0}[dir=rtl] .mdc-form-field--space-between>label,.mdc-form-field--space-between>label[dir=rtl]{margin:0}.mdc-checkbox{padding:calc((var(--mdc-checkbox-state-layer-size) - 18px) / 2);margin:calc((var(--mdc-checkbox-state-layer-size) - var(--mdc-checkbox-state-layer-size)) / 2)}.mdc-checkbox .mdc-checkbox__native-control[disabled]:not(:checked):not(:indeterminate):not([data-indeterminate=true])~.mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color);background-color:transparent}.mdc-checkbox .mdc-checkbox__native-control[disabled]:checked~.mdc-checkbox__background,.mdc-checkbox .mdc-checkbox__native-control[disabled]:indeterminate~.mdc-checkbox__background,.mdc-checkbox .mdc-checkbox__native-control[data-indeterminate=true][disabled]~.mdc-checkbox__background{border-color:transparent;background-color:var(--mdc-checkbox-disabled-selected-icon-color)}.mdc-checkbox .mdc-checkbox__native-control:enabled~.mdc-checkbox__background .mdc-checkbox__checkmark{color:var(--mdc-checkbox-selected-checkmark-color)}.mdc-checkbox .mdc-checkbox__native-control:enabled~.mdc-checkbox__background .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-selected-checkmark-color)}.mdc-checkbox .mdc-checkbox__native-control:disabled~.mdc-checkbox__background .mdc-checkbox__checkmark{color:var(--mdc-checkbox-disabled-selected-checkmark-color)}.mdc-checkbox .mdc-checkbox__native-control:disabled~.mdc-checkbox__background .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-disabled-selected-checkmark-color)}.mdc-checkbox .mdc-checkbox__native-control:enabled:not(:checked):not(:indeterminate):not([data-indeterminate=true])~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-icon-color);background-color:transparent}.mdc-checkbox .mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox .mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background,.mdc-checkbox .mdc-checkbox__native-control[data-indeterminate=true]:enabled~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-icon-color);background-color:var(--mdc-checkbox-selected-icon-color)}@keyframes mdc-checkbox-fade-in-background-8A000000FFF4433600000000FFF44336{0%{border-color:var(--mdc-checkbox-unselected-icon-color);background-color:transparent}50%{border-color:var(--mdc-checkbox-selected-icon-color);background-color:var(--mdc-checkbox-selected-icon-color)}}@keyframes mdc-checkbox-fade-out-background-8A000000FFF4433600000000FFF44336{0%,80%{border-color:var(--mdc-checkbox-selected-icon-color);background-color:var(--mdc-checkbox-selected-icon-color)}100%{border-color:var(--mdc-checkbox-unselected-icon-color);background-color:transparent}}.mdc-checkbox.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background,.mdc-checkbox.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__native-control:enabled~.mdc-checkbox__background{animation-name:mdc-checkbox-fade-in-background-8A000000FFF4433600000000FFF44336}.mdc-checkbox.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background,.mdc-checkbox.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background{animation-name:mdc-checkbox-fade-out-background-8A000000FFF4433600000000FFF44336}.mdc-checkbox:hover .mdc-checkbox__native-control:enabled:not(:checked):not(:indeterminate):not([data-indeterminate=true])~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-hover-icon-color);background-color:transparent}.mdc-checkbox:hover .mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox:hover .mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background,.mdc-checkbox:hover .mdc-checkbox__native-control[data-indeterminate=true]:enabled~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-hover-icon-color);background-color:var(--mdc-checkbox-selected-hover-icon-color)}@keyframes mdc-checkbox-fade-in-background-FF212121FFF4433600000000FFF44336{0%{border-color:var(--mdc-checkbox-unselected-hover-icon-color);background-color:transparent}50%{border-color:var(--mdc-checkbox-selected-hover-icon-color);background-color:var(--mdc-checkbox-selected-hover-icon-color)}}@keyframes mdc-checkbox-fade-out-background-FF212121FFF4433600000000FFF44336{0%,80%{border-color:var(--mdc-checkbox-selected-hover-icon-color);background-color:var(--mdc-checkbox-selected-hover-icon-color)}100%{border-color:var(--mdc-checkbox-unselected-hover-icon-color);background-color:transparent}}.mdc-checkbox:hover.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background,.mdc-checkbox:hover.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__native-control:enabled~.mdc-checkbox__background{animation-name:mdc-checkbox-fade-in-background-FF212121FFF4433600000000FFF44336}.mdc-checkbox:hover.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background,.mdc-checkbox:hover.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background{animation-name:mdc-checkbox-fade-out-background-FF212121FFF4433600000000FFF44336}.mdc-checkbox:not(:disabled):active .mdc-checkbox__native-control:enabled:not(:checked):not(:indeterminate):not([data-indeterminate=true])~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-pressed-icon-color);background-color:transparent}.mdc-checkbox:not(:disabled):active .mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox:not(:disabled):active .mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background,.mdc-checkbox:not(:disabled):active .mdc-checkbox__native-control[data-indeterminate=true]:enabled~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-pressed-icon-color);background-color:var(--mdc-checkbox-selected-pressed-icon-color)}@keyframes mdc-checkbox-fade-in-background-8A000000FFF4433600000000FFF44336{0%{border-color:var(--mdc-checkbox-unselected-pressed-icon-color);background-color:transparent}50%{border-color:var(--mdc-checkbox-selected-pressed-icon-color);background-color:var(--mdc-checkbox-selected-pressed-icon-color)}}@keyframes mdc-checkbox-fade-out-background-8A000000FFF4433600000000FFF44336{0%,80%{border-color:var(--mdc-checkbox-selected-pressed-icon-color);background-color:var(--mdc-checkbox-selected-pressed-icon-color)}100%{border-color:var(--mdc-checkbox-unselected-pressed-icon-color);background-color:transparent}}.mdc-checkbox:not(:disabled):active.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background,.mdc-checkbox:not(:disabled):active.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__native-control:enabled~.mdc-checkbox__background{animation-name:mdc-checkbox-fade-in-background-8A000000FFF4433600000000FFF44336}.mdc-checkbox:not(:disabled):active.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background,.mdc-checkbox:not(:disabled):active.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__native-control:enabled~.mdc-checkbox__background{animation-name:mdc-checkbox-fade-out-background-8A000000FFF4433600000000FFF44336}.mdc-checkbox .mdc-checkbox__background{top:calc((var(--mdc-checkbox-state-layer-size) - 18px) / 2);left:calc((var(--mdc-checkbox-state-layer-size) - 18px) / 2)}.mdc-checkbox .mdc-checkbox__native-control{top:calc((var(--mdc-checkbox-state-layer-size) - var(--mdc-checkbox-state-layer-size)) / 2);right:calc((var(--mdc-checkbox-state-layer-size) - var(--mdc-checkbox-state-layer-size)) / 2);left:calc((var(--mdc-checkbox-state-layer-size) - var(--mdc-checkbox-state-layer-size)) / 2);width:var(--mdc-checkbox-state-layer-size);height:var(--mdc-checkbox-state-layer-size)}.mdc-checkbox .mdc-checkbox__native-control:enabled:focus:focus:not(:checked):not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-focus-icon-color)}.mdc-checkbox .mdc-checkbox__native-control:enabled:focus:checked~.mdc-checkbox__background,.mdc-checkbox .mdc-checkbox__native-control:enabled:focus:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-focus-icon-color);background-color:var(--mdc-checkbox-selected-focus-icon-color)}.mdc-checkbox:hover .mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-hover-state-layer-opacity);background-color:var(--mdc-checkbox-unselected-hover-state-layer-color)}.mdc-checkbox:hover .mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color)}.mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-focus-state-layer-opacity);background-color:var(--mdc-checkbox-unselected-focus-state-layer-color)}.mdc-checkbox .mdc-checkbox__native-control:focus~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-focus-state-layer-color)}.mdc-checkbox:active .mdc-checkbox__native-control~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-pressed-state-layer-opacity);background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color)}.mdc-checkbox:active .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color)}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-hover-state-layer-opacity);background-color:var(--mdc-checkbox-selected-hover-state-layer-color)}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-hover-state-layer-color)}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-focus-state-layer-opacity);background-color:var(--mdc-checkbox-selected-focus-state-layer-color)}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-focus-state-layer-color)}.mdc-checkbox:active .mdc-checkbox__native-control:checked~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-pressed-state-layer-opacity);background-color:var(--mdc-checkbox-selected-pressed-state-layer-color)}.mdc-checkbox:active .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-pressed-state-layer-color)}html{--mdc-checkbox-disabled-selected-checkmark-color:#fff;--mdc-checkbox-selected-focus-state-layer-opacity:0.16;--mdc-checkbox-selected-hover-state-layer-opacity:0.04;--mdc-checkbox-selected-pressed-state-layer-opacity:0.16;--mdc-checkbox-unselected-focus-state-layer-opacity:0.16;--mdc-checkbox-unselected-hover-state-layer-opacity:0.04;--mdc-checkbox-unselected-pressed-state-layer-opacity:0.16}.mat-mdc-checkbox{display:inline-block;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-checkbox .mdc-checkbox__background{-webkit-print-color-adjust:exact;color-adjust:exact}.mat-mdc-checkbox._mat-animation-noopable *,.mat-mdc-checkbox._mat-animation-noopable *::before{transition:none !important;animation:none !important}.mat-mdc-checkbox label{cursor:pointer}.mat-mdc-checkbox.mat-mdc-checkbox-disabled label{cursor:default}.mat-mdc-checkbox label:empty{display:none}.cdk-high-contrast-active .mat-mdc-checkbox.mat-mdc-checkbox-disabled{opacity:.5}.cdk-high-contrast-active .mat-mdc-checkbox .mdc-checkbox__checkmark{--mdc-checkbox-selected-checkmark-color: CanvasText;--mdc-checkbox-disabled-selected-checkmark-color: CanvasText}.mat-mdc-checkbox .mdc-checkbox__ripple{opacity:0}.mat-mdc-checkbox-ripple,.mdc-checkbox__ripple{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-checkbox-ripple:not(:empty),.mdc-checkbox__ripple:not(:empty){transform:translateZ(0)}.mat-mdc-checkbox-ripple .mat-ripple-element{opacity:.1}.mat-mdc-checkbox-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-checkbox-ripple::before{border-radius:50%}.mdc-checkbox__native-control:focus~.mat-mdc-focus-indicator::before{content:""}'
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				VY = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				QY = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Vh, VY, Yi, VY] })
						}
					}
					return t
				})()
			const UO = (t, n, e) => {
					const i = Number.parseInt(t.target.value)
					return i < n ? n : i > e ? e : i
				},
				n2e = ["knob"],
				i2e = ["valueIndicatorContainer"]
			function r2e(t, n) {
				if ((1 & t && (F(0, "div", 4, 5)(2, "div", 6)(3, "span", 7), ge(4), L()()()), 2 & t)) {
					const e = Te()
					T(4), cr(e.valueIndicatorText)
				}
			}
			const o2e = ["trackActive"]
			function s2e(t, n) {
				if ((1 & t && fe(0, "div"), 2 & t)) {
					const e = n.$implicit,
						i = n.index,
						r = Te(3)
					c0(0 === e ? "mdc-slider__tick-mark--active" : "mdc-slider__tick-mark--inactive"),
						bi("transform", r._calcTickMarkTransform(i))
				}
			}
			function a2e(t, n) {
				if ((1 & t && (Cr(0), Ee(1, s2e, 1, 4, "div", 11), Er()), 2 & t)) {
					const e = Te(2)
					T(1), U("ngForOf", e._tickMarks)
				}
			}
			function c2e(t, n) {
				if ((1 & t && (F(0, "div", 8, 9), Ee(2, a2e, 2, 1, "ng-container", 10), L()), 2 & t)) {
					const e = Te()
					T(2), U("ngIf", e._cachedWidth)
				}
			}
			function l2e(t, n) {
				if ((1 & t && fe(0, "mat-slider-visual-thumb", 7), 2 & t)) {
					const e = Te()
					U("discrete", e.discrete)("thumbPosition", 1)("valueIndicatorText", e.startValueIndicatorText)
				}
			}
			const d2e = ["*"],
				fk = new He("_MatSlider"),
				zY = new He("_MatSliderThumb"),
				GY = new He("_MatSliderRangeThumb"),
				$Y = new He("_MatSliderVisualThumb")
			let u2e = (() => {
				class t {
					constructor(e, i, r, o) {
						;(this._cdr = e),
							(this._ngZone = i),
							(this._slider = o),
							(this._isHovered = !1),
							(this._isActive = !1),
							(this._isValueIndicatorVisible = !1),
							(this._onPointerMove = s => {
								if (this._sliderInput._isFocused) return
								const a = this._hostElement.getBoundingClientRect(),
									c = this._slider._isCursorOnSliderThumb(s, a)
								;(this._isHovered = c), c ? this._showHoverRipple() : this._hideRipple(this._hoverRippleRef)
							}),
							(this._onMouseLeave = () => {
								;(this._isHovered = !1), this._hideRipple(this._hoverRippleRef)
							}),
							(this._onFocus = () => {
								this._hideRipple(this._hoverRippleRef),
									this._showFocusRipple(),
									this._hostElement.classList.add("mdc-slider__thumb--focused")
							}),
							(this._onBlur = () => {
								this._isActive || this._hideRipple(this._focusRippleRef),
									this._isHovered && this._showHoverRipple(),
									this._hostElement.classList.remove("mdc-slider__thumb--focused")
							}),
							(this._onDragStart = s => {
								0 === s.button && ((this._isActive = !0), this._showActiveRipple())
							}),
							(this._onDragEnd = () => {
								;(this._isActive = !1),
									this._hideRipple(this._activeRippleRef),
									this._sliderInput._isFocused || this._hideRipple(this._focusRippleRef)
							}),
							(this._hostElement = r.nativeElement)
					}
					ngAfterViewInit() {
						;(this._ripple.radius = 24),
							(this._sliderInput = this._slider._getInput(this.thumbPosition)),
							(this._sliderInputEl = this._sliderInput._hostElement)
						const e = this._sliderInputEl
						this._ngZone.runOutsideAngular(() => {
							e.addEventListener("pointermove", this._onPointerMove),
								e.addEventListener("pointerdown", this._onDragStart),
								e.addEventListener("pointerup", this._onDragEnd),
								e.addEventListener("pointerleave", this._onMouseLeave),
								e.addEventListener("focus", this._onFocus),
								e.addEventListener("blur", this._onBlur)
						})
					}
					ngOnDestroy() {
						const e = this._sliderInputEl
						e.removeEventListener("pointermove", this._onPointerMove),
							e.removeEventListener("pointerdown", this._onDragStart),
							e.removeEventListener("pointerup", this._onDragEnd),
							e.removeEventListener("pointerleave", this._onMouseLeave),
							e.removeEventListener("focus", this._onFocus),
							e.removeEventListener("blur", this._onBlur)
					}
					_showHoverRipple() {
						this._isShowingRipple(this._hoverRippleRef) ||
							((this._hoverRippleRef = this._showRipple({ enterDuration: 0, exitDuration: 0 })),
							this._hoverRippleRef?.element.classList.add("mat-mdc-slider-hover-ripple"))
					}
					_showFocusRipple() {
						this._isShowingRipple(this._focusRippleRef) ||
							((this._focusRippleRef = this._showRipple({ enterDuration: 0, exitDuration: 0 }, !0)),
							this._focusRippleRef?.element.classList.add("mat-mdc-slider-focus-ripple"))
					}
					_showActiveRipple() {
						this._isShowingRipple(this._activeRippleRef) ||
							((this._activeRippleRef = this._showRipple({ enterDuration: 225, exitDuration: 400 })),
							this._activeRippleRef?.element.classList.add("mat-mdc-slider-active-ripple"))
					}
					_isShowingRipple(e) {
						return 0 === e?.state || 1 === e?.state
					}
					_showRipple(e, i) {
						if (
							!this._slider.disabled &&
							(this._showValueIndicator(),
							this._slider._isRange && this._slider._getThumb(1 === this.thumbPosition ? 2 : 1)._showValueIndicator(),
							!this._slider._globalRippleOptions?.disabled || i)
						)
							return this._ripple.launch({
								animation: this._slider._noopAnimations ? { enterDuration: 0, exitDuration: 0 } : e,
								centered: !0,
								persistent: !0
							})
					}
					_hideRipple(e) {
						if ((e?.fadeOut(), this._isShowingAnyRipple())) return
						this._slider._isRange || this._hideValueIndicator()
						const i = this._getSibling()
						i._isShowingAnyRipple() || (this._hideValueIndicator(), i._hideValueIndicator())
					}
					_showValueIndicator() {
						this._hostElement.classList.add("mdc-slider__thumb--with-indicator")
					}
					_hideValueIndicator() {
						this._hostElement.classList.remove("mdc-slider__thumb--with-indicator")
					}
					_getSibling() {
						return this._slider._getThumb(1 === this.thumbPosition ? 2 : 1)
					}
					_getValueIndicatorContainer() {
						return this._valueIndicatorContainer?.nativeElement
					}
					_getKnob() {
						return this._knob.nativeElement
					}
					_isShowingAnyRipple() {
						return (
							this._isShowingRipple(this._hoverRippleRef) ||
							this._isShowingRipple(this._focusRippleRef) ||
							this._isShowingRipple(this._activeRippleRef)
						)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Jr), P(mn), P(wn), P(fk))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["mat-slider-visual-thumb"]],
							viewQuery: function (i, r) {
								if ((1 & i && (_i(Cu, 5), _i(n2e, 5), _i(i2e, 5)), 2 & i)) {
									let o
									sn((o = an())) && (r._ripple = o.first),
										sn((o = an())) && (r._knob = o.first),
										sn((o = an())) && (r._valueIndicatorContainer = o.first)
								}
							},
							hostAttrs: [1, "mdc-slider__thumb", "mat-mdc-slider-visual-thumb"],
							inputs: { discrete: "discrete", thumbPosition: "thumbPosition", valueIndicatorText: "valueIndicatorText" },
							features: [Xn([{ provide: $Y, useExisting: t }])],
							decls: 4,
							vars: 2,
							consts: [
								["class", "mdc-slider__value-indicator-container", 4, "ngIf"],
								[1, "mdc-slider__thumb-knob"],
								["knob", ""],
								["matRipple", "", 1, "mat-mdc-focus-indicator", 3, "matRippleDisabled"],
								[1, "mdc-slider__value-indicator-container"],
								["valueIndicatorContainer", ""],
								[1, "mdc-slider__value-indicator"],
								[1, "mdc-slider__value-indicator-text"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, r2e, 5, 1, "div", 0), fe(1, "div", 1, 2)(3, "div", 3)),
									2 & i && (U("ngIf", r.discrete), T(3), U("matRippleDisabled", !0))
							},
							dependencies: [En, Cu],
							styles: [
								".mat-mdc-slider-visual-thumb .mat-ripple{height:100%;width:100%}.mat-mdc-slider .mdc-slider__tick-marks{justify-content:start}.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--inactive{position:absolute;left:2px}"
							],
							encapsulation: 2,
							changeDetection: 0
						})
					}
				}
				return t
			})()
			const h2e = _g(
				Um(
					class {
						constructor(t) {
							this._elementRef = t
						}
					}
				),
				"primary"
			)
			let f2e = (() => {
				class t extends h2e {
					get disabled() {
						return this._disabled
					}
					set disabled(e) {
						this._disabled = Mn(e)
						const i = this._getInput(2),
							r = this._getInput(1)
						i && (i.disabled = this._disabled), r && (r.disabled = this._disabled)
					}
					get discrete() {
						return this._discrete
					}
					set discrete(e) {
						;(this._discrete = Mn(e)), this._updateValueIndicatorUIs()
					}
					get showTickMarks() {
						return this._showTickMarks
					}
					set showTickMarks(e) {
						this._showTickMarks = Mn(e)
					}
					get min() {
						return this._min
					}
					set min(e) {
						const i = to(e, this._min)
						this._min !== i && this._updateMin(i)
					}
					_updateMin(e) {
						const i = this._min
						;(this._min = e),
							this._isRange ? this._updateMinRange({ old: i, new: e }) : this._updateMinNonRange(e),
							this._onMinMaxOrStepChange()
					}
					_updateMinRange(e) {
						const i = this._getInput(2),
							r = this._getInput(1),
							o = i.value,
							s = r.value
						;(r.min = e.new),
							(i.min = Math.max(e.new, r.value)),
							(r.max = Math.min(i.max, i.value)),
							r._updateWidthInactive(),
							i._updateWidthInactive(),
							e.new < e.old ? this._onTranslateXChangeBySideEffect(i, r) : this._onTranslateXChangeBySideEffect(r, i),
							o !== i.value && this._onValueChange(i),
							s !== r.value && this._onValueChange(r)
					}
					_updateMinNonRange(e) {
						const i = this._getInput(2)
						if (i) {
							const r = i.value
							;(i.min = e), i._updateThumbUIByValue(), this._updateTrackUI(i), r !== i.value && this._onValueChange(i)
						}
					}
					get max() {
						return this._max
					}
					set max(e) {
						const i = to(e, this._max)
						this._max !== i && this._updateMax(i)
					}
					_updateMax(e) {
						const i = this._max
						;(this._max = e),
							this._isRange ? this._updateMaxRange({ old: i, new: e }) : this._updateMaxNonRange(e),
							this._onMinMaxOrStepChange()
					}
					_updateMaxRange(e) {
						const i = this._getInput(2),
							r = this._getInput(1),
							o = i.value,
							s = r.value
						;(i.max = e.new),
							(r.max = Math.min(e.new, i.value)),
							(i.min = r.value),
							i._updateWidthInactive(),
							r._updateWidthInactive(),
							e.new > e.old ? this._onTranslateXChangeBySideEffect(r, i) : this._onTranslateXChangeBySideEffect(i, r),
							o !== i.value && this._onValueChange(i),
							s !== r.value && this._onValueChange(r)
					}
					_updateMaxNonRange(e) {
						const i = this._getInput(2)
						if (i) {
							const r = i.value
							;(i.max = e), i._updateThumbUIByValue(), this._updateTrackUI(i), r !== i.value && this._onValueChange(i)
						}
					}
					get step() {
						return this._step
					}
					set step(e) {
						const i = to(e, this._step)
						this._step !== i && this._updateStep(i)
					}
					_updateStep(e) {
						;(this._step = e),
							this._isRange ? this._updateStepRange() : this._updateStepNonRange(),
							this._onMinMaxOrStepChange()
					}
					_updateStepRange() {
						const e = this._getInput(2),
							i = this._getInput(1),
							r = e.value,
							o = i.value,
							s = i.value
						;(e.min = this._min),
							(i.max = this._max),
							(e.step = this._step),
							(i.step = this._step),
							this._platform.SAFARI && ((e.value = e.value), (i.value = i.value)),
							(e.min = Math.max(this._min, i.value)),
							(i.max = Math.min(this._max, e.value)),
							i._updateWidthInactive(),
							e._updateWidthInactive(),
							e.value < s ? this._onTranslateXChangeBySideEffect(i, e) : this._onTranslateXChangeBySideEffect(e, i),
							r !== e.value && this._onValueChange(e),
							o !== i.value && this._onValueChange(i)
					}
					_updateStepNonRange() {
						const e = this._getInput(2)
						if (e) {
							const i = e.value
							;(e.step = this._step),
								this._platform.SAFARI && (e.value = e.value),
								e._updateThumbUIByValue(),
								i !== e.value && this._onValueChange(e)
						}
					}
					constructor(e, i, r, o, s, a) {
						super(r),
							(this._ngZone = e),
							(this._cdr = i),
							(this._dir = o),
							(this._globalRippleOptions = s),
							(this._disabled = !1),
							(this._discrete = !1),
							(this._showTickMarks = !1),
							(this._min = 0),
							(this._max = 100),
							(this._step = 1),
							(this.displayWith = c => `${c}`),
							(this._rippleRadius = 24),
							(this.startValueIndicatorText = ""),
							(this.endValueIndicatorText = ""),
							(this._isRange = !1),
							(this._isRtl = !1),
							(this._hasViewInitialized = !1),
							(this._tickMarkTrackWidth = 0),
							(this._hasAnimation = !1),
							(this._resizeTimer = null),
							(this._platform = Rt(Wr)),
							(this._knobRadius = 8),
							(this._thumbsOverlap = !1),
							(this._noopAnimations = "NoopAnimations" === a),
							(this._dirChangeSubscription = this._dir.change.subscribe(() => this._onDirChange())),
							(this._isRtl = "rtl" === this._dir.value)
					}
					ngAfterViewInit() {
						this._platform.isBrowser && this._updateDimensions()
						const e = this._getInput(2),
							i = this._getInput(1)
						;(this._isRange = !!e && !!i), this._cdr.detectChanges()
						const r = this._getThumb(2)
						;(this._rippleRadius = r._ripple.radius),
							(this._inputPadding = this._rippleRadius - this._knobRadius),
							(this._inputOffset = this._knobRadius),
							this._isRange ? this._initUIRange(e, i) : this._initUINonRange(e),
							this._updateTrackUI(e),
							this._updateTickMarkUI(),
							this._updateTickMarkTrackUI(),
							this._observeHostResize(),
							this._cdr.detectChanges()
					}
					_initUINonRange(e) {
						e.initProps(),
							e.initUI(),
							this._updateValueIndicatorUI(e),
							(this._hasViewInitialized = !0),
							e._updateThumbUIByValue()
					}
					_initUIRange(e, i) {
						e.initProps(),
							e.initUI(),
							i.initProps(),
							i.initUI(),
							e._updateMinMax(),
							i._updateMinMax(),
							e._updateStaticStyles(),
							i._updateStaticStyles(),
							this._updateValueIndicatorUIs(),
							(this._hasViewInitialized = !0),
							e._updateThumbUIByValue(),
							i._updateThumbUIByValue()
					}
					ngOnDestroy() {
						this._dirChangeSubscription.unsubscribe(), this._resizeObserver?.disconnect(), (this._resizeObserver = null)
					}
					_onDirChange() {
						;(this._isRtl = "rtl" === this._dir.value),
							this._isRange ? this._onDirChangeRange() : this._onDirChangeNonRange(),
							this._updateTickMarkUI()
					}
					_onDirChangeRange() {
						const e = this._getInput(2),
							i = this._getInput(1)
						e._setIsLeftThumb(),
							i._setIsLeftThumb(),
							(e.translateX = e._calcTranslateXByValue()),
							(i.translateX = i._calcTranslateXByValue()),
							e._updateStaticStyles(),
							i._updateStaticStyles(),
							e._updateWidthInactive(),
							i._updateWidthInactive(),
							e._updateThumbUIByValue(),
							i._updateThumbUIByValue()
					}
					_onDirChangeNonRange() {
						this._getInput(2)._updateThumbUIByValue()
					}
					_observeHostResize() {
						typeof ResizeObserver > "u" ||
							!ResizeObserver ||
							this._ngZone.runOutsideAngular(() => {
								;(this._resizeObserver = new ResizeObserver(() => {
									this._isActive() || (this._resizeTimer && clearTimeout(this._resizeTimer), this._onResize())
								})),
									this._resizeObserver.observe(this._elementRef.nativeElement)
							})
					}
					_isActive() {
						return this._getThumb(1)._isActive || this._getThumb(2)._isActive
					}
					_getValue(e = 2) {
						const i = this._getInput(e)
						return i ? i.value : this.min
					}
					_skipUpdate() {
						return !(!this._getInput(1)?._skipUIUpdate && !this._getInput(2)?._skipUIUpdate)
					}
					_updateDimensions() {
						;(this._cachedWidth = this._elementRef.nativeElement.offsetWidth),
							(this._cachedLeft = this._elementRef.nativeElement.getBoundingClientRect().left)
					}
					_setTrackActiveStyles(e) {
						const i = this._trackActive.nativeElement.style
						;(i.left = e.left), (i.right = e.right), (i.transformOrigin = e.transformOrigin), (i.transform = e.transform)
					}
					_calcTickMarkTransform(e) {
						return `translateX(${e * (this._tickMarkTrackWidth / (this._tickMarks.length - 1))}px`
					}
					_onTranslateXChange(e) {
						this._hasViewInitialized && (this._updateThumbUI(e), this._updateTrackUI(e), this._updateOverlappingThumbUI(e))
					}
					_onTranslateXChangeBySideEffect(e, i) {
						this._hasViewInitialized && (e._updateThumbUIByValue(), i._updateThumbUIByValue())
					}
					_onValueChange(e) {
						this._hasViewInitialized && (this._updateValueIndicatorUI(e), this._updateTickMarkUI(), this._cdr.detectChanges())
					}
					_onMinMaxOrStepChange() {
						this._hasViewInitialized && (this._updateTickMarkUI(), this._updateTickMarkTrackUI(), this._cdr.markForCheck())
					}
					_onResize() {
						if (this._hasViewInitialized) {
							if ((this._updateDimensions(), this._isRange)) {
								const e = this._getInput(2),
									i = this._getInput(1)
								e._updateThumbUIByValue(),
									i._updateThumbUIByValue(),
									e._updateStaticStyles(),
									i._updateStaticStyles(),
									e._updateMinMax(),
									i._updateMinMax(),
									e._updateWidthInactive(),
									i._updateWidthInactive()
							} else {
								const e = this._getInput(2)
								e && e._updateThumbUIByValue()
							}
							this._updateTickMarkUI(), this._updateTickMarkTrackUI(), this._cdr.detectChanges()
						}
					}
					_areThumbsOverlapping() {
						const e = this._getInput(1),
							i = this._getInput(2)
						return !(!e || !i) && i.translateX - e.translateX < 20
					}
					_updateOverlappingThumbClassNames(e) {
						const i = e.getSibling(),
							r = this._getThumb(e.thumbPosition)
						this._getThumb(i.thumbPosition)._hostElement.classList.remove("mdc-slider__thumb--top"),
							r._hostElement.classList.toggle("mdc-slider__thumb--top", this._thumbsOverlap)
					}
					_updateOverlappingThumbUI(e) {
						!this._isRange ||
							this._skipUpdate() ||
							(this._thumbsOverlap !== this._areThumbsOverlapping() &&
								((this._thumbsOverlap = !this._thumbsOverlap), this._updateOverlappingThumbClassNames(e)))
					}
					_updateThumbUI(e) {
						this._skipUpdate() ||
							(this._getThumb(2 === e.thumbPosition ? 2 : 1)._hostElement.style.transform = `translateX(${e.translateX}px)`)
					}
					_updateValueIndicatorUI(e) {
						if (this._skipUpdate()) return
						const i = this.displayWith(e.value)
						if (
							(this._hasViewInitialized ? (e._valuetext = i) : e._hostElement.setAttribute("aria-valuetext", i),
							this.discrete)
						) {
							1 === e.thumbPosition ? (this.startValueIndicatorText = i) : (this.endValueIndicatorText = i)
							const r = this._getThumb(e.thumbPosition)
							i.length < 3
								? r._hostElement.classList.add("mdc-slider__thumb--short-value")
								: r._hostElement.classList.remove("mdc-slider__thumb--short-value")
						}
					}
					_updateValueIndicatorUIs() {
						const e = this._getInput(2),
							i = this._getInput(1)
						e && this._updateValueIndicatorUI(e), i && this._updateValueIndicatorUI(i)
					}
					_updateTickMarkTrackUI() {
						if (!this.showTickMarks || this._skipUpdate()) return
						const e = this._step && this._step > 0 ? this._step : 1,
							r = (Math.floor(this.max / e) * e - this.min) / (this.max - this.min)
						this._tickMarkTrackWidth = this._cachedWidth * r - 6
					}
					_updateTrackUI(e) {
						this._skipUpdate() || (this._isRange ? this._updateTrackUIRange(e) : this._updateTrackUINonRange(e))
					}
					_updateTrackUIRange(e) {
						const i = e.getSibling()
						if (!i || !this._cachedWidth) return
						const r = Math.abs(i.translateX - e.translateX) / this._cachedWidth
						this._setTrackActiveStyles(
							e._isLeftThumb && this._cachedWidth
								? {
										left: "auto",
										right: this._cachedWidth - i.translateX + "px",
										transformOrigin: "right",
										transform: `scaleX(${r})`
								  }
								: { left: `${i.translateX}px`, right: "auto", transformOrigin: "left", transform: `scaleX(${r})` }
						)
					}
					_updateTrackUINonRange(e) {
						this._setTrackActiveStyles(
							this._isRtl
								? { left: "auto", right: "0px", transformOrigin: "right", transform: `scaleX(${1 - e.fillPercentage})` }
								: { left: "0px", right: "auto", transformOrigin: "left", transform: `scaleX(${e.fillPercentage})` }
						)
					}
					_updateTickMarkUI() {
						if (!this.showTickMarks || void 0 === this.step || void 0 === this.min || void 0 === this.max) return
						const e = this.step > 0 ? this.step : 1
						this._isRange ? this._updateTickMarkUIRange(e) : this._updateTickMarkUINonRange(e),
							this._isRtl && this._tickMarks.reverse()
					}
					_updateTickMarkUINonRange(e) {
						const i = this._getValue()
						let r = Math.max(Math.round((i - this.min) / e), 0),
							o = Math.max(Math.round((this.max - i) / e), 0)
						this._isRtl ? r++ : o++, (this._tickMarks = Array(r).fill(0).concat(Array(o).fill(1)))
					}
					_updateTickMarkUIRange(e) {
						const i = this._getValue(),
							r = this._getValue(1),
							o = Math.max(Math.floor((r - this.min) / e), 0),
							s = Math.max(Math.floor((i - r) / e) + 1, 0),
							a = Math.max(Math.floor((this.max - i) / e), 0)
						this._tickMarks = Array(o).fill(1).concat(Array(s).fill(0), Array(a).fill(1))
					}
					_getInput(e) {
						return 2 === e && this._input
							? this._input
							: this._inputs?.length
							? 1 === e
								? this._inputs.first
								: this._inputs.last
							: void 0
					}
					_getThumb(e) {
						return 2 === e ? this._thumbs?.last : this._thumbs?.first
					}
					_setTransition(e) {
						;(this._hasAnimation = !this._platform.IOS && e && !this._noopAnimations),
							this._elementRef.nativeElement.classList.toggle("mat-mdc-slider-with-animation", this._hasAnimation)
					}
					_isCursorOnSliderThumb(e, i) {
						const r = i.width / 2,
							c = e.clientY - (i.y + r)
						return Math.pow(e.clientX - (i.x + r), 2) + Math.pow(c, 2) < Math.pow(r, 2)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(mn), P(Jr), P(wn), P(wu, 8), P(vg, 8), P(Bo, 8))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["mat-slider"]],
							contentQueries: function (i, r, o) {
								if ((1 & i && (yr(o, zY, 5), yr(o, GY, 4)), 2 & i)) {
									let s
									sn((s = an())) && (r._input = s.first), sn((s = an())) && (r._inputs = s)
								}
							},
							viewQuery: function (i, r) {
								if ((1 & i && (_i(o2e, 5), _i($Y, 5)), 2 & i)) {
									let o
									sn((o = an())) && (r._trackActive = o.first), sn((o = an())) && (r._thumbs = o)
								}
							},
							hostAttrs: [1, "mat-mdc-slider", "mdc-slider"],
							hostVars: 10,
							hostBindings: function (i, r) {
								2 & i &&
									Zt("mdc-slider--range", r._isRange)("mdc-slider--disabled", r.disabled)(
										"mdc-slider--discrete",
										r.discrete
									)("mdc-slider--tick-marks", r.showTickMarks)("_mat-animation-noopable", r._noopAnimations)
							},
							inputs: {
								color: "color",
								disableRipple: "disableRipple",
								disabled: "disabled",
								discrete: "discrete",
								showTickMarks: "showTickMarks",
								min: "min",
								max: "max",
								step: "step",
								displayWith: "displayWith"
							},
							exportAs: ["matSlider"],
							features: [Xn([{ provide: fk, useExisting: t }]), pn],
							ngContentSelectors: d2e,
							decls: 9,
							vars: 5,
							consts: [
								[1, "mdc-slider__track"],
								[1, "mdc-slider__track--inactive"],
								[1, "mdc-slider__track--active"],
								[1, "mdc-slider__track--active_fill"],
								["trackActive", ""],
								["class", "mdc-slider__tick-marks", 4, "ngIf"],
								[3, "discrete", "thumbPosition", "valueIndicatorText", 4, "ngIf"],
								[3, "discrete", "thumbPosition", "valueIndicatorText"],
								[1, "mdc-slider__tick-marks"],
								["tickMarkContainer", ""],
								[4, "ngIf"],
								[3, "class", "transform", 4, "ngFor", "ngForOf"]
							],
							template: function (i, r) {
								1 & i &&
									(co(),
									Ln(0),
									F(1, "div", 0),
									fe(2, "div", 1),
									F(3, "div", 2),
									fe(4, "div", 3, 4),
									L(),
									Ee(6, c2e, 3, 1, "div", 5),
									L(),
									Ee(7, l2e, 1, 3, "mat-slider-visual-thumb", 6),
									fe(8, "mat-slider-visual-thumb", 7)),
									2 & i &&
										(T(6),
										U("ngIf", r.showTickMarks),
										T(1),
										U("ngIf", r._isRange),
										T(1),
										U("discrete", r.discrete)("thumbPosition", 2)("valueIndicatorText", r.endValueIndicatorText))
							},
							dependencies: [_o, En, u2e],
							styles: [
								'.mdc-slider{cursor:pointer;height:48px;margin:0 24px;position:relative;touch-action:pan-y}.mdc-slider .mdc-slider__track{position:absolute;top:50%;transform:translateY(-50%);width:100%}.mdc-slider .mdc-slider__track--active,.mdc-slider .mdc-slider__track--inactive{display:flex;height:100%;position:absolute;width:100%}.mdc-slider .mdc-slider__track--active{overflow:hidden}.mdc-slider .mdc-slider__track--active_fill{border-top-style:solid;box-sizing:border-box;height:100%;width:100%;position:relative;-webkit-transform-origin:left;transform-origin:left}[dir=rtl] .mdc-slider .mdc-slider__track--active_fill,.mdc-slider .mdc-slider__track--active_fill[dir=rtl]{-webkit-transform-origin:right;transform-origin:right}.mdc-slider .mdc-slider__track--inactive{left:0;top:0}.mdc-slider .mdc-slider__track--inactive::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__track--inactive::before{border-color:CanvasText}}.mdc-slider .mdc-slider__value-indicator-container{bottom:44px;left:var(--slider-value-indicator-container-left, 50%);pointer-events:none;position:absolute;right:var(--slider-value-indicator-container-right);transform:var(--slider-value-indicator-container-transform, translateX(-50%))}.mdc-slider .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0.4, 0, 1, 1);align-items:center;border-radius:4px;display:flex;height:32px;padding:0 12px;transform:scale(0);transform-origin:bottom}.mdc-slider .mdc-slider__value-indicator::before{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:6px solid;bottom:-5px;content:"";height:0;left:var(--slider-value-indicator-caret-left, 50%);position:absolute;right:var(--slider-value-indicator-caret-right);transform:var(--slider-value-indicator-caret-transform, translateX(-50%));width:0}.mdc-slider .mdc-slider__value-indicator::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__value-indicator::after{border-color:CanvasText}}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator-container{pointer-events:auto}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale(1)}@media(prefers-reduced-motion){.mdc-slider .mdc-slider__value-indicator,.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:none}}.mdc-slider .mdc-slider__thumb{display:flex;left:-24px;outline:none;position:absolute;user-select:none;height:48px;width:48px}.mdc-slider .mdc-slider__thumb--top{z-index:1}.mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-style:solid;border-width:1px;box-sizing:content-box}.mdc-slider .mdc-slider__thumb-knob{box-sizing:border-box;left:50%;position:absolute;top:50%;transform:translate(-50%, -50%)}.mdc-slider .mdc-slider__tick-marks{align-items:center;box-sizing:border-box;display:flex;height:100%;justify-content:space-between;padding:0 1px;position:absolute;width:100%}.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:transform 80ms ease}@media(prefers-reduced-motion){.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:none}}.mdc-slider--disabled{cursor:auto}.mdc-slider--disabled .mdc-slider__thumb{pointer-events:none}.mdc-slider__input{cursor:pointer;left:2px;margin:0;height:44px;opacity:0;pointer-events:none;position:absolute;top:2px;width:44px}.mat-mdc-slider{display:inline-block;box-sizing:border-box;outline:none;vertical-align:middle;margin-left:8px;margin-right:8px;width:auto;min-width:112px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-slider .mdc-slider__thumb-knob{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb-knob{background-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000));border-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb::before,.mat-mdc-slider .mdc-slider__thumb::after{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover::before,.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-surface--hover::before{opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__track--active_fill{border-color:var(--mdc-slider-active-track-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--active_fill{border-color:var(--mdc-slider-disabled-active-track-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider .mdc-slider__track--inactive{background-color:var(--mdc-slider-inactive-track-color, var(--mdc-theme-primary, #6200ee));opacity:.24}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--inactive{background-color:var(--mdc-slider-disabled-inactive-track-color, var(--mdc-theme-on-surface, #000));opacity:.24}.mat-mdc-slider .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-inactive-container-color, var(--mdc-theme-primary, #6200ee));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-disabled-container-color, var(--mdc-theme-on-surface, #000));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__value-indicator{background-color:var(--mdc-slider-label-container-color, #666666);opacity:1}.mat-mdc-slider .mdc-slider__value-indicator::before{border-top-color:var(--mdc-slider-label-container-color, #666666)}.mat-mdc-slider .mdc-slider__value-indicator{color:var(--mdc-slider-label-label-text-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slider .mdc-slider__track{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__track--active{height:var(--mdc-slider-active-track-height, 6px);top:calc((var(--mdc-slider-inactive-track-height, 4px) - var(--mdc-slider-active-track-height, 6px)) / 2)}.mat-mdc-slider .mdc-slider__track--active_fill{border-top-width:var(--mdc-slider-active-track-height, 6px)}.mat-mdc-slider .mdc-slider__track--inactive{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{height:var(--mdc-slider-with-tick-marks-container-size, 2px);width:var(--mdc-slider-with-tick-marks-container-size, 2px)}.mat-mdc-slider.mdc-slider--disabled{opacity:0.38}.mat-mdc-slider .mdc-slider__value-indicator-text{letter-spacing:var(--mdc-slider-label-label-text-tracking, 0.0071428571em);font-size:var(--mdc-slider-label-label-text-size, 0.875rem);font-family:var(--mdc-slider-label-label-text-font, Roboto, sans-serif);font-weight:var(--mdc-slider-label-label-text-weight, 500);line-height:var(--mdc-slider-label-label-text-line-height, 1.375rem)}.mat-mdc-slider .mdc-slider__track--active{border-radius:var(--mdc-slider-active-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__track--inactive{border-radius:var(--mdc-slider-inactive-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__thumb-knob{border-radius:var(--mdc-slider-handle-shape, 50%);width:var(--mdc-slider-handle-width, 20px);height:var(--mdc-slider-handle-height, 20px);border-style:solid;border-width:calc(var(--mdc-slider-handle-height, 20px) / 2) calc(var(--mdc-slider-handle-width, 20px) / 2)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{border-radius:var(--mdc-slider-with-tick-marks-container-shape, 50%)}.mat-mdc-slider .mdc-slider__thumb-knob{box-shadow:var(--mdc-slider-handle-elevation, 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb-knob{background-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb-knob{background-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:var(--mdc-slider-with-overlap-handle-outline-color, #fff);border-width:var(--mdc-slider-with-overlap-handle-outline-width, 1px)}.mat-mdc-slider .mdc-slider__input{box-sizing:content-box;pointer-events:auto}.mat-mdc-slider .mdc-slider__input.mat-mdc-slider-input-no-pointer-events{pointer-events:none}.mat-mdc-slider .mdc-slider__input.mat-slider__right-input{left:auto;right:0}.mat-mdc-slider .mdc-slider__thumb,.mat-mdc-slider .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider.mdc-slider--discrete .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__value-indicator{word-break:normal}.mat-mdc-slider .mdc-slider__track,.mat-mdc-slider .mdc-slider__thumb{pointer-events:none}.mat-mdc-slider .mdc-slider__value-indicator{opacity:var(--mat-mdc-slider-value-indicator-opacity, 1)}.mat-mdc-slider .mat-ripple .mat-ripple-element{background-color:var(--mat-mdc-slider-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-hover-ripple{background-color:var(--mat-mdc-slider-hover-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-focus-ripple,.mat-mdc-slider .mat-ripple .mat-mdc-slider-active-ripple{background-color:var(--mat-mdc-slider-focus-ripple-color, transparent)}.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__track--active_fill,.mat-mdc-slider._mat-animation-noopable .mdc-slider__value-indicator{transition:none}.mat-mdc-slider .mat-mdc-focus-indicator::before{border-radius:50%}.mdc-slider__thumb--focused .mat-mdc-focus-indicator::before{content:""}'
							],
							encapsulation: 2,
							changeDetection: 0
						})
					}
				}
				return t
			})()
			const p2e = { provide: ds, useExisting: Kn(() => HO), multi: !0 }
			let HO = (() => {
					class t {
						get value() {
							return to(this._hostElement.value)
						}
						set value(e) {
							const i = to(e).toString()
							this._hasSetInitialValue
								? this._isActive ||
								  ((this._hostElement.value = i),
								  this._updateThumbUIByValue(),
								  this._slider._onValueChange(this),
								  this._cdr.detectChanges(),
								  this._slider._cdr.markForCheck())
								: (this._initialValue = i)
						}
						get translateX() {
							return this._slider.min >= this._slider.max
								? ((this._translateX = 0), this._translateX)
								: (void 0 === this._translateX && (this._translateX = this._calcTranslateXByValue()), this._translateX)
						}
						set translateX(e) {
							this._translateX = e
						}
						get min() {
							return to(this._hostElement.min)
						}
						set min(e) {
							;(this._hostElement.min = to(e).toString()), this._cdr.detectChanges()
						}
						get max() {
							return to(this._hostElement.max)
						}
						set max(e) {
							;(this._hostElement.max = to(e).toString()), this._cdr.detectChanges()
						}
						get step() {
							return to(this._hostElement.step)
						}
						set step(e) {
							;(this._hostElement.step = to(e).toString()), this._cdr.detectChanges()
						}
						get disabled() {
							return Mn(this._hostElement.disabled)
						}
						set disabled(e) {
							;(this._hostElement.disabled = Mn(e)),
								this._cdr.detectChanges(),
								this._slider.disabled !== this.disabled && (this._slider.disabled = this.disabled)
						}
						get percentage() {
							return this._slider.min >= this._slider.max
								? this._slider._isRtl
									? 1
									: 0
								: (this.value - this._slider.min) / (this._slider.max - this._slider.min)
						}
						get fillPercentage() {
							return this._slider._cachedWidth
								? 0 === this._translateX
									? 0
									: this.translateX / this._slider._cachedWidth
								: this._slider._isRtl
								? 1
								: 0
						}
						_setIsFocused(e) {
							this._isFocused = e
						}
						constructor(e, i, r, o) {
							;(this._ngZone = e),
								(this._elementRef = i),
								(this._cdr = r),
								(this._slider = o),
								(this.valueChange = new _n()),
								(this.dragStart = new _n()),
								(this.dragEnd = new _n()),
								(this.thumbPosition = 2),
								(this._knobRadius = 8),
								(this._isActive = !1),
								(this._isFocused = !1),
								(this._hasSetInitialValue = !1),
								(this._destroyed = new vt()),
								(this._skipUIUpdate = !1),
								(this._onTouchedFn = () => {}),
								(this._isControlInitialized = !1),
								(this._platform = Rt(Wr)),
								(this._hostElement = i.nativeElement),
								this._ngZone.runOutsideAngular(() => {
									this._hostElement.addEventListener("pointerdown", this._onPointerDown.bind(this)),
										this._hostElement.addEventListener("pointermove", this._onPointerMove.bind(this)),
										this._hostElement.addEventListener("pointerup", this._onPointerUp.bind(this))
								})
						}
						ngOnDestroy() {
							this._hostElement.removeEventListener("pointerdown", this._onPointerDown),
								this._hostElement.removeEventListener("pointermove", this._onPointerMove),
								this._hostElement.removeEventListener("pointerup", this._onPointerUp),
								this._destroyed.next(),
								this._destroyed.complete(),
								this.dragStart.complete(),
								this.dragEnd.complete()
						}
						initProps() {
							this._updateWidthInactive(),
								this.disabled !== this._slider.disabled && (this._slider.disabled = !0),
								(this.step = this._slider.step),
								(this.min = this._slider.min),
								(this.max = this._slider.max),
								this._initValue()
						}
						initUI() {
							this._updateThumbUIByValue()
						}
						_initValue() {
							;(this._hasSetInitialValue = !0),
								void 0 === this._initialValue
									? (this.value = this._getDefaultValue())
									: ((this._hostElement.value = this._initialValue),
									  this._updateThumbUIByValue(),
									  this._slider._onValueChange(this),
									  this._cdr.detectChanges())
						}
						_getDefaultValue() {
							return this.min
						}
						_onBlur() {
							this._setIsFocused(!1), this._onTouchedFn()
						}
						_onFocus() {
							this._setIsFocused(!0)
						}
						_onChange() {
							this.valueChange.emit(this.value), this._isActive && this._updateThumbUIByValue({ withAnimation: !0 })
						}
						_onInput() {
							this._onChangeFn?.(this.value),
								(this._slider.step || !this._isActive) && this._updateThumbUIByValue({ withAnimation: !0 }),
								this._slider._onValueChange(this)
						}
						_onNgControlValueChange() {
							;(!this._isActive || !this._isFocused) && (this._slider._onValueChange(this), this._updateThumbUIByValue()),
								(this._slider.disabled = this._formControl.disabled)
						}
						_onPointerDown(e) {
							if (!this.disabled && 0 === e.button) {
								if (this._platform.IOS) {
									const i = this._slider._isCursorOnSliderThumb(
										e,
										this._slider._getThumb(this.thumbPosition)._hostElement.getBoundingClientRect()
									)
									return (this._isActive = i), this._updateWidthActive(), void this._slider._updateDimensions()
								}
								;(this._isActive = !0),
									this._setIsFocused(!0),
									this._updateWidthActive(),
									this._slider._updateDimensions(),
									this._slider.step || this._updateThumbUIByPointerEvent(e, { withAnimation: !0 }),
									this.disabled ||
										(this._handleValueCorrection(e),
										this.dragStart.emit({ source: this, parent: this._slider, value: this.value }))
							}
						}
						_handleValueCorrection(e) {
							;(this._skipUIUpdate = !0),
								setTimeout(() => {
									;(this._skipUIUpdate = !1), this._fixValue(e)
								}, 0)
						}
						_fixValue(e) {
							const i = e.clientX - this._slider._cachedLeft,
								r = this._slider._cachedWidth,
								o = 0 === this._slider.step ? 1 : this._slider.step,
								s = Math.floor((this._slider.max - this._slider.min) / o),
								l =
									(Math.round((this._slider._isRtl ? 1 - i / r : i / r) * s) / s) *
										(this._slider.max - this._slider.min) +
									this._slider.min,
								d = Math.round(l / o) * o
							if (d === this.value)
								return (
									this._slider._onValueChange(this),
									void (this._slider.step > 0
										? this._updateThumbUIByValue()
										: this._updateThumbUIByPointerEvent(e, { withAnimation: this._slider._hasAnimation }))
								)
							;(this.value = d),
								this.valueChange.emit(this.value),
								this._onChangeFn?.(this.value),
								this._slider._onValueChange(this),
								this._slider.step > 0
									? this._updateThumbUIByValue()
									: this._updateThumbUIByPointerEvent(e, { withAnimation: this._slider._hasAnimation })
						}
						_onPointerMove(e) {
							!this._slider.step && this._isActive && this._updateThumbUIByPointerEvent(e)
						}
						_onPointerUp() {
							this._isActive &&
								((this._isActive = !1),
								this.dragEnd.emit({ source: this, parent: this._slider, value: this.value }),
								setTimeout(() => this._updateWidthInactive(), this._platform.IOS ? 10 : 0))
						}
						_clamp(e) {
							return Math.max(Math.min(e, this._slider._cachedWidth), 0)
						}
						_calcTranslateXByValue() {
							return this._slider._isRtl
								? (1 - this.percentage) * this._slider._cachedWidth
								: this.percentage * this._slider._cachedWidth
						}
						_calcTranslateXByPointerEvent(e) {
							return e.clientX - this._slider._cachedLeft
						}
						_updateWidthActive() {
							;(this._hostElement.style.padding = `0 ${this._slider._inputPadding}px`),
								(this._hostElement.style.width = `calc(100% + ${this._slider._inputPadding}px)`)
						}
						_updateWidthInactive() {
							;(this._hostElement.style.padding = "0px"),
								(this._hostElement.style.width = "calc(100% + 48px)"),
								(this._hostElement.style.left = "-24px")
						}
						_updateThumbUIByValue(e) {
							;(this.translateX = this._clamp(this._calcTranslateXByValue())), this._updateThumbUI(e)
						}
						_updateThumbUIByPointerEvent(e, i) {
							;(this.translateX = this._clamp(this._calcTranslateXByPointerEvent(e))), this._updateThumbUI(i)
						}
						_updateThumbUI(e) {
							this._slider._setTransition(!!e?.withAnimation), this._slider._onTranslateXChange(this)
						}
						writeValue(e) {
							;(this._isControlInitialized || null !== e) && (this.value = e)
						}
						registerOnChange(e) {
							;(this._onChangeFn = e), (this._isControlInitialized = !0)
						}
						registerOnTouched(e) {
							this._onTouchedFn = e
						}
						setDisabledState(e) {
							this.disabled = e
						}
						focus() {
							this._hostElement.focus()
						}
						blur() {
							this._hostElement.blur()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(mn), P(wn), P(Jr), P(fk))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["input", "matSliderThumb", ""]],
								hostAttrs: ["type", "range", 1, "mdc-slider__input"],
								hostVars: 1,
								hostBindings: function (i, r) {
									1 & i &&
										Le("change", function () {
											return r._onChange()
										})("input", function () {
											return r._onInput()
										})("blur", function () {
											return r._onBlur()
										})("focus", function () {
											return r._onFocus()
										}),
										2 & i && qn("aria-valuetext", r._valuetext)
								},
								inputs: { value: "value" },
								outputs: { valueChange: "valueChange", dragStart: "dragStart", dragEnd: "dragEnd" },
								exportAs: ["matSliderThumb"],
								features: [Xn([p2e, { provide: zY, useExisting: t }])]
							})
						}
					}
					return t
				})(),
				WY = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Yi, Ot, Vh] })
						}
					}
					return t
				})(),
				mk = (() => {
					class t {
						constructor() {
							;(this.step = 1), (this.disabled = !1)
						}
						handleSliderOnChange(e) {
							e !== this.value && this.onChange(e)
						}
						handleInputOnChange(e) {
							const i = UO(e, this.min, this.max)
							i !== this.value && !Number.isNaN(i) && this.onChange(i)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-slider"]],
								inputs: {
									value: "value",
									min: "min",
									max: "max",
									label: "label",
									step: "step",
									disabled: "disabled",
									onChange: "onChange"
								},
								decls: 8,
								vars: 10,
								consts: [
									[1, "cc-slider-container"],
									[1, "label"],
									[1, "slider-with-input"],
									[3, "disabled", "step", "min", "max"],
									["matSliderThumb", "", 3, "value", "input"],
									["appearance", "outline"],
									["matInput", "", "type", "number", 3, "value", "disabled", "min", "max", "input"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div", 0)(1, "mat-label", 1),
										ge(2),
										L(),
										F(3, "div", 2)(4, "mat-slider", 3)(5, "input", 4),
										Le("input", function (s) {
											return r.handleInputOnChange(s)
										}),
										L()(),
										F(6, "mat-form-field", 5)(7, "input", 6),
										Le("input", function (s) {
											return r.handleInputOnChange(s)
										}),
										L()()()()),
										2 & i &&
											(T(2),
											cr(r.label),
											T(2),
											U("disabled", r.disabled)("step", r.step)("min", r.min)("max", r.max),
											T(1),
											U("value", r.value),
											T(2),
											U("value", r.value)("disabled", r.disabled)("min", r.min)("max", r.max))
								},
								dependencies: [Bd, yf, kp, f2e, HO],
								styles: [
									"cc-slider{width:100%;margin-top:8px}cc-slider .label{margin-left:10px}cc-slider .cc-slider-container{display:flex;flex-direction:column}cc-slider .cc-slider-container .slider-with-input{display:flex;align-items:center}cc-slider .cc-slider-container .slider-with-input mat-slider{margin:0 12px;flex:2}cc-slider .cc-slider-container .slider-with-input mat-form-field{flex:1;height:32px}cc-slider .cc-slider-container .slider-with-input mat-form-field .mat-mdc-text-field-wrapper{padding:0 12px}cc-slider .cc-slider-container .slider-with-input mat-form-field .mat-mdc-text-field-wrapper .mat-mdc-form-field-flex{align-self:center}cc-slider .cc-slider-container .slider-with-input mat-form-field .mat-mdc-text-field-wrapper .mat-mdc-form-field-flex .mat-mdc-form-field-infix{padding:0;min-height:28px}cc-slider .cc-slider-container .slider-with-input mat-form-field .mat-mdc-text-field-wrapper .mat-mdc-form-field-flex .mat-mdc-form-field-infix .mat-mdc-input-element{min-height:inherit}cc-slider .cc-slider-container .slider-with-input mat-form-field .mat-mdc-form-field-subscript-wrapper.mat-mdc-form-field-bottom-align{display:none}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const VO = Mt(Vc, t =>
					(function jme(t) {
						const n = []
						if (void 0 !== t) for (const { data: e } of $r(t)) "Folder" !== e.type && n.push(e)
						return n
					})(t.unifiedMapNode)
				),
				b2e = ni(1, Gt(Lm, Si(1))),
				jY = t => {
					const n = Math.floor(t.length / 100)
					return n <= 1 ? 1 : Math.min(n, 10)
				},
				QO = { positive: !1, negative: !1, neutral: !1 },
				y2e = ni(QO, Gt(W0, zS(QO))),
				w2e = ni(!0, Gt(rv, Si(!0))),
				x2e = ni(!1, Gt(iv, Si(!1))),
				KY = Nt("SET_SORTING_ORDER_ASCENDING", { _as: "props", _p: void 0 }),
				$O = Nt("TOGGLE_SORTING_ORDER_ASCENDING"),
				C2e = ni(
					!0,
					Gt(KY, Si(!0)),
					Gt($O, t => !t)
				),
				E2e = ni(!0, Gt(Dm, Si(!0))),
				M2e = ni(!0, Gt(fg, Si(!0))),
				S2e = ni(!0, Gt(oE, Si(!0))),
				k2e = ni(!1, Gt(ov, Si(!1))),
				T2e = ni(!1, Gt(Z0, Si(!1))),
				F2e = ni(!1, Gt(q0, Si(!1))),
				B2e = ni(!1, Gt(X0, Si(!1))),
				eN = { x: 1, y: 1, z: 1 },
				I2e = ni(eN, Gt(tv, zS(eN))),
				D2e = ni(4, Gt(j0, Si(4))),
				pk = Nt("SET_AMOUNT_OF_EDGE_PREVIEWS", { _as: "props", _p: void 0 }),
				L2e = ni(1, Gt(pk, Si(1))),
				R2e = ni(!1, Gt(nE, Si(!1))),
				P2e = ni(!1, Gt(eE, Si(!1))),
				oN = Ad.SquarifiedTreeMap,
				O2e = ni(oN, Gt(J0, Si(oN))),
				N2e = ni(100, Gt(ev, Si(100))),
				aN = Qm.Standard,
				U2e = ni(aN, Gt(nv, Si(aN))),
				H2e = ni(!1, Gt(JC, Si(!1))),
				V2e = ni(!1, Gt(Y0, Si(!1))),
				Q2e = ni(
					!0,
					Gt(XI, (t, n) => n.value),
					Gt(tE, t => !t)
				),
				z2e = ni(
					!1,
					Gt(YI, (t, n) => n.value),
					Gt(qI, t => !t)
				),
				qY = Nt("SET_IS_FILE_EXPLORER_PINNED", { _as: "props", _p: void 0 }),
				dN = Nt("TOGGLE_IS_FILE_EXPLORER_PINNED"),
				G2e = ni(
					!1,
					Gt(qY, Si(!1)),
					Gt(dN, t => !t)
				),
				W2e = Im({
					colorLabels: y2e,
					showMetricLabelNodeName: w2e,
					showMetricLabelNameValue: x2e,
					sortingOrderAscending: C2e,
					isSearchPanelPinned: G2e,
					isLoadingFile: E2e,
					isLoadingMap: M2e,
					mapColors: WEe,
					resetCameraIfNewFileIsLoaded: S2e,
					showOnlyBuildingsWithEdges: k2e,
					isEdgeMetricVisible: Q2e,
					isWhiteBackground: T2e,
					invertHeight: F2e,
					invertArea: V2e,
					hideFlatBuildings: B2e,
					scaling: I2e,
					edgeHeight: D2e,
					amountOfEdgePreviews: L2e,
					amountOfTopLabels: b2e,
					isPresentationMode: R2e,
					experimentalFeaturesEnabled: P2e,
					screenshotToClipboardEnabled: H2e,
					layoutAlgorithm: O2e,
					maxTreeMapFiles: N2e,
					sharpnessMode: U2e,
					isColorMetricLinkedToHeightMetric: z2e,
					enableFloorLabels: ni(!0, Gt(K0, Si(!0)))
				}),
				j2e = {
					colorLabels: QO,
					showMetricLabelNodeName: !0,
					showMetricLabelNameValue: !1,
					sortingOrderAscending: !0,
					isSearchPanelPinned: !1,
					isLoadingFile: !0,
					isLoadingMap: !0,
					mapColors: Vu,
					resetCameraIfNewFileIsLoaded: !0,
					showOnlyBuildingsWithEdges: !1,
					isEdgeMetricVisible: !0,
					isWhiteBackground: !1,
					invertHeight: !1,
					invertArea: !1,
					hideFlatBuildings: !1,
					scaling: eN,
					edgeHeight: 4,
					amountOfEdgePreviews: 1,
					amountOfTopLabels: 1,
					isPresentationMode: !1,
					experimentalFeaturesEnabled: !1,
					screenshotToClipboardEnabled: !1,
					layoutAlgorithm: oN,
					maxTreeMapFiles: 100,
					sharpnessMode: aN,
					isColorMetricLinkedToHeightMetric: !1,
					enableFloorLabels: !0
				}
			function ZY(t, n) {
				return t.filter(e => !Tp(e, n))
			}
			function JY(t, n) {
				return eq(t, n) ? t : [...t, dd(n)]
			}
			function eq(t, n) {
				return t.some(e => Tp(e, n))
			}
			const Y2e = (t, { path: n, color: e }) => {
					const i = jP(t, n)
					;(!i || i.color !== e) && t.set(n, { path: n, color: e })
					for (const [r, o] of t)
						if (o.path === n) o.color !== e && t.delete(r)
						else if (o.path.startsWith(n)) {
							const s = jP(t, o.path)
							s && s.color === o.color && t.delete(r)
						}
				},
				tq = (t, n) => {
					const e = t.findIndex(r => r.path === n)
					if (-1 !== e) return e
					let i = -1
					for (let r = 0; r < t.length; r++) {
						const o = t[r]
						n.startsWith(o.path) && (-1 === i || t[i].path.length < o.path.length) && (i = r)
					}
					return i
				},
				fN = [],
				q2e = ni(
					fN,
					Gt(hE, Si(fN)),
					Gt(dv, (t, n) => {
						const e = new Map(t.map(i => [i.path, i]))
						for (const i of n.packages) Y2e(e, i)
						return [...e.values()]
					}),
					Gt(fE, (t, n) => {
						const e = tq(t, n.path)
						return -1 !== e
							? (function K2e(t, n) {
									return [...t.slice(0, n), ...t.slice(n + 1)]
							  })(t, e)
							: t
					})
				),
				mN = [],
				Z2e = ni(
					mN,
					Gt(rD, Si(mN)),
					Gt(G6, (t, n) => JY(t, n.edge)),
					Gt($6, (t, n) => ZY(t, n.edge))
				),
				pN = { nodes: {}, edges: {} },
				J2e = ni(
					pN,
					Gt(JI, Si(pN)),
					Gt(eD, (t, n) => ({ ...t, [n.category]: { ...t[n.category], [n.name]: n.attributeType } }))
				),
				AN = [],
				eIe = ni(
					AN,
					Gt(tD, Si(AN)),
					Gt(nD, (t, n) => JY(t, n.item)),
					Gt(dE, (t, n) =>
						(function X2e(t, n) {
							const e = [...t]
							for (const i of n) eq(e, i) || e.push(i)
							return e
						})(t, n.items)
					),
					Gt(uE, (t, n) => ZY(t, n.item))
				),
				gN = {},
				nIe = Im({
					markedPackages: q2e,
					edges: Z2e,
					attributeTypes: J2e,
					attributeDescriptors: ni(gN, Gt(ZI, Si(gN))),
					blacklist: eIe
				}),
				iIe = { markedPackages: fN, edges: mN, attributeTypes: pN, attributeDescriptors: gN, blacklist: AN },
				bN = Rv.weightedGradient,
				rIe = ni(bN, Gt(sv, Si(bN))),
				_N = XE.NAME,
				oIe = ni(_N, Gt(lE, Si(_N))),
				sIe = ni(null, Gt(Oh, Si(null))),
				yN = { from: 0, to: 0 },
				aIe = ni(yN, Gt(sd, zS(yN))),
				cIe = ni(50, Gt(lv, Si(50))),
				lIe = ni(
					"",
					Gt(Nh, Si("")),
					Gt(pv, () => "")
				),
				nq = [],
				dIe = ni(
					nq,
					Gt(sE, (t, n) => [...n.value]),
					Gt(cv, () => []),
					Gt(aE, (t, n) => (n.value === bd.rootPath ? t : [n.value, ...t])),
					Gt(cE, t => t.slice(1))
				),
				pIe = Im({
					colorMode: rIe,
					sortingOption: oIe,
					edgeMetric: sIe,
					colorRange: aIe,
					margin: cIe,
					searchPattern: lIe,
					focusedNodePath: dIe,
					heightMetric: ni(null, Gt(bu, Si(null))),
					distributionMetric: ni(null, Gt(av, Si(null))),
					colorMetric: ni(null, Gt(hl, Si(null))),
					areaMetric: ni(null, Gt(gu, Si(null)))
				}),
				AIe = {
					colorMode: bN,
					sortingOption: _N,
					edgeMetric: null,
					colorRange: yN,
					margin: 50,
					searchPattern: "",
					focusedNodePath: nq,
					heightMetric: null,
					distributionMetric: null,
					colorMetric: null,
					areaMetric: null
				},
				SN = [],
				gIe = ni(
					SN,
					Gt(mv, Si(SN)),
					Gt(dG, (t, n) => [...t, { file: n.file, selectedAs: Fi.None }]),
					Gt(xD, (t, n) =>
						(function bIe(t, n) {
							const e = t.filter(r => r.file.fileMeta.fileName !== n)
							return e.some(r => r.selectedAs === Fi.Partial) || (e[0] = { ...e[0], selectedAs: Fi.Partial }), e
						})(t, n.fileName)
					),
					Gt(CE, (t, n) =>
						(function _Ie(t, n, e) {
							return t.map(i =>
								AE(i.file, n)
									? { ...i, selectedAs: Fi.Reference }
									: e && AE(i.file, e)
									? { ...i, selectedAs: Fi.Comparison }
									: { ...i, selectedAs: Fi.None }
							)
						})(t, n.referenceFile, n.comparisonFile)
					),
					Gt(TD, (t, n) =>
						(function vIe(t, n) {
							return t.map(e =>
								AE(e.file, n)
									? { ...e, selectedAs: Fi.Reference }
									: e.selectedAs === Fi.Comparison
									? e
									: { ...e, selectedAs: Fi.None }
							)
						})(t, n.file)
					),
					Gt(kD, (t, n) =>
						(function yIe(t, n) {
							return t.map(e =>
								e.file === n
									? { ...e, selectedAs: Fi.Comparison }
									: e.selectedAs === Fi.Reference
									? e
									: { ...e, selectedAs: Fi.None }
							)
						})(t, n.file)
					),
					Gt(SD, t =>
						(function wIe(t) {
							return t.map(n =>
								n.selectedAs === Fi.Reference
									? { ...n, selectedAs: Fi.Comparison }
									: n.selectedAs === Fi.Comparison
									? { ...n, selectedAs: Fi.Reference }
									: n
							)
						})(t)
					),
					Gt(pv, (t, n) =>
						iq(
							t,
							n.files.map(e => e.fileMeta.fileName)
						)
					),
					Gt(CD, (t, n) => iq(t, n.fileNames)),
					Gt(MD, t => t.map(n => ({ ...n, selectedAs: n.selectedAs === Fi.Partial ? Fi.None : Fi.Partial }))),
					Gt(ED, t => t.map(n => ({ ...n, selectedAs: Fi.Partial })))
				)
			function iq(t, n) {
				return t.map(e => ({ ...e, selectedAs: n.includes(e.file.fileMeta.fileName) ? Fi.Partial : Fi.None }))
			}
			const xIe = ni(null, Gt(wb, Si(null))),
				CIe = ni(
					null,
					Gt(xb, (t, n) => n.value)
				),
				kIe = {
					fileSettings: nIe,
					appSettings: W2e,
					dynamicSettings: pIe,
					files: gIe,
					appStatus: Im({ hoveredNodeId: xIe, selectedBuildingId: ni(null, Gt(WP, Si(null))), rightClickedNodeData: CIe })
				},
				oq = {
					fileSettings: iIe,
					appSettings: j2e,
					dynamicSettings: AIe,
					files: SN,
					appStatus: { hoveredNodeId: null, selectedBuildingId: null, rightClickedNodeData: null }
				},
				TIe = t => (n, e) =>
					(function Fke(t) {
						return t.type === Sp.type
					})(e)
						? sq(dd(n), e.value)
						: t(n, e),
				FIe = new Set([
					"fileSettings.attributeTypes",
					"fileSettings.attributeDescriptors",
					"fileSettings.blacklist",
					"fileSettings.edges",
					"fileSettings.markedPackages",
					"dynamicSettings.focusedNodePath",
					"files"
				])
			function sq(t, n, e = []) {
				for (const [i, r] of Object.entries(n)) {
					if (null == r || !BIe(t, i)) continue
					const o = [...e, i],
						s = o.join(".")
					t[i] = "object" != typeof r || FIe.has(s) ? r : sq(t[i], r, o)
				}
				return t
			}
			function BIe(t, n) {
				return Object.prototype.hasOwnProperty.call(t, n)
			}
			function LIe(t, n) {
				if ((1 & t && (F(0, "span", 3), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1), Vt(" ", e.label, "")
				}
			}
			let kw = (() => {
				class t {
					constructor(e, i) {
						;(this.store = e), (this.state = i)
					}
					applyDefaultSettings() {
						const e = ((t, n) => {
							const e = {}
							let i = 0
							for (const r of t) {
								const o = r.split(".")
								let s = oq,
									a = e
								for (const [c, l] of o.entries())
									void 0 !== s[l] &&
										(a[l] || ((a[l] = {}), i++), c === o.length - 1 ? (a[l] = s[l]) : ((s = s[l]), (a = a[l])))
							}
							return (
								0 !== i && yO(e),
								t.includes("appSettings.amountOfTopLabels") && (e.appSettings.amountOfTopLabels = jY(VO(n))),
								e
							)
						})(this.settingsKeys, this.state.getValue())
						this.store.dispatch(Sp({ value: e })), this.callback && this.callback()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct), P(Sr))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-reset-settings-button"]],
							inputs: { settingsKeys: "settingsKeys", tooltip: "tooltip", label: "label", callback: "callback" },
							decls: 3,
							vars: 2,
							consts: [
								[3, "title", "click"],
								[1, "fa", "fa-undo"],
								["class", "reset-settings-button-label", 4, "ngIf"],
								[1, "reset-settings-button-label"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "button", 0),
									Le("click", function () {
										return r.applyDefaultSettings()
									}),
									fe(1, "i", 1),
									Ee(2, LIe, 2, 1, "span", 2),
									L()),
									2 & i && (U("title", r.tooltip), T(2), U("ngIf", r.label))
							},
							dependencies: [En],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-reset-settings-button button{color:#1b9cfc;background:none;align-items:center;display:flex;gap:4px;margin:0;padding:0}cc-reset-settings-button button .fa{display:flex;align-items:center;justify-content:center;height:40px;width:40px;font-size:18px}cc-reset-settings-button button:hover .fa{border-radius:100%;background-color:#9e9e9e33}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const RIe = function () {
				return ["dynamicSettings.margin", "appSettings.invertArea", "appSettings.enableFloorLabels"]
			}
			let PIe = (() => {
				class t {
					static {
						this.DEBOUNCE_TIME = 400
					}
					constructor(e) {
						;(this.store = e),
							(this.margin$ = this.store.select(QBe)),
							(this.enableFloorLabels$ = this.store.select(zBe)),
							(this.isInvertedArea$ = this.store.select(GBe)),
							(this.applyDebouncedMargin = Fd(i => {
								this.store.dispatch(lv({ value: i }))
							}, t.DEBOUNCE_TIME))
					}
					setEnableFloorLabel(e) {
						this.store.dispatch(K0({ value: e.checked }))
					}
					toggleInvertingArea(e) {
						this.store.dispatch(Y0({ value: e.checked }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-area-settings-panel"]],
							decls: 10,
							vars: 14,
							consts: [
								[1, "options"],
								[
									"title",
									"Amount of space between buildings in percent",
									"label",
									"Margin",
									3,
									"value",
									"onChange",
									"min",
									"max"
								],
								[3, "checked", "change"],
								[
									"tooltip",
									"Reset area metric settings to their defaults",
									"label",
									"Reset area metric settings",
									3,
									"settingsKeys"
								]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "div", 0),
									fe(1, "cc-slider", 1),
									Me(2, "async"),
									F(3, "mat-checkbox", 2),
									Le("change", function (s) {
										return r.setEnableFloorLabel(s)
									}),
									Me(4, "async"),
									ge(5, "Enable Floor Labels"),
									L(),
									F(6, "mat-checkbox", 2),
									Le("change", function (s) {
										return r.toggleInvertingArea(s)
									}),
									Me(7, "async"),
									ge(8, "Invert Area"),
									L(),
									fe(9, "cc-reset-settings-button", 3),
									L()),
									2 & i &&
										(T(1),
										U("value", De(2, 7, r.margin$))("onChange", r.applyDebouncedMargin)("min", 1)("max", 100),
										T(2),
										U("checked", De(4, 9, r.enableFloorLabels$)),
										T(3),
										U("checked", De(7, 11, r.isInvertedArea$)),
										T(3),
										U("settingsKeys", kh(13, RIe)))
							},
							dependencies: [Fb, mk, kw, Bn],
							styles: [
								"cc-area-settings-panel{text-align:left;max-height:300px}cc-area-settings-panel .options{display:flex;flex-direction:column}cc-area-settings-panel .options .margin-option{position:relative}cc-area-settings-panel .options .margin-option cc-reset-settings-button{position:absolute;top:-20%;left:20%}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const OIe = Mt(Tr, t => t.amountOfTopLabels),
				aq = Mt(Tr, t => t.colorLabels),
				NIe = Mt(aq, t => t.negative || t.neutral || t.positive),
				UIe = Mt(Tr, t => t.showMetricLabelNodeName),
				HIe = Mt(Tr, t => t.showMetricLabelNameValue),
				VIe = Mt(Tr, t => t.scaling),
				QIe = Mt(Tr, t => t.invertHeight)
			function zIe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-checkbox", 1),
						Le("change", function (r) {
							return rn(e), on(Te().setInvertHeight(r))
						}),
						Me(1, "async"),
						ge(2, " Invert Height\n"),
						L()
				}
				2 & t && U("checked", De(1, 1, Te().invertHeight$))
			}
			const GIe = function () {
				return ["appSettings.amountOfTopLabels", "appSettings.scaling.y", "appSettings.invertHeight"]
			}
			let $Ie = (() => {
					class t {
						static {
							this.DEBOUNCE_TIME = 400
						}
						constructor(e) {
							;(this.store = e),
								(this.amountOfTopLabels$ = this.store.select(OIe)),
								(this.isLabelsSliderDisabled$ = this.store.select(NIe)),
								(this.showMetricLabelNodeName$ = this.store.select(UIe)),
								(this.showMetricLabelNodeValue$ = this.store.select(HIe)),
								(this.scaling$ = this.store.select(VIe)),
								(this.invertHeight$ = this.store.select(QIe)),
								(this.isDeltaState$ = this.store.select(_f)),
								(this.applyDebouncedTopLabels = Fd(i => {
									this.store.dispatch(Lm({ value: i }))
								}, t.DEBOUNCE_TIME)),
								(this.applyDebouncedScalingY = Fd(i => {
									this.store.dispatch(tv({ value: { y: i } }))
								}, t.DEBOUNCE_TIME))
						}
						setShowMetricLabelNodeName(e) {
							this.store.dispatch(rv({ value: e.checked }))
						}
						setShowMetricLabelNameValue(e) {
							this.store.dispatch(iv({ value: e.checked }))
						}
						setInvertHeight(e) {
							this.store.dispatch(q0({ value: e.checked }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-height-settings-panel"]],
								decls: 16,
								vars: 32,
								consts: [
									[
										"label",
										"Labels",
										1,
										"cc-height-settings-panel-row",
										3,
										"disabled",
										"title",
										"min",
										"max",
										"value",
										"onChange"
									],
									[3, "checked", "change"],
									[
										"title",
										"Height",
										"label",
										"Height",
										1,
										"cc-height-settings-panel-row",
										3,
										"step",
										"min",
										"max",
										"value",
										"onChange"
									],
									[3, "checked", "change", 4, "ngIf"],
									[
										"tooltip",
										"Reset height metric settings to their defaults",
										"label",
										"Reset height metric settings",
										3,
										"settingsKeys"
									]
								],
								template: function (i, r) {
									1 & i &&
										(fe(0, "cc-slider", 0),
										Me(1, "async"),
										Me(2, "async"),
										Me(3, "async"),
										Me(4, "async"),
										F(5, "mat-checkbox", 1),
										Le("change", function (s) {
											return r.setShowMetricLabelNodeName(s)
										}),
										Me(6, "async"),
										ge(7, "Show label node names\n"),
										L(),
										F(8, "mat-checkbox", 1),
										Le("change", function (s) {
											return r.setShowMetricLabelNameValue(s)
										}),
										Me(9, "async"),
										ge(10, "Show label node metrics\n"),
										L(),
										fe(11, "cc-slider", 2),
										Me(12, "async"),
										Ee(13, zIe, 3, 3, "mat-checkbox", 3),
										Me(14, "async"),
										fe(15, "cc-reset-settings-button", 4)),
										2 & i &&
											(U("disabled", De(1, 15, r.isLabelsSliderDisabled$))(
												"title",
												De(2, 17, r.isLabelsSliderDisabled$)
													? "Disabled because color labels are used"
													: "Display the labels of the " + De(3, 19, r.amountOfTopLabels$) + " highest buildings"
											)("min", 0)("max", 50)("value", De(4, 21, r.amountOfTopLabels$))(
												"onChange",
												r.applyDebouncedTopLabels
											),
											T(5),
											U("checked", De(6, 23, r.showMetricLabelNodeName$)),
											T(3),
											U("checked", De(9, 25, r.showMetricLabelNodeValue$)),
											T(3),
											U("step", 1)("min", 1)("max", 5)("value", De(12, 27, r.scaling$).y)(
												"onChange",
												r.applyDebouncedScalingY
											),
											T(2),
											U("ngIf", !De(14, 29, r.isDeltaState$)),
											T(2),
											U("settingsKeys", kh(31, GIe)))
								},
								dependencies: [En, Fb, mk, kw, Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				WIe = (() => {
					class t {
						constructor(e) {
							;(this.store = e), (this.heightMetric$ = this.store.select(Aw))
						}
						handleHeightMetricChanged(e) {
							this.store.dispatch(bu({ value: e }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-height-metric-chooser"]],
								decls: 4,
								vars: 6,
								consts: [
									[1, "fa", "fa-arrows-v"],
									["title", "Change height metric", 3, "selectedMetricName", "searchPlaceholder", "handleMetricChanged"],
									["hoveredInformation", "", 3, "metricFor"]
								],
								template: function (i, r) {
									1 & i &&
										(fe(0, "i", 0),
										F(1, "cc-metric-chooser", 1),
										Me(2, "async"),
										fe(3, "cc-metric-chooser-value", 2),
										L()),
										2 & i &&
											(T(1),
											U("selectedMetricName", De(2, 4, r.heightMetric$))(
												"searchPlaceholder",
												"Height Metric (highest value)"
											)("handleMetricChanged", r.handleHeightMetricChanged),
											T(2),
											U("metricFor", "heightMetric"))
								},
								dependencies: [Cw, NO, Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const FN = Mt(Tr, t => t.isColorMetricLinkedToHeightMetric)
			let jIe = (() => {
					class t {
						constructor(e) {
							;(this.store = e), (this.isColorMetricLinkedToHeightMetric$ = this.store.select(FN))
						}
						toggleIsColorMetricLinkedToHeightMetric() {
							this.store.dispatch(qI())
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-link-color-metric-to-height-metric-button"]],
								decls: 4,
								vars: 6,
								consts: [
									[1, "link-metrics-button", 3, "title", "click"],
									[3, "ngClass"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.toggleIsColorMetricLinkedToHeightMetric()
										}),
										Me(1, "async"),
										fe(2, "i", 1),
										Me(3, "async"),
										L()),
										2 & i &&
											(Fa(
												"title",
												De(1, 2, r.isColorMetricLinkedToHeightMetric$)
													? "Unlink Height and Color Metric"
													: "Link Height and Color Metric"
											),
											T(2),
											U(
												"ngClass",
												De(3, 4, r.isColorMetricLinkedToHeightMetric$) ? "fa fa-chain-broken" : "fa fa-link"
											))
								},
								dependencies: [Em, Bn],
								styles: [
									"cc-link-color-metric-to-height-metric-button{display:flex;justify-content:center;height:100%}cc-link-color-metric-to-height-metric-button .link-metrics-button{width:50px;height:100%;padding:0;margin:0;background-color:transparent}cc-link-color-metric-to-height-metric-button .link-metrics-button .fa{color:#444}cc-link-color-metric-to-height-metric-button .link-metrics-button:hover{background-color:#c8c8c8}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				KIe = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.colorMetric$ = this.store.select(Af)),
								(this.isColorMetricLinkedToHeightMetric$ = this.store.select(FN)),
								(this.nonDisabledColor = "rgba(0, 0, 0, 0.38)"),
								(this.disabledColor = "rgba(68,68,68, 1)")
						}
						handleColorMetricChanged(e) {
							this.store.dispatch(hl({ value: e }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-color-metric-chooser"]],
								decls: 7,
								vars: 16,
								consts: [
									[1, "fa", "fa-paint-brush"],
									[3, "selectedMetricName", "searchPlaceholder", "handleMetricChanged", "isDisabled"],
									["hoveredInformation", "", 3, "metricFor"]
								],
								template: function (i, r) {
									1 & i &&
										(fe(0, "i", 0),
										Me(1, "async"),
										F(2, "cc-metric-chooser", 1),
										Me(3, "async"),
										Me(4, "async"),
										Me(5, "async"),
										fe(6, "cc-metric-chooser-value", 2),
										L()),
										2 & i &&
											(bi(
												"color",
												De(1, 8, r.isColorMetricLinkedToHeightMetric$) ? r.nonDisabledColor : r.disabledColor
											),
											T(2),
											U("selectedMetricName", De(3, 10, r.colorMetric$))(
												"searchPlaceholder",
												"Color Metric (highest value)"
											)("handleMetricChanged", r.handleColorMetricChanged)(
												"isDisabled",
												De(4, 12, r.isColorMetricLinkedToHeightMetric$)
											),
											qn(
												"title",
												De(5, 14, r.isColorMetricLinkedToHeightMetric$)
													? "Currently linked to height metric"
													: "Change color metric"
											),
											T(4),
											U("metricFor", "colorMetric"))
								},
								dependencies: [Cw, NO, Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const XIe = Mt(cc, t => t.colorMode),
				BN = t => {
					const e = Math.round((t.maxValue - t.minValue) / 3)
					return { from: e + t.minValue, to: 2 * e + t.minValue }
				},
				YIe = Mt(vb, _f, t => ({ leftColor: t.positive, middleColor: t.neutral, rightColor: t.negative })),
				qIe = Mt(gf, QX, (t, n) => ({ values: t.values, min: t.minValue, max: t.maxValue, from: n.from, to: n.to }))
			function cq(t, n) {
				let e
				if (void 0 === n) for (const i of t) null != i && (e < i || (void 0 === e && i >= i)) && (e = i)
				else {
					let i = -1
					for (let r of t) null != (r = n(r, ++i, t)) && (e < r || (void 0 === e && r >= r)) && (e = r)
				}
				return e
			}
			function JIe(t) {
				return t
			}
			function eDe(t) {
				return "translate(" + t + ",0)"
			}
			function tDe(t) {
				return "translate(0," + t + ")"
			}
			function nDe(t) {
				return n => +t(n)
			}
			function iDe(t, n) {
				return (n = Math.max(0, t.bandwidth() - 2 * n) / 2), t.round() && (n = Math.round(n)), e => +t(e) + n
			}
			function rDe() {
				return !this.__axis
			}
			function _k(t, n) {
				var e = [],
					i = null,
					r = null,
					o = 6,
					s = 6,
					a = 3,
					c = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5,
					l = 1 === t || 4 === t ? -1 : 1,
					d = 4 === t || 2 === t ? "x" : "y",
					u = 1 === t || 3 === t ? eDe : tDe
				function h(f) {
					var _ = i ?? (n.ticks ? n.ticks.apply(n, e) : n.domain()),
						y = r ?? (n.tickFormat ? n.tickFormat.apply(n, e) : JIe),
						C = Math.max(o, 0) + a,
						x = n.range(),
						w = +x[0] + c,
						S = +x[x.length - 1] + c,
						M = (n.bandwidth ? iDe : nDe)(n.copy(), c),
						O = f.selection ? f.selection() : f,
						N = O.selectAll(".domain").data([null]),
						j = O.selectAll(".tick").data(_, n).order(),
						le = j.exit(),
						ae = j.enter().append("g").attr("class", "tick"),
						ce = j.select("line"),
						ue = j.select("text")
					;(N = N.merge(N.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"))),
						(j = j.merge(ae)),
						(ce = ce.merge(
							ae
								.append("line")
								.attr("stroke", "currentColor")
								.attr(d + "2", l * o)
						)),
						(ue = ue.merge(
							ae
								.append("text")
								.attr("fill", "currentColor")
								.attr(d, l * C)
								.attr("dy", 1 === t ? "0em" : 3 === t ? "0.71em" : "0.32em")
						)),
						f !== O &&
							((N = N.transition(f)),
							(j = j.transition(f)),
							(ce = ce.transition(f)),
							(ue = ue.transition(f)),
							(le = le
								.transition(f)
								.attr("opacity", 1e-6)
								.attr("transform", function (Se) {
									return isFinite((Se = M(Se))) ? u(Se + c) : this.getAttribute("transform")
								})),
							ae.attr("opacity", 1e-6).attr("transform", function (Se) {
								var ve = this.parentNode.__axis
								return u((ve && isFinite((ve = ve(Se))) ? ve : M(Se)) + c)
							})),
						le.remove(),
						N.attr(
							"d",
							4 === t || 2 === t
								? s
									? "M" + l * s + "," + w + "H" + c + "V" + S + "H" + l * s
									: "M" + c + "," + w + "V" + S
								: s
								? "M" + w + "," + l * s + "V" + c + "H" + S + "V" + l * s
								: "M" + w + "," + c + "H" + S
						),
						j.attr("opacity", 1).attr("transform", function (Se) {
							return u(M(Se) + c)
						}),
						ce.attr(d + "2", l * o),
						ue.attr(d, l * C).text(y),
						O.filter(rDe)
							.attr("fill", "none")
							.attr("font-size", 10)
							.attr("font-family", "sans-serif")
							.attr("text-anchor", 2 === t ? "start" : 4 === t ? "end" : "middle"),
						O.each(function () {
							this.__axis = M
						})
				}
				return (
					(h.scale = function (f) {
						return arguments.length ? ((n = f), h) : n
					}),
					(h.ticks = function () {
						return (e = Array.from(arguments)), h
					}),
					(h.tickArguments = function (f) {
						return arguments.length ? ((e = null == f ? [] : Array.from(f)), h) : e.slice()
					}),
					(h.tickValues = function (f) {
						return arguments.length ? ((i = null == f ? null : Array.from(f)), h) : i && i.slice()
					}),
					(h.tickFormat = function (f) {
						return arguments.length ? ((r = f), h) : r
					}),
					(h.tickSize = function (f) {
						return arguments.length ? ((o = s = +f), h) : o
					}),
					(h.tickSizeInner = function (f) {
						return arguments.length ? ((o = +f), h) : o
					}),
					(h.tickSizeOuter = function (f) {
						return arguments.length ? ((s = +f), h) : s
					}),
					(h.tickPadding = function (f) {
						return arguments.length ? ((a = +f), h) : a
					}),
					(h.offset = function (f) {
						return arguments.length ? ((c = +f), h) : c
					}),
					h
				)
			}
			function aDe() {}
			function DN(t) {
				return null == t
					? aDe
					: function () {
							return this.querySelector(t)
					  }
			}
			function dDe() {
				return []
			}
			function dq(t) {
				return null == t
					? dDe
					: function () {
							return this.querySelectorAll(t)
					  }
			}
			function uq(t) {
				return function () {
					return this.matches(t)
				}
			}
			function hq(t) {
				return function (n) {
					return n.matches(t)
				}
			}
			var fDe = Array.prototype.find
			function pDe() {
				return this.firstElementChild
			}
			var gDe = Array.prototype.filter
			function bDe() {
				return Array.from(this.children)
			}
			function fq(t) {
				return new Array(t.length)
			}
			function vk(t, n) {
				;(this.ownerDocument = t.ownerDocument),
					(this.namespaceURI = t.namespaceURI),
					(this._next = null),
					(this._parent = t),
					(this.__data__ = n)
			}
			function CDe(t, n, e, i, r, o) {
				for (var a, s = 0, c = n.length, l = o.length; s < l; ++s)
					(a = n[s]) ? ((a.__data__ = o[s]), (i[s] = a)) : (e[s] = new vk(t, o[s]))
				for (; s < c; ++s) (a = n[s]) && (r[s] = a)
			}
			function EDe(t, n, e, i, r, o, s) {
				var a,
					c,
					f,
					l = new Map(),
					d = n.length,
					u = o.length,
					h = new Array(d)
				for (a = 0; a < d; ++a) (c = n[a]) && ((h[a] = f = s.call(c, c.__data__, a, n) + ""), l.has(f) ? (r[a] = c) : l.set(f, c))
				for (a = 0; a < u; ++a)
					(f = s.call(t, o[a], a, o) + ""),
						(c = l.get(f)) ? ((i[a] = c), (c.__data__ = o[a]), l.delete(f)) : (e[a] = new vk(t, o[a]))
				for (a = 0; a < d; ++a) (c = n[a]) && l.get(h[a]) === c && (r[a] = c)
			}
			function MDe(t) {
				return t.__data__
			}
			function kDe(t) {
				return "object" == typeof t && "length" in t ? t : Array.from(t)
			}
			function LDe(t, n) {
				return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN
			}
			vk.prototype = {
				constructor: vk,
				appendChild: function (t) {
					return this._parent.insertBefore(t, this._next)
				},
				insertBefore: function (t, n) {
					return this._parent.insertBefore(t, n)
				},
				querySelector: function (t) {
					return this._parent.querySelector(t)
				},
				querySelectorAll: function (t) {
					return this._parent.querySelectorAll(t)
				}
			}
			var LN = "http://www.w3.org/1999/xhtml"
			const mq = {
				svg: "http://www.w3.org/2000/svg",
				xhtml: LN,
				xlink: "http://www.w3.org/1999/xlink",
				xml: "http://www.w3.org/XML/1998/namespace",
				xmlns: "http://www.w3.org/2000/xmlns/"
			}
			function yk(t) {
				var n = (t += ""),
					e = n.indexOf(":")
				return (
					e >= 0 && "xmlns" !== (n = t.slice(0, e)) && (t = t.slice(e + 1)), mq.hasOwnProperty(n) ? { space: mq[n], local: t } : t
				)
			}
			function VDe(t) {
				return function () {
					this.removeAttribute(t)
				}
			}
			function QDe(t) {
				return function () {
					this.removeAttributeNS(t.space, t.local)
				}
			}
			function zDe(t, n) {
				return function () {
					this.setAttribute(t, n)
				}
			}
			function GDe(t, n) {
				return function () {
					this.setAttributeNS(t.space, t.local, n)
				}
			}
			function $De(t, n) {
				return function () {
					var e = n.apply(this, arguments)
					null == e ? this.removeAttribute(t) : this.setAttribute(t, e)
				}
			}
			function WDe(t, n) {
				return function () {
					var e = n.apply(this, arguments)
					null == e ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, e)
				}
			}
			function pq(t) {
				return (t.ownerDocument && t.ownerDocument.defaultView) || (t.document && t) || t.defaultView
			}
			function KDe(t) {
				return function () {
					this.style.removeProperty(t)
				}
			}
			function XDe(t, n, e) {
				return function () {
					this.style.setProperty(t, n, e)
				}
			}
			function YDe(t, n, e) {
				return function () {
					var i = n.apply(this, arguments)
					null == i ? this.style.removeProperty(t) : this.style.setProperty(t, i, e)
				}
			}
			function Bb(t, n) {
				return t.style.getPropertyValue(n) || pq(t).getComputedStyle(t, null).getPropertyValue(n)
			}
			function ZDe(t) {
				return function () {
					delete this[t]
				}
			}
			function JDe(t, n) {
				return function () {
					this[t] = n
				}
			}
			function eLe(t, n) {
				return function () {
					var e = n.apply(this, arguments)
					null == e ? delete this[t] : (this[t] = e)
				}
			}
			function Aq(t) {
				return t.trim().split(/^|\s+/)
			}
			function RN(t) {
				return t.classList || new gq(t)
			}
			function gq(t) {
				;(this._node = t), (this._names = Aq(t.getAttribute("class") || ""))
			}
			function bq(t, n) {
				for (var e = RN(t), i = -1, r = n.length; ++i < r; ) e.add(n[i])
			}
			function _q(t, n) {
				for (var e = RN(t), i = -1, r = n.length; ++i < r; ) e.remove(n[i])
			}
			function nLe(t) {
				return function () {
					bq(this, t)
				}
			}
			function iLe(t) {
				return function () {
					_q(this, t)
				}
			}
			function rLe(t, n) {
				return function () {
					;(n.apply(this, arguments) ? bq : _q)(this, t)
				}
			}
			function sLe() {
				this.textContent = ""
			}
			function aLe(t) {
				return function () {
					this.textContent = t
				}
			}
			function cLe(t) {
				return function () {
					var n = t.apply(this, arguments)
					this.textContent = n ?? ""
				}
			}
			function dLe() {
				this.innerHTML = ""
			}
			function uLe(t) {
				return function () {
					this.innerHTML = t
				}
			}
			function hLe(t) {
				return function () {
					var n = t.apply(this, arguments)
					this.innerHTML = n ?? ""
				}
			}
			function mLe() {
				this.nextSibling && this.parentNode.appendChild(this)
			}
			function ALe() {
				this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
			}
			function bLe(t) {
				return function () {
					var n = this.ownerDocument,
						e = this.namespaceURI
					return e === LN && n.documentElement.namespaceURI === LN ? n.createElement(t) : n.createElementNS(e, t)
				}
			}
			function _Le(t) {
				return function () {
					return this.ownerDocument.createElementNS(t.space, t.local)
				}
			}
			function vq(t) {
				var n = yk(t)
				return (n.local ? _Le : bLe)(n)
			}
			function yLe() {
				return null
			}
			function xLe() {
				var t = this.parentNode
				t && t.removeChild(this)
			}
			function ELe() {
				var t = this.cloneNode(!1),
					n = this.parentNode
				return n ? n.insertBefore(t, this.nextSibling) : t
			}
			function MLe() {
				var t = this.cloneNode(!0),
					n = this.parentNode
				return n ? n.insertBefore(t, this.nextSibling) : t
			}
			function BLe(t) {
				return function () {
					var n = this.__on
					if (n) {
						for (var o, e = 0, i = -1, r = n.length; e < r; ++e)
							(o = n[e]),
								(t.type && o.type !== t.type) || o.name !== t.name
									? (n[++i] = o)
									: this.removeEventListener(o.type, o.listener, o.options)
						++i ? (n.length = i) : delete this.__on
					}
				}
			}
			function ILe(t, n, e) {
				return function () {
					var r,
						i = this.__on,
						o = (function TLe(t) {
							return function (n) {
								t.call(this, n, this.__data__)
							}
						})(n)
					if (i)
						for (var s = 0, a = i.length; s < a; ++s)
							if ((r = i[s]).type === t.type && r.name === t.name)
								return (
									this.removeEventListener(r.type, r.listener, r.options),
									this.addEventListener(r.type, (r.listener = o), (r.options = e)),
									void (r.value = n)
								)
					this.addEventListener(t.type, o, e),
						(r = { type: t.type, name: t.name, value: n, listener: o, options: e }),
						i ? i.push(r) : (this.__on = [r])
				}
			}
			function yq(t, n, e) {
				var i = pq(t),
					r = i.CustomEvent
				"function" == typeof r
					? (r = new r(n, e))
					: ((r = i.document.createEvent("Event")),
					  e ? (r.initEvent(n, e.bubbles, e.cancelable), (r.detail = e.detail)) : r.initEvent(n, !1, !1)),
					t.dispatchEvent(r)
			}
			function LLe(t, n) {
				return function () {
					return yq(this, t, n)
				}
			}
			function RLe(t, n) {
				return function () {
					return yq(this, t, n.apply(this, arguments))
				}
			}
			gq.prototype = {
				add: function (t) {
					this._names.indexOf(t) < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")))
				},
				remove: function (t) {
					var n = this._names.indexOf(t)
					n >= 0 && (this._names.splice(n, 1), this._node.setAttribute("class", this._names.join(" ")))
				},
				contains: function (t) {
					return this._names.indexOf(t) >= 0
				}
			}
			var wq = [null]
			function dc(t, n) {
				;(this._groups = t), (this._parents = n)
			}
			function xq() {
				return new dc([[document.documentElement]], wq)
			}
			dc.prototype = xq.prototype = {
				constructor: dc,
				select: function cDe(t) {
					"function" != typeof t && (t = DN(t))
					for (var n = this._groups, e = n.length, i = new Array(e), r = 0; r < e; ++r)
						for (var c, l, o = n[r], s = o.length, a = (i[r] = new Array(s)), d = 0; d < s; ++d)
							(c = o[d]) && (l = t.call(c, c.__data__, d, o)) && ("__data__" in c && (l.__data__ = c.__data__), (a[d] = l))
					return new dc(i, this._parents)
				},
				selectAll: function hDe(t) {
					t =
						"function" == typeof t
							? (function uDe(t) {
									return function () {
										return (function lDe(t) {
											return null == t ? [] : Array.isArray(t) ? t : Array.from(t)
										})(t.apply(this, arguments))
									}
							  })(t)
							: dq(t)
					for (var n = this._groups, e = n.length, i = [], r = [], o = 0; o < e; ++o)
						for (var c, s = n[o], a = s.length, l = 0; l < a; ++l)
							(c = s[l]) && (i.push(t.call(c, c.__data__, l, s)), r.push(c))
					return new dc(i, r)
				},
				selectChild: function ADe(t) {
					return this.select(
						null == t
							? pDe
							: (function mDe(t) {
									return function () {
										return fDe.call(this.children, t)
									}
							  })("function" == typeof t ? t : hq(t))
					)
				},
				selectChildren: function vDe(t) {
					return this.selectAll(
						null == t
							? bDe
							: (function _De(t) {
									return function () {
										return gDe.call(this.children, t)
									}
							  })("function" == typeof t ? t : hq(t))
					)
				},
				filter: function yDe(t) {
					"function" != typeof t && (t = uq(t))
					for (var n = this._groups, e = n.length, i = new Array(e), r = 0; r < e; ++r)
						for (var c, o = n[r], s = o.length, a = (i[r] = []), l = 0; l < s; ++l)
							(c = o[l]) && t.call(c, c.__data__, l, o) && a.push(c)
					return new dc(i, this._parents)
				},
				data: function SDe(t, n) {
					if (!arguments.length) return Array.from(this, MDe)
					var e = n ? EDe : CDe,
						i = this._parents,
						r = this._groups
					"function" != typeof t &&
						(t = (function xDe(t) {
							return function () {
								return t
							}
						})(t))
					for (var o = r.length, s = new Array(o), a = new Array(o), c = new Array(o), l = 0; l < o; ++l) {
						var d = i[l],
							u = r[l],
							h = u.length,
							f = kDe(t.call(d, d && d.__data__, l, i)),
							_ = f.length,
							y = (a[l] = new Array(_)),
							C = (s[l] = new Array(_))
						e(d, u, y, C, (c[l] = new Array(h)), f, n)
						for (var M, O, w = 0, S = 0; w < _; ++w)
							if ((M = y[w])) {
								for (w >= S && (S = w + 1); !(O = C[S]) && ++S < _; );
								M._next = O || null
							}
					}
					return ((s = new dc(s, i))._enter = a), (s._exit = c), s
				},
				enter: function wDe() {
					return new dc(this._enter || this._groups.map(fq), this._parents)
				},
				exit: function TDe() {
					return new dc(this._exit || this._groups.map(fq), this._parents)
				},
				join: function FDe(t, n, e) {
					var i = this.enter(),
						r = this,
						o = this.exit()
					return (
						"function" == typeof t ? (i = t(i)) && (i = i.selection()) : (i = i.append(t + "")),
						null != n && (r = n(r)) && (r = r.selection()),
						null == e ? o.remove() : e(o),
						i && r ? i.merge(r).order() : r
					)
				},
				merge: function BDe(t) {
					for (
						var n = t.selection ? t.selection() : t,
							e = this._groups,
							i = n._groups,
							r = e.length,
							s = Math.min(r, i.length),
							a = new Array(r),
							c = 0;
						c < s;
						++c
					)
						for (var f, l = e[c], d = i[c], u = l.length, h = (a[c] = new Array(u)), _ = 0; _ < u; ++_)
							(f = l[_] || d[_]) && (h[_] = f)
					for (; c < r; ++c) a[c] = e[c]
					return new dc(a, this._parents)
				},
				selection: function NLe() {
					return this
				},
				order: function IDe() {
					for (var t = this._groups, n = -1, e = t.length; ++n < e; )
						for (var s, i = t[n], r = i.length - 1, o = i[r]; --r >= 0; )
							(s = i[r]) && (o && 4 ^ s.compareDocumentPosition(o) && o.parentNode.insertBefore(s, o), (o = s))
					return this
				},
				sort: function DDe(t) {
					function n(u, h) {
						return u && h ? t(u.__data__, h.__data__) : !u - !h
					}
					t || (t = LDe)
					for (var e = this._groups, i = e.length, r = new Array(i), o = 0; o < i; ++o) {
						for (var l, s = e[o], a = s.length, c = (r[o] = new Array(a)), d = 0; d < a; ++d) (l = s[d]) && (c[d] = l)
						c.sort(n)
					}
					return new dc(r, this._parents).order()
				},
				call: function RDe() {
					var t = arguments[0]
					return (arguments[0] = this), t.apply(null, arguments), this
				},
				nodes: function PDe() {
					return Array.from(this)
				},
				node: function ODe() {
					for (var t = this._groups, n = 0, e = t.length; n < e; ++n)
						for (var i = t[n], r = 0, o = i.length; r < o; ++r) {
							var s = i[r]
							if (s) return s
						}
					return null
				},
				size: function NDe() {
					let t = 0
					for (const n of this) ++t
					return t
				},
				empty: function UDe() {
					return !this.node()
				},
				each: function HDe(t) {
					for (var n = this._groups, e = 0, i = n.length; e < i; ++e)
						for (var a, r = n[e], o = 0, s = r.length; o < s; ++o) (a = r[o]) && t.call(a, a.__data__, o, r)
					return this
				},
				attr: function jDe(t, n) {
					var e = yk(t)
					if (arguments.length < 2) {
						var i = this.node()
						return e.local ? i.getAttributeNS(e.space, e.local) : i.getAttribute(e)
					}
					return this.each(
						(null == n ? (e.local ? QDe : VDe) : "function" == typeof n ? (e.local ? WDe : $De) : e.local ? GDe : zDe)(e, n)
					)
				},
				style: function qDe(t, n, e) {
					return arguments.length > 1
						? this.each((null == n ? KDe : "function" == typeof n ? YDe : XDe)(t, n, e ?? ""))
						: Bb(this.node(), t)
				},
				property: function tLe(t, n) {
					return arguments.length > 1 ? this.each((null == n ? ZDe : "function" == typeof n ? eLe : JDe)(t, n)) : this.node()[t]
				},
				classed: function oLe(t, n) {
					var e = Aq(t + "")
					if (arguments.length < 2) {
						for (var i = RN(this.node()), r = -1, o = e.length; ++r < o; ) if (!i.contains(e[r])) return !1
						return !0
					}
					return this.each(("function" == typeof n ? rLe : n ? nLe : iLe)(e, n))
				},
				text: function lLe(t) {
					return arguments.length ? this.each(null == t ? sLe : ("function" == typeof t ? cLe : aLe)(t)) : this.node().textContent
				},
				html: function fLe(t) {
					return arguments.length ? this.each(null == t ? dLe : ("function" == typeof t ? hLe : uLe)(t)) : this.node().innerHTML
				},
				raise: function pLe() {
					return this.each(mLe)
				},
				lower: function gLe() {
					return this.each(ALe)
				},
				append: function vLe(t) {
					var n = "function" == typeof t ? t : vq(t)
					return this.select(function () {
						return this.appendChild(n.apply(this, arguments))
					})
				},
				insert: function wLe(t, n) {
					var e = "function" == typeof t ? t : vq(t),
						i = null == n ? yLe : "function" == typeof n ? n : DN(n)
					return this.select(function () {
						return this.insertBefore(e.apply(this, arguments), i.apply(this, arguments) || null)
					})
				},
				remove: function CLe() {
					return this.each(xLe)
				},
				clone: function SLe(t) {
					return this.select(t ? MLe : ELe)
				},
				datum: function kLe(t) {
					return arguments.length ? this.property("__data__", t) : this.node().__data__
				},
				on: function DLe(t, n, e) {
					var r,
						s,
						i = (function FLe(t) {
							return t
								.trim()
								.split(/^|\s+/)
								.map(function (n) {
									var e = "",
										i = n.indexOf(".")
									return i >= 0 && ((e = n.slice(i + 1)), (n = n.slice(0, i))), { type: n, name: e }
								})
						})(t + ""),
						o = i.length
					if (!(arguments.length < 2)) {
						for (a = n ? ILe : BLe, r = 0; r < o; ++r) this.each(a(i[r], n, e))
						return this
					}
					var a = this.node().__on
					if (a)
						for (var d, c = 0, l = a.length; c < l; ++c)
							for (r = 0, d = a[c]; r < o; ++r) if ((s = i[r]).type === d.type && s.name === d.name) return d.value
				},
				dispatch: function PLe(t, n) {
					return this.each(("function" == typeof n ? RLe : LLe)(t, n))
				},
				[Symbol.iterator]: function* OLe() {
					for (var t = this._groups, n = 0, e = t.length; n < e; ++n)
						for (var s, i = t[n], r = 0, o = i.length; r < o; ++r) (s = i[r]) && (yield s)
				}
			}
			const Fw = xq
			var ULe = { value: () => {} }
			function Cq() {
				for (var i, t = 0, n = arguments.length, e = {}; t < n; ++t) {
					if (!(i = arguments[t] + "") || i in e || /[\s.]/.test(i)) throw new Error("illegal type: " + i)
					e[i] = []
				}
				return new wk(e)
			}
			function wk(t) {
				this._ = t
			}
			function VLe(t, n) {
				for (var r, e = 0, i = t.length; e < i; ++e) if ((r = t[e]).name === n) return r.value
			}
			function Eq(t, n, e) {
				for (var i = 0, r = t.length; i < r; ++i)
					if (t[i].name === n) {
						;(t[i] = ULe), (t = t.slice(0, i).concat(t.slice(i + 1)))
						break
					}
				return null != e && t.push({ name: n, value: e }), t
			}
			wk.prototype = Cq.prototype = {
				constructor: wk,
				on: function (t, n) {
					var r,
						e = this._,
						i = (function HLe(t, n) {
							return t
								.trim()
								.split(/^|\s+/)
								.map(function (e) {
									var i = "",
										r = e.indexOf(".")
									if ((r >= 0 && ((i = e.slice(r + 1)), (e = e.slice(0, r))), e && !n.hasOwnProperty(e)))
										throw new Error("unknown type: " + e)
									return { type: e, name: i }
								})
						})(t + "", e),
						o = -1,
						s = i.length
					if (!(arguments.length < 2)) {
						if (null != n && "function" != typeof n) throw new Error("invalid callback: " + n)
						for (; ++o < s; )
							if ((r = (t = i[o]).type)) e[r] = Eq(e[r], t.name, n)
							else if (null == n) for (r in e) e[r] = Eq(e[r], t.name, null)
						return this
					}
					for (; ++o < s; ) if ((r = (t = i[o]).type) && (r = VLe(e[r], t.name))) return r
				},
				copy: function () {
					var t = {},
						n = this._
					for (var e in n) t[e] = n[e].slice()
					return new wk(t)
				},
				call: function (t, n) {
					if ((r = arguments.length - 2) > 0) for (var r, o, e = new Array(r), i = 0; i < r; ++i) e[i] = arguments[i + 2]
					if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t)
					for (i = 0, r = (o = this._[t]).length; i < r; ++i) o[i].value.apply(n, e)
				},
				apply: function (t, n, e) {
					if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t)
					for (var i = this._[t], r = 0, o = i.length; r < o; ++r) i[r].value.apply(n, e)
				}
			}
			const QLe = Cq
			var xk,
				Dw,
				Ib = 0,
				Bw = 0,
				Iw = 0,
				Mq = 1e3,
				Ck = 0,
				Dp = 0,
				Ek = 0,
				Lw = "object" == typeof performance && performance.now ? performance : Date,
				Sq =
					"object" == typeof window && window.requestAnimationFrame
						? window.requestAnimationFrame.bind(window)
						: function (t) {
								setTimeout(t, 17)
						  }
			function PN() {
				return Dp || (Sq(zLe), (Dp = Lw.now() + Ek))
			}
			function zLe() {
				Dp = 0
			}
			function Mk() {
				this._call = this._time = this._next = null
			}
			function kq(t, n, e) {
				var i = new Mk()
				return i.restart(t, n, e), i
			}
			function Tq() {
				;(Dp = (Ck = Lw.now()) + Ek), (Ib = Bw = 0)
				try {
					!(function GLe() {
						PN(), ++Ib
						for (var n, t = xk; t; ) (n = Dp - t._time) >= 0 && t._call.call(void 0, n), (t = t._next)
						--Ib
					})()
				} finally {
					;(Ib = 0),
						(function WLe() {
							for (var t, e, n = xk, i = 1 / 0; n; )
								n._call
									? (i > n._time && (i = n._time), (t = n), (n = n._next))
									: ((e = n._next), (n._next = null), (n = t ? (t._next = e) : (xk = e)))
							;(Dw = t), ON(i)
						})(),
						(Dp = 0)
				}
			}
			function $Le() {
				var t = Lw.now(),
					n = t - Ck
				n > Mq && ((Ek -= n), (Ck = t))
			}
			function ON(t) {
				Ib ||
					(Bw && (Bw = clearTimeout(Bw)),
					t - Dp > 24
						? (t < 1 / 0 && (Bw = setTimeout(Tq, t - Lw.now() - Ek)), Iw && (Iw = clearInterval(Iw)))
						: (Iw || ((Ck = Lw.now()), (Iw = setInterval($Le, Mq))), (Ib = 1), Sq(Tq)))
			}
			function Fq(t, n, e) {
				var i = new Mk()
				return (
					i.restart(
						r => {
							i.stop(), t(r + n)
						},
						(n = null == n ? 0 : +n),
						e
					),
					i
				)
			}
			Mk.prototype = kq.prototype = {
				constructor: Mk,
				restart: function (t, n, e) {
					if ("function" != typeof t) throw new TypeError("callback is not a function")
					;(e = (null == e ? PN() : +e) + (null == n ? 0 : +n)),
						!this._next && Dw !== this && (Dw ? (Dw._next = this) : (xk = this), (Dw = this)),
						(this._call = t),
						(this._time = e),
						ON()
				},
				stop: function () {
					this._call && ((this._call = null), (this._time = 1 / 0), ON())
				}
			}
			var jLe = QLe("start", "end", "cancel", "interrupt"),
				KLe = [],
				Bq = 0,
				Sk = 3
			function Tk(t, n, e, i, r, o) {
				var s = t.__transition
				if (s) {
					if (e in s) return
				} else t.__transition = {}
				!(function XLe(t, n, e) {
					var r,
						i = t.__transition
					function s(l) {
						var d, u, h, f
						if (1 !== e.state) return c()
						for (d in i)
							if ((f = i[d]).name === e.name) {
								if (f.state === Sk) return Fq(s)
								4 === f.state
									? ((f.state = 6), f.timer.stop(), f.on.call("interrupt", t, t.__data__, f.index, f.group), delete i[d])
									: +d < n &&
									  ((f.state = 6), f.timer.stop(), f.on.call("cancel", t, t.__data__, f.index, f.group), delete i[d])
							}
						if (
							(Fq(function () {
								e.state === Sk && ((e.state = 4), e.timer.restart(a, e.delay, e.time), a(l))
							}),
							(e.state = 2),
							e.on.call("start", t, t.__data__, e.index, e.group),
							2 === e.state)
						) {
							for (e.state = Sk, r = new Array((h = e.tween.length)), d = 0, u = -1; d < h; ++d)
								(f = e.tween[d].value.call(t, t.__data__, e.index, e.group)) && (r[++u] = f)
							r.length = u + 1
						}
					}
					function a(l) {
						for (
							var d = l < e.duration ? e.ease.call(null, l / e.duration) : (e.timer.restart(c), (e.state = 5), 1),
								u = -1,
								h = r.length;
							++u < h;

						)
							r[u].call(t, d)
						5 === e.state && (e.on.call("end", t, t.__data__, e.index, e.group), c())
					}
					function c() {
						for (var l in ((e.state = 6), e.timer.stop(), delete i[n], i)) return
						delete t.__transition
					}
					;(i[n] = e),
						(e.timer = kq(
							function o(l) {
								;(e.state = 1), e.timer.restart(s, e.delay, e.time), e.delay <= l && s(l - e.delay)
							},
							0,
							e.time
						))
				})(t, e, {
					name: n,
					index: i,
					group: r,
					on: jLe,
					tween: KLe,
					time: o.time,
					delay: o.delay,
					duration: o.duration,
					ease: o.ease,
					timer: null,
					state: Bq
				})
			}
			function HN(t, n) {
				var e = kl(t, n)
				if (e.state > Bq) throw new Error("too late; already scheduled")
				return e
			}
			function Id(t, n) {
				var e = kl(t, n)
				if (e.state > Sk) throw new Error("too late; already running")
				return e
			}
			function kl(t, n) {
				var e = t.__transition
				if (!e || !(e = e[n])) throw new Error("transition not found")
				return e
			}
			function Tl(t, n) {
				return (
					(t = +t),
					(n = +n),
					function (e) {
						return t * (1 - e) + n * e
					}
				)
			}
			var Fk,
				Lq = 180 / Math.PI,
				VN = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }
			function Rq(t, n, e, i, r, o) {
				var s, a, c
				return (
					(s = Math.sqrt(t * t + n * n)) && ((t /= s), (n /= s)),
					(c = t * e + n * i) && ((e -= t * c), (i -= n * c)),
					(a = Math.sqrt(e * e + i * i)) && ((e /= a), (i /= a), (c /= a)),
					t * i < n * e && ((t = -t), (n = -n), (c = -c), (s = -s)),
					{ translateX: r, translateY: o, rotate: Math.atan2(n, t) * Lq, skewX: Math.atan(c) * Lq, scaleX: s, scaleY: a }
				)
			}
			function Pq(t, n, e, i) {
				function r(l) {
					return l.length ? l.pop() + " " : ""
				}
				return function (l, d) {
					var u = [],
						h = []
					return (
						(l = t(l)),
						(d = t(d)),
						(function o(l, d, u, h, f, _) {
							if (l !== u || d !== h) {
								var y = f.push("translate(", null, n, null, e)
								_.push({ i: y - 4, x: Tl(l, u) }, { i: y - 2, x: Tl(d, h) })
							} else (u || h) && f.push("translate(" + u + n + h + e)
						})(l.translateX, l.translateY, d.translateX, d.translateY, u, h),
						(function s(l, d, u, h) {
							l !== d
								? (l - d > 180 ? (d += 360) : d - l > 180 && (l += 360),
								  h.push({ i: u.push(r(u) + "rotate(", null, i) - 2, x: Tl(l, d) }))
								: d && u.push(r(u) + "rotate(" + d + i)
						})(l.rotate, d.rotate, u, h),
						(function a(l, d, u, h) {
							l !== d
								? h.push({ i: u.push(r(u) + "skewX(", null, i) - 2, x: Tl(l, d) })
								: d && u.push(r(u) + "skewX(" + d + i)
						})(l.skewX, d.skewX, u, h),
						(function c(l, d, u, h, f, _) {
							if (l !== u || d !== h) {
								var y = f.push(r(f) + "scale(", null, ",", null, ")")
								_.push({ i: y - 4, x: Tl(l, u) }, { i: y - 2, x: Tl(d, h) })
							} else (1 !== u || 1 !== h) && f.push(r(f) + "scale(" + u + "," + h + ")")
						})(l.scaleX, l.scaleY, d.scaleX, d.scaleY, u, h),
						(l = d = null),
						function (f) {
							for (var C, _ = -1, y = h.length; ++_ < y; ) u[(C = h[_]).i] = C.x(f)
							return u.join("")
						}
					)
				}
			}
			var eRe = Pq(
					function ZLe(t) {
						const n = new ("function" == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix)(t + "")
						return n.isIdentity ? VN : Rq(n.a, n.b, n.c, n.d, n.e, n.f)
					},
					"px, ",
					"px)",
					"deg)"
				),
				tRe = Pq(
					function JLe(t) {
						return null != t &&
							(Fk || (Fk = document.createElementNS("http://www.w3.org/2000/svg", "g")),
							Fk.setAttribute("transform", t),
							(t = Fk.transform.baseVal.consolidate()))
							? Rq((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f)
							: VN
					},
					", ",
					")",
					")"
				)
			function nRe(t, n) {
				var e, i
				return function () {
					var r = Id(this, t),
						o = r.tween
					if (o !== e)
						for (var s = 0, a = (i = e = o).length; s < a; ++s)
							if (i[s].name === n) {
								;(i = i.slice()).splice(s, 1)
								break
							}
					r.tween = i
				}
			}
			function iRe(t, n, e) {
				var i, r
				if ("function" != typeof e) throw new Error()
				return function () {
					var o = Id(this, t),
						s = o.tween
					if (s !== i) {
						r = (i = s).slice()
						for (var a = { name: n, value: e }, c = 0, l = r.length; c < l; ++c)
							if (r[c].name === n) {
								r[c] = a
								break
							}
						c === l && r.push(a)
					}
					o.tween = r
				}
			}
			function QN(t, n, e) {
				var i = t._id
				return (
					t.each(function () {
						var r = Id(this, i)
						;(r.value || (r.value = {}))[n] = e.apply(this, arguments)
					}),
					function (r) {
						return kl(r, i).value[n]
					}
				)
			}
			function zN(t, n, e) {
				;(t.prototype = n.prototype = e), (e.constructor = t)
			}
			function Oq(t, n) {
				var e = Object.create(t.prototype)
				for (var i in n) e[i] = n[i]
				return e
			}
			function Rw() {}
			var Bk = 1 / 0.7,
				Db = "\\s*([+-]?\\d+)\\s*",
				Ow = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
				Dd = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
				oRe = /^#([0-9a-f]{3,8})$/,
				sRe = new RegExp(`^rgb\\(${Db},${Db},${Db}\\)$`),
				aRe = new RegExp(`^rgb\\(${Dd},${Dd},${Dd}\\)$`),
				cRe = new RegExp(`^rgba\\(${Db},${Db},${Db},${Ow}\\)$`),
				lRe = new RegExp(`^rgba\\(${Dd},${Dd},${Dd},${Ow}\\)$`),
				dRe = new RegExp(`^hsl\\(${Ow},${Dd},${Dd}\\)$`),
				uRe = new RegExp(`^hsla\\(${Ow},${Dd},${Dd},${Ow}\\)$`),
				Nq = {
					aliceblue: 15792383,
					antiquewhite: 16444375,
					aqua: 65535,
					aquamarine: 8388564,
					azure: 15794175,
					beige: 16119260,
					bisque: 16770244,
					black: 0,
					blanchedalmond: 16772045,
					blue: 255,
					blueviolet: 9055202,
					brown: 10824234,
					burlywood: 14596231,
					cadetblue: 6266528,
					chartreuse: 8388352,
					chocolate: 13789470,
					coral: 16744272,
					cornflowerblue: 6591981,
					cornsilk: 16775388,
					crimson: 14423100,
					cyan: 65535,
					darkblue: 139,
					darkcyan: 35723,
					darkgoldenrod: 12092939,
					darkgray: 11119017,
					darkgreen: 25600,
					darkgrey: 11119017,
					darkkhaki: 12433259,
					darkmagenta: 9109643,
					darkolivegreen: 5597999,
					darkorange: 16747520,
					darkorchid: 10040012,
					darkred: 9109504,
					darksalmon: 15308410,
					darkseagreen: 9419919,
					darkslateblue: 4734347,
					darkslategray: 3100495,
					darkslategrey: 3100495,
					darkturquoise: 52945,
					darkviolet: 9699539,
					deeppink: 16716947,
					deepskyblue: 49151,
					dimgray: 6908265,
					dimgrey: 6908265,
					dodgerblue: 2003199,
					firebrick: 11674146,
					floralwhite: 16775920,
					forestgreen: 2263842,
					fuchsia: 16711935,
					gainsboro: 14474460,
					ghostwhite: 16316671,
					gold: 16766720,
					goldenrod: 14329120,
					gray: 8421504,
					green: 32768,
					greenyellow: 11403055,
					grey: 8421504,
					honeydew: 15794160,
					hotpink: 16738740,
					indianred: 13458524,
					indigo: 4915330,
					ivory: 16777200,
					khaki: 15787660,
					lavender: 15132410,
					lavenderblush: 16773365,
					lawngreen: 8190976,
					lemonchiffon: 16775885,
					lightblue: 11393254,
					lightcoral: 15761536,
					lightcyan: 14745599,
					lightgoldenrodyellow: 16448210,
					lightgray: 13882323,
					lightgreen: 9498256,
					lightgrey: 13882323,
					lightpink: 16758465,
					lightsalmon: 16752762,
					lightseagreen: 2142890,
					lightskyblue: 8900346,
					lightslategray: 7833753,
					lightslategrey: 7833753,
					lightsteelblue: 11584734,
					lightyellow: 16777184,
					lime: 65280,
					limegreen: 3329330,
					linen: 16445670,
					magenta: 16711935,
					maroon: 8388608,
					mediumaquamarine: 6737322,
					mediumblue: 205,
					mediumorchid: 12211667,
					mediumpurple: 9662683,
					mediumseagreen: 3978097,
					mediumslateblue: 8087790,
					mediumspringgreen: 64154,
					mediumturquoise: 4772300,
					mediumvioletred: 13047173,
					midnightblue: 1644912,
					mintcream: 16121850,
					mistyrose: 16770273,
					moccasin: 16770229,
					navajowhite: 16768685,
					navy: 128,
					oldlace: 16643558,
					olive: 8421376,
					olivedrab: 7048739,
					orange: 16753920,
					orangered: 16729344,
					orchid: 14315734,
					palegoldenrod: 15657130,
					palegreen: 10025880,
					paleturquoise: 11529966,
					palevioletred: 14381203,
					papayawhip: 16773077,
					peachpuff: 16767673,
					peru: 13468991,
					pink: 16761035,
					plum: 14524637,
					powderblue: 11591910,
					purple: 8388736,
					rebeccapurple: 6697881,
					red: 16711680,
					rosybrown: 12357519,
					royalblue: 4286945,
					saddlebrown: 9127187,
					salmon: 16416882,
					sandybrown: 16032864,
					seagreen: 3050327,
					seashell: 16774638,
					sienna: 10506797,
					silver: 12632256,
					skyblue: 8900331,
					slateblue: 6970061,
					slategray: 7372944,
					slategrey: 7372944,
					snow: 16775930,
					springgreen: 65407,
					steelblue: 4620980,
					tan: 13808780,
					teal: 32896,
					thistle: 14204888,
					tomato: 16737095,
					turquoise: 4251856,
					violet: 15631086,
					wheat: 16113331,
					white: 16777215,
					whitesmoke: 16119285,
					yellow: 16776960,
					yellowgreen: 10145074
				}
			function Uq() {
				return this.rgb().formatHex()
			}
			function Hq() {
				return this.rgb().formatRgb()
			}
			function Lp(t) {
				var n, e
				return (
					(t = (t + "").trim().toLowerCase()),
					(n = oRe.exec(t))
						? ((e = n[1].length),
						  (n = parseInt(n[1], 16)),
						  6 === e
								? Vq(n)
								: 3 === e
								? new Pa(((n >> 8) & 15) | ((n >> 4) & 240), ((n >> 4) & 15) | (240 & n), ((15 & n) << 4) | (15 & n), 1)
								: 8 === e
								? Ik((n >> 24) & 255, (n >> 16) & 255, (n >> 8) & 255, (255 & n) / 255)
								: 4 === e
								? Ik(
										((n >> 12) & 15) | ((n >> 8) & 240),
										((n >> 8) & 15) | ((n >> 4) & 240),
										((n >> 4) & 15) | (240 & n),
										(((15 & n) << 4) | (15 & n)) / 255
								  )
								: null)
						: (n = sRe.exec(t))
						? new Pa(n[1], n[2], n[3], 1)
						: (n = aRe.exec(t))
						? new Pa((255 * n[1]) / 100, (255 * n[2]) / 100, (255 * n[3]) / 100, 1)
						: (n = cRe.exec(t))
						? Ik(n[1], n[2], n[3], n[4])
						: (n = lRe.exec(t))
						? Ik((255 * n[1]) / 100, (255 * n[2]) / 100, (255 * n[3]) / 100, n[4])
						: (n = dRe.exec(t))
						? Gq(n[1], n[2] / 100, n[3] / 100, 1)
						: (n = uRe.exec(t))
						? Gq(n[1], n[2] / 100, n[3] / 100, n[4])
						: Nq.hasOwnProperty(t)
						? Vq(Nq[t])
						: "transparent" === t
						? new Pa(NaN, NaN, NaN, 0)
						: null
				)
			}
			function Vq(t) {
				return new Pa((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1)
			}
			function Ik(t, n, e, i) {
				return i <= 0 && (t = n = e = NaN), new Pa(t, n, e, i)
			}
			function Dk(t, n, e, i) {
				return 1 === arguments.length
					? (function mRe(t) {
							return t instanceof Rw || (t = Lp(t)), t ? new Pa((t = t.rgb()).r, t.g, t.b, t.opacity) : new Pa()
					  })(t)
					: new Pa(t, n, e, i ?? 1)
			}
			function Pa(t, n, e, i) {
				;(this.r = +t), (this.g = +n), (this.b = +e), (this.opacity = +i)
			}
			function Qq() {
				return `#${Pp(this.r)}${Pp(this.g)}${Pp(this.b)}`
			}
			function zq() {
				const t = Lk(this.opacity)
				return `${1 === t ? "rgb(" : "rgba("}${Rp(this.r)}, ${Rp(this.g)}, ${Rp(this.b)}${1 === t ? ")" : `, ${t})`}`
			}
			function Lk(t) {
				return isNaN(t) ? 1 : Math.max(0, Math.min(1, t))
			}
			function Rp(t) {
				return Math.max(0, Math.min(255, Math.round(t) || 0))
			}
			function Pp(t) {
				return ((t = Rp(t)) < 16 ? "0" : "") + t.toString(16)
			}
			function Gq(t, n, e, i) {
				return i <= 0 ? (t = n = e = NaN) : e <= 0 || e >= 1 ? (t = n = NaN) : n <= 0 && (t = NaN), new Fl(t, n, e, i)
			}
			function $q(t) {
				if (t instanceof Fl) return new Fl(t.h, t.s, t.l, t.opacity)
				if ((t instanceof Rw || (t = Lp(t)), !t)) return new Fl()
				if (t instanceof Fl) return t
				var n = (t = t.rgb()).r / 255,
					e = t.g / 255,
					i = t.b / 255,
					r = Math.min(n, e, i),
					o = Math.max(n, e, i),
					s = NaN,
					a = o - r,
					c = (o + r) / 2
				return (
					a
						? ((s = n === o ? (e - i) / a + 6 * (e < i) : e === o ? (i - n) / a + 2 : (n - e) / a + 4),
						  (a /= c < 0.5 ? o + r : 2 - o - r),
						  (s *= 60))
						: (a = c > 0 && c < 1 ? 0 : s),
					new Fl(s, a, c, t.opacity)
				)
			}
			function Fl(t, n, e, i) {
				;(this.h = +t), (this.s = +n), (this.l = +e), (this.opacity = +i)
			}
			function Wq(t) {
				return (t = (t || 0) % 360) < 0 ? t + 360 : t
			}
			function Rk(t) {
				return Math.max(0, Math.min(1, t || 0))
			}
			function GN(t, n, e) {
				return 255 * (t < 60 ? n + ((e - n) * t) / 60 : t < 180 ? e : t < 240 ? n + ((e - n) * (240 - t)) / 60 : n)
			}
			function jq(t, n, e, i, r) {
				var o = t * t,
					s = o * t
				return ((1 - 3 * t + 3 * o - s) * n + (4 - 6 * o + 3 * s) * e + (1 + 3 * t + 3 * o - 3 * s) * i + s * r) / 6
			}
			zN(Rw, Lp, {
				copy(t) {
					return Object.assign(new this.constructor(), this, t)
				},
				displayable() {
					return this.rgb().displayable()
				},
				hex: Uq,
				formatHex: Uq,
				formatHex8: function hRe() {
					return this.rgb().formatHex8()
				},
				formatHsl: function fRe() {
					return $q(this).formatHsl()
				},
				formatRgb: Hq,
				toString: Hq
			}),
				zN(
					Pa,
					Dk,
					Oq(Rw, {
						brighter(t) {
							return (t = null == t ? Bk : Math.pow(Bk, t)), new Pa(this.r * t, this.g * t, this.b * t, this.opacity)
						},
						darker(t) {
							return (t = null == t ? 0.7 : Math.pow(0.7, t)), new Pa(this.r * t, this.g * t, this.b * t, this.opacity)
						},
						rgb() {
							return this
						},
						clamp() {
							return new Pa(Rp(this.r), Rp(this.g), Rp(this.b), Lk(this.opacity))
						},
						displayable() {
							return (
								-0.5 <= this.r &&
								this.r < 255.5 &&
								-0.5 <= this.g &&
								this.g < 255.5 &&
								-0.5 <= this.b &&
								this.b < 255.5 &&
								0 <= this.opacity &&
								this.opacity <= 1
							)
						},
						hex: Qq,
						formatHex: Qq,
						formatHex8: function pRe() {
							return `#${Pp(this.r)}${Pp(this.g)}${Pp(this.b)}${Pp(255 * (isNaN(this.opacity) ? 1 : this.opacity))}`
						},
						formatRgb: zq,
						toString: zq
					})
				),
				zN(
					Fl,
					function ARe(t, n, e, i) {
						return 1 === arguments.length ? $q(t) : new Fl(t, n, e, i ?? 1)
					},
					Oq(Rw, {
						brighter(t) {
							return (t = null == t ? Bk : Math.pow(Bk, t)), new Fl(this.h, this.s, this.l * t, this.opacity)
						},
						darker(t) {
							return (t = null == t ? 0.7 : Math.pow(0.7, t)), new Fl(this.h, this.s, this.l * t, this.opacity)
						},
						rgb() {
							var t = (this.h % 360) + 360 * (this.h < 0),
								n = isNaN(t) || isNaN(this.s) ? 0 : this.s,
								e = this.l,
								i = e + (e < 0.5 ? e : 1 - e) * n,
								r = 2 * e - i
							return new Pa(
								GN(t >= 240 ? t - 240 : t + 120, r, i),
								GN(t, r, i),
								GN(t < 120 ? t + 240 : t - 120, r, i),
								this.opacity
							)
						},
						clamp() {
							return new Fl(Wq(this.h), Rk(this.s), Rk(this.l), Lk(this.opacity))
						},
						displayable() {
							return (
								((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
								0 <= this.l &&
								this.l <= 1 &&
								0 <= this.opacity &&
								this.opacity <= 1
							)
						},
						formatHsl() {
							const t = Lk(this.opacity)
							return `${1 === t ? "hsl(" : "hsla("}${Wq(this.h)}, ${100 * Rk(this.s)}%, ${100 * Rk(this.l)}%${
								1 === t ? ")" : `, ${t})`
							}`
						}
					})
				)
			const $N = t => () => t
			function Xq(t, n) {
				var e = n - t
				return e
					? (function Kq(t, n) {
							return function (e) {
								return t + e * n
							}
					  })(t, e)
					: $N(isNaN(t) ? n : t)
			}
			const Pk = (function t(n) {
				var e = (function vRe(t) {
					return 1 == (t = +t)
						? Xq
						: function (n, e) {
								return e - n
									? (function _Re(t, n, e) {
											return (
												(t = Math.pow(t, e)),
												(n = Math.pow(n, e) - t),
												(e = 1 / e),
												function (i) {
													return Math.pow(t + i * n, e)
												}
											)
									  })(n, e, t)
									: $N(isNaN(n) ? e : n)
						  }
				})(n)
				function i(r, o) {
					var s = e((r = Dk(r)).r, (o = Dk(o)).r),
						a = e(r.g, o.g),
						c = e(r.b, o.b),
						l = Xq(r.opacity, o.opacity)
					return function (d) {
						return (r.r = s(d)), (r.g = a(d)), (r.b = c(d)), (r.opacity = l(d)), r + ""
					}
				}
				return (i.gamma = t), i
			})(1)
			function Yq(t) {
				return function (n) {
					var s,
						a,
						e = n.length,
						i = new Array(e),
						r = new Array(e),
						o = new Array(e)
					for (s = 0; s < e; ++s) (a = Dk(n[s])), (i[s] = a.r || 0), (r[s] = a.g || 0), (o[s] = a.b || 0)
					return (
						(i = t(i)),
						(r = t(r)),
						(o = t(o)),
						(a.opacity = 1),
						function (c) {
							return (a.r = i(c)), (a.g = r(c)), (a.b = o(c)), a + ""
						}
					)
				}
			}
			Yq(function gRe(t) {
				var n = t.length - 1
				return function (e) {
					var i = e <= 0 ? (e = 0) : e >= 1 ? ((e = 1), n - 1) : Math.floor(e * n),
						r = t[i],
						o = t[i + 1]
					return jq((e - i / n) * n, i > 0 ? t[i - 1] : 2 * r - o, r, o, i < n - 1 ? t[i + 2] : 2 * o - r)
				}
			}),
				Yq(function bRe(t) {
					var n = t.length
					return function (e) {
						var i = Math.floor(((e %= 1) < 0 ? ++e : e) * n)
						return jq((e - i / n) * n, t[(i + n - 1) % n], t[i % n], t[(i + 1) % n], t[(i + 2) % n])
					}
				})
			var WN = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
				jN = new RegExp(WN.source, "g")
			function qq(t, n) {
				var i,
					r,
					o,
					e = (WN.lastIndex = jN.lastIndex = 0),
					s = -1,
					a = [],
					c = []
				for (t += "", n += ""; (i = WN.exec(t)) && (r = jN.exec(n)); )
					(o = r.index) > e && ((o = n.slice(e, o)), a[s] ? (a[s] += o) : (a[++s] = o)),
						(i = i[0]) === (r = r[0]) ? (a[s] ? (a[s] += r) : (a[++s] = r)) : ((a[++s] = null), c.push({ i: s, x: Tl(i, r) })),
						(e = jN.lastIndex)
				return (
					e < n.length && ((o = n.slice(e)), a[s] ? (a[s] += o) : (a[++s] = o)),
					a.length < 2
						? c[0]
							? (function wRe(t) {
									return function (n) {
										return t(n) + ""
									}
							  })(c[0].x)
							: (function yRe(t) {
									return function () {
										return t
									}
							  })(n)
						: ((n = c.length),
						  function (l) {
								for (var u, d = 0; d < n; ++d) a[(u = c[d]).i] = u.x(l)
								return a.join("")
						  })
				)
			}
			function Zq(t, n) {
				var e
				return ("number" == typeof n ? Tl : n instanceof Lp ? Pk : (e = Lp(n)) ? ((n = e), Pk) : qq)(t, n)
			}
			function xRe(t) {
				return function () {
					this.removeAttribute(t)
				}
			}
			function CRe(t) {
				return function () {
					this.removeAttributeNS(t.space, t.local)
				}
			}
			function ERe(t, n, e) {
				var i,
					o,
					r = e + ""
				return function () {
					var s = this.getAttribute(t)
					return s === r ? null : s === i ? o : (o = n((i = s), e))
				}
			}
			function MRe(t, n, e) {
				var i,
					o,
					r = e + ""
				return function () {
					var s = this.getAttributeNS(t.space, t.local)
					return s === r ? null : s === i ? o : (o = n((i = s), e))
				}
			}
			function SRe(t, n, e) {
				var i, r, o
				return function () {
					var s,
						c,
						a = e(this)
					return null == a
						? void this.removeAttribute(t)
						: (s = this.getAttribute(t)) === (c = a + "")
						? null
						: s === i && c === r
						? o
						: ((r = c), (o = n((i = s), a)))
				}
			}
			function kRe(t, n, e) {
				var i, r, o
				return function () {
					var s,
						c,
						a = e(this)
					return null == a
						? void this.removeAttributeNS(t.space, t.local)
						: (s = this.getAttributeNS(t.space, t.local)) === (c = a + "")
						? null
						: s === i && c === r
						? o
						: ((r = c), (o = n((i = s), a)))
				}
			}
			function IRe(t, n) {
				var e, i
				function r() {
					var o = n.apply(this, arguments)
					return (
						o !== i &&
							(e =
								(i = o) &&
								(function BRe(t, n) {
									return function (e) {
										this.setAttributeNS(t.space, t.local, n.call(this, e))
									}
								})(t, o)),
						e
					)
				}
				return (r._value = n), r
			}
			function DRe(t, n) {
				var e, i
				function r() {
					var o = n.apply(this, arguments)
					return (
						o !== i &&
							(e =
								(i = o) &&
								(function FRe(t, n) {
									return function (e) {
										this.setAttribute(t, n.call(this, e))
									}
								})(t, o)),
						e
					)
				}
				return (r._value = n), r
			}
			function RRe(t, n) {
				return function () {
					HN(this, t).delay = +n.apply(this, arguments)
				}
			}
			function PRe(t, n) {
				return (
					(n = +n),
					function () {
						HN(this, t).delay = n
					}
				)
			}
			function NRe(t, n) {
				return function () {
					Id(this, t).duration = +n.apply(this, arguments)
				}
			}
			function URe(t, n) {
				return (
					(n = +n),
					function () {
						Id(this, t).duration = n
					}
				)
			}
			var ePe = Fw.prototype.constructor
			function Jq(t) {
				return function () {
					this.style.removeProperty(t)
				}
			}
			var bPe = 0
			function ju(t, n, e, i) {
				;(this._groups = t), (this._parents = n), (this._name = e), (this._id = i)
			}
			function eZ() {
				return ++bPe
			}
			var Ku = Fw.prototype
			ju.prototype = function _Pe(t) {
				return Fw().transition(t)
			}.prototype = {
				constructor: ju,
				select: function ZRe(t) {
					var n = this._name,
						e = this._id
					"function" != typeof t && (t = DN(t))
					for (var i = this._groups, r = i.length, o = new Array(r), s = 0; s < r; ++s)
						for (var d, u, a = i[s], c = a.length, l = (o[s] = new Array(c)), h = 0; h < c; ++h)
							(d = a[h]) &&
								(u = t.call(d, d.__data__, h, a)) &&
								("__data__" in d && (u.__data__ = d.__data__), (l[h] = u), Tk(l[h], n, e, h, l, kl(d, e)))
					return new ju(o, this._parents, n, e)
				},
				selectAll: function JRe(t) {
					var n = this._name,
						e = this._id
					"function" != typeof t && (t = dq(t))
					for (var i = this._groups, r = i.length, o = [], s = [], a = 0; a < r; ++a)
						for (var d, c = i[a], l = c.length, u = 0; u < l; ++u)
							if ((d = c[u])) {
								for (var f, h = t.call(d, d.__data__, u, c), _ = kl(d, e), y = 0, C = h.length; y < C; ++y)
									(f = h[y]) && Tk(f, n, e, y, h, _)
								o.push(h), s.push(d)
							}
					return new ju(o, s, n, e)
				},
				selectChild: Ku.selectChild,
				selectChildren: Ku.selectChildren,
				filter: function $Re(t) {
					"function" != typeof t && (t = uq(t))
					for (var n = this._groups, e = n.length, i = new Array(e), r = 0; r < e; ++r)
						for (var c, o = n[r], s = o.length, a = (i[r] = []), l = 0; l < s; ++l)
							(c = o[l]) && t.call(c, c.__data__, l, o) && a.push(c)
					return new ju(i, this._parents, this._name, this._id)
				},
				merge: function WRe(t) {
					if (t._id !== this._id) throw new Error()
					for (var n = this._groups, e = t._groups, i = n.length, o = Math.min(i, e.length), s = new Array(i), a = 0; a < o; ++a)
						for (var h, c = n[a], l = e[a], d = c.length, u = (s[a] = new Array(d)), f = 0; f < d; ++f)
							(h = c[f] || l[f]) && (u[f] = h)
					for (; a < i; ++a) s[a] = n[a]
					return new ju(s, this._parents, this._name, this._id)
				},
				selection: function tPe() {
					return new ePe(this._groups, this._parents)
				},
				transition: function APe() {
					for (var t = this._name, n = this._id, e = eZ(), i = this._groups, r = i.length, o = 0; o < r; ++o)
						for (var c, s = i[o], a = s.length, l = 0; l < a; ++l)
							if ((c = s[l])) {
								var d = kl(c, n)
								Tk(c, t, e, l, s, { time: d.time + d.delay + d.duration, delay: 0, duration: d.duration, ease: d.ease })
							}
					return new ju(i, this._parents, t, e)
				},
				call: Ku.call,
				nodes: Ku.nodes,
				node: Ku.node,
				size: Ku.size,
				empty: Ku.empty,
				each: Ku.each,
				on: function XRe(t, n) {
					var e = this._id
					return arguments.length < 2
						? kl(this.node(), e).on.on(t)
						: this.each(
								(function KRe(t, n, e) {
									var i,
										r,
										o = (function jRe(t) {
											return (t + "")
												.trim()
												.split(/^|\s+/)
												.every(function (n) {
													var e = n.indexOf(".")
													return e >= 0 && (n = n.slice(0, e)), !n || "start" === n
												})
										})(n)
											? HN
											: Id
									return function () {
										var s = o(this, t),
											a = s.on
										a !== i && (r = (i = a).copy()).on(n, e), (s.on = r)
									}
								})(e, t, n)
						  )
				},
				attr: function TRe(t, n) {
					var e = yk(t),
						i = "transform" === e ? tRe : Zq
					return this.attrTween(
						t,
						"function" == typeof n
							? (e.local ? kRe : SRe)(e, i, QN(this, "attr." + t, n))
							: null == n
							? (e.local ? CRe : xRe)(e)
							: (e.local ? MRe : ERe)(e, i, n)
					)
				},
				attrTween: function LRe(t, n) {
					var e = "attr." + t
					if (arguments.length < 2) return (e = this.tween(e)) && e._value
					if (null == n) return this.tween(e, null)
					if ("function" != typeof n) throw new Error()
					var i = yk(t)
					return this.tween(e, (i.local ? IRe : DRe)(i, n))
				},
				style: function sPe(t, n, e) {
					var i = "transform" == (t += "") ? eRe : Zq
					return null == n
						? this.styleTween(
								t,
								(function nPe(t, n) {
									var e, i, r
									return function () {
										var o = Bb(this, t),
											s = (this.style.removeProperty(t), Bb(this, t))
										return o === s ? null : o === e && s === i ? r : (r = n((e = o), (i = s)))
									}
								})(t, i)
						  ).on("end.style." + t, Jq(t))
						: "function" == typeof n
						? this.styleTween(
								t,
								(function rPe(t, n, e) {
									var i, r, o
									return function () {
										var s = Bb(this, t),
											a = e(this),
											c = a + ""
										return (
											null == a && (this.style.removeProperty(t), (c = a = Bb(this, t))),
											s === c ? null : s === i && c === r ? o : ((r = c), (o = n((i = s), a)))
										)
									}
								})(t, i, QN(this, "style." + t, n))
						  ).each(
								(function oPe(t, n) {
									var e,
										i,
										r,
										a,
										o = "style." + n,
										s = "end." + o
									return function () {
										var c = Id(this, t),
											l = c.on,
											d = null == c.value[o] ? a || (a = Jq(n)) : void 0
										;(l !== e || r !== d) && (i = (e = l).copy()).on(s, (r = d)), (c.on = i)
									}
								})(this._id, t)
						  )
						: this.styleTween(
								t,
								(function iPe(t, n, e) {
									var i,
										o,
										r = e + ""
									return function () {
										var s = Bb(this, t)
										return s === r ? null : s === i ? o : (o = n((i = s), e))
									}
								})(t, i, n),
								e
						  ).on("end.style." + t, null)
				},
				styleTween: function lPe(t, n, e) {
					var i = "style." + (t += "")
					if (arguments.length < 2) return (i = this.tween(i)) && i._value
					if (null == n) return this.tween(i, null)
					if ("function" != typeof n) throw new Error()
					return this.tween(
						i,
						(function cPe(t, n, e) {
							var i, r
							function o() {
								var s = n.apply(this, arguments)
								return (
									s !== r &&
										(i =
											(r = s) &&
											(function aPe(t, n, e) {
												return function (i) {
													this.style.setProperty(t, n.call(this, i), e)
												}
											})(t, s, e)),
									i
								)
							}
							return (o._value = n), o
						})(t, n, e ?? "")
					)
				},
				text: function hPe(t) {
					return this.tween(
						"text",
						"function" == typeof t
							? (function uPe(t) {
									return function () {
										var n = t(this)
										this.textContent = n ?? ""
									}
							  })(QN(this, "text", t))
							: (function dPe(t) {
									return function () {
										this.textContent = t
									}
							  })(null == t ? "" : t + "")
					)
				},
				textTween: function pPe(t) {
					var n = "text"
					if (arguments.length < 1) return (n = this.tween(n)) && n._value
					if (null == t) return this.tween(n, null)
					if ("function" != typeof t) throw new Error()
					return this.tween(
						n,
						(function mPe(t) {
							var n, e
							function i() {
								var r = t.apply(this, arguments)
								return (
									r !== e &&
										(n =
											(e = r) &&
											(function fPe(t) {
												return function (n) {
													this.textContent = t.call(this, n)
												}
											})(r)),
									n
								)
							}
							return (i._value = t), i
						})(t)
					)
				},
				remove: function qRe() {
					return this.on(
						"end.remove",
						(function YRe(t) {
							return function () {
								var n = this.parentNode
								for (var e in this.__transition) if (+e !== t) return
								n && n.removeChild(this)
							}
						})(this._id)
					)
				},
				tween: function rRe(t, n) {
					var e = this._id
					if (((t += ""), arguments.length < 2)) {
						for (var s, i = kl(this.node(), e).tween, r = 0, o = i.length; r < o; ++r) if ((s = i[r]).name === t) return s.value
						return null
					}
					return this.each((null == n ? nRe : iRe)(e, t, n))
				},
				delay: function ORe(t) {
					var n = this._id
					return arguments.length ? this.each(("function" == typeof t ? RRe : PRe)(n, t)) : kl(this.node(), n).delay
				},
				duration: function HRe(t) {
					var n = this._id
					return arguments.length ? this.each(("function" == typeof t ? NRe : URe)(n, t)) : kl(this.node(), n).duration
				},
				ease: function QRe(t) {
					var n = this._id
					return arguments.length
						? this.each(
								(function VRe(t, n) {
									if ("function" != typeof n) throw new Error()
									return function () {
										Id(this, t).ease = n
									}
								})(n, t)
						  )
						: kl(this.node(), n).ease
				},
				easeVarying: function GRe(t) {
					if ("function" != typeof t) throw new Error()
					return this.each(
						(function zRe(t, n) {
							return function () {
								var e = n.apply(this, arguments)
								if ("function" != typeof e) throw new Error()
								Id(this, t).ease = e
							}
						})(this._id, t)
					)
				},
				end: function gPe() {
					var t,
						n,
						e = this,
						i = e._id,
						r = e.size()
					return new Promise(function (o, s) {
						var a = { value: s },
							c = {
								value: function () {
									0 == --r && o()
								}
							}
						e.each(function () {
							var l = Id(this, i),
								d = l.on
							d !== t && ((n = (t = d).copy())._.cancel.push(a), n._.interrupt.push(a), n._.end.push(c)), (l.on = n)
						}),
							0 === r && o()
					})
				},
				[Symbol.iterator]: Ku[Symbol.iterator]
			}
			var yPe = {
				time: null,
				delay: 0,
				duration: 250,
				ease: function vPe(t) {
					return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2
				}
			}
			function wPe(t, n) {
				for (var e; !(e = t.__transition) || !(e = e[n]); ) if (!(t = t.parentNode)) throw new Error(`transition ${n} not found`)
				return e
			}
			;(Fw.prototype.interrupt = function qLe(t) {
				return this.each(function () {
					!(function YLe(t, n) {
						var i,
							r,
							s,
							e = t.__transition,
							o = !0
						if (e) {
							for (s in ((n = null == n ? null : n + ""), e))
								(i = e[s]).name === n
									? ((r = i.state > 2 && i.state < 5),
									  (i.state = 6),
									  i.timer.stop(),
									  i.on.call(r ? "interrupt" : "cancel", t, t.__data__, i.index, i.group),
									  delete e[s])
									: (o = !1)
							o && delete t.__transition
						}
					})(this, t)
				})
			}),
				(Fw.prototype.transition = function xPe(t) {
					var n, e
					t instanceof ju ? ((n = t._id), (t = t._name)) : ((n = eZ()), ((e = yPe).time = PN()), (t = null == t ? null : t + ""))
					for (var i = this._groups, r = i.length, o = 0; o < r; ++o)
						for (var c, s = i[o], a = s.length, l = 0; l < a; ++l) (c = s[l]) && Tk(c, t, n, l, s, e || wPe(c, n))
					return new ju(i, this._parents, t, n)
				})
			Math
			function Nw(t) {
				return { type: t }
			}
			function Uk(t, n) {
				if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf("e")) < 0) return null
				var e,
					i = t.slice(0, e)
				return [i.length > 1 ? i[0] + i.slice(2) : i, +t.slice(e + 1)]
			}
			function Pb(t) {
				return (t = Uk(Math.abs(t))) ? t[1] : NaN
			}
			;["w", "e"].map(Nw), ["n", "s"].map(Nw), ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(Nw)
			var sZ,
				LPe = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i
			function Hk(t) {
				if (!(n = LPe.exec(t))) throw new Error("invalid format: " + t)
				var n
				return new ZN({
					fill: n[1],
					align: n[2],
					sign: n[3],
					symbol: n[4],
					zero: n[5],
					width: n[6],
					comma: n[7],
					precision: n[8] && n[8].slice(1),
					trim: n[9],
					type: n[10]
				})
			}
			function ZN(t) {
				;(this.fill = void 0 === t.fill ? " " : t.fill + ""),
					(this.align = void 0 === t.align ? ">" : t.align + ""),
					(this.sign = void 0 === t.sign ? "-" : t.sign + ""),
					(this.symbol = void 0 === t.symbol ? "" : t.symbol + ""),
					(this.zero = !!t.zero),
					(this.width = void 0 === t.width ? void 0 : +t.width),
					(this.comma = !!t.comma),
					(this.precision = void 0 === t.precision ? void 0 : +t.precision),
					(this.trim = !!t.trim),
					(this.type = void 0 === t.type ? "" : t.type + "")
			}
			function aZ(t, n) {
				var e = Uk(t, n)
				if (!e) return t + ""
				var i = e[0],
					r = e[1]
				return r < 0
					? "0." + new Array(-r).join("0") + i
					: i.length > r + 1
					? i.slice(0, r + 1) + "." + i.slice(r + 1)
					: i + new Array(r - i.length + 2).join("0")
			}
			;(Hk.prototype = ZN.prototype),
				(ZN.prototype.toString = function () {
					return (
						this.fill +
						this.align +
						this.sign +
						this.symbol +
						(this.zero ? "0" : "") +
						(void 0 === this.width ? "" : Math.max(1, 0 | this.width)) +
						(this.comma ? "," : "") +
						(void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) +
						(this.trim ? "~" : "") +
						this.type
					)
				})
			const cZ = {
				"%": (t, n) => (100 * t).toFixed(n),
				b: t => Math.round(t).toString(2),
				c: t => t + "",
				d: function BPe(t) {
					return Math.abs((t = Math.round(t))) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10)
				},
				e: (t, n) => t.toExponential(n),
				f: (t, n) => t.toFixed(n),
				g: (t, n) => t.toPrecision(n),
				o: t => Math.round(t).toString(8),
				p: (t, n) => aZ(100 * t, n),
				r: aZ,
				s: function PPe(t, n) {
					var e = Uk(t, n)
					if (!e) return t + ""
					var i = e[0],
						r = e[1],
						o = r - (sZ = 3 * Math.max(-8, Math.min(8, Math.floor(r / 3)))) + 1,
						s = i.length
					return o === s
						? i
						: o > s
						? i + new Array(o - s + 1).join("0")
						: o > 0
						? i.slice(0, o) + "." + i.slice(o)
						: "0." + new Array(1 - o).join("0") + Uk(t, Math.max(0, n + o - 1))[0]
				},
				X: t => Math.round(t).toString(16).toUpperCase(),
				x: t => Math.round(t).toString(16)
			}
			function lZ(t) {
				return t
			}
			var Vk,
				Qk,
				hZ,
				dZ = Array.prototype.map,
				uZ = ["y", "z", "a", "f", "p", "n", "\xb5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"]
			!(function NPe(t) {
				;(Vk = (function OPe(t) {
					var n =
							void 0 === t.grouping || void 0 === t.thousands
								? lZ
								: (function IPe(t, n) {
										return function (e, i) {
											for (
												var r = e.length, o = [], s = 0, a = t[0], c = 0;
												r > 0 &&
												a > 0 &&
												(c + a + 1 > i && (a = Math.max(1, i - c)),
												o.push(e.substring((r -= a), r + a)),
												!((c += a + 1) > i));

											)
												a = t[(s = (s + 1) % t.length)]
											return o.reverse().join(n)
										}
								  })(dZ.call(t.grouping, Number), t.thousands + ""),
						e = void 0 === t.currency ? "" : t.currency[0] + "",
						i = void 0 === t.currency ? "" : t.currency[1] + "",
						r = void 0 === t.decimal ? "." : t.decimal + "",
						o =
							void 0 === t.numerals
								? lZ
								: (function DPe(t) {
										return function (n) {
											return n.replace(/[0-9]/g, function (e) {
												return t[+e]
											})
										}
								  })(dZ.call(t.numerals, String)),
						s = void 0 === t.percent ? "%" : t.percent + "",
						a = void 0 === t.minus ? "\u2212" : t.minus + "",
						c = void 0 === t.nan ? "NaN" : t.nan + ""
					function l(u) {
						var h = (u = Hk(u)).fill,
							f = u.align,
							_ = u.sign,
							y = u.symbol,
							C = u.zero,
							x = u.width,
							w = u.comma,
							S = u.precision,
							M = u.trim,
							O = u.type
						"n" === O ? ((w = !0), (O = "g")) : cZ[O] || (void 0 === S && (S = 12), (M = !0), (O = "g")),
							(C || ("0" === h && "=" === f)) && ((C = !0), (h = "0"), (f = "="))
						var N = "$" === y ? e : "#" === y && /[boxX]/.test(O) ? "0" + O.toLowerCase() : "",
							j = "$" === y ? i : /[%p]/.test(O) ? s : "",
							le = cZ[O],
							ae = /[defgprs%]/.test(O)
						function ce(ue) {
							var W,
								me,
								Z,
								Se = N,
								ve = j
							if ("c" === O) (ve = le(ue) + ve), (ue = "")
							else {
								var Ae = (ue = +ue) < 0 || 1 / ue < 0
								if (
									((ue = isNaN(ue) ? c : le(Math.abs(ue), S)),
									M &&
										(ue = (function RPe(t) {
											e: for (var r, n = t.length, e = 1, i = -1; e < n; ++e)
												switch (t[e]) {
													case ".":
														i = r = e
														break
													case "0":
														0 === i && (i = e), (r = e)
														break
													default:
														if (!+t[e]) break e
														i > 0 && (i = 0)
												}
											return i > 0 ? t.slice(0, i) + t.slice(r + 1) : t
										})(ue)),
									Ae && 0 == +ue && "+" !== _ && (Ae = !1),
									(Se = (Ae ? ("(" === _ ? _ : a) : "-" === _ || "(" === _ ? "" : _) + Se),
									(ve = ("s" === O ? uZ[8 + sZ / 3] : "") + ve + (Ae && "(" === _ ? ")" : "")),
									ae)
								)
									for (W = -1, me = ue.length; ++W < me; )
										if (48 > (Z = ue.charCodeAt(W)) || Z > 57) {
											;(ve = (46 === Z ? r + ue.slice(W + 1) : ue.slice(W)) + ve), (ue = ue.slice(0, W))
											break
										}
							}
							w && !C && (ue = n(ue, 1 / 0))
							var Ie = Se.length + ue.length + ve.length,
								Pe = Ie < x ? new Array(x - Ie + 1).join(h) : ""
							switch ((w && C && ((ue = n(Pe + ue, Pe.length ? x - ve.length : 1 / 0)), (Pe = "")), f)) {
								case "<":
									ue = Se + ue + ve + Pe
									break
								case "=":
									ue = Se + Pe + ue + ve
									break
								case "^":
									ue = Pe.slice(0, (Ie = Pe.length >> 1)) + Se + ue + ve + Pe.slice(Ie)
									break
								default:
									ue = Pe + Se + ue + ve
							}
							return o(ue)
						}
						return (
							(S = void 0 === S ? 6 : /[gprs]/.test(O) ? Math.max(1, Math.min(21, S)) : Math.max(0, Math.min(20, S))),
							(ce.toString = function () {
								return u + ""
							}),
							ce
						)
					}
					return {
						format: l,
						formatPrefix: function d(u, h) {
							var f = l((((u = Hk(u)).type = "f"), u)),
								_ = 3 * Math.max(-8, Math.min(8, Math.floor(Pb(h) / 3))),
								y = Math.pow(10, -_),
								C = uZ[8 + _ / 3]
							return function (x) {
								return f(y * x) + C
							}
						}
					}
				})(t)),
					(Qk = Vk.format),
					(hZ = Vk.formatPrefix)
			})({ thousands: ",", grouping: [3], currency: ["$", ""] })
			const UPe = Math.sqrt(50),
				HPe = Math.sqrt(10),
				VPe = Math.sqrt(2)
			function zk(t, n, e) {
				const i = (n - t) / Math.max(0, e),
					r = Math.floor(Math.log10(i)),
					o = i / Math.pow(10, r),
					s = o >= UPe ? 10 : o >= HPe ? 5 : o >= VPe ? 2 : 1
				let a, c, l
				return (
					r < 0
						? ((l = Math.pow(10, -r) / s),
						  (a = Math.round(t * l)),
						  (c = Math.round(n * l)),
						  a / l < t && ++a,
						  c / l > n && --c,
						  (l = -l))
						: ((l = Math.pow(10, r) * s), (a = Math.round(t / l)), (c = Math.round(n / l)), a * l < t && ++a, c * l > n && --c),
					c < a && 0.5 <= e && e < 2 ? zk(t, n, 2 * e) : [a, c, l]
				)
			}
			function JN(t, n, e) {
				return zk((t = +t), (n = +n), (e = +e))[2]
			}
			function Gk(t, n) {
				return null == t || null == n ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN
			}
			function GPe(t, n) {
				return null == t || null == n ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN
			}
			function fZ(t) {
				let n, e, i
				function r(a, c, l = 0, d = a.length) {
					if (l < d) {
						if (0 !== n(c, c)) return d
						do {
							const u = (l + d) >>> 1
							e(a[u], c) < 0 ? (l = u + 1) : (d = u)
						} while (l < d)
					}
					return l
				}
				return (
					2 !== t.length
						? ((n = Gk), (e = (a, c) => Gk(t(a), c)), (i = (a, c) => t(a) - c))
						: ((n = t === Gk || t === GPe ? t : $Pe), (e = t), (i = t)),
					{
						left: r,
						center: function s(a, c, l = 0, d = a.length) {
							const u = r(a, c, l, d - 1)
							return u > l && i(a[u - 1], c) > -i(a[u], c) ? u - 1 : u
						},
						right: function o(a, c, l = 0, d = a.length) {
							if (l < d) {
								if (0 !== n(c, c)) return d
								do {
									const u = (l + d) >>> 1
									e(a[u], c) <= 0 ? (l = u + 1) : (d = u)
								} while (l < d)
							}
							return l
						}
					}
				)
			}
			function $Pe() {
				return 0
			}
			const jPe = fZ(Gk).right,
				KPe =
					(fZ(function WPe(t) {
						return null === t ? NaN : +t
					}),
					jPe)
			function pZ(t, n) {
				var s,
					e = n ? n.length : 0,
					i = t ? Math.min(e, t.length) : 0,
					r = new Array(i),
					o = new Array(e)
				for (s = 0; s < i; ++s) r[s] = e3(t[s], n[s])
				for (; s < e; ++s) o[s] = n[s]
				return function (a) {
					for (s = 0; s < i; ++s) o[s] = r[s](a)
					return o
				}
			}
			function XPe(t, n) {
				var e = new Date()
				return (
					(t = +t),
					(n = +n),
					function (i) {
						return e.setTime(t * (1 - i) + n * i), e
					}
				)
			}
			function YPe(t, n) {
				var r,
					e = {},
					i = {}
				for (r in ((null === t || "object" != typeof t) && (t = {}), (null === n || "object" != typeof n) && (n = {}), n))
					r in t ? (e[r] = e3(t[r], n[r])) : (i[r] = n[r])
				return function (o) {
					for (r in e) i[r] = e[r](o)
					return i
				}
			}
			function qPe(t, n) {
				n || (n = [])
				var r,
					e = t ? Math.min(n.length, t.length) : 0,
					i = n.slice()
				return function (o) {
					for (r = 0; r < e; ++r) i[r] = t[r] * (1 - o) + n[r] * o
					return i
				}
			}
			function e3(t, n) {
				var i,
					e = typeof n
				return null == n || "boolean" === e
					? $N(n)
					: ("number" === e
							? Tl
							: "string" === e
							? (i = Lp(n))
								? ((n = i), Pk)
								: qq
							: n instanceof Lp
							? Pk
							: n instanceof Date
							? XPe
							: (function ZPe(t) {
									return ArrayBuffer.isView(t) && !(t instanceof DataView)
							  })(n)
							? qPe
							: Array.isArray(n)
							? pZ
							: ("function" != typeof n.valueOf && "function" != typeof n.toString) || isNaN(n)
							? YPe
							: Tl)(t, n)
			}
			function JPe(t, n) {
				return (
					(t = +t),
					(n = +n),
					function (e) {
						return Math.round(t * (1 - e) + n * e)
					}
				)
			}
			function tOe(t) {
				return +t
			}
			var AZ = [0, 1]
			function Ob(t) {
				return t
			}
			function t3(t, n) {
				return (n -= t = +t)
					? function (e) {
							return (e - t) / n
					  }
					: (function eOe(t) {
							return function () {
								return t
							}
					  })(isNaN(n) ? NaN : 0.5)
			}
			function iOe(t, n, e) {
				var i = t[0],
					r = t[1],
					o = n[0],
					s = n[1]
				return (
					r < i ? ((i = t3(r, i)), (o = e(s, o))) : ((i = t3(i, r)), (o = e(o, s))),
					function (a) {
						return o(i(a))
					}
				)
			}
			function rOe(t, n, e) {
				var i = Math.min(t.length, n.length) - 1,
					r = new Array(i),
					o = new Array(i),
					s = -1
				for (t[i] < t[0] && ((t = t.slice().reverse()), (n = n.slice().reverse())); ++s < i; )
					(r[s] = t3(t[s], t[s + 1])), (o[s] = e(n[s], n[s + 1]))
				return function (a) {
					var c = KPe(t, a, 1, i) - 1
					return o[c](r[c](a))
				}
			}
			function cOe(t, n) {
				switch (arguments.length) {
					case 0:
						break
					case 1:
						this.range(t)
						break
					default:
						this.range(n).domain(t)
				}
				return this
			}
			function fOe(t) {
				var n = t.domain
				return (
					(t.ticks = function (e) {
						var i = n()
						return (function QPe(t, n, e) {
							if (!((e = +e) > 0)) return []
							if ((t = +t) == (n = +n)) return [t]
							const i = n < t,
								[r, o, s] = i ? zk(n, t, e) : zk(t, n, e)
							if (!(o >= r)) return []
							const a = o - r + 1,
								c = new Array(a)
							if (i)
								if (s < 0) for (let l = 0; l < a; ++l) c[l] = (o - l) / -s
								else for (let l = 0; l < a; ++l) c[l] = (o - l) * s
							else if (s < 0) for (let l = 0; l < a; ++l) c[l] = (r + l) / -s
							else for (let l = 0; l < a; ++l) c[l] = (r + l) * s
							return c
						})(i[0], i[i.length - 1], e ?? 10)
					}),
					(t.tickFormat = function (e, i) {
						var r = n()
						return (function hOe(t, n, e, i) {
							var o,
								r = (function zPe(t, n, e) {
									e = +e
									const i = (n = +n) < (t = +t),
										r = i ? JN(n, t, e) : JN(t, n, e)
									return (i ? -1 : 1) * (r < 0 ? 1 / -r : r)
								})(t, n, e)
							switch ((i = Hk(i ?? ",f")).type) {
								case "s":
									var s = Math.max(Math.abs(t), Math.abs(n))
									return (
										null == i.precision &&
											!isNaN(
												(o = (function lOe(t, n) {
													return Math.max(
														0,
														3 * Math.max(-8, Math.min(8, Math.floor(Pb(n) / 3))) - Pb(Math.abs(t))
													)
												})(r, s))
											) &&
											(i.precision = o),
										hZ(i, s)
									)
								case "":
								case "e":
								case "g":
								case "p":
								case "r":
									null == i.precision &&
										!isNaN(
											(o = (function dOe(t, n) {
												return (t = Math.abs(t)), (n = Math.abs(n) - t), Math.max(0, Pb(n) - Pb(t)) + 1
											})(r, Math.max(Math.abs(t), Math.abs(n))))
										) &&
										(i.precision = o - ("e" === i.type))
									break
								case "f":
								case "%":
									null == i.precision &&
										!isNaN(
											(o = (function uOe(t) {
												return Math.max(0, -Pb(Math.abs(t)))
											})(r))
										) &&
										(i.precision = o - 2 * ("%" === i.type))
							}
							return Qk(i)
						})(r[0], r[r.length - 1], e ?? 10, i)
					}),
					(t.nice = function (e) {
						null == e && (e = 10)
						var c,
							l,
							i = n(),
							r = 0,
							o = i.length - 1,
							s = i[r],
							a = i[o],
							d = 10
						for (a < s && ((l = s), (s = a), (a = l), (l = r), (r = o), (o = l)); d-- > 0; ) {
							if ((l = JN(s, a, e)) === c) return (i[r] = s), (i[o] = a), n(i)
							if (l > 0) (s = Math.floor(s / l) * l), (a = Math.ceil(a / l) * l)
							else {
								if (!(l < 0)) break
								;(s = Math.ceil(s * l) / l), (a = Math.floor(a * l) / l)
							}
							c = l
						}
						return t
					}),
					t
				)
			}
			function n3() {
				var t = (function aOe() {
					return (function sOe() {
						var i,
							r,
							o,
							a,
							c,
							l,
							t = AZ,
							n = AZ,
							e = e3,
							s = Ob
						function d() {
							var h = Math.min(t.length, n.length)
							return (
								s !== Ob &&
									(s = (function nOe(t, n) {
										var e
										return (
											t > n && ((e = t), (t = n), (n = e)),
											function (i) {
												return Math.max(t, Math.min(n, i))
											}
										)
									})(t[0], t[h - 1])),
								(a = h > 2 ? rOe : iOe),
								(c = l = null),
								u
							)
						}
						function u(h) {
							return null == h || isNaN((h = +h)) ? o : (c || (c = a(t.map(i), n, e)))(i(s(h)))
						}
						return (
							(u.invert = function (h) {
								return s(r((l || (l = a(n, t.map(i), Tl)))(h)))
							}),
							(u.domain = function (h) {
								return arguments.length ? ((t = Array.from(h, tOe)), d()) : t.slice()
							}),
							(u.range = function (h) {
								return arguments.length ? ((n = Array.from(h)), d()) : n.slice()
							}),
							(u.rangeRound = function (h) {
								return (n = Array.from(h)), (e = JPe), d()
							}),
							(u.clamp = function (h) {
								return arguments.length ? ((s = !!h || Ob), d()) : s !== Ob
							}),
							(u.interpolate = function (h) {
								return arguments.length ? ((e = h), d()) : e
							}),
							(u.unknown = function (h) {
								return arguments.length ? ((o = h), u) : o
							}),
							function (h, f) {
								return (i = h), (r = f), d()
							}
						)
					})()(Ob, Ob)
				})()
				return (
					(t.copy = function () {
						return (function oOe(t, n) {
							return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown())
						})(t, n3())
					}),
					cOe.apply(t, arguments),
					fOe(t)
				)
			}
			function gZ(t) {
				return "string" == typeof t ? new dc([[document.querySelector(t)]], [document.documentElement]) : new dc([[t]], wq)
			}
			function Nb(t) {
				return function () {
					return t
				}
			}
			function bZ(t) {
				this._context = t
			}
			function pOe(t) {
				return new bZ(t)
			}
			bZ.prototype = {
				areaStart: function () {
					this._line = 0
				},
				areaEnd: function () {
					this._line = NaN
				},
				lineStart: function () {
					this._point = 0
				},
				lineEnd: function () {
					;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(), (this._line = 1 - this._line)
				},
				point: function (t, n) {
					switch (((t = +t), (n = +n), this._point)) {
						case 0:
							;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)
							break
						case 1:
							this._point = 2
						default:
							this._context.lineTo(t, n)
					}
				}
			}
			const i3 = Math.PI,
				r3 = 2 * i3,
				Op = 1e-6,
				AOe = r3 - Op
			function _Z(t) {
				this._ += t[0]
				for (let n = 1, e = t.length; n < e; ++n) this._ += arguments[n] + t[n]
			}
			class $k {
				constructor(n) {
					;(this._x0 = this._y0 = this._x1 = this._y1 = null),
						(this._ = ""),
						(this._append =
							null == n
								? _Z
								: (function gOe(t) {
										let n = Math.floor(t)
										if (!(n >= 0)) throw new Error(`invalid digits: ${t}`)
										if (n > 15) return _Z
										const e = 10 ** n
										return function (i) {
											this._ += i[0]
											for (let r = 1, o = i.length; r < o; ++r) this._ += Math.round(arguments[r] * e) / e + i[r]
										}
								  })(n))
				}
				moveTo(n, e) {
					this._append`M${(this._x0 = this._x1 = +n)},${(this._y0 = this._y1 = +e)}`
				}
				closePath() {
					null !== this._x1 && ((this._x1 = this._x0), (this._y1 = this._y0), this._append`Z`)
				}
				lineTo(n, e) {
					this._append`L${(this._x1 = +n)},${(this._y1 = +e)}`
				}
				quadraticCurveTo(n, e, i, r) {
					this._append`Q${+n},${+e},${(this._x1 = +i)},${(this._y1 = +r)}`
				}
				bezierCurveTo(n, e, i, r, o, s) {
					this._append`C${+n},${+e},${+i},${+r},${(this._x1 = +o)},${(this._y1 = +s)}`
				}
				arcTo(n, e, i, r, o) {
					if (((n = +n), (e = +e), (i = +i), (r = +r), (o = +o) < 0)) throw new Error(`negative radius: ${o}`)
					let s = this._x1,
						a = this._y1,
						c = i - n,
						l = r - e,
						d = s - n,
						u = a - e,
						h = d * d + u * u
					if (null === this._x1) this._append`M${(this._x1 = n)},${(this._y1 = e)}`
					else if (h > Op)
						if (Math.abs(u * c - l * d) > Op && o) {
							let f = i - s,
								_ = r - a,
								y = c * c + l * l,
								C = f * f + _ * _,
								x = Math.sqrt(y),
								w = Math.sqrt(h),
								S = o * Math.tan((i3 - Math.acos((y + h - C) / (2 * x * w))) / 2),
								M = S / w,
								O = S / x
							Math.abs(M - 1) > Op && this._append`L${n + M * d},${e + M * u}`,
								this._append`A${o},${o},0,0,${+(u * f > d * _)},${(this._x1 = n + O * c)},${(this._y1 = e + O * l)}`
						} else this._append`L${(this._x1 = n)},${(this._y1 = e)}`
				}
				arc(n, e, i, r, o, s) {
					if (((n = +n), (e = +e), (s = !!s), (i = +i) < 0)) throw new Error(`negative radius: ${i}`)
					let a = i * Math.cos(r),
						c = i * Math.sin(r),
						l = n + a,
						d = e + c,
						u = 1 ^ s,
						h = s ? r - o : o - r
					null === this._x1
						? this._append`M${l},${d}`
						: (Math.abs(this._x1 - l) > Op || Math.abs(this._y1 - d) > Op) && this._append`L${l},${d}`,
						i &&
							(h < 0 && (h = (h % r3) + r3),
							h > AOe
								? this._append`A${i},${i},0,1,${u},${n - a},${e - c}A${i},${i},0,1,${u},${(this._x1 = l)},${(this._y1 = d)}`
								: h > Op &&
								  this._append`A${i},${i},0,${+(h >= i3)},${u},${(this._x1 = n + i * Math.cos(o))},${(this._y1 =
										e + i * Math.sin(o))}`)
				}
				rect(n, e, i, r) {
					this._append`M${(this._x0 = this._x1 = +n)},${(this._y0 = this._y1 = +e)}h${(i = +i)}v${+r}h${-i}Z`
				}
				toString() {
					return this._
				}
			}
			function vOe(t) {
				return t[0]
			}
			function yOe(t) {
				return t[1]
			}
			function Wk(t, n) {
				;(this._context = t), (this._t = n)
			}
			function xOe(t) {
				return new Wk(t, 0)
			}
			function Ub(t, n, e) {
				;(this.k = t), (this.x = n), (this.y = e)
			}
			;(Wk.prototype = {
				areaStart: function () {
					this._line = 0
				},
				areaEnd: function () {
					this._line = NaN
				},
				lineStart: function () {
					;(this._x = this._y = NaN), (this._point = 0)
				},
				lineEnd: function () {
					0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y),
						(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
						this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line))
				},
				point: function (t, n) {
					switch (((t = +t), (n = +n), this._point)) {
						case 0:
							;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)
							break
						case 1:
							this._point = 2
						default:
							if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n)
							else {
								var e = this._x * (1 - this._t) + t * this._t
								this._context.lineTo(e, this._y), this._context.lineTo(e, n)
							}
					}
					;(this._x = t), (this._y = n)
				}
			}),
				(Ub.prototype = {
					constructor: Ub,
					scale: function (t) {
						return 1 === t ? this : new Ub(this.k * t, this.x, this.y)
					},
					translate: function (t, n) {
						return (0 === t) & (0 === n) ? this : new Ub(this.k, this.x + this.k * t, this.y + this.k * n)
					},
					apply: function (t) {
						return [t[0] * this.k + this.x, t[1] * this.k + this.y]
					},
					applyX: function (t) {
						return t * this.k + this.x
					},
					applyY: function (t) {
						return t * this.k + this.y
					},
					invert: function (t) {
						return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k]
					},
					invertX: function (t) {
						return (t - this.x) / this.k
					},
					invertY: function (t) {
						return (t - this.y) / this.k
					},
					rescaleX: function (t) {
						return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t))
					},
					rescaleY: function (t) {
						return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t))
					},
					toString: function () {
						return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
					}
				}),
				new Ub(1, 0, 0)
			let BOe = (() => {
				class t {
					ngOnChanges() {
						this.values.length > 0 &&
							((this.percentileRanks = this.isAttributeDirectionInversed
								? this.calculateReversedPercentileRanks(this.values)
								: this.calculatePercentileRanks(this.values)),
							this.renderDiagram())
					}
					renderDiagram() {
						this.initializeDiagramDimesions(), this.clearDiagramContainer()
						const e = this.createSvg(),
							i = this.createGroup(e),
							r = this.createXScale(),
							o = this.createYScale()
						this.drawAxes(i, r, o), this.drawFrame(i), this.drawLabels(i), this.drawAreas(i, r), this.drawLine(i)
					}
					initializeDiagramDimesions() {
						;(this.frameWidth = 296),
							(this.frameBuffer = 10),
							(this.frameHeight = 80),
							(this.marginTop = 10),
							(this.marginBottom = 10),
							(this.marginLeft = 66),
							(this.marginRight = 54),
							(this.diagramWidth = this.frameWidth - this.marginLeft - this.marginRight),
							(this.diagramHeight = this.frameHeight - this.marginTop - this.marginBottom),
							(this.yLabelYOffset = -47)
					}
					clearDiagramContainer() {
						gZ("#cc-range-diagram-container").selectAll("*").remove()
					}
					createSvg() {
						return gZ("#cc-range-diagram-container").append("svg")
					}
					createGroup(e) {
						return e.append("g").attr("transform", `translate(${this.marginLeft}, ${this.marginTop})`)
					}
					drawFrame(e) {
						e.append("path")
							.attr(
								"d",
								`M ${-this.frameBuffer} ${-this.frameBuffer} h${this.diagramWidth + 2 * this.frameBuffer} v${
									this.diagramHeight + 2 * this.frameBuffer
								} h${-this.diagramWidth - 2 * this.frameBuffer} v${-this.diagramHeight - 2 * this.frameBuffer}`
							)
							.attr("fill", "none")
							.attr("stroke", "#888")
							.attr("stroke-width", "1px")
					}
					drawAxes(e, i, r) {
						e
							.append("g")
							.attr("id", "axis-x")
							.attr("transform", `translate(0,${this.diagramHeight + this.frameBuffer})`)
							.call(
								(function oDe(t) {
									return _k(3, t)
								})(i).ticks(5)
							)
							.attr("color", "#888"),
							e
								.append("g")
								.attr("id", "axis-y")
								.attr("transform", `translate(${-this.frameBuffer}, 0)`)
								.call(
									(function sDe(t) {
										return _k(4, t)
									})(r)
										.ticks(5)
										.tickFormat(function (o) {
											return o >= 1e4 ? `${Qk(".0f")(o / 1e3)}k` : o >= 1e3 ? `${Qk(".1f")(o / 1e3)}k` : o.toString()
										})
								)
								.attr("color", "#888")
					}
					createXScale() {
						return n3()
							.domain(
								(function ZIe(t, n) {
									let e, i
									if (void 0 === n)
										for (const r of t)
											null != r && (void 0 === e ? r >= r && (e = i = r) : (e > r && (e = r), i < r && (i = r)))
									else {
										let r = -1
										for (let o of t)
											null != (o = n(o, ++r, t)) &&
												(void 0 === e ? o >= o && (e = i = o) : (e > o && (e = o), i < o && (i = o)))
									}
									return [e, i]
								})(this.percentileRanks, e => e.x)
							)
							.range([0, this.diagramWidth])
					}
					createYScale() {
						const e = [0, cq(this.percentileRanks, r => r.y)],
							i = [cq(this.percentileRanks, r => r.y), 0]
						return n3()
							.domain(this.isAttributeDirectionInversed ? i : e)
							.range([this.diagramHeight, 0])
					}
					drawLabels(e) {
						const o = (this.diagramHeight + 2 * this.frameBuffer) / 2 - this.frameBuffer
						e
							.append("text")
							.attr("id", "y-label")
							.attr("class", "y label")
							.attr("transform", "rotate(-90)")
							.attr("x", -o)
							.attr("y", this.yLabelYOffset)
							.attr("text-anchor", "middle")
							.attr("fill", "#888")
							.text(`${this.colorMetric}`),
							e
								.append("text")
								.attr("id", "x-label")
								.attr("class", "x label")
								.attr("text-anchor", "middle")
								.attr("x", this.diagramWidth / 2)
								.attr("y", this.diagramHeight + this.marginTop + this.marginBottom + 2 * this.frameBuffer)
								.attr("fill", "#888")
								.text(`Quantiles (% of ${this.colorMetric})`)
					}
					drawAreas(e, i) {
						const r = i(
								this.isAttributeDirectionInversed
									? this.calculateReversedPercentileFromMetricValue(this.currentRightValue)
									: this.calculatePercentileFromMetricValue(this.currentLeftValue)
							),
							o = i(
								this.isAttributeDirectionInversed
									? this.calculateReversedPercentileFromMetricValue(this.currentLeftValue)
									: this.calculatePercentileFromMetricValue(this.currentRightValue)
							)
						e
							.append("rect")
							.attr("class", "left-area")
							.attr("x", 0)
							.attr("y", -this.frameBuffer)
							.attr("width", r)
							.attr("height", this.diagramHeight + 2 * this.frameBuffer)
							.style("fill", this.isAttributeDirectionInversed ? this.rightColor : this.leftColor)
							.style("fill-opacity", "0.3"),
							e
								.append("rect")
								.attr("class", "middle-area")
								.attr("x", r)
								.attr("y", -this.frameBuffer)
								.attr("width", o - r)
								.attr("height", this.diagramHeight + 2 * this.frameBuffer)
								.style("fill", this.middleColor)
								.style("fill-opacity", "0.3"),
							e
								.append("rect")
								.attr("class", "right-area")
								.attr("x", o)
								.attr("y", -this.frameBuffer)
								.attr("width", this.diagramWidth - o)
								.attr("height", this.diagramHeight + 2 * this.frameBuffer)
								.style("fill", this.isAttributeDirectionInversed ? this.leftColor : this.rightColor)
								.style("fill-opacity", "0.3")
					}
					drawLine(e) {
						e.append("path")
							.attr("id", "diagram-path")
							.datum(this.percentileRanks)
							.attr("fill", "none")
							.attr("stroke", "#888")
							.attr("stroke-width", 1)
							.attr(
								"d",
								(function wOe(t, n) {
									var e = Nb(!0),
										i = null,
										r = pOe,
										o = null,
										s = (function _Oe(t) {
											let n = 3
											return (
												(t.digits = function (e) {
													if (!arguments.length) return n
													if (null == e) n = null
													else {
														const i = Math.floor(e)
														if (!(i >= 0)) throw new RangeError(`invalid digits: ${e}`)
														n = i
													}
													return t
												}),
												() => new $k(n)
											)
										})(a)
									function a(c) {
										var l,
											u,
											f,
											d = (c = (function mOe(t) {
												return "object" == typeof t && "length" in t ? t : Array.from(t)
											})(c)).length,
											h = !1
										for (null == i && (o = r((f = s()))), l = 0; l <= d; ++l)
											!(l < d && e((u = c[l]), l, c)) === h && ((h = !h) ? o.lineStart() : o.lineEnd()),
												h && o.point(+t(u, l, c), +n(u, l, c))
										if (f) return (o = null), f + "" || null
									}
									return (
										(t = "function" == typeof t ? t : void 0 === t ? vOe : Nb(t)),
										(n = "function" == typeof n ? n : void 0 === n ? yOe : Nb(n)),
										(a.x = function (c) {
											return arguments.length ? ((t = "function" == typeof c ? c : Nb(+c)), a) : t
										}),
										(a.y = function (c) {
											return arguments.length ? ((n = "function" == typeof c ? c : Nb(+c)), a) : n
										}),
										(a.defined = function (c) {
											return arguments.length ? ((e = "function" == typeof c ? c : Nb(!!c)), a) : e
										}),
										(a.curve = function (c) {
											return arguments.length ? ((r = c), null != i && (o = r(i)), a) : r
										}),
										(a.context = function (c) {
											return arguments.length ? (null == c ? (i = o = null) : (o = r((i = c))), a) : i
										}),
										a
									)
								})()
									.curve(xOe)
									.x(i => this.createXScale()(i.x))
									.y(i => this.createYScale()(i.y))
							)
					}
					calculatePercentileRanks(e) {
						const i = [...new Set(e)].sort((s, a) => s - a),
							r = e.length,
							o = [{ x: 0, y: i[0] }]
						for (const s of i) {
							const c = (e.filter(l => l <= s).length / r) * 100
							o.push({ x: c, y: s })
						}
						return o
					}
					calculateReversedPercentileRanks(e) {
						const i = [...new Set(e)].sort((s, a) => s - a).reverse(),
							r = e.length,
							o = [{ x: 0, y: i[0] }]
						for (const s of i) {
							const c = (e.filter(l => l >= s).length / r) * 100
							o.push({ x: c, y: s })
						}
						return o.sort((s, a) => s.x - a.x)
					}
					calculatePercentileFromMetricValue(e) {
						if (e === this.minValue) return 0
						if (e === this.maxValue) return 100
						let i = null
						for (const r of this.percentileRanks) {
							if (!(r.y < e)) return i
							i = r.x
						}
					}
					calculateReversedPercentileFromMetricValue(e) {
						if (e === this.maxValue) return 0
						if (e === this.minValue) return 100
						let i = null
						for (const r of this.percentileRanks) {
							if (!(r.y > e)) return i
							i = r.x
						}
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-metric-color-range-diagram"]],
							inputs: {
								minValue: "minValue",
								maxValue: "maxValue",
								colorMetric: "colorMetric",
								values: "values",
								currentLeftValue: "currentLeftValue",
								currentRightValue: "currentRightValue",
								leftColor: "leftColor",
								middleColor: "middleColor",
								rightColor: "rightColor",
								isAttributeDirectionInversed: "isAttributeDirectionInversed"
							},
							features: [Ar],
							decls: 1,
							vars: 0,
							consts: [["id", "cc-range-diagram-container", 1, "cc-range-diagram-container"]],
							template: function (i, r) {
								1 & i && fe(0, "div", 0)
							},
							styles: [
								"#slider-label-left,#slider-label-right,#x-label,#y-label,#axis-x,#axis-y{font-size:11px}#slider-label-left[text-anchor].end,#slider-label-right[text-anchor].end,#x-label[text-anchor].end,#y-label[text-anchor].end,#axis-x[text-anchor].end,#axis-y[text-anchor].end{text-anchor:end}#slider-label-left[text-anchor].start,#slider-label-right[text-anchor].start,#x-label[text-anchor].start,#y-label[text-anchor].start,#axis-x[text-anchor].start,#axis-y[text-anchor].start{text-anchor:start}#slider-label-left{font-size:11px;fill:#888;text-anchor:end;dominant-baseline:hanging}#slider-label-right{font-size:11px;fill:#888;text-anchor:start;dominant-baseline:hanging}.cc-range-diagram-container{display:flex;justify-content:center;align-items:center}.cc-range-diagram-container svg{width:100%;height:130px}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const DOe = ({ thumbX: t, minValue: n, maxValue: e, sliderWidth: i }) => Math.round(n + t * ((e - n) / i)),
				yZ = ({ newThumbScreenX: t, sliderBoundingClientRectX: n, thumbRadius: e, sliderWidth: i, minValue: r, maxValue: o }) => {
					const s = t - n + e
					return { updatedThumbX: s, upcomingValue: DOe({ thumbX: s, minValue: r, maxValue: o, sliderWidth: i }) }
				},
				POe = ["minLabel"],
				OOe = ["maxLabel"],
				NOe = ["currentLeftLabel"],
				UOe = ["currentRightLabel"],
				HOe = ["combinedCurrentLeftRightLabel"]
			let VOe = (() => {
				class t {
					constructor(e) {
						;(this.changeDetector = e), (this.hideMinLabel = !1), (this.hideMaxLabel = !1), (this.doLeftRightLabelOverlap = !1)
					}
					ngAfterViewChecked() {
						this.updateLabelDisplays()
					}
					updateLabelDisplays() {
						const e = this.minLabel.nativeElement.getBoundingClientRect().width,
							i = this.currentLeftLabel.nativeElement.getBoundingClientRect().width
						this.currentLeftLabelLeftPosition = this.sliderRangePosition.leftEnd - i / 2
						const r = this.currentRightLabel.nativeElement.getBoundingClientRect().width,
							o = this.sliderWidth - this.maxLabel.nativeElement.getBoundingClientRect().width
						;(this.currentRightLabelLeftPosition = this.sliderRangePosition.rightStart - r / 2),
							(this.hideMinLabel = this.currentLeftLabelLeftPosition <= e + 4),
							(this.hideMaxLabel = this.currentRightLabelLeftPosition + r + 4 >= o)
						const s = this.currentLeftLabelLeftPosition + i
						this.doLeftRightLabelOverlap = s + 4 >= this.currentRightLabelLeftPosition
						const a = (s + this.currentRightLabelLeftPosition) / 2,
							c = this.combinedCurrentLeftRightLabel.nativeElement.getBoundingClientRect().width
						;(this.combinedCurrentLeftRightLabelLeftPosition = a - c / 2), this.changeDetector.detectChanges()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Jr))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-range-slider-labels"]],
							viewQuery: function (i, r) {
								if ((1 & i && (_i(POe, 5), _i(OOe, 5), _i(NOe, 5), _i(UOe, 5), _i(HOe, 5)), 2 & i)) {
									let o
									sn((o = an())) && (r.minLabel = o.first),
										sn((o = an())) && (r.maxLabel = o.first),
										sn((o = an())) && (r.currentLeftLabel = o.first),
										sn((o = an())) && (r.currentRightLabel = o.first),
										sn((o = an())) && (r.combinedCurrentLeftRightLabel = o.first)
								}
							},
							inputs: {
								minValue: "minValue",
								maxValue: "maxValue",
								leftValueLabel: "leftValueLabel",
								rightValueLabel: "rightValueLabel",
								sliderRangePosition: "sliderRangePosition",
								sliderWidth: "sliderWidth"
							},
							decls: 15,
							vars: 26,
							consts: [
								[1, "cc-range-slider-label"],
								["minLabel", ""],
								["currentLeftLabel", ""],
								["currentRightLabel", ""],
								["combinedCurrentLeftRightLabel", ""],
								["maxLabel", ""]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "div", 0, 1),
									ge(2),
									L(),
									F(3, "div", 0, 2),
									ge(5),
									L(),
									F(6, "div", 0, 3),
									ge(8),
									L(),
									F(9, "div", 0, 4),
									ge(11),
									L(),
									F(12, "div", 0, 5),
									ge(14),
									L()),
									2 & i &&
										(bi("left", 0, "px")("visibility", r.hideMinLabel ? "hidden" : "visible"),
										T(2),
										Vt(" ", r.minValue, "\n"),
										T(1),
										bi(
											"left",
											r.currentLeftLabelLeftPosition,
											"px"
										)("visibility", r.doLeftRightLabelOverlap ? "hidden" : "visible"),
										T(2),
										Vt(" ", r.leftValueLabel, "\n"),
										T(1),
										bi(
											"left",
											r.currentRightLabelLeftPosition,
											"px"
										)("visibility", r.doLeftRightLabelOverlap ? "hidden" : "visible"),
										T(2),
										Vt(" ", r.rightValueLabel, "\n"),
										T(1),
										bi(
											"left",
											r.combinedCurrentLeftRightLabelLeftPosition,
											"px"
										)("visibility", r.doLeftRightLabelOverlap ? "visible" : "hidden"),
										T(2),
										JA(" ", r.leftValueLabel, " - ", r.rightValueLabel, "\n"),
										T(1),
										bi("right", 0, "px")("visibility", r.hideMaxLabel ? "hidden" : "visible"),
										T(2),
										Vt(" ", r.maxValue, "\n"))
							},
							styles: [
								"cc-range-slider-labels .cc-range-slider-label{position:absolute;top:0;line-height:24px;font-size:14px;color:#aeaeae}\n"
							],
							encapsulation: 2,
							changeDetection: 0
						})
					}
				}
				return t
			})()
			const QOe = ["rangeSliderContainer"],
				zOe = ["leftThumb"],
				GOe = ["rightThumb"]
			let $Oe = (() => {
				class t {
					constructor() {
						;(this.sliderWidth = 150),
							(this.sliderRangePosition = { leftEnd: 0, rightStart: 0 }),
							(this.thumbRadius = 7),
							(this.currentlySliding = void 0),
							(this.resetCurrentlySlidingOnNextMouseUp = e => {
								const i = () => {
									;(this.currentlySliding = void 0),
										document.removeEventListener("mouseup", i),
										document.removeEventListener("mousemove", e)
								}
								document.addEventListener("mouseup", i)
							}),
							(this.handleLeftThumbMoved = e => {
								const i = (({
									deltaX: t,
									thumbScreenX: n,
									thumbRadius: e,
									otherThumbScreenX: i,
									sliderBoundingClientRectX: r,
									sliderWidth: o,
									minValue: s,
									maxValue: a
								}) => {
									let c = n + t
									return (
										c < r - e && (c = r - e),
										c > i && (c = i),
										yZ({
											newThumbScreenX: c,
											sliderBoundingClientRectX: r,
											thumbRadius: e,
											sliderWidth: o,
											minValue: s,
											maxValue: a
										})
									)
								})({
									deltaX: e.movementX,
									thumbScreenX: this.leftThumb.nativeElement.getBoundingClientRect().x,
									thumbRadius: this.thumbRadius,
									otherThumbScreenX: this.rightThumb.nativeElement.getBoundingClientRect().x,
									sliderBoundingClientRectX: this.sliderContainer.nativeElement.getBoundingClientRect().x,
									sliderWidth: this.sliderWidth,
									minValue: this.minValue,
									maxValue: this.maxValue
								})
								;(this.sliderRangePosition = { leftEnd: i.updatedThumbX, rightStart: this.sliderRangePosition.rightStart }),
									(this.upcomingLeftValue = i.upcomingValue),
									this.handleValueChange({ newLeftValue: i.upcomingValue })
							}),
							(this.handleRightThumbMoved = e => {
								const i = (({
									deltaX: t,
									thumbScreenX: n,
									thumbRadius: e,
									otherThumbScreenX: i,
									sliderBoundingClientRectX: r,
									sliderWidth: o,
									minValue: s,
									maxValue: a
								}) => {
									let c = n + t
									return (
										c > r + o - e && (c = r + o - e),
										c < i && (c = i),
										yZ({
											newThumbScreenX: c,
											sliderBoundingClientRectX: r,
											thumbRadius: e,
											sliderWidth: o,
											minValue: s,
											maxValue: a
										})
									)
								})({
									deltaX: e.movementX,
									thumbScreenX: this.rightThumb.nativeElement.getBoundingClientRect().x,
									thumbRadius: this.thumbRadius,
									otherThumbScreenX: this.leftThumb.nativeElement.getBoundingClientRect().x,
									sliderBoundingClientRectX: this.sliderContainer.nativeElement.getBoundingClientRect().x,
									sliderWidth: this.sliderWidth,
									minValue: this.minValue,
									maxValue: this.maxValue
								})
								;(this.sliderRangePosition = { leftEnd: this.sliderRangePosition.leftEnd, rightStart: i.updatedThumbX }),
									(this.upcomingRightValue = i.upcomingValue),
									this.handleValueChange({ newRightValue: i.upcomingValue })
							})
					}
					ngOnChanges(e) {
						this.currentlySliding ||
							((this.sliderRangePosition = (({
								minValue: t,
								maxValue: n,
								currentLeftValue: e,
								currentRightValue: i,
								sliderWidth: r
							}) => {
								const o = n - t
								return o <= 0
									? { leftEnd: r, rightStart: r }
									: { leftEnd: ((e - t) / o) * r, rightStart: ((i - t) / o) * r }
							})({
								minValue: this.minValue,
								maxValue: this.maxValue,
								currentLeftValue: this.currentLeftValue,
								currentRightValue: this.currentRightValue,
								sliderWidth: this.sliderWidth
							})),
							e.currentLeftValue && (this.upcomingLeftValue = this.currentLeftValue),
							e.currentRightValue && (this.upcomingRightValue = this.currentRightValue))
					}
					setCurrentlySliding(e) {
						switch (((this.currentlySliding = e), this.currentlySliding)) {
							case "leftThumb":
								document.addEventListener("mousemove", this.handleLeftThumbMoved),
									(this.rightThumb.nativeElement.style.zIndex = "0"),
									(this.leftThumb.nativeElement.style.zIndex = "1"),
									this.resetCurrentlySlidingOnNextMouseUp(this.handleLeftThumbMoved)
								break
							case "rightThumb":
								document.addEventListener("mousemove", this.handleRightThumbMoved),
									(this.leftThumb.nativeElement.style.zIndex = "0"),
									(this.rightThumb.nativeElement.style.zIndex = "1"),
									this.resetCurrentlySlidingOnNextMouseUp(this.handleRightThumbMoved)
						}
					}
					handleCurrentLeftInputChanged(e) {
						const i = UO(e, this.minValue, this.currentRightValue)
						i !== this.currentLeftValue && this.handleValueChange({ newLeftValue: i })
					}
					handleCurrentRightInputChanged(e) {
						const i = UO(e, this.currentLeftValue, this.maxValue)
						i !== this.currentRightValue && this.handleValueChange({ newRightValue: i })
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-metric-color-range-slider"]],
							viewQuery: function (i, r) {
								if ((1 & i && (_i(QOe, 5), _i(zOe, 5), _i(GOe, 5)), 2 & i)) {
									let o
									sn((o = an())) && (r.sliderContainer = o.first),
										sn((o = an())) && (r.leftThumb = o.first),
										sn((o = an())) && (r.rightThumb = o.first)
								}
							},
							inputs: {
								minValue: "minValue",
								maxValue: "maxValue",
								currentLeftValue: "currentLeftValue",
								currentRightValue: "currentRightValue",
								leftColor: "leftColor",
								middleColor: "middleColor",
								rightColor: "rightColor",
								handleValueChange: "handleValueChange",
								sliderWidth: "sliderWidth",
								isAttributeDirectionInversed: "isAttributeDirectionInversed"
							},
							features: [Ar],
							decls: 15,
							vars: 28,
							consts: [
								[1, "cc-range-slider-container"],
								["appearance", "outline"],
								["matInput", "", "type", "number", 3, "value", "min", "max", "input"],
								[1, "cc-range-slider-slider"],
								["rangeSliderContainer", ""],
								[1, "cc-range-slider-bar"],
								[1, "cc-range-slider-slider-thumb", 3, "mousedown"],
								["leftThumb", ""],
								["rightThumb", ""],
								[3, "minValue", "maxValue", "leftValueLabel", "rightValueLabel", "sliderRangePosition", "sliderWidth"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "div", 0)(1, "mat-form-field", 1)(2, "input", 2),
									Le("input", function (s) {
										return r.handleCurrentLeftInputChanged(s)
									}),
									L()(),
									F(3, "div", 3, 4),
									fe(5, "span", 5)(6, "span", 5)(7, "span", 5),
									F(8, "div", 6, 7),
									Le("mousedown", function () {
										return r.setCurrentlySliding("leftThumb")
									}),
									L(),
									F(10, "div", 6, 8),
									Le("mousedown", function () {
										return r.setCurrentlySliding("rightThumb")
									}),
									L(),
									fe(12, "cc-range-slider-labels", 9),
									L(),
									F(13, "mat-form-field", 1)(14, "input", 2),
									Le("input", function (s) {
										return r.handleCurrentRightInputChanged(s)
									}),
									L()()()),
									2 & i &&
										(T(2),
										U("value", r.currentLeftValue)("min", r.minValue)("max", r.upcomingRightValue),
										T(3),
										bi("width", r.sliderRangePosition.leftEnd, "px")("border-bottom-color", r.leftColor),
										T(1),
										bi(
											"width",
											r.sliderRangePosition.rightStart - r.sliderRangePosition.leftEnd,
											"px"
										)("border-bottom-color", r.middleColor),
										T(1),
										bi(
											"width",
											r.sliderWidth - r.sliderRangePosition.rightStart,
											"px"
										)("border-bottom-color", r.rightColor),
										T(1),
										bi("left", r.sliderRangePosition.leftEnd - r.thumbRadius, "px"),
										T(2),
										bi("left", r.sliderRangePosition.rightStart - r.thumbRadius, "px"),
										T(2),
										U("minValue", r.minValue)("maxValue", r.maxValue)("leftValueLabel", r.upcomingLeftValue)(
											"rightValueLabel",
											r.upcomingRightValue
										)("sliderRangePosition", r.sliderRangePosition)("sliderWidth", r.sliderWidth),
										T(2),
										U("value", r.currentRightValue)("min", r.upcomingLeftValue)("max", r.maxValue))
							},
							dependencies: [Bd, kp, VOe],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-metric-color-range-slider .cc-range-slider-container{display:flex;align-items:center;margin:0 10px}cc-metric-color-range-slider .cc-range-slider-container mat-form-field{height:32px}cc-metric-color-range-slider .cc-range-slider-container mat-form-field .mat-mdc-text-field-wrapper{padding:0 4px}cc-metric-color-range-slider .cc-range-slider-container mat-form-field .mat-mdc-text-field-wrapper .mat-mdc-form-field-flex{align-self:center}cc-metric-color-range-slider .cc-range-slider-container mat-form-field .mat-mdc-text-field-wrapper .mat-mdc-form-field-flex .mat-mdc-form-field-infix{padding:0;min-height:28px}cc-metric-color-range-slider .cc-range-slider-container mat-form-field .mat-mdc-text-field-wrapper .mat-mdc-form-field-flex .mat-mdc-form-field-infix .mat-mdc-input-element{min-height:inherit}cc-metric-color-range-slider .cc-range-slider-container mat-form-field .mat-mdc-form-field-subscript-wrapper.mat-mdc-form-field-bottom-align{display:none}cc-metric-color-range-slider .cc-range-slider-container .cc-range-slider-slider{flex:1;margin:0 8px;position:relative;line-height:48px}cc-metric-color-range-slider .cc-range-slider-container .cc-range-slider-slider .cc-range-slider-bar{display:inline-block;border-bottom-width:4px;border-bottom-style:solid}cc-metric-color-range-slider .cc-range-slider-container .cc-range-slider-slider .cc-range-slider-slider-thumb{cursor:pointer;position:absolute;top:20px;border-radius:100%;border:7px solid #1b9cfc}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const WOe = function () {
				return ["appSettings.mapColors.positiveDelta", "appSettings.mapColors.negativeDelta"]
			}
			function jOe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div"),
						fe(1, "cc-metric-color-range-slider", 5),
						Me(2, "async"),
						Me(3, "async"),
						Me(4, "async"),
						Me(5, "async"),
						Me(6, "async"),
						Me(7, "async"),
						Me(8, "async"),
						Me(9, "async"),
						fe(10, "cc-reset-settings-button", 6)(11, "cc-metric-color-range-diagram", 7),
						Me(12, "async"),
						Me(13, "async"),
						Me(14, "async"),
						Me(15, "async"),
						Me(16, "async"),
						Me(17, "async"),
						Me(18, "async"),
						Me(19, "async"),
						Me(20, "async"),
						Me(21, "async"),
						F(22, "mat-form-field", 8)(23, "mat-label"),
						ge(24, "Gradient Mode"),
						L(),
						F(25, "mat-select", 9),
						Le("selectionChange", function (r) {
							return rn(e), on(Te().handleColorModeChange(r.value))
						}),
						Me(26, "async"),
						F(27, "div", 10),
						Le("mousedown", function (r) {
							return r.stopPropagation()
						}),
						F(28, "mat-option", 11),
						ge(29, "Absolute"),
						L(),
						F(30, "mat-option", 12),
						ge(31, "Focused Gradient"),
						L(),
						F(32, "mat-option", 13),
						ge(33, "Weighted Gradient"),
						L(),
						F(34, "mat-option", 14),
						ge(35, "True Gradient"),
						L()()()()()
				}
				if (2 & t) {
					const e = Te()
					T(1),
						U("minValue", De(2, 22, e.sliderValues$).min)("maxValue", De(3, 24, e.sliderValues$).max)(
							"currentLeftValue",
							De(4, 26, e.sliderValues$).from
						)("currentRightValue", De(5, 28, e.sliderValues$).to)("leftColor", De(6, 30, e.sliderColors$).leftColor)(
							"middleColor",
							De(7, 32, e.sliderColors$).middleColor
						)("rightColor", De(8, 34, e.sliderColors$).rightColor)("handleValueChange", e.handleValueChange)(
							"isAttributeDirectionInversed",
							De(9, 36, e.isAttributeDescriptionInversed$)
						),
						T(9),
						U("settingsKeys", kh(60, WOe))("callback", e.resetColorRange),
						T(1),
						U("minValue", De(12, 38, e.sliderValues$).min)("maxValue", De(13, 40, e.sliderValues$).max)(
							"currentLeftValue",
							De(14, 42, e.sliderValues$).from
						)("currentRightValue", De(15, 44, e.sliderValues$).to)("leftColor", De(16, 46, e.sliderColors$).leftColor)(
							"middleColor",
							De(17, 48, e.sliderColors$).middleColor
						)("rightColor", De(18, 50, e.sliderColors$).rightColor)("colorMetric", De(19, 52, e.colorMetric$))(
							"values",
							De(20, 54, e.sliderValues$).values
						)("isAttributeDirectionInversed", De(21, 56, e.isAttributeDescriptionInversed$)),
						T(14),
						U("value", De(26, 58, e.colorMode$))
				}
			}
			function KOe(t, n) {
				if (1 & t) {
					const e = ri()
					Cr(0),
						F(1, "div", 2),
						fe(2, "cc-color-picker-for-map-color", 1),
						F(3, "mat-checkbox", 15),
						Le("change", function (r) {
							return rn(e), on(Te().toggleColorLabel(r, "positive"))
						}),
						Me(4, "async"),
						ge(5, "Show labels"),
						L()(),
						F(6, "div", 2),
						fe(7, "cc-color-picker-for-map-color", 1),
						F(8, "mat-checkbox", 15),
						Le("change", function (r) {
							return rn(e), on(Te().toggleColorLabel(r, "neutral"))
						}),
						Me(9, "async"),
						ge(10, "Show labels"),
						L()(),
						F(11, "div", 2),
						fe(12, "cc-color-picker-for-map-color", 1),
						F(13, "mat-checkbox", 15),
						Le("change", function (r) {
							return rn(e), on(Te().toggleColorLabel(r, "negative"))
						}),
						Me(14, "async"),
						ge(15, "Show labels"),
						L()(),
						Er()
				}
				if (2 & t) {
					const e = Te()
					T(2),
						U("mapColorFor", "positive"),
						T(1),
						U("checked", De(4, 6, e.colorLabels$).positive),
						T(4),
						U("mapColorFor", "neutral"),
						T(1),
						U("checked", De(9, 8, e.colorLabels$).neutral),
						T(4),
						U("mapColorFor", "negative"),
						T(1),
						U("checked", De(14, 10, e.colorLabels$).negative)
				}
			}
			function XOe(t, n) {
				1 & t && (Cr(0), fe(1, "cc-color-picker-for-map-color", 1)(2, "cc-color-picker-for-map-color", 1), Er()),
					2 & t && (T(1), U("mapColorFor", "positiveDelta"), T(1), U("mapColorFor", "negativeDelta"))
			}
			function YOe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-checkbox", 15),
						Le("change", function (r) {
							return rn(e), on(Te().handleIsColorRangeInvertedChange(r.checked))
						}),
						ge(1, "Invert Colors"),
						L()
				}
				2 & t && U("checked", Te().isColorRangeInverted)
			}
			function qOe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-checkbox", 15),
						Le("change", function (r) {
							return rn(e), on(Te().handleAreDeltaColorsInverted(r.checked))
						}),
						ge(1, "Invert Colors"),
						L()
				}
				2 & t && U("checked", Te().areDeltaColorsInverted)
			}
			const ZOe = function () {
					return ["appSettings.mapColors.positiveDelta", "appSettings.mapColors.negativeDelta", "appSettings.mapColors.selected"]
				},
				JOe = function () {
					return [
						"appSettings.mapColors.positive",
						"appSettings.mapColors.negative",
						"appSettings.mapColors.neutral",
						"appSettings.mapColors.selected"
					]
				}
			let eNe = (() => {
				class t {
					constructor(e, i) {
						;(this.store = e),
							(this.state = i),
							(this.colorMode$ = this.store.select(XIe)),
							(this.colorLabels$ = this.store.select(aq)),
							(this.colorMetric$ = this.store.select(Af)),
							(this.isDeltaState$ = this.store.select(_f)),
							(this.sliderValues$ = this.store.select(qIe)),
							(this.sliderColors$ = this.store.select(YIe)),
							(this.isAttributeDescriptionInversed$ = this.checkIsAttributeDirectionReversed()),
							(this.isColorRangeInverted = !1),
							(this.areDeltaColorsInverted = !1),
							(this.newLeftValue = null),
							(this.newRightValue = null),
							(this.handleValueChange = ({ newLeftValue: r, newRightValue: o }) => {
								;(this.newLeftValue = r ?? this.newLeftValue),
									(this.newRightValue = o ?? this.newRightValue),
									this.updateColorRangeDebounced()
							}),
							(this.updateColorRangeDebounced = Fd(() => {
								const r = {}
								null !== this.newLeftValue && (r.from = this.newLeftValue),
									null !== this.newRightValue && (r.to = this.newRightValue),
									this.store.dispatch(sd({ value: r })),
									(this.newLeftValue = null),
									(this.newRightValue = null)
							}, 400)),
							(this.resetInvertColorCheckboxes = () => {
								;(this.isColorRangeInverted = !1), (this.areDeltaColorsInverted = !1)
							}),
							(this.resetColorRange = () => {
								const r = gf(this.state.getValue())
								this.store.dispatch(sd({ value: BN(r) }))
							})
					}
					checkIsAttributeDirectionReversed() {
						return this.colorMetric$.pipe(Ke(e => 1 === this.state.getValue().fileSettings.attributeDescriptors[e]?.direction))
					}
					handleColorModeChange(e) {
						this.store.dispatch(sv({ value: e }))
					}
					toggleColorLabel(e, i) {
						this.store.dispatch(W0({ value: { [i]: e.checked } }))
					}
					handleIsColorRangeInvertedChange(e) {
						;(this.isColorRangeInverted = e), this.store.dispatch(iE())
					}
					handleAreDeltaColorsInverted(e) {
						;(this.areDeltaColorsInverted = e), this.store.dispatch(rE())
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct), P(Sr))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-color-settings-panel"]],
							decls: 15,
							vars: 24,
							consts: [
								[4, "ngIf"],
								[3, "mapColorFor"],
								[1, "color-row"],
								["tooltip", "Reset color values to default", "label", "Reset colors", 3, "settingsKeys", "callback"],
								[3, "checked", "change", 4, "ngIf"],
								[
									3,
									"minValue",
									"maxValue",
									"currentLeftValue",
									"currentRightValue",
									"leftColor",
									"middleColor",
									"rightColor",
									"handleValueChange",
									"isAttributeDirectionInversed"
								],
								[
									"tooltip",
									"Reset slider thresholds to default",
									"label",
									"Reset thresholds",
									3,
									"settingsKeys",
									"callback"
								],
								[
									3,
									"minValue",
									"maxValue",
									"currentLeftValue",
									"currentRightValue",
									"leftColor",
									"middleColor",
									"rightColor",
									"colorMetric",
									"values",
									"isAttributeDirectionInversed"
								],
								["appearance", "outline", 1, "gradient-mode-selector"],
								[3, "value", "selectionChange"],
								[3, "mousedown"],
								["value", "absolute"],
								["value", "focusedGradient"],
								["value", "weightedGradient"],
								["value", "trueGradient"],
								[3, "checked", "change"]
							],
							template: function (i, r) {
								1 & i &&
									(Ee(0, jOe, 36, 61, "div", 0),
									Me(1, "async"),
									Me(2, "async"),
									Ee(3, KOe, 16, 12, "ng-container", 0),
									Me(4, "async"),
									Ee(5, XOe, 3, 2, "ng-container", 0),
									Me(6, "async"),
									fe(7, "cc-color-picker-for-map-color", 1),
									F(8, "div", 2),
									fe(9, "cc-reset-settings-button", 3),
									Me(10, "async"),
									Ee(11, YOe, 2, 1, "mat-checkbox", 4),
									Me(12, "async"),
									Ee(13, qOe, 2, 1, "mat-checkbox", 4),
									Me(14, "async"),
									L()),
									2 & i &&
										(U("ngIf", !De(1, 8, r.isDeltaState$) && "unary" !== De(2, 10, r.colorMetric$)),
										T(3),
										U("ngIf", !De(4, 12, r.isDeltaState$)),
										T(2),
										U("ngIf", De(6, 14, r.isDeltaState$)),
										T(2),
										U("mapColorFor", "selected"),
										T(2),
										U("settingsKeys", De(10, 16, r.isDeltaState$) ? kh(22, ZOe) : kh(23, JOe))(
											"callback",
											r.resetInvertColorCheckboxes
										),
										T(2),
										U("ngIf", !De(12, 18, r.isDeltaState$)),
										T(2),
										U("ngIf", De(14, 20, r.isDeltaState$)))
							},
							dependencies: [En, _O, BOe, $Oe, kw, Bd, yf, Fp, Qh, Fb, Bn],
							styles: [
								"cc-color-settings-panel.cc-metric-settings-panel .gradient-mode-selector{height:40px;margin:5px 10px;width:243px}cc-color-settings-panel.cc-metric-settings-panel .gradient-mode-selector .mat-mdc-text-field-wrapper .mat-mdc-form-field-flex .mat-mdc-form-field-infix{padding:10px;min-height:28px}cc-color-settings-panel.cc-metric-settings-panel .gradient-mode-selector .mat-mdc-text-field-wrapper .mat-mdc-form-field-flex .mat-mdc-form-field-infix .mat-mdc-input-element{min-height:inherit}cc-color-settings-panel.cc-metric-settings-panel .gradient-mode-selector .mat-mdc-form-field-subscript-wrapper.mat-mdc-form-field-bottom-align{display:none}cc-color-settings-panel.cc-metric-settings-panel .color-row{display:flex;align-items:center}cc-color-picker-for-map-color{width:50%}cc-reset-settings-button{width:50%}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const s3 = Mt(Tr, t => t.isEdgeMetricVisible)
			function tNe(t, n) {
				if ((1 & t && (F(0, "div", 5)(1, "div", 6), fe(2, "cc-metric-chooser-type", 7), ge(3), L()()), 2 & t)) {
					const e = n.$implicit
					T(2), U("attributeType", "edges")("metricFor", "edgeMetric"), T(1), Vt(" ", e, " ")
				}
			}
			function nNe(t, n) {
				if (
					(1 & t &&
						(F(0, "cc-metric-chooser", 2), Me(1, "async"), F(2, "div", 3), Ee(3, tNe, 4, 3, "div", 4), Me(4, "async"), L()()),
					2 & t)
				) {
					const e = n.$implicit,
						i = Te()
					Zt("is-edge-metric-disabled", !De(1, 7, i.isEdgeMetricVisible$)),
						U("selectedMetricName", e)("searchPlaceholder", "Edge Metric (highest value)")(
							"handleMetricChanged",
							i.handleEdgeMetricChanged
						)("type", "edge"),
						T(3),
						U("ngIf", De(4, 9, i.edgeValue$))
				}
			}
			let iNe = (() => {
				class t {
					constructor(e, i) {
						;(this.store = e),
							(this.nodeSelectionService = i),
							(this.edgeValue$ = this.createEdgeValue()),
							(this.edgeMetric$ = this.store.select(zu)),
							(this.isEdgeMetricVisible$ = this.store.select(s3)),
							(this.formatHoveredEdgeValue = (r, o) => {
								if (!o) return null
								const s = o.edgeAttributes[r]
								return s ? `${this.formatValue(s.incoming)} / ${this.formatValue(s.outgoing)}` : null
							}),
							(this.formatValue = r => ("number" == typeof r ? r.toLocaleString() : "-"))
					}
					handleEdgeMetricChanged(e) {
						this.store.dispatch(Oh({ value: e }))
					}
					createEdgeValue() {
						return xu([this.store.select(zu), this.nodeSelectionService.createNodeObservable()]).pipe(
							Ke(([e, i]) => this.formatHoveredEdgeValue(e, i))
						)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct), P(hk))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-edge-metric-chooser"]],
							decls: 3,
							vars: 3,
							consts: [
								[1, "fa", "fa-exchange"],
								[
									"title",
									"Change edge metric",
									3,
									"is-edge-metric-disabled",
									"selectedMetricName",
									"searchPlaceholder",
									"handleMetricChanged",
									"type",
									4,
									"ngIf"
								],
								[
									"title",
									"Change edge metric",
									3,
									"selectedMetricName",
									"searchPlaceholder",
									"handleMetricChanged",
									"type"
								],
								["hoveredInformation", "", 1, "cc-metric-chooser-container"],
								["class", "metric-value", 4, "ngIf"],
								[1, "metric-value"],
								[1, "rounded-box"],
								[3, "attributeType", "metricFor"]
							],
							template: function (i, r) {
								1 & i && (fe(0, "i", 0), Ee(1, nNe, 5, 11, "cc-metric-chooser", 1), Me(2, "async")),
									2 & i && (T(1), U("ngIf", De(2, 1, r.edgeMetric$)))
							},
							dependencies: [En, Cw, NY, Bn],
							styles: [
								"cc-edge-metric-chooser cc-metric-chooser.is-edge-metric-disabled .mat-mdc-select-value{color:gray}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const rNe = Mt(Tr, t => t.edgeHeight),
				oNe = Mt(Tr, t => t.showOnlyBuildingsWithEdges),
				sNe = Mt(Fs, zu, (t, n) => t.nodeEdgeMetricsMap.get(n)?.size ?? 0)
			let aNe = (() => {
				class t {
					constructor(e) {
						this.store = e
					}
					ngOnInit() {
						this.isEdgeMetricVisible$ = this.store.select(s3)
					}
					toggleEdgeMetric() {
						this.store.dispatch(tE())
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-edge-metric-toggle"]],
							decls: 3,
							vars: 3,
							consts: [[1, "edgeMetricCheckbox", 3, "checked", "change"]],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-checkbox", 0),
									Le("change", function () {
										return r.toggleEdgeMetric()
									}),
									Me(1, "async"),
									ge(2, " Disable edge metric\n"),
									L()),
									2 & i && U("checked", !De(1, 1, r.isEdgeMetricVisible$))
							},
							dependencies: [Fb, Bn],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const cNe = function () {
				return ["appSettings.showOnlyBuildingsWithEdges", "appSettings.amountOfEdgePreviews", "appSettings.edgeHeight"]
			}
			let lNe = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.amountOfBuildingsWithSelectedEdgeMetric$ = this.store.select(sNe)),
							(this.edgePreviewLabel$ = this.amountOfBuildingsWithSelectedEdgeMetric$.pipe(
								Ke(i => `Preview the edges of up to ${i} buildings with the highest amount of incoming and outgoing edges`)
							)),
							(this.amountOfEdgePreviews$ = this.store.select(PY)),
							(this.edgeHeight$ = this.store.select(rNe)),
							(this.showOnlyBuildingsWithEdges$ = this.store.select(oNe)),
							(this.applySettingsAmountOfEdgePreviews = i => {
								this.store.dispatch(pk({ value: i }))
							}),
							(this.applySettingsEdgeHeight = i => {
								this.store.dispatch(j0({ value: i }))
							})
					}
					applyShowOnlyBuildingsWithEdges(e) {
						this.store.dispatch(ov({ value: e.checked }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-edge-settings-panel"]],
							decls: 17,
							vars: 35,
							consts: [
								[3, "title", "label", "value", "onChange", "min", "max", "disabled"],
								["title", "Adjust the curve height", 3, "label", "value", "onChange", "min", "max", "disabled"],
								[1, "wrapper"],
								[3, "mapColorFor"],
								[3, "checked", "disabled", "change"],
								[
									"tooltip",
									"Reset edge metric settings to their defaults",
									"label",
									"Reset edge metric settings",
									3,
									"settingsKeys"
								]
							],
							template: function (i, r) {
								1 & i &&
									(fe(0, "cc-slider", 0),
									Me(1, "async"),
									Me(2, "async"),
									Me(3, "async"),
									Me(4, "async"),
									fe(5, "cc-slider", 1),
									Me(6, "async"),
									Me(7, "async"),
									F(8, "div", 2),
									fe(9, "cc-color-picker-for-map-color", 3)(10, "cc-color-picker-for-map-color", 3),
									L(),
									F(11, "mat-checkbox", 4),
									Le("change", function (s) {
										return r.applyShowOnlyBuildingsWithEdges(s)
									}),
									Me(12, "async"),
									Me(13, "async"),
									ge(14, " Only show nodes with edges\n"),
									L(),
									fe(15, "cc-edge-metric-toggle")(16, "cc-reset-settings-button", 5)),
									2 & i &&
										(U("title", De(1, 18, r.edgePreviewLabel$))("label", "Preview")(
											"value",
											De(2, 20, r.amountOfEdgePreviews$)
										)("onChange", r.applySettingsAmountOfEdgePreviews)("min", 0)(
											"max",
											De(3, 22, r.amountOfBuildingsWithSelectedEdgeMetric$)
										)("disabled", 0 === De(4, 24, r.amountOfBuildingsWithSelectedEdgeMetric$)),
										T(5),
										U("label", "Height")("value", De(6, 26, r.edgeHeight$))("onChange", r.applySettingsEdgeHeight)(
											"min",
											1
										)("max", 9)("disabled", 0 === De(7, 28, r.amountOfBuildingsWithSelectedEdgeMetric$)),
										T(4),
										U("mapColorFor", "outgoingEdge"),
										T(1),
										U("mapColorFor", "incomingEdge"),
										T(1),
										U("checked", De(12, 30, r.showOnlyBuildingsWithEdges$))(
											"disabled",
											0 === De(13, 32, r.amountOfBuildingsWithSelectedEdgeMetric$)
										),
										T(5),
										U("settingsKeys", kh(34, cNe)))
							},
							dependencies: [kw, mk, Fb, _O, aNe, Bn],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function dNe(t, n) {
				1 & t && (F(0, "mat-card", 20), fe(1, "cc-link-color-metric-to-height-metric-button"), L())
			}
			function uNe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-card", 21)(1, "div", 1)(2, "div", 22),
						fe(3, "cc-color-metric-chooser"),
						L(),
						F(4, "span", 23),
						Le("click", function () {
							return rn(e), on(Te().updatePanelSelection("COLOR_PANEL_OPEN"))
						}),
						ge(5, " Color Metric Options "),
						fe(6, "i", 9),
						L()(),
						fe(7, "cc-color-settings-panel", 10),
						L()
				}
				if (2 & t) {
					const e = Te()
					Zt("expanded", "COLOR_PANEL_OPEN" === e.panelSelection), T(7), Zt("hidden", "COLOR_PANEL_OPEN" !== e.panelSelection)
				}
			}
			function hNe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-card", 24)(1, "div", 1)(2, "div", 25),
						fe(3, "cc-edge-metric-chooser"),
						L(),
						F(4, "span", 26),
						Le("click", function () {
							return rn(e), on(Te().updatePanelSelection("EDGE_PANEL_OPEN"))
						}),
						ge(5, " Edge Metric Options "),
						fe(6, "i", 9),
						L(),
						fe(7, "cc-edge-settings-panel", 10),
						L()()
				}
				if (2 & t) {
					const e = Te()
					Zt("expanded", "EDGE_PANEL_OPEN" === e.panelSelection), T(7), Zt("hidden", "EDGE_PANEL_OPEN" !== e.panelSelection)
				}
			}
			function fNe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-card", 27)(1, "div", 28),
						Le("click", function () {
							return rn(e), on(Te().updatePanelSelection("COLOR_PANEL_OPEN"))
						}),
						fe(2, "i", 29),
						ge(3, " Color Settings "),
						fe(4, "i", 30),
						L(),
						fe(5, "cc-color-settings-panel", 10),
						L()
				}
				if (2 & t) {
					const e = Te()
					T(5), Zt("hidden", "COLOR_PANEL_OPEN" !== e.panelSelection)
				}
			}
			let mNe = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.panelSelection = "NONE"),
							(this.experimentalFeaturesEnabled$ = this.store.select(vO)),
							(this.isDeltaState$ = this.store.select(_f)),
							(this.hasEdgeMetric$ = this.store.select(Fs).pipe(Ke(i => i.edgeMetricData.length > 0))),
							(this.closePanelSelectionOnOutsideClick = i => {
								"NONE" !== this.panelSelection && this.isOutside(i) && (this.panelSelection = "NONE")
							}),
							(this.panelSelectionComponents = [
								"CC-AREA-SETTINGS-PANEL",
								"CC-HEIGHT-SETTINGS-PANEL",
								"CC-COLOR-SETTINGS-PANEL",
								"CC-EDGE-SETTINGS-PANEL",
								"COLOR-CHROME"
							]),
							(this.panelSectionTogglerTitles = [
								"Show area metric settings",
								"Show height metric settings",
								"Show color metric settings",
								"Show edge metric settings"
							])
					}
					ngOnInit() {
						document.addEventListener("mousedown", this.closePanelSelectionOnOutsideClick)
					}
					ngOnDestroy() {
						document.removeEventListener("mousedown", this.closePanelSelectionOnOutsideClick)
					}
					updatePanelSelection(e) {
						this.panelSelection = this.panelSelection === e ? "NONE" : e
					}
					isOutside(e) {
						return e
							.composedPath()
							.every(
								i =>
									!this.panelSelectionComponents.includes(i.nodeName) &&
									!this.panelSectionTogglerTitles.includes(i.title) &&
									"codemap-context-menu" !== i.id
							)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-ribbon-bar"]],
							decls: 44,
							vars: 20,
							consts: [
								["appearance", "outlined", "id", "scenario-card", 1, "scenario-card"],
								[1, "section"],
								[1, "section-header"],
								[1, "section-title", "no-hover"],
								["appearance", "outlined", "id", "custom-configs-card", 1, "custom-configs-card"],
								["appearance", "outlined", "id", "ai-card", 1, "ai-card"],
								["appearance", "outlined", "id", "area-metric-card", 1, "area-metric-card", "metric-card"],
								["id", "area-metric-header-section", 1, "section-header"],
								["title", "Show area metric settings", 1, "section-title", 3, "click"],
								[1, "fa", "fa-angle-down"],
								[1, "cc-metric-settings-panel"],
								["appearance", "outlined", "id", "height-and-color-metric-container"],
								["appearance", "outlined", "id", "height-metric-card", 1, "height-metric-card", "metric-card"],
								["id", "height-metric-section", 1, "section"],
								["id", "height-metric-header-section", 1, "section-header"],
								["title", "Show height metric settings", 1, "section-title", 3, "click"],
								["appearance", "outlined", "class", "link-color-metric-to-height-metric-card", 4, "ngIf"],
								[
									"appearance",
									"outlined",
									"id",
									"color-metric-card",
									"class",
									"color-metric-card metric-card",
									3,
									"expanded",
									4,
									"ngIf"
								],
								[
									"appearance",
									"outlined",
									"id",
									"edge-metric-card",
									"class",
									"edge-metric-card metric-card",
									3,
									"expanded",
									4,
									"ngIf"
								],
								["appearance", "outlined", "id", "color-settings-card", 4, "ngIf"],
								["appearance", "outlined", 1, "link-color-metric-to-height-metric-card"],
								["appearance", "outlined", "id", "color-metric-card", 1, "color-metric-card", "metric-card"],
								["id", "color-metric-header-section", 1, "section-header"],
								["title", "Show color metric settings", 1, "section-title", 3, "click"],
								["appearance", "outlined", "id", "edge-metric-card", 1, "edge-metric-card", "metric-card"],
								["id", "edge-metric-header-section", 1, "section-header"],
								["title", "Show edge metric settings", 1, "section-title", 3, "click"],
								["appearance", "outlined", "id", "color-settings-card"],
								["title", "Show color settings", 1, "delta-color-section", 3, "click"],
								[1, "fa", "fa-paint-brush", "color-icon"],
								[1, "fa", "fa-sort-down", "color-dropdown-icon"]
							],
							template: function (i, r) {
								1 & i &&
									(fe(0, "cc-search-panel"),
									F(1, "mat-card", 0)(2, "div", 1)(3, "div", 2),
									fe(4, "cc-show-scenarios-button"),
									L(),
									F(5, "span", 3),
									ge(6, "Metric Templates"),
									L()()(),
									F(7, "mat-card", 4)(8, "div", 1)(9, "div", 2),
									fe(10, "cc-custom-configs"),
									L(),
									F(11, "span", 3),
									ge(12, "Custom Views"),
									L()()(),
									F(13, "mat-card", 5)(14, "div", 1)(15, "div", 2),
									fe(16, "cc-artificial-intelligence"),
									L(),
									F(17, "span", 3),
									ge(18, "Suspicious Metrics"),
									L()()(),
									F(19, "mat-card", 6)(20, "div", 1)(21, "div", 7),
									fe(22, "cc-area-metric-chooser"),
									L(),
									F(23, "span", 8),
									Le("click", function () {
										return r.updatePanelSelection("AREA_PANEL_OPEN")
									}),
									ge(24, " Area Metric Options "),
									fe(25, "i", 9),
									L()(),
									fe(26, "cc-area-settings-panel", 10),
									L(),
									F(27, "mat-card", 11)(28, "mat-card", 12)(29, "div", 13)(30, "div", 14),
									fe(31, "cc-height-metric-chooser"),
									L(),
									F(32, "span", 15),
									Le("click", function () {
										return r.updatePanelSelection("HEIGHT_PANEL_OPEN")
									}),
									ge(33, " Height Metric Options "),
									fe(34, "i", 9),
									L()(),
									fe(35, "cc-height-settings-panel", 10),
									L(),
									Ee(36, dNe, 2, 0, "mat-card", 16),
									Me(37, "async"),
									Ee(38, uNe, 8, 4, "mat-card", 17),
									Me(39, "async"),
									L(),
									Ee(40, hNe, 8, 4, "mat-card", 18),
									Me(41, "async"),
									Ee(42, fNe, 6, 2, "mat-card", 19),
									Me(43, "async")),
									2 & i &&
										(T(19),
										Zt("expanded", "AREA_PANEL_OPEN" === r.panelSelection),
										T(7),
										Zt("hidden", "AREA_PANEL_OPEN" !== r.panelSelection),
										T(2),
										Zt("expanded", "HEIGHT_PANEL_OPEN" === r.panelSelection),
										T(7),
										Zt("hidden", "HEIGHT_PANEL_OPEN" !== r.panelSelection),
										T(1),
										U("ngIf", !De(37, 12, r.isDeltaState$)),
										T(2),
										U("ngIf", !De(39, 14, r.isDeltaState$)),
										T(2),
										U("ngIf", De(41, 16, r.hasEdgeMetric$)),
										T(2),
										U("ngIf", De(43, 18, r.isDeltaState$)))
							},
							dependencies: [En, rk, $X, zTe, fY, FFe, VBe, PIe, $Ie, WIe, jIe, KIe, eNe, iNe, lNe, Bn],
							styles: [
								'cc-ribbon-bar{position:fixed;z-index:10;white-space:nowrap;display:flex;flex-wrap:nowrap;flex-direction:row;width:100%}cc-ribbon-bar #height-and-color-metric-container{display:flex;flex-wrap:nowrap;flex-direction:row;border:none;flex:2.5 2.5 0}cc-ribbon-bar #height-and-color-metric-container .mat-mdc-card{box-shadow:none}cc-ribbon-bar .cc-ribbon-bar-menu-button{height:22px;line-height:22px;min-width:45px;margin:0;padding:0;font-size:9pt;background-color:#e6e6e6f5;color:#444}cc-ribbon-bar .cc-ribbon-bar-menu-button:hover{background-color:#c8c8c8}cc-ribbon-bar cc-search-panel .search-panel-card{border-left:none;width:100%}cc-ribbon-bar cc-search-panel .search-panel-card.expanded{height:100%}cc-ribbon-bar cc-search-panel .search-panel-card.expanded .section-body{min-height:162px;max-height:500px;overflow-y:auto}cc-ribbon-bar cc-search-panel .search-panel-card .section-body{display:flex;flex-direction:column;padding:6px;position:absolute;top:45px;background:white;border:1px solid #b5b5b5;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f}cc-ribbon-bar cc-search-panel .search-panel-card .section-body.hidden{display:none;pointer-events:none}cc-ribbon-bar .mat-mdc-card{padding:0;height:46px;border-radius:0;border-top:1px solid #cdcdcd;flex:1 1 0;transition:.2s width ease-in-out}cc-ribbon-bar .mat-mdc-card .section{display:inline-block;height:100%;width:100%;vertical-align:top;overflow:hidden}cc-ribbon-bar .mat-mdc-card .section#height-metric-section{border-right:none}cc-ribbon-bar .mat-mdc-card .section .section-header{margin:0 5px;height:31px;color:#444;overflow:hidden;padding:5px}cc-ribbon-bar .mat-mdc-card .section .section-header#area-metric-header-section,cc-ribbon-bar .mat-mdc-card .section .section-header#height-metric-header-section,cc-ribbon-bar .mat-mdc-card .section .section-header#color-metric-header-section,cc-ribbon-bar .mat-mdc-card .section .section-header#edge-metric-header-section{border-bottom:1px solid rgba(0,0,0,.12)}cc-ribbon-bar .mat-mdc-card .section .section-title{font-size:8pt;display:block;width:100%;height:100%;color:gray;text-align:center;transition:background-color .4s;border-bottom:1px solid transparent}cc-ribbon-bar .mat-mdc-card .section .section-title:hover{background-color:#e0e0e0;cursor:pointer}cc-ribbon-bar .mat-mdc-card .section .section-title:focus{outline:none}cc-ribbon-bar .mat-mdc-card .section .section-title.no-hover{pointer-events:none}cc-ribbon-bar .mat-mdc-card .section .section-title i:before{content:"\\f107"}cc-ribbon-bar .mat-mdc-card.expanded .section-title i:before{content:"\\f106"}cc-ribbon-bar .mat-mdc-card.expanded .section-body cc-reset-settings-button button{opacity:1;pointer-events:all}cc-ribbon-bar .mat-mdc-card .section-height-metric-card{border-right:none}cc-ribbon-bar .mat-mdc-card .delta-color-section{line-height:45px;vertical-align:baseline}cc-ribbon-bar .mat-mdc-card .delta-color-section:hover{cursor:pointer}cc-ribbon-bar .mat-mdc-card .delta-color-section .color-icon{margin:8px}cc-ribbon-bar .mat-mdc-card .delta-color-section .color-dropdown-icon{position:absolute;top:12px;right:8px}cc-ribbon-bar .mat-mdc-card.ai-card .section .section-header,cc-ribbon-bar .mat-mdc-card.custom-configs-card .section .section-header{overflow:visible;text-align:center}cc-ribbon-bar .mat-mdc-card.ai-card .section .section-title,cc-ribbon-bar .mat-mdc-card.custom-configs-card .section .section-title{padding:1px 5px}cc-ribbon-bar mat-card,cc-ribbon-bar .section .section-header,cc-ribbon-bar .section .section-body,cc-ribbon-bar .section-body cc-reset-settings-button button{transition:height .1s ease}cc-ribbon-bar mat-card.custom-configs-card,cc-ribbon-bar mat-card.ai-card{max-width:120px;min-width:120px}cc-ribbon-bar mat-card.link-color-metric-to-height-metric-card{display:flex;justify-content:center;flex-grow:0}cc-ribbon-bar mat-card.scenario-card{max-width:100px;min-width:100px}cc-ribbon-bar cc-area-metric-chooser,cc-ribbon-bar cc-height-metric-chooser,cc-ribbon-bar cc-color-metric-chooser,cc-ribbon-bar cc-edge-metric-chooser{display:flex;align-items:center;margin:auto}cc-ribbon-bar cc-area-metric-chooser i,cc-ribbon-bar cc-height-metric-chooser i,cc-ribbon-bar cc-color-metric-chooser i,cc-ribbon-bar cc-edge-metric-chooser i{margin-right:8px}cc-ribbon-bar .cc-metric-settings-panel{display:flex;flex-direction:column;position:absolute;top:45px;right:0;padding:8px;width:280px;background:white;border:1px solid #b5b5b5;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f;overflow:hidden;opacity:1;font-size:.9em;transition:max-height .2s ease-in-out}cc-ribbon-bar .cc-metric-settings-panel.hidden{max-height:0;pointer-events:none;opacity:0;transition:opacity 0ms .2s,max-height .2s ease-in-out}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const wZ = () => {
					const t = document.createElement("INPUT")
					return (
						t.setAttribute("type", "file"),
						t.setAttribute("accept", ".json,.gz"),
						t.setAttribute("multiple", ""),
						document.body.appendChild(t),
						t
					)
				},
				Hb = "base"
			function xZ(t, n, e, i, r, o) {
				if (0 === t.length) return
				const [s] = t
				let a = { name: s, type: CZ(t) ? Da.FILE : Da.FOLDER, attributes: {} }
				CZ(t)
					? (a = (function bNe(t, n, e) {
							const i = { ...n }
							return (i.attributes = { height: e.scale.y }), { name: t, type: Da.FOLDER, attributes: {}, children: [i] }
					  })(s, a, i))
					: (a.children = []),
					(function gNe(t, n) {
						return t.some(e => e.name === n)
					})(n, s)
						? (a = n.find(d => d.name === s))
						: n.push(a)
				const c = r.find(d => d.name === e)
				a.fixedPosition = (function _Ne(t, n, e, i) {
					let r
					if (t.type === Da.FOLDER) {
						const s = n.position.z - n.scale.z / 2,
							c = e.position.z - e.scale.z / 2,
							l = jk(((e.position.x - e.scale.x / 2 - (n.position.x - n.scale.x / 2)) / n.scale.x) * 100, 2)
						r = {
							left: jk(((c - s) / n.scale.z) * 100, 2),
							top: l,
							width: jk((e.scale.z / n.scale.z) * 100, 2),
							height: jk((e.scale.x / n.scale.x) * 100, 2)
						}
					}
					return (
						t.name === i &&
							(r = (function vNe(t) {
								const n = { ...t }
								return (n.top = Math.floor(50 - n.height / 2)), (n.left = Math.floor(50 - n.width / 2)), n
							})(r)),
						r
					)
				})(a, c, i, o.name)
				const l = e === Hb ? a.name : `${e}.${a.name}`
				xZ(t.slice(1), a.children, l, i, r, o)
			}
			function CZ(t) {
				return 1 === t.length
			}
			function jk(t, n) {
				const e = Math.pow(10, n)
				return Math.round(t * e) / e
			}
			function EZ(t) {
				const n = t.replaceAll(".", "/"),
					i = t.split(".").slice(-1)
				return `/${Hb}/${n}/${i}`
			}
			const CNe = JSON.parse(
					'{"$id":"http://example.com/example.json","$schema":"http://json-schema.org/draft-07/schema","default":{},"description":"This is the JSON Schema for the GameObjectsPositions structure","examples":[{"gameObjectPositions":[{"name":"root.analysis.import.SourceCodeParser.src.test.kotlin.de.maibornwolff.codecharta.importer.sourcecodeparser.oop.core.extract.HelloWorldTest","position":{"x":69,"y":18.5,"z":228.5},"scale":{"x":9,"y":5,"z":9}},{"name":"root.analysis.import.SourceCodeParser.src.test.kotlin.de.maibornwolff.codecharta.importer.sourcecodeparser.oop.core.extract.TryCatchFinallyTest","position":{"x":66,"y":22.5,"z":177.5},"scale":{"x":1,"y":13,"z":1}}],"cycles":[{"from":"root.analysis.import.SCMLogParser.src.main.java.de.maibornwolff.codecharta.importer.scmlogparser.SCMLogParser","to":"root.analysis.import.SCMLogParser.src.main.java.de.maibornwolff.codecharta.importer.scmlogparser.SCMLogParserParameter"}]}],"required":["gameObjectPositions"],"title":"The root schema","type":"object","properties":{"gameObjectPositions":{"$id":"#/properties/gameObjectPositions","type":"array","title":"The gameObjectPositions schema","description":"Defines the position and scale of GameObjects","default":[],"examples":[[{"name":"root.analysis.import.SourceCodeParser.src.test.kotlin.de.maibornwolff.codecharta.importer.sourcecodeparser.oop.core.extract.HelloWorldTest","position":{"x":69,"y":18.5,"z":228.5},"scale":{"x":9,"y":5,"z":9}},{"name":"root.analysis.import.SourceCodeParser.src.test.kotlin.de.maibornwolff.codecharta.importer.sourcecodeparser.oop.core.extract.SwitchCaseTest","position":{"x":65,"y":22,"z":181},"scale":{"x":2,"y":12,"z":2}}]],"additionalItems":true,"items":{"$id":"#/properties/gameObjectPositions/items","anyOf":[{"$id":"#/properties/gameObjectPositions/items/anyOf/0","type":"object","title":"The first anyOf schema","description":"Defines the properties of a GameObject","default":{},"examples":[{"name":"root.analysis.import.SourceCodeParser.src.test.kotlin.de.maibornwolff.codecharta.importer.sourcecodeparser.oop.core.extract.HelloWorldTest","position":{"x":69,"y":18.5,"z":228.5},"scale":{"x":9,"y":5,"z":9}}],"required":["name","position","scale"],"properties":{"name":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/name","type":"string","title":"The name schema","description":"An explanation about the purpose of this instance.","default":"","examples":["root.analysis.import.SourceCodeParser.src.test.kotlin.de.maibornwolff.codecharta.importer.sourcecodeparser.oop.core.extract.HelloWorldTest"]},"position":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/position","type":"object","title":"The position schema","description":"The position in absolute values","default":{},"examples":[{"x":69,"y":18.5,"z":228.5}],"required":["x","y","z"],"properties":{"x":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/position/properties/x","type":"number","title":"The x schema","description":"x position","default":0,"examples":[69]},"y":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/position/properties/y","type":"number","title":"The y schema","description":"y position","default":0,"examples":[18.5]},"z":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/position/properties/z","type":"number","title":"The z schema","description":"z position","default":0,"examples":[228.5]}},"additionalProperties":true},"scale":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/scale","type":"object","title":"The scale schema","description":"The scale of GameObjects","default":{},"examples":[{"x":9,"y":5,"z":9}],"required":["x","y","z"],"properties":{"x":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/scale/properties/x","type":"number","title":"The x schema","description":"x scale","default":0,"examples":[9]},"y":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/scale/properties/y","type":"number","title":"The y schema","description":"y scale","default":0,"examples":[5]},"z":{"$id":"#/properties/gameObjectPositions/items/anyOf/0/properties/scale/properties/z","type":"number","title":"The z schema","description":"z scale","default":0,"examples":[9]}},"additionalProperties":true}},"additionalProperties":true}]}},"cycles":{"$id":"#/properties/cycles","type":"array","title":"The cycles schema","description":"Defines the cycles between GameObjects","default":[],"examples":[[{"from":"root.analysis.import.SCMLogParser.src.main.java.de.maibornwolff.codecharta.importer.scmlogparser.SCMLogParser","to":"root.analysis.import.SCMLogParser.src.main.java.de.maibornwolff.codecharta.importer.scmlogparser.SCMLogParserParameter"}]],"additionalItems":true,"items":{"$id":"#/properties/cycles/items","anyOf":[{"$id":"#/properties/cycles/items/anyOf/0","type":"object","title":"The first anyOf schema","description":"A cycle between two GameObjects","default":{},"examples":[{"from":"root.analysis.import.SCMLogParser.src.main.java.de.maibornwolff.codecharta.importer.scmlogparser.SCMLogParser","to":"root.analysis.import.SCMLogParser.src.main.java.de.maibornwolff.codecharta.importer.scmlogparser.SCMLogParserParameter"}],"required":["from","to"],"properties":{"from":{"$id":"#/properties/cycles/items/anyOf/0/properties/from","type":"string","title":"The from schema","description":"from GameObject","default":"","examples":["root.analysis.import.SCMLogParser.src.main.java.de.maibornwolff.codecharta.importer.scmlogparser.SCMLogParser"]},"to":{"$id":"#/properties/cycles/items/anyOf/0/properties/to","type":"string","title":"The to schema","description":"to GameObject","default":"","examples":["root.analysis.import.SCMLogParser.src.main.java.de.maibornwolff.codecharta.importer.scmlogparser.SCMLogParserParameter"]}},"additionalProperties":true}]}}},"additionalProperties":true}'
				),
				MZ = t => {
					const n = []
					for (let e = 0; e < t.length; e++) n.push(MNe(t[e]))
					return n
				},
				MNe = (function () {
					var t = _r(function* (n) {
						return new Promise(e => {
							const i = n.name.endsWith(".gz"),
								r = new FileReader()
							let o
							i ? r.readAsArrayBuffer(n) : r.readAsText(n, "utf8"),
								(r.onload = s => {
									const a = s.target.result.toString()
									;(o = i ? $L(s.target.result, { to: "string" }) : a),
										a.includes("gameObjectPositions") &&
											(function ENe(t) {
												return new (w9())({ allErrors: !0 }).validate(CNe, JSON.parse(t))
											})(a) &&
											(o = JSON.stringify(
												(function pNe(t) {
													const { gameObjectPositions: n, cycles: e = [] } = JSON.parse(t),
														i = {
															checksum: "",
															data: {
																projectName: "GameObjects",
																fileChecksum: "",
																apiVersion: "1.3",
																nodes: []
															}
														},
														r = [{ name: Hb, type: Da.FOLDER, attributes: {}, children: [] }]
													!(function ANe(t) {
														for (const n of t)
															n.name.startsWith("root") ||
																(n.name = n.name.startsWith(".") ? `root${n.name}` : `root.${n.name}`)
													})(n)
													const o = n.find(a => "root" === a.name),
														s = (function xNe(t) {
															const n = Math.max(t.x, t.z)
															return { name: Hb, position: { x: 0, y: 0, z: 0 }, scale: { x: n, y: 0, z: n } }
														})(o.scale)
													n.push(s)
													for (const a of n) {
														const c = a.name.split(".")
														c[0] !== Hb && xZ(c, r[0].children, Hb, a, n, o)
													}
													return (
														(i.data.nodes = r),
														(i.data.edges = e.map(a =>
															(function yNe(t) {
																return {
																	fromNodeName: EZ(t.from),
																	toNodeName: EZ(t.to),
																	attributes: { coupling: 100 }
																}
															})(a)
														)),
														(i.data.attributeTypes = (function wNe() {
															return { edges: { coupling: zh.relative } }
														})()),
														(i.checksum = bE()(JSON.stringify(i.data))),
														i
													)
												})(a)
											))
								}),
								(r.onloadend = () => {
									e(o)
								})
						})
					})
					return function (e) {
						return t.apply(this, arguments)
					}
				})()
			let SZ = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e), (this.loadFileService = i), (this.isUploading = !1)
						}
						uploadFiles() {
							const e = wZ()
							e.addEventListener("change", () => {
								this.uploadFilesOnEvent(e)
							}),
								e.click()
						}
						uploadFilesOnEvent(e) {
							var i = this
							return _r(function* () {
								try {
									;(i.isUploading = !0), i.store.dispatch(Dm({ value: !0 })), i.store.dispatch(fg({ value: !0 }))
									const r = yield Promise.all(MZ(e.files)),
										{ customConfigs: o, ccFiles: s } = i.splitCustomConfigsAndCCFiles(e.files, r)
									for (const a of o) ki.importCustomConfigs(a)
									s.length > 0 && (yield i.loadFileService.loadFiles(s))
								} catch {
									i.store.dispatch(Dm({ value: !1 })), i.store.dispatch(fg({ value: !1 }))
								} finally {
									i.isUploading = !1
								}
							})()
						}
						splitCustomConfigsAndCCFiles(e, i) {
							const r = [],
								o = []
							for (const [s, a] of i.entries()) {
								const c = e[s].name
								c.includes(dY) ? r.push(a) : o.push({ fileName: c, fileSize: e[s].size, content: wD(a) })
							}
							return { customConfigs: r, ccFiles: o }
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(wg))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				Vb = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-action-icon"]],
								inputs: { icon: "icon" },
								decls: 1,
								vars: 2,
								consts: [["role", "button"]],
								template: function (i, r) {
									1 & i && fe(0, "i", 0), 2 & i && c0(r.icon)
								},
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-action-icon{display:inline-flex;align-items:center;cursor:pointer;width:24px;height:24px;border-radius:100%;background-color:#1b9cfc;font-size:14px}cc-action-icon:hover{background-color:#0374c9}cc-action-icon.disabled{opacity:.5}cc-action-icon i,cc-action-icon i.fa{margin:auto;line-height:1.5;color:#fff}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				SNe = (() => {
					class t {
						constructor(e) {
							this.uploadFilesService = e
						}
						uploadFiles() {
							this.uploadFilesService.uploadFiles()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(SZ))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-upload-files-button"]],
								decls: 1,
								vars: 1,
								consts: [["title", "Load cc.json files", 3, "icon", "click"]],
								template: function (i, r) {
									1 & i &&
										(F(0, "cc-action-icon", 0),
										Le("click", function () {
											return r.uploadFiles()
										}),
										L()),
										2 & i && U("icon", "fa fa-folder-open folder-icon")
								},
								dependencies: [Vb],
								styles: ["cc-upload-files-button i{padding-left:1px}\n"],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			var a3 = typeof navigator < "u" && navigator.userAgent.toLowerCase().indexOf("firefox") > 0
			function c3(t, n, e, i) {
				t.addEventListener
					? t.addEventListener(n, e, i)
					: t.attachEvent &&
					  t.attachEvent("on".concat(n), function () {
							e(window.event)
					  })
			}
			function kZ(t, n) {
				for (var e = n.slice(0, n.length - 1), i = 0; i < e.length; i++) e[i] = t[e[i].toLowerCase()]
				return e
			}
			function TZ(t) {
				"string" != typeof t && (t = "")
				for (var n = (t = t.replace(/\s/g, "")).split(","), e = n.lastIndexOf(""); e >= 0; )
					(n[e - 1] += ","), n.splice(e, 1), (e = n.lastIndexOf(""))
				return n
			}
			for (
				var Uw = {
						backspace: 8,
						"\u232b": 8,
						tab: 9,
						clear: 12,
						enter: 13,
						"\u21a9": 13,
						return: 13,
						esc: 27,
						escape: 27,
						space: 32,
						left: 37,
						up: 38,
						right: 39,
						down: 40,
						del: 46,
						delete: 46,
						ins: 45,
						insert: 45,
						home: 36,
						end: 35,
						pageup: 33,
						pagedown: 34,
						capslock: 20,
						num_0: 96,
						num_1: 97,
						num_2: 98,
						num_3: 99,
						num_4: 100,
						num_5: 101,
						num_6: 102,
						num_7: 103,
						num_8: 104,
						num_9: 105,
						num_multiply: 106,
						num_add: 107,
						num_enter: 108,
						num_subtract: 109,
						num_decimal: 110,
						num_divide: 111,
						"\u21ea": 20,
						",": 188,
						".": 190,
						"/": 191,
						"`": 192,
						"-": a3 ? 173 : 189,
						"=": a3 ? 61 : 187,
						";": a3 ? 59 : 186,
						"'": 222,
						"[": 219,
						"]": 221,
						"\\": 220
					},
					Ld = {
						"\u21e7": 16,
						shift: 16,
						"\u2325": 18,
						alt: 18,
						option: 18,
						"\u2303": 17,
						ctrl: 17,
						control: 17,
						"\u2318": 91,
						cmd: 91,
						command: 91
					},
					l3 = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey", shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 },
					Rs = { 16: !1, 18: !1, 17: !1, 91: !1 },
					$o = {},
					Kk = 1;
				Kk < 20;
				Kk++
			)
				Uw["f".concat(Kk)] = 111 + Kk
			var Xr = [],
				FZ = !1,
				BZ = "all",
				IZ = [],
				Xk = function (n) {
					return Uw[n.toLowerCase()] || Ld[n.toLowerCase()] || n.toUpperCase().charCodeAt(0)
				}
			function DZ(t) {
				BZ = t || "all"
			}
			function Hw() {
				return BZ || "all"
			}
			var d3 = function (n) {
				var i = n.scope,
					r = n.method,
					o = n.splitKey,
					s = void 0 === o ? "+" : o
				TZ(n.key).forEach(function (c) {
					var l = c.split(s),
						d = l.length,
						u = l[d - 1],
						h = "*" === u ? "*" : Xk(u)
					if ($o[h]) {
						i || (i = Hw())
						var f = d > 1 ? kZ(Ld, l) : []
						$o[h] = $o[h].filter(function (_) {
							return !(
								(!r || _.method === r) &&
								_.scope === i &&
								(function kNe(t, n) {
									for (
										var e = t.length >= n.length ? t : n, i = t.length >= n.length ? n : t, r = !0, o = 0;
										o < e.length;
										o++
									)
										-1 === i.indexOf(e[o]) && (r = !1)
									return r
								})(_.mods, f)
							)
						})
					}
				})
			}
			function LZ(t, n, e, i) {
				var r
				if (n.element === i && (n.scope === e || "all" === n.scope)) {
					for (var o in ((r = n.mods.length > 0), Rs))
						Object.prototype.hasOwnProperty.call(Rs, o) &&
							((!Rs[o] && n.mods.indexOf(+o) > -1) || (Rs[o] && -1 === n.mods.indexOf(+o))) &&
							(r = !1)
					;((0 === n.mods.length && !Rs[16] && !Rs[18] && !Rs[17] && !Rs[91]) || r || "*" === n.shortcut) &&
						!1 === n.method(t, n) &&
						(t.preventDefault ? t.preventDefault() : (t.returnValue = !1),
						t.stopPropagation && t.stopPropagation(),
						t.cancelBubble && (t.cancelBubble = !0))
				}
			}
			function RZ(t, n) {
				var e = $o["*"],
					i = t.keyCode || t.which || t.charCode
				if (Rd.filter.call(this, t)) {
					if (
						((93 === i || 224 === i) && (i = 91),
						-1 === Xr.indexOf(i) && 229 !== i && Xr.push(i),
						["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function (_) {
							var y = l3[_]
							t[_] && -1 === Xr.indexOf(y)
								? Xr.push(y)
								: !t[_] && Xr.indexOf(y) > -1
								? Xr.splice(Xr.indexOf(y), 1)
								: "metaKey" === _ &&
								  t[_] &&
								  3 === Xr.length &&
								  (t.ctrlKey || t.shiftKey || t.altKey || (Xr = Xr.slice(Xr.indexOf(y))))
						}),
						i in Rs)
					) {
						for (var r in ((Rs[i] = !0), Ld)) Ld[r] === i && (Rd[r] = !0)
						if (!e) return
					}
					for (var o in Rs) Object.prototype.hasOwnProperty.call(Rs, o) && (Rs[o] = t[l3[o]])
					t.getModifierState &&
						(!t.altKey || t.ctrlKey) &&
						t.getModifierState("AltGraph") &&
						(-1 === Xr.indexOf(17) && Xr.push(17), -1 === Xr.indexOf(18) && Xr.push(18), (Rs[17] = !0), (Rs[18] = !0))
					var s = Hw()
					if (e)
						for (var a = 0; a < e.length; a++)
							e[a].scope === s &&
								(("keydown" === t.type && e[a].keydown) || ("keyup" === t.type && e[a].keyup)) &&
								LZ(t, e[a], s, n)
					if (i in $o)
						for (var c = 0; c < $o[i].length; c++)
							if ((("keydown" === t.type && $o[i][c].keydown) || ("keyup" === t.type && $o[i][c].keyup)) && $o[i][c].key) {
								for (var l = $o[i][c], u = l.key.split(l.splitKey), h = [], f = 0; f < u.length; f++) h.push(Xk(u[f]))
								h.sort().join("") === Xr.sort().join("") && LZ(t, l, s, n)
							}
				}
			}
			function Rd(t, n, e) {
				Xr = []
				var i = TZ(t),
					r = [],
					o = "all",
					s = document,
					a = 0,
					c = !1,
					l = !0,
					d = "+",
					u = !1
				for (
					void 0 === e && "function" == typeof n && (e = n),
						"[object Object]" === Object.prototype.toString.call(n) &&
							(n.scope && (o = n.scope),
							n.element && (s = n.element),
							n.keyup && (c = n.keyup),
							void 0 !== n.keydown && (l = n.keydown),
							void 0 !== n.capture && (u = n.capture),
							"string" == typeof n.splitKey && (d = n.splitKey)),
						"string" == typeof n && (o = n);
					a < i.length;
					a++
				)
					(r = []),
						(t = i[a].split(d)).length > 1 && (r = kZ(Ld, t)),
						(t = "*" === (t = t[t.length - 1]) ? "*" : Xk(t)) in $o || ($o[t] = []),
						$o[t].push({
							keyup: c,
							keydown: l,
							scope: o,
							mods: r,
							shortcut: i[a],
							method: e,
							key: i[a],
							splitKey: d,
							element: s
						})
				typeof s < "u" &&
					!(function NNe(t) {
						return IZ.indexOf(t) > -1
					})(s) &&
					window &&
					(IZ.push(s),
					c3(
						s,
						"keydown",
						function (h) {
							RZ(h, s)
						},
						u
					),
					FZ ||
						((FZ = !0),
						c3(
							window,
							"focus",
							function () {
								Xr = []
							},
							u
						)),
					c3(
						s,
						"keyup",
						function (h) {
							RZ(h, s),
								(function PNe(t) {
									var n = t.keyCode || t.which || t.charCode,
										e = Xr.indexOf(n)
									if (
										(e >= 0 && Xr.splice(e, 1),
										t.key && "meta" === t.key.toLowerCase() && Xr.splice(0, Xr.length),
										(93 === n || 224 === n) && (n = 91),
										n in Rs)
									)
										for (var i in ((Rs[n] = !1), Ld)) Ld[i] === n && (Rd[i] = !1)
								})(h)
						},
						u
					))
			}
			var u3 = {
				getPressedKeyString: function INe() {
					return Xr.map(function (t) {
						return (
							(function (n) {
								return Object.keys(Uw).find(function (e) {
									return Uw[e] === n
								})
							})(t) ||
							(function (n) {
								return Object.keys(Ld).find(function (e) {
									return Ld[e] === n
								})
							})(t) ||
							String.fromCharCode(t)
						)
					})
				},
				setScope: DZ,
				getScope: Hw,
				deleteScope: function RNe(t, n) {
					var e, i
					for (var r in (t || (t = Hw()), $o))
						if (Object.prototype.hasOwnProperty.call($o, r))
							for (e = $o[r], i = 0; i < e.length; ) e[i].scope === t ? e.splice(i, 1) : i++
					Hw() === t && DZ(n || "all")
				},
				getPressedKeyCodes: function BNe() {
					return Xr.slice(0)
				},
				isPressed: function LNe(t) {
					return "string" == typeof t && (t = Xk(t)), -1 !== Xr.indexOf(t)
				},
				filter: function DNe(t) {
					var n = t.target || t.srcElement,
						e = n.tagName,
						i = !0
					return (n.isContentEditable || (("INPUT" === e || "TEXTAREA" === e || "SELECT" === e) && !n.readOnly)) && (i = !1), i
				},
				trigger: function UNe(t) {
					var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "all"
					Object.keys($o).forEach(function (e) {
						$o[e]
							.filter(function (r) {
								return r.scope === n && r.shortcut === t
							})
							.forEach(function (r) {
								r && r.method && r.method()
							})
					})
				},
				unbind: function ONe(t) {
					if (typeof t > "u")
						Object.keys($o).forEach(function (s) {
							return delete $o[s]
						})
					else if (Array.isArray(t))
						t.forEach(function (s) {
							s.key && d3(s)
						})
					else if ("object" == typeof t) t.key && d3(t)
					else if ("string" == typeof t) {
						for (var n = arguments.length, e = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) e[i - 1] = arguments[i]
						var r = e[0],
							o = e[1]
						"function" == typeof r && ((o = r), (r = "")), d3({ key: t, scope: r, method: o, splitKey: "+" })
					}
				},
				keyMap: Uw,
				modifier: Ld,
				modifierMap: l3
			}
			for (var h3 in u3) Object.prototype.hasOwnProperty.call(u3, h3) && (Rd[h3] = u3[h3])
			if (typeof window < "u") {
				var HNe = window.hotkeys
				;(Rd.noConflict = function (t) {
					return t && window.hotkeys === Rd && (window.hotkeys = HNe), Rd
				}),
					(window.hotkeys = Rd)
			}
			var VNe = A(4456),
				QNe = A.n(VNe)
			function f3() {
				return (
					(f3 = _r(function* (t) {
						const n = [new ClipboardItem({ [t.type]: t })]
						yield navigator.clipboard.write(n)
					})),
					f3.apply(this, arguments)
				)
			}
			const PZ = Mt(Tr, t => t.screenshotToClipboardEnabled)
			function $Ne(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "cc-action-icon", 2),
						Le("click", function () {
							return rn(e), on(Te().makeScreenshotToClipboard())
						}),
						L()
				}
				if (2 & t) {
					const e = Te()
					Zt("disabled", !e.isWriteToClipboardAllowed), Fa("title", e.TITLE_CLIPBOARD_BUTTON), U("icon", "fa fa-camera")
				}
			}
			function WNe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "cc-action-icon", 2),
						Le("click", function () {
							return rn(e), on(Te().makeScreenshotToFile())
						}),
						L()
				}
				2 & t && (Fa("title", Te().TITLE_FILE_BUTTON), U("icon", "fa fa-camera"))
			}
			let jNe = (() => {
				class t {
					constructor(e, i, r, o, s) {
						;(this.threeCameraService = e),
							(this.threeSceneService = i),
							(this.threeRendererService = r),
							(this.store = o),
							(this.state = s),
							(this.SCREENSHOT_HOTKEY_TO_FILE = "Ctrl+Alt+S"),
							(this.SCREENSHOT_HOTKEY_TO_CLIPBOARD = "Ctrl+Alt+F"),
							(this.isScreenshotToClipboardEnabled$ = this.store.select(PZ))
					}
					ngOnInit() {
						;(this.isWriteToClipboardAllowed = (function GNe() {
							return "clipboard" in navigator && "write" in navigator.clipboard
						})()),
							(this.TITLE_CLIPBOARD_BUTTON = this.createTitleClipboardButton()),
							(this.TITLE_FILE_BUTTON = this.createTitleFileButton()),
							Rd(this.SCREENSHOT_HOTKEY_TO_FILE, () => {
								this.makeScreenshotToFile()
							}),
							Rd(this.SCREENSHOT_HOTKEY_TO_CLIPBOARD, () => {
								this.makeScreenshotToClipboard()
							})
					}
					makeScreenshotToFile() {
						var e = this
						return _r(function* () {
							const i = e.threeRendererService.renderer,
								r = e.saveRenderSettings(i),
								o = yield e.buildScreenShotCanvas(i)
							e.downloadScreenshot(o, e.state.getValue().files), e.applyRenderSettings(i, r)
						})()
					}
					makeScreenshotToClipboard() {
						var e = this
						return _r(function* () {
							if (!e.isWriteToClipboardAllowed) return
							const i = e.threeRendererService.renderer,
								r = e.saveRenderSettings(i),
								o = yield e.buildScreenShotCanvas(i),
								s = new Promise(c => o.toBlob(c))
							e.applyRenderSettings(i, r)
							const a = yield s
							yield (function zNe(t) {
								return f3.apply(this, arguments)
							})(a)
						})()
					}
					downloadScreenshot(e, i) {
						const r = e.toDataURL("image/png"),
							o = document.createElement("a")
						;(o.download = (function mme(t, n) {
							const e = ad(t) ? "delta" : "",
								r = yD(t).map(a =>
									(function pme(t) {
										return t.file.fileMeta.fileName.replace(/(.cc)?.json$/, "")
									})(a)
								),
								o = (function Ame(t) {
									return t.length <= 3 ? t.join(pE) : [t.at(0), nG, t.at(-1)].join(pE)
								})(r)
							return (function gme(t, n, e) {
								const i = [n, t].filter(o => o.length > 0).join(pE),
									r = 255 - e.length - vD.length
								return i.length <= r ? [i, pE, e, vD].join("") : [i.slice(0, r - 1), nG, e, vD].join("")
							})(o, e, n)
						})(i, "map")),
							(o.href = r),
							document.body.appendChild(o),
							o.click(),
							o.remove()
					}
					saveRenderSettings(e) {
						const i = e.getPixelRatio(),
							r = new Lt()
						return e.getClearColor(r), { pixelRatio: i, clearColor: r }
					}
					applyRenderSettings(e, i) {
						const { pixelRatio: r, clearColor: o } = i
						e.setPixelRatio(r), e.setClearColor(o), e.render(this.threeSceneService.scene, this.threeCameraService.camera)
					}
					buildScreenShotCanvas(e) {
						var i = this
						return _r(function* () {
							e.setPixelRatio(window.devicePixelRatio),
								e.setClearColor(new Lt(0, 0, 0), 0),
								e.render(i.threeSceneService.scene, i.threeCameraService.camera)
							const r = new Set([
									"cc-logo",
									"cc-tool-bar",
									"cc-view-cube",
									"cc-ribbon-bar",
									"cc-file-extension-bar",
									"cc-attribute-side-bar",
									"cc-loading-file-progess-spinner"
								]),
								o = new Set(["legend-panel-button"]),
								s = document.querySelector("body")?.offsetHeight,
								a = document.querySelector("cc-ribbon-bar")?.offsetHeight,
								c = document.querySelector("cc-tool-bar")?.offsetHeight,
								l = document.querySelector("cc-file-extension-bar")?.offsetHeight,
								d = a + c + l,
								u = yield QNe()(document.querySelector("body"), {
									removeContainer: !0,
									backgroundColor: "#00",
									scrollY: -d,
									height: s - d,
									ignoreElements: h => r.has(h.tagName.toLowerCase()) || o.has(h.id) || "10000" === h.style.zIndex
								})
							return i.getCroppedCanvas(u)
						})()
					}
					getCroppedCanvas(e) {
						const i = e.getContext("2d"),
							r = e.width,
							o = e.height,
							a = i.getImageData(0, 0, r, o).data
						let c = r,
							l = o,
							d = 0,
							u = 0
						for (let _ = 0; _ < r; _++)
							for (let y = 0; y < o; y++)
								a[4 * (r * y + _) + 3] > 0 &&
									((c = Math.min(c, _)), (d = Math.max(d, _)), (l = Math.min(l, y)), (u = Math.max(u, y)))
						const h = document.createElement("canvas"),
							f = h.getContext("2d")
						return (
							(h.width = d - c + 1),
							(h.height = u - l + 1),
							f.drawImage(e, c, l, h.width, h.height, 0, 0, h.width, h.height),
							h
						)
					}
					createTitleClipboardButton() {
						return this.isWriteToClipboardAllowed
							? `Take a screenshot of the map with ${this.SCREENSHOT_HOTKEY_TO_CLIPBOARD} (copy to clipboard) or ${this.SCREENSHOT_HOTKEY_TO_FILE} (save as file)`
							: "Firefox does not support copying to clipboard"
					}
					createTitleFileButton() {
						return `Take a screenshot of the map with ${this.SCREENSHOT_HOTKEY_TO_FILE} (save as file) or ${this.SCREENSHOT_HOTKEY_TO_CLIPBOARD} (copy to clipboard)`
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Td), P(Qc), P(Ri), P(Ct), P(Sr))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-screenshot-button"]],
							decls: 4,
							vars: 6,
							consts: [
								[3, "icon", "title", "disabled", "click", 4, "ngIf"],
								[3, "icon", "title", "click", 4, "ngIf"],
								[3, "icon", "title", "click"]
							],
							template: function (i, r) {
								1 & i &&
									(Ee(0, $Ne, 1, 4, "cc-action-icon", 0),
									Me(1, "async"),
									Ee(2, WNe, 1, 2, "cc-action-icon", 1),
									Me(3, "async")),
									2 & i &&
										(U("ngIf", De(1, 2, r.isScreenshotToClipboardEnabled$)),
										T(2),
										U("ngIf", !De(3, 4, r.isScreenshotToClipboardEnabled$)))
							},
							dependencies: [En, Vb, Bn],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function KNe(t) {
				return `\t\u2022 ${t.filePath} (${t.value})\n`
			}
			function XNe(t) {
				return `${t.toUpperCase()}\n`
			}
			function JNe(t) {
				return t.type === Da.FILE && void 0 !== t.attributes
			}
			function e3e(t, n, e) {
				for (const [i, r] of Object.entries(t.attributes)) {
					const o = n?.[i]?.direction,
						s = { filePath: t.path, value: r }
					if (e.has(i)) {
						const a = e.get(i)
						t3e(a, s, o), e.set(i, a.slice(0, 10))
					} else e.set(i, [s])
				}
			}
			function t3e(t, n, e) {
				const i = (function n3e(t) {
						return 1 === t ? (n, e) => n.value - e.value : (n, e) => e.value - n.value
					})(e),
					r = t.findIndex(o => i(n, o) < 0)
				;-1 === r ? t.push(n) : t.splice(r, 0, n)
			}
			let OZ = (() => {
					class t {
						constructor(e) {
							this.state = e
						}
						getClipboardText() {
							const r = (function ZNe(t, n) {
								const e = new Map()
								for (const { data: i } of $r(t)) JNe(i) && e3e(i, n, e)
								return e
							})(this.getUnifiedMapNode(), this.state.getValue().fileSettings.attributeDescriptors)
							return (function YNe(t) {
								let n = ""
								for (const [e, i] of t.entries()) {
									n += XNe(e)
									for (const r of i) n += KNe(r)
								}
								return n
							})(r)
						}
						getUnifiedMapNode() {
							const { unifiedMapNode: e } = Vc(this.state.getValue())
							return e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Sr))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				i3e = (() => {
					class t {
						constructor(e) {
							this.copyToClipboardService = e
						}
						copyNamesToClipBoard() {
							var e = this
							return _r(function* () {
								yield navigator.clipboard.writeText(e.copyToClipboardService.getClipboardText())
							})()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(OZ))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-copy-to-clipboard-button"]],
								decls: 1,
								vars: 0,
								consts: [
									[
										"icon",
										"fa fa-clipboard",
										"title",
										"Copy filenames with highest metric values to clipboard",
										3,
										"click"
									]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "cc-action-icon", 0),
										Le("click", function () {
											return r.copyNamesToClipBoard()
										}),
										L())
								},
								dependencies: [Vb],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			var m3 = function () {}
			m3.prototype = {
				constructor: m3,
				parse: function (t, n) {
					void 0 === n && (n = {})
					var e = void 0 !== n.binary && n.binary,
						i = [],
						r = 0
					t.traverse(function (Se) {
						if (Se.isMesh) {
							var ve = Se.geometry
							if (!0 !== ve.isBufferGeometry)
								throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.")
							var W = ve.index,
								me = ve.getAttribute("position")
							;(r += null !== W ? W.count / 3 : me.count / 3), i.push({ object3d: Se, geometry: ve })
						}
					})
					var o,
						s = 80
					if (!0 === e) {
						var c = new ArrayBuffer(2 * r + 3 * r * 4 * 4 + 80 + 4)
						;(o = new DataView(c)).setUint32(s, r, !0), (s += 4)
					} else (o = ""), (o += "solid exported\n")
					for (
						var l = new K(), d = new K(), u = new K(), h = new K(), f = new K(), _ = new K(), y = 0, C = i.length;
						y < C;
						y++
					) {
						var x = i[y].object3d,
							w = i[y].geometry,
							S = w.index,
							M = w.getAttribute("position")
						if (null !== S) for (var O = 0; O < S.count; O += 3) ae(S.getX(O + 0), S.getX(O + 1), S.getX(O + 2), M, x)
						else for (O = 0; O < M.count; O += 3) ae(O + 0, O + 1, O + 2, M, x)
					}
					return !1 === e && (o += "endsolid exported\n"), o
					function ae(Se, ve, W, me, Z) {
						l.fromBufferAttribute(me, Se),
							d.fromBufferAttribute(me, ve),
							u.fromBufferAttribute(me, W),
							!0 === Z.isSkinnedMesh && (Z.boneTransform(Se, l), Z.boneTransform(ve, d), Z.boneTransform(W, u)),
							l.applyMatrix4(Z.matrixWorld),
							d.applyMatrix4(Z.matrixWorld),
							u.applyMatrix4(Z.matrixWorld),
							(function ce(Se, ve, W) {
								h.subVectors(W, ve),
									f.subVectors(Se, ve),
									h.cross(f).normalize(),
									_.copy(h).normalize(),
									!0 === e
										? (o.setFloat32(s, _.x, !0),
										  o.setFloat32((s += 4), _.y, !0),
										  o.setFloat32((s += 4), _.z, !0),
										  (s += 4))
										: ((o += "\tfacet normal " + _.x + " " + _.y + " " + _.z + "\n"), (o += "\t\touter loop\n"))
							})(l, d, u),
							ue(l),
							ue(d),
							ue(u),
							!0 === e ? (o.setUint16(s, 0, !0), (s += 2)) : ((o += "\t\tendloop\n"), (o += "\tendfacet\n"))
					}
					function ue(Se) {
						!0 === e
							? (o.setFloat32(s, Se.x, !0), o.setFloat32((s += 4), Se.y, !0), o.setFloat32((s += 4), Se.z, !0), (s += 4))
							: (o += "\t\t\tvertex " + Se.x + " " + Se.y + " " + Se.z + "\n")
					}
				}
			}
			let r3e = (() => {
				class t {
					constructor(e, i) {
						;(this.state = e), (this.threeSceneService = i), (this.exporter = new m3())
					}
					downloadStlFile() {
						const e = _u(this.state.getValue()),
							i = Vc(this.state.getValue()).unifiedFileMeta?.fileName,
							r = this.threeSceneService.getMapMesh().getThreeMesh(),
							o = this.exporter.parse(r, { binary: !0 }),
							s = `${pf.getNewFileName(i, ad(e))}.stl`
						TO.downloadData(o, s)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Sr), P(Qc))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-export-threed-map-button"]],
							decls: 1,
							vars: 1,
							consts: [["title", "Download stl file for 3D printing", 3, "icon", "click"]],
							template: function (i, r) {
								1 & i &&
									(F(0, "cc-action-icon", 0),
									Le("click", function () {
										return r.downloadStlFile()
									}),
									L()),
									2 & i && U("icon", "fa fa-cube")
							},
							dependencies: [Vb],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function s3e(t = a3e) {
				return Wt((n, e) => {
					let i = !1
					n.subscribe(
						we(
							e,
							r => {
								;(i = !0), e.next(r)
							},
							() => (i ? e.complete() : e.error(t()))
						)
					)
				})
			}
			function a3e() {
				return new mL()
			}
			const f3e = Mt(_u, t => iG(t)),
				NZ = Mt(Fs, Cb, Af, Aw, (t, n, e, i) =>
					((t, n) => n.every(e => ((t, n) => t.some(e => e.name === n))(t, e)))(t.nodeMetricData, [n, e, i])
				),
				m3e = Mt(cc, t =>
					(t =>
						Object.entries(t).every(([n, e]) =>
							((t, n) =>
								"edgeMetric" === t || (null !== n && ("object" != typeof n || Object.values(n).every(e => null !== e))))(
								n,
								e
							)
						))(t)
				),
				p3e =
					(Mt(Fs, f3e, NZ, m3e, (t, n, e, i) => !(null === t.nodeMetricData || !n || !e || !i)),
					t => (t.some(n => "rloc" === n.name) ? "rloc" : "unary")),
				A3e = ["rloc", "real_lines_of_code", "loc", "lines_of_code", "lines", "statements", "functions"],
				UZ = ["mcc", "cognitive_complexity", "sonar_cognitive_complexity", "max_nesting_level", "indentation_level"]
			function g3e(t) {
				return t.some(n => n.maxValue > 0)
			}
			let v3e = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.resetChosenDistributionMetric$ = yo(
								() =>
									this.store.select(Fs).pipe(
										Ke(i => i.nodeMetricData),
										xi(g3e),
										mu(this.store.select(NZ)),
										xi(([, i]) => !i),
										eo(([i]) => {
											HZ(this.store, i)
										})
									),
								{ dispatch: !1 }
							))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Ct))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			function HZ(t, n) {
				t.dispatch(av({ value: p3e(n) }))
				let [e, i, r] = (function _3e(t) {
					const n = [],
						e = { AreaMetric: A3e, HeightMetric: UZ, ColorMetric: UZ },
						i = new Set(t.map(r => r.name))
					for (const r in e)
						for (const o of e[r])
							if (i.has(o)) {
								n.push(o)
								break
							}
					return n
				})(n)
				;(!e || !i || !r) &&
					([e, i, r] = (function b3e(t, n) {
						const e = []
						let i
						for (const r of t) if (r.maxValue && (e.push(r.name), (i = r.name), 0 == --n)) return e
						if (!i) throw new Error("there are no metrics available")
						for (; n-- > 0; ) e.push(i)
						return e
					})(n, 3)),
					t.dispatch(gu({ value: e })),
					t.dispatch(bu({ value: i })),
					t.dispatch(hl({ value: r }))
			}
			let y3e = (() => {
					class t {
						constructor(e, i, r, o) {
							;(this.store = e),
								(this.httpClient = i),
								(this.loadFileService = r),
								(this.loadInitialFileService = o),
								(this.urlUtils = new J$(this.httpClient))
						}
						resetMap() {
							var e = this
							return _r(function* () {
								if (
									(yield (function cme() {
										return gD.apply(this, arguments)
									})(),
									e.store.dispatch(Sp({ value: oq })),
									e.loadInitialFileService.checkFileQueryParameterPresent())
								)
									try {
										const r = yield e.urlUtils.getFileDataFromQueryParam()
										e.loadFileService.loadFiles(r), e.loadInitialFileService.setRenderStateFromUrl()
									} catch {
										e.loadFileService.loadFiles([lM, dM])
									}
								else e.loadFileService.loadFiles([lM, dM])
								e.resetMetrics()
							})()
						}
						resetMetrics() {
							this.store
								.select(Fs)
								.pipe(
									(function c3e(t, n) {
										const e = arguments.length >= 2
										return i =>
											i.pipe(
												t ? xi((r, o) => t(r, o, i)) : Re,
												Do(1),
												e
													? (function o3e(t) {
															return Wt((n, e) => {
																let i = !1
																n.subscribe(
																	we(
																		e,
																		r => {
																			;(i = !0), e.next(r)
																		},
																		() => {
																			i || e.next(t), e.complete()
																		}
																	)
																)
															})
													  })(n)
													: s3e(() => new mL())
											)
									})(),
									eo(e => {
										HZ(this.store, e.nodeMetricData)
									})
								)
								.subscribe()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct), P(J2), P(wg), P(WL))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["ng-component"]],
								decls: 12,
								vars: 0,
								consts: [
									["xmlns", "http://www.w3.org/1999/html", 1, "header"],
									[1, "dialog-content"],
									["mat-button", "", "mat-dialog-close", ""],
									["mat-button", "", "mat-dialog-close", "", "cdkFocusInitial", "", 3, "click"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "mat-toolbar", 0)(1, "h2"),
										ge(2, "Confirm reset map to default"),
										L()(),
										F(3, "mat-dialog-content")(4, "div", 1)(5, "p"),
										ge(6, "Uploaded maps, selected metrics and settings are reset to default"),
										L()()(),
										F(7, "mat-dialog-actions")(8, "button", 2),
										ge(9, "No"),
										L(),
										F(10, "button", 3),
										Le("click", function () {
											return r.resetMap()
										}),
										ge(11, "Yes"),
										L()())
								},
								dependencies: [Qs, md, Hm, Vm, Mb],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}.cc-confirm-reset-map-dialog .mat-mdc-dialog-container{padding:0;width:500px;overflow:hidden}.cc-confirm-reset-map-dialog .mat-mdc-dialog-container mat-toolbar.header{background-color:#1b9cfc}.cc-confirm-reset-map-dialog .mat-mdc-dialog-container mat-toolbar.header h2{color:#fff}.cc-confirm-reset-map-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions{margin:0;padding:0 8px;position:relative;display:flex;justify-content:right}.cc-confirm-reset-map-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions .mat-mdc-button{padding:0 8px;margin:8px 0 8px 8px;color:#1b9cfc;background-color:#8a848414;bottom:0}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				w3e = (() => {
					class t {
						constructor(e) {
							this.dialog = e
						}
						showConfirmResetStateDialog() {
							this.dialog.open(y3e, { panelClass: "cc-confirm-reset-map-dialog" })
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(la))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-reset-map-button"]],
								decls: 1,
								vars: 1,
								consts: [["title", "Reset map to default", 3, "icon", "click"]],
								template: function (i, r) {
									1 & i &&
										(F(0, "cc-action-icon", 0),
										Le("click", function () {
											return r.showConfirmResetStateDialog()
										}),
										L()),
										2 & i && U("icon", "fa fa-undo")
								},
								dependencies: [Vb],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const x3e = Mt(vb, t => `linear-gradient(${t.positiveDelta} 50%, ${t.negativeDelta} 50%)`)
			function C3e(t, n) {
				if ((1 & t && (F(0, "mat-option", 7), ge(1), Me(2, "removeExtension"), L()), 2 & t)) {
					const e = n.$implicit
					U("value", e.file), T(1), Vt(" ", De(2, 2, e.file.fileMeta.fileName), " ")
				}
			}
			function E3e(t, n) {
				if ((1 & t && (F(0, "mat-option", 7), ge(1), Me(2, "removeExtension"), L()), 2 & t)) {
					const e = n.$implicit
					U("value", e.file), T(1), Vt(" ", De(2, 2, e.file.fileMeta.fileName), " ")
				}
			}
			let M3e = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.files$ = this.store.select(_u)),
								(this.referenceFile$ = this.store.select(F9)),
								(this.comparisonFile$ = this.files$.pipe(Ke(i => i.find(r => r.selectedAs === Fi.Comparison)?.file))),
								(this.possibleComparisonFiles$ = this.files$.pipe(Ke(i => i.filter(r => r.selectedAs !== Fi.Reference)))),
								(this.pictogramBackground$ = this.store.select(x3e))
						}
						handleDeltaReferenceFileChange(e) {
							this.store.dispatch(TD({ file: e }))
						}
						handleDeltaComparisonFileChange(e) {
							this.store.dispatch(kD({ file: e }))
						}
						switchReferenceAndComparison() {
							this.store.dispatch(SD())
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-file-panel-delta-selector"]],
								decls: 14,
								vars: 19,
								consts: [
									[1, "delta-select-wrapper"],
									[1, "delta-select", 3, "value", "selectionChange"],
									[3, "value", 4, "ngFor", "ngForOf"],
									[
										"title",
										"Switch reference and comparison file",
										1,
										"reference-comparison-switch",
										3,
										"disabled",
										"click"
									],
									[1, "fa", "fa-arrows-h"],
									["placeholder", "select comparison file", 1, "delta-select", 3, "value", "selectionChange"],
									[1, "pictogram"],
									[3, "value"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div", 0)(1, "mat-select", 1),
										Le("selectionChange", function (s) {
											return r.handleDeltaReferenceFileChange(s.value)
										}),
										Me(2, "async"),
										Ee(3, C3e, 3, 4, "mat-option", 2),
										Me(4, "async"),
										L(),
										F(5, "button", 3),
										Le("click", function () {
											return r.switchReferenceAndComparison()
										}),
										Me(6, "async"),
										fe(7, "i", 4),
										L(),
										F(8, "mat-select", 5),
										Le("selectionChange", function (s) {
											return r.handleDeltaComparisonFileChange(s.value)
										}),
										Me(9, "async"),
										Ee(10, E3e, 3, 4, "mat-option", 2),
										Me(11, "async"),
										L(),
										F(12, "div", 6),
										Me(13, "async"),
										L()()),
										2 & i &&
											(T(1),
											U("value", De(2, 7, r.referenceFile$)),
											T(2),
											U("ngForOf", De(4, 9, r.files$)),
											T(2),
											U("disabled", void 0 === De(6, 11, r.comparisonFile$)),
											T(3),
											U("value", De(9, 13, r.comparisonFile$)),
											T(2),
											U("ngForOf", De(11, 15, r.possibleComparisonFiles$)),
											T(2),
											bi("background", De(13, 17, r.pictogramBackground$)))
								},
								dependencies: [_o, Fp, Qh, Bn, oO],
								styles: ["cc-file-panel-delta-selector .delta-select-wrapper{display:flex;gap:12px}\n"],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				S3e = (() => {
					class t {
						constructor(e) {
							this.store = e
						}
						onRemoveFile(e, i) {
							this.store.dispatch(xD({ fileName: e })), i.stopPropagation(), i.preventDefault()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-remove-file-button"]],
								inputs: { filename: "filename" },
								decls: 2,
								vars: 0,
								consts: [
									["title", "Remove map", 1, "remove-button", 3, "click"],
									[1, "fa", "fa-trash", "delete-symbol"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function (s) {
											return r.onRemoveFile(r.filename, s)
										}),
										fe(1, "i", 1),
										L())
								},
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function k3e(t, n) {
				1 & t && fe(0, "cc-remove-file-button", 6), 2 & t && U("filename", Te().$implicit.file.fileMeta.fileName)
			}
			function T3e(t, n) {
				if (
					(1 & t && (F(0, "mat-option", 4), ge(1), Me(2, "removeExtension"), Ee(3, k3e, 1, 1, "cc-remove-file-button", 5), L()),
					2 & t)
				) {
					const e = n.$implicit,
						i = Te()
					U("value", e.file), T(1), Vt(" ", De(2, 3, e.file.fileMeta.fileName), " "), T(2), U("ngIf", i.fileStates.length > 1)
				}
			}
			let F3e = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.fileStates = []),
							(this.selectedFilesInUI = []),
							(this.selectedFilesInStore = []),
							(this.filesSubscription = this.store.select(_u).subscribe(i => {
								;(this.fileStates = i),
									(this.selectedFilesInStore = i.filter(r => r.selectedAs === Fi.Partial).map(r => r.file)),
									(this.selectedFilesInUI = this.selectedFilesInStore)
							}))
					}
					ngOnDestroy() {
						this.filesSubscription.unsubscribe()
					}
					handleSelectedFilesChanged(e) {
						;(this.selectedFilesInUI = e), e.length > 0 && this.store.dispatch(pv({ files: e }))
					}
					handleOpenedChanged(e) {
						e || (this.selectedFilesInUI = this.selectedFilesInStore)
					}
					handleSelectZeroFiles() {
						this.selectedFilesInUI = []
					}
					handleInvertSelectedFiles() {
						this.selectedFilesInUI.length === this.fileStates.length ? (this.selectedFilesInUI = []) : this.store.dispatch(MD())
					}
					handleSelectAllFiles() {
						this.store.dispatch(ED())
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-file-panel-file-selector"]],
							decls: 9,
							vars: 2,
							consts: [
								[
									"panelClass",
									"file-select",
									"multiple",
									"",
									1,
									"standard-select",
									3,
									"value",
									"valueChange",
									"selectionChange",
									"openedChange"
								],
								[1, "file-selection-actions"],
								[1, "file-select-action-button", 3, "click"],
								["class", "filenames", 3, "value", 4, "ngFor", "ngForOf"],
								[1, "filenames", 3, "value"],
								[3, "filename", 4, "ngIf"],
								[3, "filename"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-select", 0),
									Le("valueChange", function (s) {
										return (r.selectedFilesInUI = s)
									})("selectionChange", function (s) {
										return r.handleSelectedFilesChanged(s.value)
									})("openedChange", function (s) {
										return r.handleOpenedChanged(s)
									}),
									F(1, "div", 1)(2, "button", 2),
									Le("click", function () {
										return r.handleSelectAllFiles()
									}),
									ge(3, "All"),
									L(),
									F(4, "button", 2),
									Le("click", function () {
										return r.handleSelectZeroFiles()
									}),
									ge(5, "None"),
									L(),
									F(6, "button", 2),
									Le("click", function () {
										return r.handleInvertSelectedFiles()
									}),
									ge(7, "Invert"),
									L()(),
									Ee(8, T3e, 4, 5, "mat-option", 3),
									L()),
									2 & i && (U("value", r.selectedFilesInUI), T(8), U("ngForOf", r.fileStates))
							},
							dependencies: [_o, En, Fp, Qh, S3e, oO],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}.file-select.mat-mdc-select-panel{min-width:max-content;padding:0}.file-select.mat-mdc-select-panel .mat-mdc-option .mdc-list-item__primary-text{flex:1;display:flex;justify-content:space-between;align-items:center}.file-select.mat-mdc-select-panel .file-selection-actions{display:flex}.file-select.mat-mdc-select-panel button{width:100%;font-size:16px;margin:0;background-color:transparent}.file-select.mat-mdc-select-panel button:hover{background-color:#0000000d;color:#1b9cfc}.file-select.mat-mdc-select-panel button.file-select-action-button{padding:15px 10px}.file-select.mat-mdc-select-panel button.remove-button{padding:8px 10px}.file-select.mat-mdc-select-panel button.remove-button:hover{border-radius:50%}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function VZ() {
				return Wt((t, n) => {
					let e,
						i = !1
					t.subscribe(
						we(n, r => {
							const o = e
							;(e = r), i && n.next([o, r]), (i = !0)
						})
					)
				})
			}
			let QZ = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e),
								(this.state = i),
								(this.lastSetFilesOfPreviousMode = []),
								(this.subscription = this.store
									.select(_u)
									.pipe(
										VZ(),
										xi(([r, o]) => ad(r) !== ad(o) || 0 === o.length),
										eo(([r, o]) => {
											this.lastSetFilesOfPreviousMode = 0 === o.length ? o : r
										})
									)
									.subscribe())
						}
						ngOnDestroy() {
							this.subscription.unsubscribe()
						}
						toggle() {
							if (0 === this.lastSetFilesOfPreviousMode.length || ad(this.lastSetFilesOfPreviousMode)) {
								const i = _u(this.state.getValue())
								this.lastSetFilesOfPreviousMode = this.filterNoneExisting(i, this.lastSetFilesOfPreviousMode)
								const r =
										this.lastSetFilesOfPreviousMode.find(s => s.selectedAs === Fi.Reference) ??
										i.find(s => s.selectedAs === Fi.Partial),
									o = this.lastSetFilesOfPreviousMode.find(s => s.selectedAs === Fi.Comparison)
								this.store.dispatch(CE({ referenceFile: r.file, comparisonFile: o?.file }))
							} else this.store.dispatch(mv({ value: this.lastSetFilesOfPreviousMode }))
						}
						filterNoneExisting(e, i) {
							return i.filter(r => e.find(o => AE(o.file, r.file)))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(Sr))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				B3e = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e), (this.fileSelectionModeService = i), (this.isDeltaState$ = this.store.select(_f))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct), P(QZ))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-file-panel-state-buttons"]],
								decls: 11,
								vars: 14,
								consts: [
									["mat-button", "", 1, "state-selector-button", "mode-selector", "left", 3, "disabled", "click"],
									[1, "text"],
									["mat-button", "", 1, "state-selector-button", "mode-selector", "right", 3, "disabled", "click"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div")(1, "button", 0),
										Le("click", function () {
											return r.fileSelectionModeService.toggle()
										}),
										Me(2, "async"),
										Me(3, "async"),
										F(4, "span", 1),
										ge(5, "Standard"),
										L()(),
										F(6, "button", 2),
										Le("click", function () {
											return r.fileSelectionModeService.toggle()
										}),
										Me(7, "async"),
										Me(8, "async"),
										F(9, "span", 1),
										ge(10, "Delta"),
										L()()()),
										2 & i &&
											(T(1),
											Zt("current", !De(2, 6, r.isDeltaState$)),
											U("disabled", !De(3, 8, r.isDeltaState$)),
											T(5),
											Zt("current", De(7, 10, r.isDeltaState$)),
											U("disabled", De(8, 12, r.isDeltaState$)))
								},
								dependencies: [Qs, Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function I3e(t, n) {
				1 & t && fe(0, "cc-file-panel-file-selector")
			}
			function D3e(t, n) {
				1 & t && fe(0, "cc-file-panel-delta-selector")
			}
			let L3e = (() => {
				class t {
					constructor(e) {
						;(this.store = e), (this.isDeltaState$ = this.store.select(_f))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-file-panel"]],
							decls: 5,
							vars: 6,
							consts: [[4, "ngIf"]],
							template: function (i, r) {
								1 & i &&
									(fe(0, "cc-file-panel-state-buttons"),
									Ee(1, I3e, 1, 0, "cc-file-panel-file-selector", 0),
									Me(2, "async"),
									Ee(3, D3e, 1, 0, "cc-file-panel-delta-selector", 0),
									Me(4, "async")),
									2 & i && (T(1), U("ngIf", !De(2, 2, r.isDeltaState$)), T(2), U("ngIf", De(4, 4, r.isDeltaState$)))
							},
							dependencies: [En, M3e, F3e, B3e, Bn],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-file-panel{display:flex;gap:inherit}cc-file-panel.hidden{display:none}cc-file-panel .state-selector-button.mode-selector{height:24px;width:66px;background-color:#fff}cc-file-panel .state-selector-button.mode-selector.middle{border-left:1px solid rgba(230,230,230,.96);border-right:1px solid rgba(230,230,230,.96)}cc-file-panel .state-selector-button.mode-selector.current{background-color:#1b9cfc;color:#fff}cc-file-panel .state-selector-button.mode-selector.current:hover{background-color:#1b9cfc}cc-file-panel .reference-comparison-switch{background-color:#1b9cfc;margin:0;height:24px;width:36px;border-radius:5px}cc-file-panel .reference-comparison-switch[disabled]{background-color:#ccc}cc-file-panel .reference-comparison-switch:hover{background-color:#0374c9}cc-file-panel .reference-comparison-switch:hover[disabled]{background-color:#ccc}cc-file-panel .reference-comparison-switch .fa{vertical-align:middle;color:#fff}cc-file-panel .pictogram{display:inline-flex;width:10px;margin-right:5px;margin-left:5px;height:22px;border-radius:2px;align-self:center;vertical-align:bottom}cc-file-panel .standard-select,cc-file-panel .delta-select{width:200px}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const R3e = Mt(wY, t => t && { path: t.path.slice(1).split("/"), isFile: "File" === t.type })
			function P3e(t, n) {
				if ((1 & t && fe(0, "i", 4), 2 & t)) {
					const e = Te(2).$implicit
					Zt("fa-file-o", e.isFile)("fa-folder", !e.isFile)
				}
			}
			function O3e(t, n) {
				1 & t && fe(0, "i", 5)
			}
			function N3e(t, n) {
				if ((1 & t && (F(0, "span"), Ee(1, P3e, 1, 4, "i", 2), F(2, "span"), ge(3), L(), Ee(4, O3e, 1, 0, "i", 3), L()), 2 & t)) {
					const e = n.$implicit,
						i = n.last
					T(1), U("ngIf", i), T(1), Zt("bold", i), T(1), cr(e), T(1), U("ngIf", !i)
				}
			}
			function U3e(t, n) {
				if ((1 & t && (Cr(0), Ee(1, N3e, 5, 5, "span", 1), Er()), 2 & t)) {
					const e = n.$implicit
					T(1), U("ngForOf", e.path)
				}
			}
			let H3e = (() => {
				class t {
					constructor(e) {
						;(this.store = e), (this.hoveredNodePathPanelData$ = this.store.select(R3e))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-hovered-node-path-panel"]],
							decls: 2,
							vars: 3,
							consts: [
								[4, "ngIf"],
								[4, "ngFor", "ngForOf"],
								["class", "fa", 3, "fa-file-o", "fa-folder", 4, "ngIf"],
								["class", "fa fa-angle-right", 4, "ngIf"],
								[1, "fa"],
								[1, "fa", "fa-angle-right"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, U3e, 2, 1, "ng-container", 0), Me(1, "async")),
									2 & i && U("ngIf", De(1, 1, r.hoveredNodePathPanelData$))
							},
							dependencies: [_o, En, Bn],
							styles: [
								"cc-hovered-node-path-panel{width:100%;min-width:400px;display:inline-block;vertical-align:middle;margin:0 8px;font-size:10pt;overflow:hidden;white-space:nowrap}cc-hovered-node-path-panel .bold{font-weight:600}cc-hovered-node-path-panel i{margin:0 4px}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const V3e = Mt(Tr, t => t.isLoadingMap),
				Q3e = ["determinateSpinner"]
			function z3e(t, n) {
				if ((1 & t && (Xa(), F(0, "svg", 11), fe(1, "circle", 12), L()), 2 & t)) {
					const e = Te()
					qn("viewBox", e._viewBox()),
						T(1),
						bi("stroke-dasharray", e._strokeCircumference(), "px")("stroke-dashoffset", e._strokeCircumference() / 2, "px")(
							"stroke-width",
							e._circleStrokeWidth(),
							"%"
						),
						qn("r", e._circleRadius())
				}
			}
			const G3e = _g(
					class {
						constructor(t) {
							this._elementRef = t
						}
					},
					"primary"
				),
				$3e = new He("mat-progress-spinner-default-options", {
					providedIn: "root",
					factory: function W3e() {
						return { diameter: zZ }
					}
				}),
				zZ = 100
			let GZ = (() => {
					class t extends G3e {
						constructor(e, i, r) {
							super(e),
								(this.mode =
									"mat-spinner" === this._elementRef.nativeElement.nodeName.toLowerCase()
										? "indeterminate"
										: "determinate"),
								(this._value = 0),
								(this._diameter = zZ),
								(this._noopAnimations = "NoopAnimations" === i && !!r && !r._forceAnimations),
								r &&
									(r.color && (this.color = this.defaultColor = r.color),
									r.diameter && (this.diameter = r.diameter),
									r.strokeWidth && (this.strokeWidth = r.strokeWidth))
						}
						get value() {
							return "determinate" === this.mode ? this._value : 0
						}
						set value(e) {
							this._value = Math.max(0, Math.min(100, to(e)))
						}
						get diameter() {
							return this._diameter
						}
						set diameter(e) {
							this._diameter = to(e)
						}
						get strokeWidth() {
							return this._strokeWidth ?? this.diameter / 10
						}
						set strokeWidth(e) {
							this._strokeWidth = to(e)
						}
						_circleRadius() {
							return (this.diameter - 10) / 2
						}
						_viewBox() {
							const e = 2 * this._circleRadius() + this.strokeWidth
							return `0 0 ${e} ${e}`
						}
						_strokeCircumference() {
							return 2 * Math.PI * this._circleRadius()
						}
						_strokeDashOffset() {
							return "determinate" === this.mode ? (this._strokeCircumference() * (100 - this._value)) / 100 : null
						}
						_circleStrokeWidth() {
							return (this.strokeWidth / this.diameter) * 100
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(Bo, 8), P($3e))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-progress-spinner"], ["mat-spinner"]],
								viewQuery: function (i, r) {
									if ((1 & i && _i(Q3e, 5), 2 & i)) {
										let o
										sn((o = an())) && (r._determinateCircle = o.first)
									}
								},
								hostAttrs: [
									"role",
									"progressbar",
									"tabindex",
									"-1",
									1,
									"mat-mdc-progress-spinner",
									"mdc-circular-progress"
								],
								hostVars: 16,
								hostBindings: function (i, r) {
									2 & i &&
										(qn("aria-valuemin", 0)("aria-valuemax", 100)(
											"aria-valuenow",
											"determinate" === r.mode ? r.value : null
										)("mode", r.mode),
										bi("width", r.diameter, "px")("height", r.diameter, "px")(
											"--mdc-circular-progress-size",
											r.diameter + "px"
										)("--mdc-circular-progress-active-indicator-width", r.diameter + "px"),
										Zt("_mat-animation-noopable", r._noopAnimations)(
											"mdc-circular-progress--indeterminate",
											"indeterminate" === r.mode
										))
								},
								inputs: { color: "color", mode: "mode", value: "value", diameter: "diameter", strokeWidth: "strokeWidth" },
								exportAs: ["matProgressSpinner"],
								features: [pn],
								decls: 14,
								vars: 11,
								consts: [
									["circle", ""],
									["aria-hidden", "true", 1, "mdc-circular-progress__determinate-container"],
									["determinateSpinner", ""],
									[
										"xmlns",
										"http://www.w3.org/2000/svg",
										"focusable",
										"false",
										1,
										"mdc-circular-progress__determinate-circle-graphic"
									],
									["cx", "50%", "cy", "50%", 1, "mdc-circular-progress__determinate-circle"],
									["aria-hidden", "true", 1, "mdc-circular-progress__indeterminate-container"],
									[1, "mdc-circular-progress__spinner-layer"],
									[1, "mdc-circular-progress__circle-clipper", "mdc-circular-progress__circle-left"],
									[3, "ngTemplateOutlet"],
									[1, "mdc-circular-progress__gap-patch"],
									[1, "mdc-circular-progress__circle-clipper", "mdc-circular-progress__circle-right"],
									[
										"xmlns",
										"http://www.w3.org/2000/svg",
										"focusable",
										"false",
										1,
										"mdc-circular-progress__indeterminate-circle-graphic"
									],
									["cx", "50%", "cy", "50%"]
								],
								template: function (i, r) {
									if (
										(1 & i &&
											(Ee(0, z3e, 2, 8, "ng-template", null, 0, oa),
											F(2, "div", 1, 2),
											Xa(),
											F(4, "svg", 3),
											fe(5, "circle", 4),
											L()(),
											ph(),
											F(6, "div", 5)(7, "div", 6)(8, "div", 7),
											qA(9, 8),
											L(),
											F(10, "div", 9),
											qA(11, 8),
											L(),
											F(12, "div", 10),
											qA(13, 8),
											L()()()),
										2 & i)
									) {
										const o = br(1)
										T(4),
											qn("viewBox", r._viewBox()),
											T(1),
											bi("stroke-dasharray", r._strokeCircumference(), "px")(
												"stroke-dashoffset",
												r._strokeDashOffset(),
												"px"
											)("stroke-width", r._circleStrokeWidth(), "%"),
											qn("r", r._circleRadius()),
											T(4),
											U("ngTemplateOutlet", o),
											T(2),
											U("ngTemplateOutlet", o),
											T(2),
											U("ngTemplateOutlet", o)
									}
								},
								dependencies: [x0],
								styles: [
									"@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-color-1-fade-in-out{from{opacity:.99}25%{opacity:.99}26%{opacity:0}89%{opacity:0}90%{opacity:.99}to{opacity:.99}}@keyframes mdc-circular-progress-color-2-fade-in-out{from{opacity:0}15%{opacity:0}25%{opacity:.99}50%{opacity:.99}51%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-3-fade-in-out{from{opacity:0}40%{opacity:0}50%{opacity:.99}75%{opacity:.99}76%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-4-fade-in-out{from{opacity:0}65%{opacity:0}75%{opacity:.99}90%{opacity:.99}to{opacity:0}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}.mdc-circular-progress{display:inline-flex;position:relative;direction:ltr;line-height:0;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-1{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-1-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-2{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-2-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-3{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-3-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-4{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-4-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--closed{opacity:0}.mat-mdc-progress-spinner{--mdc-circular-progress-active-indicator-width:4px;--mdc-circular-progress-size:48px}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mat-mdc-progress-spinner circle{stroke-width:var(--mdc-circular-progress-active-indicator-width)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-1 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-2 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-3 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-4 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mat-mdc-progress-spinner .mdc-circular-progress{width:var(--mdc-circular-progress-size) !important;height:var(--mdc-circular-progress-size) !important}.mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}"
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				$Z = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Yi] })
						}
					}
					return t
				})(),
				K3e = (() => {
					class t {
						constructor(e) {
							this.isLoadingMap$ = e.select(V3e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-loading-map-progress-spinner"]],
								decls: 2,
								vars: 4,
								consts: [["id", "loading-gif-map", "mode", "indeterminate", "diameter", "22", "title", "Rendering map"]],
								template: function (i, r) {
									1 & i && (fe(0, "mat-progress-spinner", 0), Me(1, "async")),
										2 & i && bi("visibility", De(1, 2, r.isLoadingMap$) ? "visible" : "hidden")
								},
								dependencies: [GZ, Bn],
								styles: ["cc-loading-map-progress-spinner{display:inline-block;vertical-align:middle}\n"],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const X3e = Mt(Tr, t => t.isPresentationMode)
			let Y3e = (() => {
				class t {
					constructor(e) {
						;(this.store = e), (this.isPresentationModeEnabled$ = this.store.select(X3e))
					}
					setPresentationModeEnabled(e) {
						this.store.dispatch(nE({ value: e.checked }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-presentation-mode-button"]],
							decls: 5,
							vars: 6,
							consts: [
								["aria-label", "Presentation Mode Toggle", 3, "checked", "title", "change"],
								[1, "presentation-mode-icon", "fa", "fa-television"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-slide-toggle", 0),
									Le("change", function (s) {
										return r.setPresentationModeEnabled(s)
									}),
									Me(1, "async"),
									Me(2, "async"),
									fe(3, "i", 1),
									ge(4, " Presentation Mode\n"),
									L()),
									2 & i &&
										U("checked", De(1, 2, r.isPresentationModeEnabled$))(
											"title",
											De(2, 4, r.isPresentationModeEnabled$)
												? "Disable flashlight hover effect"
												: "Enable flashlight hover effect"
										)
							},
							dependencies: [sk, Bn],
							styles: [
								"cc-presentation-mode-button mat-slide-toggle.mat-mdc-slide-toggle div.mdc-form-field{font-size:10pt;flex-direction:row-reverse;gap:12px}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const q3e = Mt(Tr, t => t.hideFlatBuildings),
				WZ = Mt(Tr, t => t.resetCameraIfNewFileIsLoaded),
				jZ = Mt(Tr, t => t.layoutAlgorithm),
				Z3e = Mt(Tr, t => t.maxTreeMapFiles)
			function J3e(t, n) {
				if ((1 & t && (F(0, "mat-option", 4), ge(1), L()), 2 & t)) {
					const e = n.$implicit
					U("value", e), T(1), Vt(" ", e, " ")
				}
			}
			function eUe(t, n) {
				if ((1 & t && (fe(0, "cc-slider", 5), Me(1, "async")), 2 & t)) {
					const e = Te()
					U("label", "Maximum TreeMap Files")("min", 1)("max", 1e3)("value", De(1, 5, e.maxTreeMapFiles$))(
						"onChange",
						e.handleChangeMaxTreeMapFiles
					)
				}
			}
			let tUe = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.layoutAlgorithms = Object.values(Ad)),
							(this.layoutAlgorithm$ = this.store.select(jZ)),
							(this.maxTreeMapFiles$ = this.store.select(Z3e)),
							(this.handleChangeMaxTreeMapFiles = Fd(i => {
								this.store.dispatch(ev({ value: i }))
							}, 400))
					}
					handleSelectedLayoutAlgorithmChanged(e) {
						this.store.dispatch(J0({ value: e.value }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-map-layout-selection"]],
							decls: 8,
							vars: 7,
							consts: [
								["appearance", "outline"],
								[3, "value", "selectionChange"],
								[3, "value", 4, "ngFor", "ngForOf"],
								["class", "cc-tree-maps-max-tree-map-files", 3, "label", "min", "max", "value", "onChange", 4, "ngIf"],
								[3, "value"],
								[1, "cc-tree-maps-max-tree-map-files", 3, "label", "min", "max", "value", "onChange"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-form-field", 0)(1, "mat-label"),
									ge(2, "Map Layout"),
									L(),
									F(3, "mat-select", 1),
									Le("selectionChange", function (s) {
										return r.handleSelectedLayoutAlgorithmChanged(s)
									}),
									Me(4, "async"),
									Ee(5, J3e, 2, 2, "mat-option", 2),
									L()(),
									Ee(6, eUe, 2, 7, "cc-slider", 3),
									Me(7, "async")),
									2 & i &&
										(T(3),
										U("value", De(4, 3, r.layoutAlgorithm$)),
										T(2),
										U("ngForOf", r.layoutAlgorithms),
										T(1),
										U("ngIf", "TreeMapStreet" === De(7, 5, r.layoutAlgorithm$)))
							},
							dependencies: [_o, En, Bd, yf, Fp, Qh, mk, Bn],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function nUe(t, n) {
				if ((1 & t && (F(0, "mat-option", 3), ge(1), L()), 2 & t)) {
					const e = n.$implicit
					U("value", e), T(1), Vt(" ", e, " ")
				}
			}
			let iUe = (() => {
				class t {
					constructor(e) {
						;(this.store = e), (this.sharpnessModes = Object.values(Qm)), (this.sharpnessMode$ = this.store.select(eW))
					}
					handleSelectedSharpnessModeChanged(e) {
						this.store.dispatch(nv({ value: e.value }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-display-quality-selection"]],
							decls: 6,
							vars: 4,
							consts: [
								["appearance", "outline"],
								[3, "value", "selectionChange"],
								[3, "value", 4, "ngFor", "ngForOf"],
								[3, "value"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-form-field", 0)(1, "mat-label"),
									ge(2, "Display Quality"),
									L(),
									F(3, "mat-select", 1),
									Le("selectionChange", function (s) {
										return r.handleSelectedSharpnessModeChanged(s)
									}),
									Me(4, "async"),
									Ee(5, nUe, 2, 2, "mat-option", 2),
									L()()),
									2 & i && (T(3), U("value", De(4, 2, r.sharpnessMode$)), T(2), U("ngForOf", r.sharpnessModes))
							},
							dependencies: [_o, Bd, yf, Fp, Qh, Bn],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const rUe = function () {
				return [
					"appSettings.hideFlatBuildings",
					"appSettings.isWhiteBackground",
					"appSettings.resetCameraIfNewFileIsLoaded",
					"appSettings.layoutAlgorithm",
					"appSettings.maxTreeMapFiles"
				]
			}
			let oUe = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.screenshotToClipboardEnabled$ = this.store.select(PZ)),
								(this.experimentalFeaturesEnabled$ = this.store.select(vO)),
								(this.isWhiteBackground$ = this.store.select(rX)),
								(this.hideFlatBuildings$ = this.store.select(q3e)),
								(this.resetCameraIfNewFileIsLoaded$ = this.store.select(WZ))
						}
						handleResetCameraIfNewFileIsLoadedChanged(e) {
							this.store.dispatch(oE({ value: e.checked }))
						}
						handleHideFlatBuildingsChanged(e) {
							this.store.dispatch(X0({ value: e.checked }))
						}
						handleIsWhiteBackgroundChanged(e) {
							this.store.dispatch(Z0({ value: e.checked }))
						}
						handleExperimentalFeaturesEnabledChanged(e) {
							this.store.dispatch(eE({ value: e.checked }))
						}
						handleScreenshotToClipboardEnabledChanged(e) {
							this.store.dispatch(JC({ value: e.checked }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["ng-component"]],
								decls: 36,
								vars: 17,
								consts: [
									["color", "primary"],
									[1, "cc-global-configuration-dialog-content"],
									[1, "cc-global-configuration-align-right"],
									[1, "cc-global-configuration-toggle-option"],
									[3, "checked", "change"],
									[
										"tooltip",
										"Reset global settings to their defaults",
										"label",
										"Reset global settings",
										3,
										"settingsKeys"
									],
									[1, "cc-global-configuration-links-list"],
									[
										"href",
										"https://github.com/MaibornWolff/codecharta/blob/main/README.md",
										"target",
										"_blank",
										"rel",
										"noopener noreferrer",
										1,
										"weblink"
									],
									[1, "fa", "fa-external-link", "icon-link"],
									[
										"href",
										"https://github.com/MaibornWolff/codecharta/",
										"target",
										"_blank",
										"rel",
										"noopener noreferrer",
										1,
										"weblink"
									],
									[
										"href",
										"https://github.com/MaibornWolff/codecharta/wiki",
										"target",
										"_blank",
										"rel",
										"noopener noreferrer",
										1,
										"weblink"
									],
									["align", "end"],
									["mat-button", "", "mat-dialog-close", "", "cdkFocusInitial", ""]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "mat-toolbar", 0),
										ge(1, "Global Configuration"),
										L(),
										F(2, "div", 1),
										fe(3, "div", 2)(4, "cc-map-layout-selection")(5, "cc-display-quality-selection"),
										F(6, "div", 3)(7, "mat-slide-toggle", 4),
										Le("change", function (s) {
											return r.handleHideFlatBuildingsChanged(s)
										}),
										Me(8, "async"),
										ge(9, " Hide Flattened Buildings "),
										L(),
										F(10, "mat-slide-toggle", 4),
										Le("change", function (s) {
											return r.handleResetCameraIfNewFileIsLoadedChanged(s)
										}),
										Me(11, "async"),
										ge(12, " Reset Camera when changing map "),
										L(),
										F(13, "mat-slide-toggle", 4),
										Le("change", function (s) {
											return r.handleIsWhiteBackgroundChanged(s)
										}),
										Me(14, "async"),
										ge(15, " White Background "),
										L(),
										F(16, "mat-slide-toggle", 4),
										Le("change", function (s) {
											return r.handleExperimentalFeaturesEnabledChanged(s)
										}),
										Me(17, "async"),
										ge(18, " Enable Experimental Features "),
										L(),
										F(19, "mat-slide-toggle", 4),
										Le("change", function (s) {
											return r.handleScreenshotToClipboardEnabledChanged(s)
										}),
										Me(20, "async"),
										ge(21, " Screenshot to clipboard "),
										L()(),
										fe(22, "cc-reset-settings-button", 5),
										F(23, "div", 6)(24, "a", 7),
										fe(25, "em", 8),
										ge(26, "How-to "),
										L(),
										F(27, "a", 9),
										fe(28, "em", 8),
										ge(29, "Github "),
										L(),
										F(30, "a", 10),
										fe(31, "em", 8),
										ge(32, "Wiki "),
										L()(),
										F(33, "mat-dialog-actions", 11)(34, "button", 12),
										ge(35, "Close"),
										L()()()),
										2 & i &&
											(T(7),
											U("checked", De(8, 6, r.hideFlatBuildings$)),
											T(3),
											U("checked", De(11, 8, r.resetCameraIfNewFileIsLoaded$)),
											T(3),
											U("checked", De(14, 10, r.isWhiteBackground$)),
											T(3),
											U("checked", De(17, 12, r.experimentalFeaturesEnabled$)),
											T(3),
											U("checked", De(20, 14, r.screenshotToClipboardEnabled$)),
											T(3),
											U("settingsKeys", kh(16, rUe)))
								},
								dependencies: [Qs, md, Vm, Mb, sk, kw, tUe, iUe, Bn],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				sUe = (() => {
					class t {
						constructor(e) {
							this.dialog = e
						}
						showGlobalConfiguration() {
							this.dialog.open(oUe, { panelClass: "cc-global-configuration-dialog" })
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(la))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-global-configuration-button"]],
								decls: 4,
								vars: 1,
								consts: [
									["mat-button", "", "title", "Global Configuration", 3, "click"],
									[3, "icon"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.showGlobalConfiguration()
										}),
										F(1, "span"),
										ge(2, "Global Configuration"),
										L(),
										fe(3, "cc-action-icon", 1),
										L()),
										2 & i && (T(3), U("icon", "fa fa-cog"))
								},
								dependencies: [Qs, Vb],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-global-configuration-button button{margin:0;padding:0}cc-global-configuration-button button cc-action-icon{margin-left:12px}cc-global-configuration-button button:hover cc-action-icon{background-color:#0374c9}.cc-global-configuration-dialog .mat-mdc-dialog-container{width:36vw;min-width:600px}.cc-global-configuration-dialog .mat-mdc-dialog-container .cc-global-configuration-dialog-content{padding:0 16px;display:flex;flex-direction:column;gap:26px}.cc-global-configuration-dialog .mat-mdc-dialog-container cc-map-layout-selection>mat-form-field,.cc-global-configuration-dialog .mat-mdc-dialog-container cc-display-quality-selection>mat-form-field{width:100%}.cc-global-configuration-dialog .mat-mdc-dialog-container cc-map-layout-selection>mat-form-field .mat-mdc-form-field-subscript-wrapper.mat-mdc-form-field-bottom-align,.cc-global-configuration-dialog .mat-mdc-dialog-container cc-display-quality-selection>mat-form-field .mat-mdc-form-field-subscript-wrapper.mat-mdc-form-field-bottom-align{display:none}.cc-global-configuration-dialog .mat-mdc-dialog-container cc-map-layout-selection .cc-tree-maps-max-tree-map-files,.cc-global-configuration-dialog .mat-mdc-dialog-container cc-display-quality-selection .cc-tree-maps-max-tree-map-files{display:inline-block;padding-left:16px}.cc-global-configuration-dialog .mat-mdc-dialog-container .cc-global-configuration-toggle-option{display:flex;flex-direction:column;gap:inherit}.cc-global-configuration-dialog .mat-mdc-dialog-container .cc-global-configuration-links-list{display:flex;gap:16px}.cc-global-configuration-dialog .mat-mdc-dialog-container .cc-global-configuration-links-list .weblink{display:block;color:#000000de;text-decoration:none}.cc-global-configuration-dialog .mat-mdc-dialog-container .cc-global-configuration-links-list .weblink .fa{margin:8px}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function aUe(t, n) {
				1 & t && fe(0, "cc-file-panel")
			}
			function cUe(t, n) {
				1 & t && fe(0, "cc-hovered-node-path-panel")
			}
			let lUe = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.hoveredNodeId$ = this.store.select(mw)),
								(this.experimentalFeaturesEnabled$ = this.store.select(vO))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-tool-bar"]],
								decls: 13,
								vars: 6,
								consts: [
									[4, "ngIf"],
									[1, "right-aligned"]
								],
								template: function (i, r) {
									1 & i &&
										(fe(0, "cc-upload-files-button")(1, "cc-screenshot-button")(2, "cc-copy-to-clipboard-button")(
											3,
											"cc-export-threed-map-button"
										)(4, "cc-reset-map-button"),
										Ee(5, aUe, 1, 0, "cc-file-panel", 0),
										Me(6, "async"),
										Ee(7, cUe, 1, 0, "cc-hovered-node-path-panel", 0),
										Me(8, "async"),
										F(9, "div", 1),
										fe(10, "cc-loading-map-progress-spinner")(11, "cc-presentation-mode-button")(
											12,
											"cc-global-configuration-button"
										),
										L()),
										2 & i &&
											(T(5),
											U("ngIf", null === De(6, 2, r.hoveredNodeId$)),
											T(2),
											U("ngIf", null !== De(8, 4, r.hoveredNodeId$)))
								},
								dependencies: [En, SNe, jNe, i3e, r3e, w3e, L3e, H3e, K3e, Y3e, sUe, Bn],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-tool-bar{display:flex;gap:8px;padding-left:8px;align-items:center;background-color:#f0f0f0;height:35px;border-bottom:1px solid #cdcdcd}cc-tool-bar .right-aligned{position:absolute;right:4px;display:inline-flex;align-items:center;width:400px;justify-content:space-between}cc-tool-bar span{font-size:10pt}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				KZ = (() => {
					class t {
						static {
							this.NO_EXTENSION = "None"
						}
						static {
							this.OTHER_EXTENSION = "other"
						}
						static {
							this.OTHER_GROUP_THRESHOLD_VALUE = 3
						}
						static getMetricDistribution(e, i) {
							if (!e) return []
							const r = new Map()
							let o = 0
							for (const a of $r(e))
								if (uo(a) && !a.data.isExcluded) {
									const c = a.data.attributes[i],
										l = t.estimateFileExtension(a.data.name),
										d = r.get(l)
									;(o += c), d ? (d.absoluteMetricValue += c) : r.set(l, t.getDistributionObject(l, c))
								}
							if (0 === o) return [t.getNoneExtension()]
							let s = []
							for (const a of r.values())
								0 !== a.absoluteMetricValue && ((a.relativeMetricValue = (100 * a.absoluteMetricValue) / o), s.push(a))
							return (
								s.sort((a, c) => c.absoluteMetricValue - a.absoluteMetricValue),
								(s = t.getMetricDistributionWithOthers(s)),
								s.length > 0 ? s : [t.getNoneExtension()]
							)
						}
						static getMetricDistributionWithOthers(e) {
							const i = t.getOtherExtension(),
								r = []
							for (const o of e)
								o.relativeMetricValue > t.OTHER_GROUP_THRESHOLD_VALUE
									? r.push(o)
									: ((i.absoluteMetricValue += o.absoluteMetricValue), (i.relativeMetricValue += o.relativeMetricValue))
							return i.relativeMetricValue > 0 && r.push(i), r
						}
						static getOtherExtension() {
							return {
								fileExtension: t.OTHER_EXTENSION,
								absoluteMetricValue: 0,
								relativeMetricValue: 0,
								color: t.getColor(t.OTHER_EXTENSION)
							}
						}
						static getDistributionObject(e, i) {
							return { fileExtension: e, absoluteMetricValue: i, relativeMetricValue: 0, color: t.getColor(e) }
						}
						static estimateFileExtension(e) {
							const i = e.lastIndexOf(".")
							return i > 0 && i !== e.length ? e.slice(i + 1).toLowerCase() : t.NO_EXTENSION
						}
						static getNoneExtension() {
							return {
								fileExtension: t.NO_EXTENSION,
								absoluteMetricValue: null,
								relativeMetricValue: 100,
								color: t.getColor(t.NO_EXTENSION)
							}
						}
						static getColor(e) {
							if (e === t.NO_EXTENSION || e === t.OTHER_EXTENSION) return "#676867"
							let i = 0
							for (let r = 0; r < e.length; r++) i = e.codePointAt(r) + ((i << 5) - i)
							return new zK(i % 360, 60, 50).toString()
						}
					}
					return t
				})()
			const XZ = Mt(cc, t => t.distributionMetric),
				dUe = Mt(Vc, XZ, (t, n) => KZ.getMetricDistribution(t.unifiedMapNode, n))
			let uUe = (() => {
				class t {
					constructor(e) {
						;(this.store = e), (this.distributionMetric$ = this.store.select(XZ))
					}
					handleDistributionMetricChanged(e) {
						this.store.dispatch(av({ value: e }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-distribution-metric-chooser"]],
							decls: 3,
							vars: 5,
							consts: [
								[1, "fa", "fa-pie-chart"],
								[3, "selectedMetricName", "searchPlaceholder", "handleMetricChanged"]
							],
							template: function (i, r) {
								1 & i && (fe(0, "i", 0)(1, "cc-metric-chooser", 1), Me(2, "async")),
									2 & i &&
										(T(1),
										U("selectedMetricName", De(2, 3, r.distributionMetric$))(
											"searchPlaceholder",
											"Distribution Metric (highest value)"
										)("handleMetricChanged", r.handleDistributionMetricChanged))
							},
							dependencies: [Cw, Bn],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function hUe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "span", 7),
						Le("click", function () {
							return rn(e), on(Te().toggleShowAbsoluteValues())
						}),
						F(1, "div", 8),
						Le("mouseover", function () {
							const o = rn(e).$implicit
							return on(Te().onHoverFileExtensionBar(o.fileExtension))
						})("mouseleave", function () {
							return rn(e), on(Te().onUnhoverFileExtensionBar())
						}),
						ge(2),
						L()()
				}
				if (2 & t) {
					const e = n.$implicit,
						i = Te()
					bi("width", e.relativeMetricValue + "%")("background", e.color),
						T(1),
						Fa(
							"title",
							e.fileExtension.toString() +
								" " +
								(i.showAbsoluteValues ? e.absoluteMetricValue.toFixed(0) : e.relativeMetricValue.toFixed(2) + "%")
						),
						T(1),
						JA(
							" ",
							e.relativeMetricValue >= e.fileExtension.length / 2 + 1 ? e.fileExtension : "",
							" ",
							i.showAbsoluteValues ? e.absoluteMetricValue.toLocaleString() : e.relativeMetricValue.toFixed(2) + "%",
							" "
						)
				}
			}
			function fUe(t, n) {
				if ((1 & t && (F(0, "div", 9), fe(1, "span", 10), ge(2), F(3, "span", 11), ge(4), L()()), 2 & t)) {
					const e = n.$implicit,
						i = Te()
					T(1),
						bi("background", e.color),
						T(1),
						Vt("", e.fileExtension, " : "),
						T(2),
						Vt(" ", i.showAbsoluteValues ? e.absoluteMetricValue.toLocaleString() : e.relativeMetricValue.toFixed(2) + "%", " ")
				}
			}
			let mUe = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e),
								(this.threeSceneService = i),
								(this.showAbsoluteValues = !1),
								(this.showDetails = !1),
								this.store.select(dUe).subscribe(r => {
									this.metricDistribution = r
								})
						}
						onHoverFileExtensionBar(e) {
							const i = new Set()
							for (const r of this.metricDistribution) "other" !== r.fileExtension && i.add(r.fileExtension)
							for (const r of this.threeSceneService.getMapMesh().getMeshDescription().buildings)
								if (r.node.isLeaf) {
									const o = KZ.estimateFileExtension(r.node.name)
									;(o === e || ("other" === e && !i.has(o))) && this.threeSceneService.addBuildingToHighlightingList(r)
								}
							this.threeSceneService.highlightBuildings()
						}
						onUnhoverFileExtensionBar() {
							this.threeSceneService.clearHighlight()
						}
						toggleShowDetails() {
							this.showDetails = !this.showDetails
						}
						toggleShowAbsoluteValues() {
							this.showAbsoluteValues = !this.showAbsoluteValues
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct), P(Qc))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-file-extension-bar"]],
								decls: 8,
								vars: 7,
								consts: [
									[1, "cc-distribution"],
									["title", "Distribution metric"],
									[1, "cc-bar"],
									["class", "cc-bar-section", 3, "width", "background", "click", 4, "ngFor", "ngForOf"],
									[1, "cc-show-details-button", 3, "click"],
									[1, "cc-distribution-details", 3, "click"],
									["class", "cc-distribution-details-entry", 4, "ngFor", "ngForOf"],
									[1, "cc-bar-section", 3, "click"],
									[1, "cc-bar-section-text", 3, "title", "mouseover", "mouseleave"],
									[1, "cc-distribution-details-entry"],
									[1, "cc-dot"],
									[1, "cc-detail-metric-value"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div", 0),
										fe(1, "cc-distribution-metric-chooser", 1),
										F(2, "div", 2),
										Ee(3, hUe, 3, 7, "span", 3),
										L(),
										F(4, "button", 4),
										Le("click", function () {
											return r.toggleShowDetails()
										}),
										fe(5, "i"),
										L()(),
										F(6, "div", 5),
										Le("click", function () {
											return r.toggleShowAbsoluteValues()
										}),
										Ee(7, fUe, 5, 4, "div", 6),
										L()),
										2 & i &&
											(T(3),
											U("ngForOf", r.metricDistribution),
											T(2),
											du("fa ", r.showDetails ? "fa-caret-up" : "fa-caret-down", ""),
											T(1),
											Zt("cc-hidden", !r.showDetails),
											T(1),
											U("ngForOf", r.metricDistribution))
								},
								dependencies: [_o, uUe],
								styles: [
									'cc-file-extension-bar{z-index:30;background-color:#fff}cc-file-extension-bar .cc-distribution{display:flex;height:17px}cc-file-extension-bar .cc-distribution cc-distribution-metric-chooser{width:210px;display:flex;align-items:center;font-size:12px;gap:6px;padding-left:6px}cc-file-extension-bar .cc-distribution cc-distribution-metric-chooser .mat-mdc-select{border-bottom:0}cc-file-extension-bar .cc-distribution .cc-bar{flex:1}cc-file-extension-bar .cc-distribution .cc-bar .cc-bar-section{height:100%;display:inline-block;overflow:hidden;color:#fff;text-align:center;cursor:pointer;outline:none}cc-file-extension-bar .cc-distribution .cc-bar .cc-bar-section:not(:last-child){border-right:1px solid white}cc-file-extension-bar .cc-distribution .cc-bar .cc-bar-section .cc-bar-section-text{font-size:10px;margin:2px 0;white-space:nowrap;padding:0 10px;text-overflow:""}cc-file-extension-bar .cc-show-details-button{line-height:10px;width:45px;margin:0;padding:0;background-color:#e6e6e6f5}cc-file-extension-bar .cc-distribution-details{border-top:1px solid #cdcdcd;height:25px;transition:all linear .2s}cc-file-extension-bar .cc-distribution-details.cc-hidden{height:0;border-top:0 solid #cdcdcd}cc-file-extension-bar .cc-distribution-details:hover{cursor:pointer}cc-file-extension-bar .cc-distribution-details .cc-distribution-details-entry{display:inline-block;font-size:15px;color:#000;margin:3px 0 3px 30px}cc-file-extension-bar .cc-distribution-details .cc-distribution-details-entry .cc-dot{height:10px;width:10px;border-radius:50%;display:inline-block;margin-right:8px}cc-file-extension-bar .cc-distribution-details .cc-distribution-details-entry .cc-detail-metric-value{color:gray}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				pUe = (() => {
					class t {
						constructor(e) {
							this.isLoadingFile$ = e.select(jL)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-loading-file-progress-spinner"]],
								decls: 3,
								vars: 4,
								consts: [
									["id", "loading-gif-file"],
									["mode", "indeterminate", "diameter", "96"]
								],
								template: function (i, r) {
									1 & i && (F(0, "div", 0), Me(1, "async"), fe(2, "mat-progress-spinner", 1), L()),
										2 & i && bi("visibility", De(1, 2, r.isLoadingFile$) ? "visible" : "hidden")
								},
								dependencies: [GZ, Bn],
								styles: [
									"cc-loading-file-progress-spinner #loading-gif-file{position:fixed;left:0;top:0;width:100%;height:100%;z-index:40;background-color:#fffc;display:inline-block;text-align:center}cc-loading-file-progress-spinner #loading-gif-file mat-progress-spinner.mat-mdc-progress-spinner{display:inline-block;margin:22% auto 0}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				AUe = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e), (this.loadInitialFileService = i), (this.isInitialized = !1)
						}
						ngOnInit() {
							var e = this
							return _r(function* () {
								e.store.dispatch(Dm({ value: !0 })),
									yield e.loadInitialFileService.loadFilesOrSampleFiles(),
									(e.isInitialized = !0)
							})()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct), P(WL))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-code-charta"]],
								decls: 8,
								vars: 2,
								template: function (i, r) {
									1 & i &&
										(F(0, "div"),
										fe(1, "cc-tool-bar")(2, "cc-file-extension-bar")(3, "cc-ribbon-bar")(4, "cc-code-map")(
											5,
											"cc-legend-panel"
										)(6, "cc-loading-file-progress-spinner")(7, "cc-logo"),
										L()),
										2 & i && bi("visibility", r.isInitialized ? "visible" : "hidden")
								},
								dependencies: [j0e, nSe, wke, mNe, lUe, mUe, pUe],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-code-charta #logo{display:flex;flex-direction:column;position:absolute;left:2em;bottom:1em;z-index:1}cc-code-charta #logo img{object-fit:contain;max-width:100%;height:auto}cc-code-charta #logo h2{color:#5a585a;font-weight:700;font-size:10px;text-align:center;margin:0;z-index:-1}cc-code-charta #codeMap{position:fixed;z-index:0;top:98px;left:0;width:100%;height:100%}cc-code-charta .cc-shadow{box-shadow:0 1px 5px #0003!important}cc-code-charta cc-attribute-side-bar .side-bar-container,cc-code-charta cc-legend-panel .block-wrapper,cc-code-charta cc-legend-panel .panel-button,cc-code-charta cc-view-cube,cc-code-charta unfocus-button-component{transition:right .3s ease}cc-code-charta .small-action-button{display:inline-block;height:24px;width:24px;vertical-align:top}cc-code-charta .state-selector-button{height:22px;vertical-align:bottom;width:30px;min-height:0;min-width:0;margin:0;padding:0;font-size:9pt;text-transform:none;background-color:#e6e6e6f5}cc-code-charta .state-selector-button:hover{background-color:#c8c8c8!important}cc-code-charta .state-selector-button i{vertical-align:middle;height:26px}cc-code-charta .state-selector-button.left{border-radius:5px 0 0 5px}cc-code-charta .state-selector-button.middle{border-radius:0;border-left:1px solid rgb(255,255,255);border-right:1px solid rgb(255,255,255)}cc-code-charta .state-selector-button.right{border-radius:0 5px 5px 0}cc-code-charta .state-selector-button.current{background-color:#009688;color:#fff}cc-code-charta .state-selector-button.current:hover{background-color:#0374c9!important}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				gUe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot] })
						}
					}
					return t
				})()
			function YZ(t) {
				return new ht(3e3, !1)
			}
			function Ef(t) {
				switch (t.length) {
					case 0:
						return new Fv()
					case 1:
						return t[0]
					default:
						return new u9(t)
				}
			}
			function qZ(t, n, e = new Map(), i = new Map()) {
				const r = [],
					o = []
				let s = -1,
					a = null
				if (
					(n.forEach(c => {
						const l = c.get("offset"),
							d = l == s,
							u = (d && a) || new Map()
						c.forEach((h, f) => {
							let _ = f,
								y = h
							if ("offset" !== f)
								switch (((_ = t.normalizePropertyName(_, r)), y)) {
									case "!":
										y = e.get(f)
										break
									case Eu:
										y = i.get(f)
										break
									default:
										y = t.normalizeStyleValue(f, _, y, r)
								}
							u.set(_, y)
						}),
							d || o.push(u),
							(a = u),
							(s = l)
					}),
					r.length)
				)
					throw (function HUe(t) {
						return new ht(3502, !1)
					})()
				return o
			}
			function p3(t, n, e, i) {
				switch (n) {
					case "start":
						t.onStart(() => i(e && A3(e, "start", t)))
						break
					case "done":
						t.onDone(() => i(e && A3(e, "done", t)))
						break
					case "destroy":
						t.onDestroy(() => i(e && A3(e, "destroy", t)))
				}
			}
			function A3(t, n, e) {
				const o = g3(t.element, t.triggerName, t.fromState, t.toState, n || t.phaseName, e.totalTime ?? t.totalTime, !!e.disabled),
					s = t._data
				return null != s && (o._data = s), o
			}
			function g3(t, n, e, i, r = "", o = 0, s) {
				return { element: t, triggerName: n, fromState: e, toState: i, phaseName: r, totalTime: o, disabled: !!s }
			}
			function uc(t, n, e) {
				let i = t.get(n)
				return i || t.set(n, (i = e)), i
			}
			function ZZ(t) {
				const n = t.indexOf(":")
				return [t.substring(1, n), t.slice(n + 1)]
			}
			const ZUe = (() => (typeof document > "u" ? null : document.documentElement))()
			function b3(t) {
				const n = t.parentNode || t.host || null
				return n === ZUe ? null : n
			}
			let Np = null,
				JZ = !1
			function eJ(t, n) {
				for (; n; ) {
					if (n === t) return !0
					n = b3(n)
				}
				return !1
			}
			function tJ(t, n, e) {
				if (e) return Array.from(t.querySelectorAll(n))
				const i = t.querySelector(n)
				return i ? [i] : []
			}
			let nJ = (() => {
					class t {
						validateStyleProperty(e) {
							return (function e4e(t) {
								Np ||
									((Np =
										(function t4e() {
											return typeof document < "u" ? document.body : null
										})() || {}),
									(JZ = !!Np.style && "WebkitAppearance" in Np.style))
								let n = !0
								return (
									Np.style &&
										!(function JUe(t) {
											return "ebkit" == t.substring(1, 6)
										})(t) &&
										((n = t in Np.style),
										!n && JZ && (n = "Webkit" + t.charAt(0).toUpperCase() + t.slice(1) in Np.style)),
									n
								)
							})(e)
						}
						matchesElement(e, i) {
							return !1
						}
						containsElement(e, i) {
							return eJ(e, i)
						}
						getParentElement(e) {
							return b3(e)
						}
						query(e, i, r) {
							return tJ(e, i, r)
						}
						computeStyle(e, i, r) {
							return r || ""
						}
						animate(e, i, r, o, s, a = [], c) {
							return new Fv(r, o)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				_3 = (() => {
					class t {
						static {
							this.NOOP = new nJ()
						}
					}
					return t
				})()
			const n4e = 1e3,
				v3 = "ng-enter",
				Yk = "ng-leave",
				qk = "ng-trigger",
				Zk = ".ng-trigger",
				rJ = "ng-animating",
				y3 = ".ng-animating"
			function Yu(t) {
				if ("number" == typeof t) return t
				const n = t.match(/^(-?[\.\d]+)(m?s)/)
				return !n || n.length < 2 ? 0 : w3(parseFloat(n[1]), n[2])
			}
			function w3(t, n) {
				return "s" === n ? t * n4e : t
			}
			function Jk(t, n, e) {
				return t.hasOwnProperty("duration")
					? t
					: (function r4e(t, n, e) {
							let r,
								o = 0,
								s = ""
							if ("string" == typeof t) {
								const a = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i)
								if (null === a) return n.push(YZ()), { duration: 0, delay: 0, easing: "" }
								r = w3(parseFloat(a[1]), a[2])
								const c = a[3]
								null != c && (o = w3(parseFloat(c), a[4]))
								const l = a[5]
								l && (s = l)
							} else r = t
							if (!e) {
								let a = !1,
									c = n.length
								r < 0 &&
									(n.push(
										(function bUe() {
											return new ht(3100, !1)
										})()
									),
									(a = !0)),
									o < 0 &&
										(n.push(
											(function _Ue() {
												return new ht(3101, !1)
											})()
										),
										(a = !0)),
									a && n.splice(c, 0, YZ())
							}
							return { duration: r, delay: o, easing: s }
					  })(t, n, e)
			}
			function Vw(t, n = {}) {
				return (
					Object.keys(t).forEach(e => {
						n[e] = t[e]
					}),
					n
				)
			}
			function oJ(t) {
				const n = new Map()
				return (
					Object.keys(t).forEach(e => {
						n.set(e, t[e])
					}),
					n
				)
			}
			function Mf(t, n = new Map(), e) {
				if (e) for (let [i, r] of e) n.set(i, r)
				for (let [i, r] of t) n.set(i, r)
				return n
			}
			function Pd(t, n, e) {
				n.forEach((i, r) => {
					const o = C3(r)
					e && !e.has(r) && e.set(r, t.style[o]), (t.style[o] = i)
				})
			}
			function Up(t, n) {
				n.forEach((e, i) => {
					const r = C3(i)
					t.style[r] = ""
				})
			}
			function Qw(t) {
				return Array.isArray(t) ? (1 == t.length ? t[0] : d9(t)) : t
			}
			const x3 = new RegExp("{{\\s*(.+?)\\s*}}", "g")
			function aJ(t) {
				let n = []
				if ("string" == typeof t) {
					let e
					for (; (e = x3.exec(t)); ) n.push(e[1])
					x3.lastIndex = 0
				}
				return n
			}
			function zw(t, n, e) {
				const i = t.toString(),
					r = i.replace(x3, (o, s) => {
						let a = n[s]
						return (
							null == a &&
								(e.push(
									(function yUe(t) {
										return new ht(3003, !1)
									})()
								),
								(a = "")),
							a.toString()
						)
					})
				return r == i ? t : r
			}
			function eT(t) {
				const n = []
				let e = t.next()
				for (; !e.done; ) n.push(e.value), (e = t.next())
				return n
			}
			const a4e = /-+([a-z0-9])/g
			function C3(t) {
				return t.replace(a4e, (...n) => n[1].toUpperCase())
			}
			function hc(t, n, e) {
				switch (n.type) {
					case 7:
						return t.visitTrigger(n, e)
					case 0:
						return t.visitState(n, e)
					case 1:
						return t.visitTransition(n, e)
					case 2:
						return t.visitSequence(n, e)
					case 3:
						return t.visitGroup(n, e)
					case 4:
						return t.visitAnimate(n, e)
					case 5:
						return t.visitKeyframes(n, e)
					case 6:
						return t.visitStyle(n, e)
					case 8:
						return t.visitReference(n, e)
					case 9:
						return t.visitAnimateChild(n, e)
					case 10:
						return t.visitAnimateRef(n, e)
					case 11:
						return t.visitQuery(n, e)
					case 12:
						return t.visitStagger(n, e)
					default:
						throw (function wUe(t) {
							return new ht(3004, !1)
						})()
				}
			}
			const tT = "*"
			function d4e(t, n) {
				const e = []
				return (
					"string" == typeof t
						? t.split(/\s*,\s*/).forEach(i =>
								(function u4e(t, n, e) {
									if (":" == t[0]) {
										const c = (function h4e(t, n) {
											switch (t) {
												case ":enter":
													return "void => *"
												case ":leave":
													return "* => void"
												case ":increment":
													return (e, i) => parseFloat(i) > parseFloat(e)
												case ":decrement":
													return (e, i) => parseFloat(i) < parseFloat(e)
												default:
													return (
														n.push(
															(function PUe(t) {
																return new ht(3016, !1)
															})()
														),
														"* => *"
													)
											}
										})(t, e)
										if ("function" == typeof c) return void n.push(c)
										t = c
									}
									const i = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/)
									if (null == i || i.length < 4)
										return (
											e.push(
												(function RUe(t) {
													return new ht(3015, !1)
												})()
											),
											n
										)
									const r = i[1],
										o = i[2],
										s = i[3]
									n.push(lJ(r, s))
									"<" == o[0] && !(r == tT && s == tT) && n.push(lJ(s, r))
								})(i, e, n)
						  )
						: e.push(t),
					e
				)
			}
			const nT = new Set(["true", "1"]),
				iT = new Set(["false", "0"])
			function lJ(t, n) {
				const e = nT.has(t) || iT.has(t),
					i = nT.has(n) || iT.has(n)
				return (r, o) => {
					let s = t == tT || t == r,
						a = n == tT || n == o
					return (
						!s && e && "boolean" == typeof r && (s = r ? nT.has(t) : iT.has(t)),
						!a && i && "boolean" == typeof o && (a = o ? nT.has(n) : iT.has(n)),
						s && a
					)
				}
			}
			const f4e = new RegExp("s*:selfs*,?", "g")
			function E3(t, n, e, i) {
				return new m4e(t).build(n, e, i)
			}
			class m4e {
				constructor(n) {
					this._driver = n
				}
				build(n, e, i) {
					const r = new g4e(e)
					return this._resetContextStyleTimingState(r), hc(this, Qw(n), r)
				}
				_resetContextStyleTimingState(n) {
					;(n.currentQuerySelector = ""),
						(n.collectedStyles = new Map()),
						n.collectedStyles.set("", new Map()),
						(n.currentTime = 0)
				}
				visitTrigger(n, e) {
					let i = (e.queryCount = 0),
						r = (e.depCount = 0)
					const o = [],
						s = []
					return (
						"@" == n.name.charAt(0) &&
							e.errors.push(
								(function CUe() {
									return new ht(3006, !1)
								})()
							),
						n.definitions.forEach(a => {
							if ((this._resetContextStyleTimingState(e), 0 == a.type)) {
								const c = a,
									l = c.name
								l
									.toString()
									.split(/\s*,\s*/)
									.forEach(d => {
										;(c.name = d), o.push(this.visitState(c, e))
									}),
									(c.name = l)
							} else if (1 == a.type) {
								const c = this.visitTransition(a, e)
								;(i += c.queryCount), (r += c.depCount), s.push(c)
							} else
								e.errors.push(
									(function EUe() {
										return new ht(3007, !1)
									})()
								)
						}),
						{ type: 7, name: n.name, states: o, transitions: s, queryCount: i, depCount: r, options: null }
					)
				}
				visitState(n, e) {
					const i = this.visitStyle(n.styles, e),
						r = (n.options && n.options.params) || null
					if (i.containsDynamicStyles) {
						const o = new Set(),
							s = r || {}
						i.styles.forEach(a => {
							a instanceof Map &&
								a.forEach(c => {
									aJ(c).forEach(l => {
										s.hasOwnProperty(l) || o.add(l)
									})
								})
						}),
							o.size &&
								(eT(o.values()),
								e.errors.push(
									(function MUe(t, n) {
										return new ht(3008, !1)
									})()
								))
					}
					return { type: 0, name: n.name, style: i, options: r ? { params: r } : null }
				}
				visitTransition(n, e) {
					;(e.queryCount = 0), (e.depCount = 0)
					const i = hc(this, Qw(n.animation), e)
					return {
						type: 1,
						matchers: d4e(n.expr, e.errors),
						animation: i,
						queryCount: e.queryCount,
						depCount: e.depCount,
						options: Hp(n.options)
					}
				}
				visitSequence(n, e) {
					return { type: 2, steps: n.steps.map(i => hc(this, i, e)), options: Hp(n.options) }
				}
				visitGroup(n, e) {
					const i = e.currentTime
					let r = 0
					const o = n.steps.map(s => {
						e.currentTime = i
						const a = hc(this, s, e)
						return (r = Math.max(r, e.currentTime)), a
					})
					return (e.currentTime = r), { type: 3, steps: o, options: Hp(n.options) }
				}
				visitAnimate(n, e) {
					const i = (function _4e(t, n) {
						if (t.hasOwnProperty("duration")) return t
						if ("number" == typeof t) return M3(Jk(t, n).duration, 0, "")
						const e = t
						if (e.split(/\s+/).some(o => "{" == o.charAt(0) && "{" == o.charAt(1))) {
							const o = M3(0, 0, "")
							return (o.dynamic = !0), (o.strValue = e), o
						}
						const r = Jk(e, n)
						return M3(r.duration, r.delay, r.easing)
					})(n.timings, e.errors)
					e.currentAnimateTimings = i
					let r,
						o = n.styles ? n.styles : wo({})
					if (5 == o.type) r = this.visitKeyframes(o, e)
					else {
						let s = n.styles,
							a = !1
						if (!s) {
							a = !0
							const l = {}
							i.easing && (l.easing = i.easing), (s = wo(l))
						}
						e.currentTime += i.duration + i.delay
						const c = this.visitStyle(s, e)
						;(c.isEmptyStep = a), (r = c)
					}
					return (e.currentAnimateTimings = null), { type: 4, timings: i, style: r, options: null }
				}
				visitStyle(n, e) {
					const i = this._makeStyleAst(n, e)
					return this._validateStyleAst(i, e), i
				}
				_makeStyleAst(n, e) {
					const i = [],
						r = Array.isArray(n.styles) ? n.styles : [n.styles]
					for (let a of r) "string" == typeof a ? (a === Eu ? i.push(a) : e.errors.push(new ht(3002, !1))) : i.push(oJ(a))
					let o = !1,
						s = null
					return (
						i.forEach(a => {
							if (a instanceof Map && (a.has("easing") && ((s = a.get("easing")), a.delete("easing")), !o))
								for (let c of a.values())
									if (c.toString().indexOf("{{") >= 0) {
										o = !0
										break
									}
						}),
						{ type: 6, styles: i, easing: s, offset: n.offset, containsDynamicStyles: o, options: null }
					)
				}
				_validateStyleAst(n, e) {
					const i = e.currentAnimateTimings
					let r = e.currentTime,
						o = e.currentTime
					i && o > 0 && (o -= i.duration + i.delay),
						n.styles.forEach(s => {
							"string" != typeof s &&
								s.forEach((a, c) => {
									const l = e.collectedStyles.get(e.currentQuerySelector),
										d = l.get(c)
									let u = !0
									d &&
										(o != r &&
											o >= d.startTime &&
											r <= d.endTime &&
											(e.errors.push(
												(function kUe(t, n, e, i, r) {
													return new ht(3010, !1)
												})()
											),
											(u = !1)),
										(o = d.startTime)),
										u && l.set(c, { startTime: o, endTime: r }),
										e.options &&
											(function s4e(t, n, e) {
												const i = n.params || {},
													r = aJ(t)
												r.length &&
													r.forEach(o => {
														i.hasOwnProperty(o) ||
															e.push(
																(function vUe(t) {
																	return new ht(3001, !1)
																})()
															)
													})
											})(a, e.options, e.errors)
								})
						})
				}
				visitKeyframes(n, e) {
					const i = { type: 5, styles: [], options: null }
					if (!e.currentAnimateTimings)
						return (
							e.errors.push(
								(function TUe() {
									return new ht(3011, !1)
								})()
							),
							i
						)
					let o = 0
					const s = []
					let a = !1,
						c = !1,
						l = 0
					const d = n.steps.map(x => {
						const w = this._makeStyleAst(x, e)
						let S =
								null != w.offset
									? w.offset
									: (function b4e(t) {
											if ("string" == typeof t) return null
											let n = null
											if (Array.isArray(t))
												t.forEach(e => {
													if (e instanceof Map && e.has("offset")) {
														const i = e
														;(n = parseFloat(i.get("offset"))), i.delete("offset")
													}
												})
											else if (t instanceof Map && t.has("offset")) {
												const e = t
												;(n = parseFloat(e.get("offset"))), e.delete("offset")
											}
											return n
									  })(w.styles),
							M = 0
						return null != S && (o++, (M = w.offset = S)), (c = c || M < 0 || M > 1), (a = a || M < l), (l = M), s.push(M), w
					})
					c &&
						e.errors.push(
							(function FUe() {
								return new ht(3012, !1)
							})()
						),
						a &&
							e.errors.push(
								(function BUe() {
									return new ht(3200, !1)
								})()
							)
					const u = n.steps.length
					let h = 0
					o > 0 && o < u
						? e.errors.push(
								(function IUe() {
									return new ht(3202, !1)
								})()
						  )
						: 0 == o && (h = 1 / (u - 1))
					const f = u - 1,
						_ = e.currentTime,
						y = e.currentAnimateTimings,
						C = y.duration
					return (
						d.forEach((x, w) => {
							const S = h > 0 ? (w == f ? 1 : h * w) : s[w],
								M = S * C
							;(e.currentTime = _ + y.delay + M),
								(y.duration = M),
								this._validateStyleAst(x, e),
								(x.offset = S),
								i.styles.push(x)
						}),
						i
					)
				}
				visitReference(n, e) {
					return { type: 8, animation: hc(this, Qw(n.animation), e), options: Hp(n.options) }
				}
				visitAnimateChild(n, e) {
					return e.depCount++, { type: 9, options: Hp(n.options) }
				}
				visitAnimateRef(n, e) {
					return { type: 10, animation: this.visitReference(n.animation, e), options: Hp(n.options) }
				}
				visitQuery(n, e) {
					const i = e.currentQuerySelector,
						r = n.options || {}
					e.queryCount++, (e.currentQuery = n)
					const [o, s] = (function p4e(t) {
						const n = !!t.split(/\s*,\s*/).find(e => ":self" == e)
						return (
							n && (t = t.replace(f4e, "")),
							(t = t
								.replace(/@\*/g, Zk)
								.replace(/@\w+/g, e => Zk + "-" + e.slice(1))
								.replace(/:animating/g, y3)),
							[t, n]
						)
					})(n.selector)
					;(e.currentQuerySelector = i.length ? i + " " + o : o), uc(e.collectedStyles, e.currentQuerySelector, new Map())
					const a = hc(this, Qw(n.animation), e)
					return (
						(e.currentQuery = null),
						(e.currentQuerySelector = i),
						{
							type: 11,
							selector: o,
							limit: r.limit || 0,
							optional: !!r.optional,
							includeSelf: s,
							animation: a,
							originalSelector: n.selector,
							options: Hp(n.options)
						}
					)
				}
				visitStagger(n, e) {
					e.currentQuery ||
						e.errors.push(
							(function DUe() {
								return new ht(3013, !1)
							})()
						)
					const i = "full" === n.timings ? { duration: 0, delay: 0, easing: "full" } : Jk(n.timings, e.errors, !0)
					return { type: 12, animation: hc(this, Qw(n.animation), e), timings: i, options: null }
				}
			}
			class g4e {
				constructor(n) {
					;(this.errors = n),
						(this.queryCount = 0),
						(this.depCount = 0),
						(this.currentTransition = null),
						(this.currentQuery = null),
						(this.currentQuerySelector = null),
						(this.currentAnimateTimings = null),
						(this.currentTime = 0),
						(this.collectedStyles = new Map()),
						(this.options = null),
						(this.unsupportedCSSPropertiesFound = new Set())
				}
			}
			function Hp(t) {
				return (
					t
						? (t = Vw(t)).params &&
						  (t.params = (function A4e(t) {
								return t ? Vw(t) : null
						  })(t.params))
						: (t = {}),
					t
				)
			}
			function M3(t, n, e) {
				return { duration: t, delay: n, easing: e }
			}
			function S3(t, n, e, i, r, o, s = null, a = !1) {
				return {
					type: 1,
					element: t,
					keyframes: n,
					preStyleProps: e,
					postStyleProps: i,
					duration: r,
					delay: o,
					totalTime: r + o,
					easing: s,
					subTimeline: a
				}
			}
			class rT {
				constructor() {
					this._map = new Map()
				}
				get(n) {
					return this._map.get(n) || []
				}
				append(n, e) {
					let i = this._map.get(n)
					i || this._map.set(n, (i = [])), i.push(...e)
				}
				has(n) {
					return this._map.has(n)
				}
				clear() {
					this._map.clear()
				}
			}
			const w4e = new RegExp(":enter", "g"),
				C4e = new RegExp(":leave", "g")
			function k3(t, n, e, i, r, o = new Map(), s = new Map(), a, c, l = []) {
				return new E4e().buildKeyframes(t, n, e, i, r, o, s, a, c, l)
			}
			class E4e {
				buildKeyframes(n, e, i, r, o, s, a, c, l, d = []) {
					l = l || new rT()
					const u = new T3(n, e, l, r, o, d, [])
					u.options = c
					const h = c.delay ? Yu(c.delay) : 0
					u.currentTimeline.delayNextStep(h), u.currentTimeline.setStyles([s], null, u.errors, c), hc(this, i, u)
					const f = u.timelines.filter(_ => _.containsAnimation())
					if (f.length && a.size) {
						let _
						for (let y = f.length - 1; y >= 0; y--) {
							const C = f[y]
							if (C.element === e) {
								_ = C
								break
							}
						}
						_ && !_.allowOnlyTimelineStyles() && _.setStyles([a], null, u.errors, c)
					}
					return f.length ? f.map(_ => _.buildKeyframes()) : [S3(e, [], [], [], 0, h, "", !1)]
				}
				visitTrigger(n, e) {}
				visitState(n, e) {}
				visitTransition(n, e) {}
				visitAnimateChild(n, e) {
					const i = e.subInstructions.get(e.element)
					if (i) {
						const r = e.createSubContext(n.options),
							o = e.currentTimeline.currentTime,
							s = this._visitSubInstructions(i, r, r.options)
						o != s && e.transformIntoNewTimeline(s)
					}
					e.previousNode = n
				}
				visitAnimateRef(n, e) {
					const i = e.createSubContext(n.options)
					i.transformIntoNewTimeline(),
						this._applyAnimationRefDelays([n.options, n.animation.options], e, i),
						this.visitReference(n.animation, i),
						e.transformIntoNewTimeline(i.currentTimeline.currentTime),
						(e.previousNode = n)
				}
				_applyAnimationRefDelays(n, e, i) {
					for (const r of n) {
						const o = r?.delay
						if (o) {
							const s = "number" == typeof o ? o : Yu(zw(o, r?.params ?? {}, e.errors))
							i.delayNextStep(s)
						}
					}
				}
				_visitSubInstructions(n, e, i) {
					let o = e.currentTimeline.currentTime
					const s = null != i.duration ? Yu(i.duration) : null,
						a = null != i.delay ? Yu(i.delay) : null
					return (
						0 !== s &&
							n.forEach(c => {
								const l = e.appendInstructionToTimeline(c, s, a)
								o = Math.max(o, l.duration + l.delay)
							}),
						o
					)
				}
				visitReference(n, e) {
					e.updateOptions(n.options, !0), hc(this, n.animation, e), (e.previousNode = n)
				}
				visitSequence(n, e) {
					const i = e.subContextCount
					let r = e
					const o = n.options
					if (o && (o.params || o.delay) && ((r = e.createSubContext(o)), r.transformIntoNewTimeline(), null != o.delay)) {
						6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), (r.previousNode = oT))
						const s = Yu(o.delay)
						r.delayNextStep(s)
					}
					n.steps.length &&
						(n.steps.forEach(s => hc(this, s, r)),
						r.currentTimeline.applyStylesToKeyframe(),
						r.subContextCount > i && r.transformIntoNewTimeline()),
						(e.previousNode = n)
				}
				visitGroup(n, e) {
					const i = []
					let r = e.currentTimeline.currentTime
					const o = n.options && n.options.delay ? Yu(n.options.delay) : 0
					n.steps.forEach(s => {
						const a = e.createSubContext(n.options)
						o && a.delayNextStep(o), hc(this, s, a), (r = Math.max(r, a.currentTimeline.currentTime)), i.push(a.currentTimeline)
					}),
						i.forEach(s => e.currentTimeline.mergeTimelineCollectedStyles(s)),
						e.transformIntoNewTimeline(r),
						(e.previousNode = n)
				}
				_visitTiming(n, e) {
					if (n.dynamic) {
						const i = n.strValue
						return Jk(e.params ? zw(i, e.params, e.errors) : i, e.errors)
					}
					return { duration: n.duration, delay: n.delay, easing: n.easing }
				}
				visitAnimate(n, e) {
					const i = (e.currentAnimateTimings = this._visitTiming(n.timings, e)),
						r = e.currentTimeline
					i.delay && (e.incrementTime(i.delay), r.snapshotCurrentStyles())
					const o = n.style
					5 == o.type
						? this.visitKeyframes(o, e)
						: (e.incrementTime(i.duration), this.visitStyle(o, e), r.applyStylesToKeyframe()),
						(e.currentAnimateTimings = null),
						(e.previousNode = n)
				}
				visitStyle(n, e) {
					const i = e.currentTimeline,
						r = e.currentAnimateTimings
					!r && i.hasCurrentStyleProperties() && i.forwardFrame()
					const o = (r && r.easing) || n.easing
					n.isEmptyStep ? i.applyEmptyStep(o) : i.setStyles(n.styles, o, e.errors, e.options), (e.previousNode = n)
				}
				visitKeyframes(n, e) {
					const i = e.currentAnimateTimings,
						r = e.currentTimeline.duration,
						o = i.duration,
						a = e.createSubContext().currentTimeline
					;(a.easing = i.easing),
						n.styles.forEach(c => {
							a.forwardTime((c.offset || 0) * o),
								a.setStyles(c.styles, c.easing, e.errors, e.options),
								a.applyStylesToKeyframe()
						}),
						e.currentTimeline.mergeTimelineCollectedStyles(a),
						e.transformIntoNewTimeline(r + o),
						(e.previousNode = n)
				}
				visitQuery(n, e) {
					const i = e.currentTimeline.currentTime,
						r = n.options || {},
						o = r.delay ? Yu(r.delay) : 0
					o &&
						(6 === e.previousNode.type || (0 == i && e.currentTimeline.hasCurrentStyleProperties())) &&
						(e.currentTimeline.snapshotCurrentStyles(), (e.previousNode = oT))
					let s = i
					const a = e.invokeQuery(n.selector, n.originalSelector, n.limit, n.includeSelf, !!r.optional, e.errors)
					e.currentQueryTotal = a.length
					let c = null
					a.forEach((l, d) => {
						e.currentQueryIndex = d
						const u = e.createSubContext(n.options, l)
						o && u.delayNextStep(o),
							l === e.element && (c = u.currentTimeline),
							hc(this, n.animation, u),
							u.currentTimeline.applyStylesToKeyframe(),
							(s = Math.max(s, u.currentTimeline.currentTime))
					}),
						(e.currentQueryIndex = 0),
						(e.currentQueryTotal = 0),
						e.transformIntoNewTimeline(s),
						c && (e.currentTimeline.mergeTimelineCollectedStyles(c), e.currentTimeline.snapshotCurrentStyles()),
						(e.previousNode = n)
				}
				visitStagger(n, e) {
					const i = e.parentContext,
						r = e.currentTimeline,
						o = n.timings,
						s = Math.abs(o.duration),
						a = s * (e.currentQueryTotal - 1)
					let c = s * e.currentQueryIndex
					switch (o.duration < 0 ? "reverse" : o.easing) {
						case "reverse":
							c = a - c
							break
						case "full":
							c = i.currentStaggerTime
					}
					const d = e.currentTimeline
					c && d.delayNextStep(c)
					const u = d.currentTime
					hc(this, n.animation, e),
						(e.previousNode = n),
						(i.currentStaggerTime = r.currentTime - u + (r.startTime - i.currentTimeline.startTime))
				}
			}
			const oT = {}
			class T3 {
				constructor(n, e, i, r, o, s, a, c) {
					;(this._driver = n),
						(this.element = e),
						(this.subInstructions = i),
						(this._enterClassName = r),
						(this._leaveClassName = o),
						(this.errors = s),
						(this.timelines = a),
						(this.parentContext = null),
						(this.currentAnimateTimings = null),
						(this.previousNode = oT),
						(this.subContextCount = 0),
						(this.options = {}),
						(this.currentQueryIndex = 0),
						(this.currentQueryTotal = 0),
						(this.currentStaggerTime = 0),
						(this.currentTimeline = c || new sT(this._driver, e, 0)),
						a.push(this.currentTimeline)
				}
				get params() {
					return this.options.params
				}
				updateOptions(n, e) {
					if (!n) return
					const i = n
					let r = this.options
					null != i.duration && (r.duration = Yu(i.duration)), null != i.delay && (r.delay = Yu(i.delay))
					const o = i.params
					if (o) {
						let s = r.params
						s || (s = this.options.params = {}),
							Object.keys(o).forEach(a => {
								;(!e || !s.hasOwnProperty(a)) && (s[a] = zw(o[a], s, this.errors))
							})
					}
				}
				_copyOptions() {
					const n = {}
					if (this.options) {
						const e = this.options.params
						if (e) {
							const i = (n.params = {})
							Object.keys(e).forEach(r => {
								i[r] = e[r]
							})
						}
					}
					return n
				}
				createSubContext(n = null, e, i) {
					const r = e || this.element,
						o = new T3(
							this._driver,
							r,
							this.subInstructions,
							this._enterClassName,
							this._leaveClassName,
							this.errors,
							this.timelines,
							this.currentTimeline.fork(r, i || 0)
						)
					return (
						(o.previousNode = this.previousNode),
						(o.currentAnimateTimings = this.currentAnimateTimings),
						(o.options = this._copyOptions()),
						o.updateOptions(n),
						(o.currentQueryIndex = this.currentQueryIndex),
						(o.currentQueryTotal = this.currentQueryTotal),
						(o.parentContext = this),
						this.subContextCount++,
						o
					)
				}
				transformIntoNewTimeline(n) {
					return (
						(this.previousNode = oT),
						(this.currentTimeline = this.currentTimeline.fork(this.element, n)),
						this.timelines.push(this.currentTimeline),
						this.currentTimeline
					)
				}
				appendInstructionToTimeline(n, e, i) {
					const r = { duration: e ?? n.duration, delay: this.currentTimeline.currentTime + (i ?? 0) + n.delay, easing: "" },
						o = new M4e(this._driver, n.element, n.keyframes, n.preStyleProps, n.postStyleProps, r, n.stretchStartingKeyframe)
					return this.timelines.push(o), r
				}
				incrementTime(n) {
					this.currentTimeline.forwardTime(this.currentTimeline.duration + n)
				}
				delayNextStep(n) {
					n > 0 && this.currentTimeline.delayNextStep(n)
				}
				invokeQuery(n, e, i, r, o, s) {
					let a = []
					if ((r && a.push(this.element), n.length > 0)) {
						n = (n = n.replace(w4e, "." + this._enterClassName)).replace(C4e, "." + this._leaveClassName)
						let l = this._driver.query(this.element, n, 1 != i)
						0 !== i && (l = i < 0 ? l.slice(l.length + i, l.length) : l.slice(0, i)), a.push(...l)
					}
					return (
						!o &&
							0 == a.length &&
							s.push(
								(function LUe(t) {
									return new ht(3014, !1)
								})()
							),
						a
					)
				}
			}
			class sT {
				constructor(n, e, i, r) {
					;(this._driver = n),
						(this.element = e),
						(this.startTime = i),
						(this._elementTimelineStylesLookup = r),
						(this.duration = 0),
						(this.easing = null),
						(this._previousKeyframe = new Map()),
						(this._currentKeyframe = new Map()),
						(this._keyframes = new Map()),
						(this._styleSummary = new Map()),
						(this._localTimelineStyles = new Map()),
						(this._pendingStyles = new Map()),
						(this._backFill = new Map()),
						(this._currentEmptyStepKeyframe = null),
						this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map()),
						(this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e)),
						this._globalTimelineStyles ||
							((this._globalTimelineStyles = this._localTimelineStyles),
							this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)),
						this._loadKeyframe()
				}
				containsAnimation() {
					switch (this._keyframes.size) {
						case 0:
							return !1
						case 1:
							return this.hasCurrentStyleProperties()
						default:
							return !0
					}
				}
				hasCurrentStyleProperties() {
					return this._currentKeyframe.size > 0
				}
				get currentTime() {
					return this.startTime + this.duration
				}
				delayNextStep(n) {
					const e = 1 === this._keyframes.size && this._pendingStyles.size
					this.duration || e ? (this.forwardTime(this.currentTime + n), e && this.snapshotCurrentStyles()) : (this.startTime += n)
				}
				fork(n, e) {
					return this.applyStylesToKeyframe(), new sT(this._driver, n, e || this.currentTime, this._elementTimelineStylesLookup)
				}
				_loadKeyframe() {
					this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe),
						(this._currentKeyframe = this._keyframes.get(this.duration)),
						this._currentKeyframe ||
							((this._currentKeyframe = new Map()), this._keyframes.set(this.duration, this._currentKeyframe))
				}
				forwardFrame() {
					;(this.duration += 1), this._loadKeyframe()
				}
				forwardTime(n) {
					this.applyStylesToKeyframe(), (this.duration = n), this._loadKeyframe()
				}
				_updateStyle(n, e) {
					this._localTimelineStyles.set(n, e),
						this._globalTimelineStyles.set(n, e),
						this._styleSummary.set(n, { time: this.currentTime, value: e })
				}
				allowOnlyTimelineStyles() {
					return this._currentEmptyStepKeyframe !== this._currentKeyframe
				}
				applyEmptyStep(n) {
					n && this._previousKeyframe.set("easing", n)
					for (let [e, i] of this._globalTimelineStyles) this._backFill.set(e, i || Eu), this._currentKeyframe.set(e, Eu)
					this._currentEmptyStepKeyframe = this._currentKeyframe
				}
				setStyles(n, e, i, r) {
					e && this._previousKeyframe.set("easing", e)
					const o = (r && r.params) || {},
						s = (function S4e(t, n) {
							const e = new Map()
							let i
							return (
								t.forEach(r => {
									if ("*" === r) {
										i = i || n.keys()
										for (let o of i) e.set(o, Eu)
									} else Mf(r, e)
								}),
								e
							)
						})(n, this._globalTimelineStyles)
					for (let [a, c] of s) {
						const l = zw(c, o, i)
						this._pendingStyles.set(a, l),
							this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) ?? Eu),
							this._updateStyle(a, l)
					}
				}
				applyStylesToKeyframe() {
					0 != this._pendingStyles.size &&
						(this._pendingStyles.forEach((n, e) => {
							this._currentKeyframe.set(e, n)
						}),
						this._pendingStyles.clear(),
						this._localTimelineStyles.forEach((n, e) => {
							this._currentKeyframe.has(e) || this._currentKeyframe.set(e, n)
						}))
				}
				snapshotCurrentStyles() {
					for (let [n, e] of this._localTimelineStyles) this._pendingStyles.set(n, e), this._updateStyle(n, e)
				}
				getFinalKeyframe() {
					return this._keyframes.get(this.duration)
				}
				get properties() {
					const n = []
					for (let e in this._currentKeyframe) n.push(e)
					return n
				}
				mergeTimelineCollectedStyles(n) {
					n._styleSummary.forEach((e, i) => {
						const r = this._styleSummary.get(i)
						;(!r || e.time > r.time) && this._updateStyle(i, e.value)
					})
				}
				buildKeyframes() {
					this.applyStylesToKeyframe()
					const n = new Set(),
						e = new Set(),
						i = 1 === this._keyframes.size && 0 === this.duration
					let r = []
					this._keyframes.forEach((a, c) => {
						const l = Mf(a, new Map(), this._backFill)
						l.forEach((d, u) => {
							"!" === d ? n.add(u) : d === Eu && e.add(u)
						}),
							i || l.set("offset", c / this.duration),
							r.push(l)
					})
					const o = n.size ? eT(n.values()) : [],
						s = e.size ? eT(e.values()) : []
					if (i) {
						const a = r[0],
							c = new Map(a)
						a.set("offset", 0), c.set("offset", 1), (r = [a, c])
					}
					return S3(this.element, r, o, s, this.duration, this.startTime, this.easing, !1)
				}
			}
			class M4e extends sT {
				constructor(n, e, i, r, o, s, a = !1) {
					super(n, e, s.delay),
						(this.keyframes = i),
						(this.preStyleProps = r),
						(this.postStyleProps = o),
						(this._stretchStartingKeyframe = a),
						(this.timings = { duration: s.duration, delay: s.delay, easing: s.easing })
				}
				containsAnimation() {
					return this.keyframes.length > 1
				}
				buildKeyframes() {
					let n = this.keyframes,
						{ delay: e, duration: i, easing: r } = this.timings
					if (this._stretchStartingKeyframe && e) {
						const o = [],
							s = i + e,
							a = e / s,
							c = Mf(n[0])
						c.set("offset", 0), o.push(c)
						const l = Mf(n[0])
						l.set("offset", hJ(a)), o.push(l)
						const d = n.length - 1
						for (let u = 1; u <= d; u++) {
							let h = Mf(n[u])
							const f = h.get("offset")
							h.set("offset", hJ((e + f * i) / s)), o.push(h)
						}
						;(i = s), (e = 0), (r = ""), (n = o)
					}
					return S3(this.element, n, this.preStyleProps, this.postStyleProps, i, e, r, !0)
				}
			}
			function hJ(t, n = 3) {
				const e = Math.pow(10, n - 1)
				return Math.round(t * e) / e
			}
			class F3 {}
			const k4e = new Set([
				"width",
				"height",
				"minWidth",
				"minHeight",
				"maxWidth",
				"maxHeight",
				"left",
				"top",
				"bottom",
				"right",
				"fontSize",
				"outlineWidth",
				"outlineOffset",
				"paddingTop",
				"paddingLeft",
				"paddingBottom",
				"paddingRight",
				"marginTop",
				"marginLeft",
				"marginBottom",
				"marginRight",
				"borderRadius",
				"borderWidth",
				"borderTopWidth",
				"borderLeftWidth",
				"borderRightWidth",
				"borderBottomWidth",
				"textIndent",
				"perspective"
			])
			class T4e extends F3 {
				normalizePropertyName(n, e) {
					return C3(n)
				}
				normalizeStyleValue(n, e, i, r) {
					let o = ""
					const s = i.toString().trim()
					if (k4e.has(e) && 0 !== i && "0" !== i)
						if ("number" == typeof i) o = "px"
						else {
							const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/)
							a &&
								0 == a[1].length &&
								r.push(
									(function xUe(t, n) {
										return new ht(3005, !1)
									})()
								)
						}
					return s + o
				}
			}
			function fJ(t, n, e, i, r, o, s, a, c, l, d, u, h) {
				return {
					type: 0,
					element: t,
					triggerName: n,
					isRemovalTransition: r,
					fromState: e,
					fromStyles: o,
					toState: i,
					toStyles: s,
					timelines: a,
					queriedElements: c,
					preStyleProps: l,
					postStyleProps: d,
					totalTime: u,
					errors: h
				}
			}
			const B3 = {}
			class mJ {
				constructor(n, e, i) {
					;(this._triggerName = n), (this.ast = e), (this._stateStyles = i)
				}
				match(n, e, i, r) {
					return (function F4e(t, n, e, i, r) {
						return t.some(o => o(n, e, i, r))
					})(this.ast.matchers, n, e, i, r)
				}
				buildStyles(n, e, i) {
					let r = this._stateStyles.get("*")
					return void 0 !== n && (r = this._stateStyles.get(n?.toString()) || r), r ? r.buildStyles(e, i) : new Map()
				}
				build(n, e, i, r, o, s, a, c, l, d) {
					const u = [],
						h = (this.ast.options && this.ast.options.params) || B3,
						_ = this.buildStyles(i, (a && a.params) || B3, u),
						y = (c && c.params) || B3,
						C = this.buildStyles(r, y, u),
						x = new Set(),
						w = new Map(),
						S = new Map(),
						M = "void" === r,
						O = { params: B4e(y, h), delay: this.ast.options?.delay },
						N = d ? [] : k3(n, e, this.ast.animation, o, s, _, C, O, l, u)
					let j = 0
					if (
						(N.forEach(ae => {
							j = Math.max(ae.duration + ae.delay, j)
						}),
						u.length)
					)
						return fJ(e, this._triggerName, i, r, M, _, C, [], [], w, S, j, u)
					N.forEach(ae => {
						const ce = ae.element,
							ue = uc(w, ce, new Set())
						ae.preStyleProps.forEach(ve => ue.add(ve))
						const Se = uc(S, ce, new Set())
						ae.postStyleProps.forEach(ve => Se.add(ve)), ce !== e && x.add(ce)
					})
					const le = eT(x.values())
					return fJ(e, this._triggerName, i, r, M, _, C, N, le, w, S, j)
				}
			}
			function B4e(t, n) {
				const e = Vw(n)
				for (const i in t) t.hasOwnProperty(i) && null != t[i] && (e[i] = t[i])
				return e
			}
			class I4e {
				constructor(n, e, i) {
					;(this.styles = n), (this.defaultParams = e), (this.normalizer = i)
				}
				buildStyles(n, e) {
					const i = new Map(),
						r = Vw(this.defaultParams)
					return (
						Object.keys(n).forEach(o => {
							const s = n[o]
							null !== s && (r[o] = s)
						}),
						this.styles.styles.forEach(o => {
							"string" != typeof o &&
								o.forEach((s, a) => {
									s && (s = zw(s, r, e))
									const c = this.normalizer.normalizePropertyName(a, e)
									;(s = this.normalizer.normalizeStyleValue(a, c, s, e)), i.set(a, s)
								})
						}),
						i
					)
				}
			}
			class L4e {
				constructor(n, e, i) {
					;(this.name = n),
						(this.ast = e),
						(this._normalizer = i),
						(this.transitionFactories = []),
						(this.states = new Map()),
						e.states.forEach(r => {
							this.states.set(r.name, new I4e(r.style, (r.options && r.options.params) || {}, i))
						}),
						pJ(this.states, "true", "1"),
						pJ(this.states, "false", "0"),
						e.transitions.forEach(r => {
							this.transitionFactories.push(new mJ(n, r, this.states))
						}),
						(this.fallbackTransition = (function R4e(t, n, e) {
							return new mJ(
								t,
								{
									type: 1,
									animation: { type: 2, steps: [], options: null },
									matchers: [(s, a) => !0],
									options: null,
									queryCount: 0,
									depCount: 0
								},
								n
							)
						})(n, this.states))
				}
				get containsQueries() {
					return this.ast.queryCount > 0
				}
				matchTransition(n, e, i, r) {
					return this.transitionFactories.find(s => s.match(n, e, i, r)) || null
				}
				matchStyles(n, e, i) {
					return this.fallbackTransition.buildStyles(n, e, i)
				}
			}
			function pJ(t, n, e) {
				t.has(n) ? t.has(e) || t.set(e, t.get(n)) : t.has(e) && t.set(n, t.get(e))
			}
			const P4e = new rT()
			class O4e {
				constructor(n, e, i) {
					;(this.bodyNode = n),
						(this._driver = e),
						(this._normalizer = i),
						(this._animations = new Map()),
						(this._playersById = new Map()),
						(this.players = [])
				}
				register(n, e) {
					const i = [],
						o = E3(this._driver, e, i, [])
					if (i.length)
						throw (function VUe(t) {
							return new ht(3503, !1)
						})()
					this._animations.set(n, o)
				}
				_buildPlayer(n, e, i) {
					const r = n.element,
						o = qZ(this._normalizer, n.keyframes, e, i)
					return this._driver.animate(r, o, n.duration, n.delay, n.easing, [], !0)
				}
				create(n, e, i = {}) {
					const r = [],
						o = this._animations.get(n)
					let s
					const a = new Map()
					if (
						(o
							? ((s = k3(this._driver, e, o, v3, Yk, new Map(), new Map(), i, P4e, r)),
							  s.forEach(d => {
									const u = uc(a, d.element, new Map())
									d.postStyleProps.forEach(h => u.set(h, null))
							  }))
							: (r.push(
									(function QUe() {
										return new ht(3300, !1)
									})()
							  ),
							  (s = [])),
						r.length)
					)
						throw (function zUe(t) {
							return new ht(3504, !1)
						})()
					a.forEach((d, u) => {
						d.forEach((h, f) => {
							d.set(f, this._driver.computeStyle(u, f, Eu))
						})
					})
					const l = Ef(
						s.map(d => {
							const u = a.get(d.element)
							return this._buildPlayer(d, new Map(), u)
						})
					)
					return this._playersById.set(n, l), l.onDestroy(() => this.destroy(n)), this.players.push(l), l
				}
				destroy(n) {
					const e = this._getPlayer(n)
					e.destroy(), this._playersById.delete(n)
					const i = this.players.indexOf(e)
					i >= 0 && this.players.splice(i, 1)
				}
				_getPlayer(n) {
					const e = this._playersById.get(n)
					if (!e)
						throw (function GUe(t) {
							return new ht(3301, !1)
						})()
					return e
				}
				listen(n, e, i, r) {
					const o = g3(e, "", "", "")
					return p3(this._getPlayer(n), i, o, r), () => {}
				}
				command(n, e, i, r) {
					if ("register" == i) return void this.register(n, r[0])
					if ("create" == i) return void this.create(n, e, r[0] || {})
					const o = this._getPlayer(n)
					switch (i) {
						case "play":
							o.play()
							break
						case "pause":
							o.pause()
							break
						case "reset":
							o.reset()
							break
						case "restart":
							o.restart()
							break
						case "finish":
							o.finish()
							break
						case "init":
							o.init()
							break
						case "setPosition":
							o.setPosition(parseFloat(r[0]))
							break
						case "destroy":
							this.destroy(n)
					}
				}
			}
			const AJ = "ng-animate-queued",
				I3 = "ng-animate-disabled",
				Q4e = [],
				gJ = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 },
				z4e = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 },
				Bl = "__ng_removed"
			class D3 {
				get params() {
					return this.options.params
				}
				constructor(n, e = "") {
					this.namespaceId = e
					const i = n && n.hasOwnProperty("value")
					if (
						((this.value = (function j4e(t) {
							return t ?? null
						})(i ? n.value : n)),
						i)
					) {
						const o = Vw(n)
						delete o.value, (this.options = o)
					} else this.options = {}
					this.options.params || (this.options.params = {})
				}
				absorbOptions(n) {
					const e = n.params
					if (e) {
						const i = this.options.params
						Object.keys(e).forEach(r => {
							null == i[r] && (i[r] = e[r])
						})
					}
				}
			}
			const Gw = "void",
				L3 = new D3(Gw)
			class G4e {
				constructor(n, e, i) {
					;(this.id = n),
						(this.hostElement = e),
						(this._engine = i),
						(this.players = []),
						(this._triggers = new Map()),
						(this._queue = []),
						(this._elementListeners = new Map()),
						(this._hostClassName = "ng-tns-" + n),
						zc(e, this._hostClassName)
				}
				listen(n, e, i, r) {
					if (!this._triggers.has(e))
						throw (function $Ue(t, n) {
							return new ht(3302, !1)
						})()
					if (null == i || 0 == i.length)
						throw (function WUe(t) {
							return new ht(3303, !1)
						})()
					if (
						!(function K4e(t) {
							return "start" == t || "done" == t
						})(i)
					)
						throw (function jUe(t, n) {
							return new ht(3400, !1)
						})()
					const o = uc(this._elementListeners, n, []),
						s = { name: e, phase: i, callback: r }
					o.push(s)
					const a = uc(this._engine.statesByElement, n, new Map())
					return (
						a.has(e) || (zc(n, qk), zc(n, qk + "-" + e), a.set(e, L3)),
						() => {
							this._engine.afterFlush(() => {
								const c = o.indexOf(s)
								c >= 0 && o.splice(c, 1), this._triggers.has(e) || a.delete(e)
							})
						}
					)
				}
				register(n, e) {
					return !this._triggers.has(n) && (this._triggers.set(n, e), !0)
				}
				_getTrigger(n) {
					const e = this._triggers.get(n)
					if (!e)
						throw (function KUe(t) {
							return new ht(3401, !1)
						})()
					return e
				}
				trigger(n, e, i, r = !0) {
					const o = this._getTrigger(e),
						s = new R3(this.id, e, n)
					let a = this._engine.statesByElement.get(n)
					a || (zc(n, qk), zc(n, qk + "-" + e), this._engine.statesByElement.set(n, (a = new Map())))
					let c = a.get(e)
					const l = new D3(i, this.id)
					if (
						(!(i && i.hasOwnProperty("value")) && c && l.absorbOptions(c.options),
						a.set(e, l),
						c || (c = L3),
						l.value !== Gw && c.value === l.value)
					) {
						if (
							!(function q4e(t, n) {
								const e = Object.keys(t),
									i = Object.keys(n)
								if (e.length != i.length) return !1
								for (let r = 0; r < e.length; r++) {
									const o = e[r]
									if (!n.hasOwnProperty(o) || t[o] !== n[o]) return !1
								}
								return !0
							})(c.params, l.params)
						) {
							const y = [],
								C = o.matchStyles(c.value, c.params, y),
								x = o.matchStyles(l.value, l.params, y)
							y.length
								? this._engine.reportError(y)
								: this._engine.afterFlush(() => {
										Up(n, C), Pd(n, x)
								  })
						}
						return
					}
					const h = uc(this._engine.playersByElement, n, [])
					h.forEach(y => {
						y.namespaceId == this.id && y.triggerName == e && y.queued && y.destroy()
					})
					let f = o.matchTransition(c.value, l.value, n, l.params),
						_ = !1
					if (!f) {
						if (!r) return
						;(f = o.fallbackTransition), (_ = !0)
					}
					return (
						this._engine.totalQueuedPlayers++,
						this._queue.push({
							element: n,
							triggerName: e,
							transition: f,
							fromState: c,
							toState: l,
							player: s,
							isFallbackTransition: _
						}),
						_ ||
							(zc(n, AJ),
							s.onStart(() => {
								Qb(n, AJ)
							})),
						s.onDone(() => {
							let y = this.players.indexOf(s)
							y >= 0 && this.players.splice(y, 1)
							const C = this._engine.playersByElement.get(n)
							if (C) {
								let x = C.indexOf(s)
								x >= 0 && C.splice(x, 1)
							}
						}),
						this.players.push(s),
						h.push(s),
						s
					)
				}
				deregister(n) {
					this._triggers.delete(n),
						this._engine.statesByElement.forEach(e => e.delete(n)),
						this._elementListeners.forEach((e, i) => {
							this._elementListeners.set(
								i,
								e.filter(r => r.name != n)
							)
						})
				}
				clearElementCache(n) {
					this._engine.statesByElement.delete(n), this._elementListeners.delete(n)
					const e = this._engine.playersByElement.get(n)
					e && (e.forEach(i => i.destroy()), this._engine.playersByElement.delete(n))
				}
				_signalRemovalForInnerTriggers(n, e) {
					const i = this._engine.driver.query(n, Zk, !0)
					i.forEach(r => {
						if (r[Bl]) return
						const o = this._engine.fetchNamespacesByElement(r)
						o.size ? o.forEach(s => s.triggerLeaveAnimation(r, e, !1, !0)) : this.clearElementCache(r)
					}),
						this._engine.afterFlushAnimationsDone(() => i.forEach(r => this.clearElementCache(r)))
				}
				triggerLeaveAnimation(n, e, i, r) {
					const o = this._engine.statesByElement.get(n),
						s = new Map()
					if (o) {
						const a = []
						if (
							(o.forEach((c, l) => {
								if ((s.set(l, c.value), this._triggers.has(l))) {
									const d = this.trigger(n, l, Gw, r)
									d && a.push(d)
								}
							}),
							a.length)
						)
							return (
								this._engine.markElementAsRemoved(this.id, n, !0, e, s),
								i && Ef(a).onDone(() => this._engine.processLeaveNode(n)),
								!0
							)
					}
					return !1
				}
				prepareLeaveAnimationListeners(n) {
					const e = this._elementListeners.get(n),
						i = this._engine.statesByElement.get(n)
					if (e && i) {
						const r = new Set()
						e.forEach(o => {
							const s = o.name
							if (r.has(s)) return
							r.add(s)
							const c = this._triggers.get(s).fallbackTransition,
								l = i.get(s) || L3,
								d = new D3(Gw),
								u = new R3(this.id, s, n)
							this._engine.totalQueuedPlayers++,
								this._queue.push({
									element: n,
									triggerName: s,
									transition: c,
									fromState: l,
									toState: d,
									player: u,
									isFallbackTransition: !0
								})
						})
					}
				}
				removeNode(n, e) {
					const i = this._engine
					if ((n.childElementCount && this._signalRemovalForInnerTriggers(n, e), this.triggerLeaveAnimation(n, e, !0))) return
					let r = !1
					if (i.totalAnimations) {
						const o = i.players.length ? i.playersByQueriedElement.get(n) : []
						if (o && o.length) r = !0
						else {
							let s = n
							for (; (s = s.parentNode); )
								if (i.statesByElement.get(s)) {
									r = !0
									break
								}
						}
					}
					if ((this.prepareLeaveAnimationListeners(n), r)) i.markElementAsRemoved(this.id, n, !1, e)
					else {
						const o = n[Bl]
						;(!o || o === gJ) &&
							(i.afterFlush(() => this.clearElementCache(n)), i.destroyInnerAnimations(n), i._onRemovalComplete(n, e))
					}
				}
				insertNode(n, e) {
					zc(n, this._hostClassName)
				}
				drainQueuedTransitions(n) {
					const e = []
					return (
						this._queue.forEach(i => {
							const r = i.player
							if (r.destroyed) return
							const o = i.element,
								s = this._elementListeners.get(o)
							s &&
								s.forEach(a => {
									if (a.name == i.triggerName) {
										const c = g3(o, i.triggerName, i.fromState.value, i.toState.value)
										;(c._data = n), p3(i.player, a.phase, c, a.callback)
									}
								}),
								r.markedForDestroy
									? this._engine.afterFlush(() => {
											r.destroy()
									  })
									: e.push(i)
						}),
						(this._queue = []),
						e.sort((i, r) => {
							const o = i.transition.ast.depCount,
								s = r.transition.ast.depCount
							return 0 == o || 0 == s ? o - s : this._engine.driver.containsElement(i.element, r.element) ? 1 : -1
						})
					)
				}
				destroy(n) {
					this.players.forEach(e => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, n)
				}
			}
			class $4e {
				_onRemovalComplete(n, e) {
					this.onRemovalComplete(n, e)
				}
				constructor(n, e, i) {
					;(this.bodyNode = n),
						(this.driver = e),
						(this._normalizer = i),
						(this.players = []),
						(this.newHostElements = new Map()),
						(this.playersByElement = new Map()),
						(this.playersByQueriedElement = new Map()),
						(this.statesByElement = new Map()),
						(this.disabledNodes = new Set()),
						(this.totalAnimations = 0),
						(this.totalQueuedPlayers = 0),
						(this._namespaceLookup = {}),
						(this._namespaceList = []),
						(this._flushFns = []),
						(this._whenQuietFns = []),
						(this.namespacesByHostElement = new Map()),
						(this.collectedEnterElements = []),
						(this.collectedLeaveElements = []),
						(this.onRemovalComplete = (r, o) => {})
				}
				get queuedPlayers() {
					const n = []
					return (
						this._namespaceList.forEach(e => {
							e.players.forEach(i => {
								i.queued && n.push(i)
							})
						}),
						n
					)
				}
				createNamespace(n, e) {
					const i = new G4e(n, e, this)
					return (
						this.bodyNode && this.driver.containsElement(this.bodyNode, e)
							? this._balanceNamespaceList(i, e)
							: (this.newHostElements.set(e, i), this.collectEnterElement(e)),
						(this._namespaceLookup[n] = i)
					)
				}
				_balanceNamespaceList(n, e) {
					const i = this._namespaceList,
						r = this.namespacesByHostElement
					if (i.length - 1 >= 0) {
						let s = !1,
							a = this.driver.getParentElement(e)
						for (; a; ) {
							const c = r.get(a)
							if (c) {
								const l = i.indexOf(c)
								i.splice(l + 1, 0, n), (s = !0)
								break
							}
							a = this.driver.getParentElement(a)
						}
						s || i.unshift(n)
					} else i.push(n)
					return r.set(e, n), n
				}
				register(n, e) {
					let i = this._namespaceLookup[n]
					return i || (i = this.createNamespace(n, e)), i
				}
				registerTrigger(n, e, i) {
					let r = this._namespaceLookup[n]
					r && r.register(e, i) && this.totalAnimations++
				}
				destroy(n, e) {
					n &&
						(this.afterFlush(() => {}),
						this.afterFlushAnimationsDone(() => {
							const i = this._fetchNamespace(n)
							this.namespacesByHostElement.delete(i.hostElement)
							const r = this._namespaceList.indexOf(i)
							r >= 0 && this._namespaceList.splice(r, 1), i.destroy(e), delete this._namespaceLookup[n]
						}))
				}
				_fetchNamespace(n) {
					return this._namespaceLookup[n]
				}
				fetchNamespacesByElement(n) {
					const e = new Set(),
						i = this.statesByElement.get(n)
					if (i)
						for (let r of i.values())
							if (r.namespaceId) {
								const o = this._fetchNamespace(r.namespaceId)
								o && e.add(o)
							}
					return e
				}
				trigger(n, e, i, r) {
					if (aT(e)) {
						const o = this._fetchNamespace(n)
						if (o) return o.trigger(e, i, r), !0
					}
					return !1
				}
				insertNode(n, e, i, r) {
					if (!aT(e)) return
					const o = e[Bl]
					if (o && o.setForRemoval) {
						;(o.setForRemoval = !1), (o.setForMove = !0)
						const s = this.collectedLeaveElements.indexOf(e)
						s >= 0 && this.collectedLeaveElements.splice(s, 1)
					}
					if (n) {
						const s = this._fetchNamespace(n)
						s && s.insertNode(e, i)
					}
					r && this.collectEnterElement(e)
				}
				collectEnterElement(n) {
					this.collectedEnterElements.push(n)
				}
				markElementAsDisabled(n, e) {
					e
						? this.disabledNodes.has(n) || (this.disabledNodes.add(n), zc(n, I3))
						: this.disabledNodes.has(n) && (this.disabledNodes.delete(n), Qb(n, I3))
				}
				removeNode(n, e, i) {
					if (aT(e)) {
						const r = n ? this._fetchNamespace(n) : null
						r ? r.removeNode(e, i) : this.markElementAsRemoved(n, e, !1, i)
						const o = this.namespacesByHostElement.get(e)
						o && o.id !== n && o.removeNode(e, i)
					} else this._onRemovalComplete(e, i)
				}
				markElementAsRemoved(n, e, i, r, o) {
					this.collectedLeaveElements.push(e),
						(e[Bl] = { namespaceId: n, setForRemoval: r, hasAnimation: i, removedBeforeQueried: !1, previousTriggersValues: o })
				}
				listen(n, e, i, r, o) {
					return aT(e) ? this._fetchNamespace(n).listen(e, i, r, o) : () => {}
				}
				_buildInstruction(n, e, i, r, o) {
					return n.transition.build(
						this.driver,
						n.element,
						n.fromState.value,
						n.toState.value,
						i,
						r,
						n.fromState.options,
						n.toState.options,
						e,
						o
					)
				}
				destroyInnerAnimations(n) {
					let e = this.driver.query(n, Zk, !0)
					e.forEach(i => this.destroyActiveAnimationsForElement(i)),
						0 != this.playersByQueriedElement.size &&
							((e = this.driver.query(n, y3, !0)), e.forEach(i => this.finishActiveQueriedAnimationOnElement(i)))
				}
				destroyActiveAnimationsForElement(n) {
					const e = this.playersByElement.get(n)
					e &&
						e.forEach(i => {
							i.queued ? (i.markedForDestroy = !0) : i.destroy()
						})
				}
				finishActiveQueriedAnimationOnElement(n) {
					const e = this.playersByQueriedElement.get(n)
					e && e.forEach(i => i.finish())
				}
				whenRenderingDone() {
					return new Promise(n => {
						if (this.players.length) return Ef(this.players).onDone(() => n())
						n()
					})
				}
				processLeaveNode(n) {
					const e = n[Bl]
					if (e && e.setForRemoval) {
						if (((n[Bl] = gJ), e.namespaceId)) {
							this.destroyInnerAnimations(n)
							const i = this._fetchNamespace(e.namespaceId)
							i && i.clearElementCache(n)
						}
						this._onRemovalComplete(n, e.setForRemoval)
					}
					n.classList?.contains(I3) && this.markElementAsDisabled(n, !1),
						this.driver.query(n, ".ng-animate-disabled", !0).forEach(i => {
							this.markElementAsDisabled(i, !1)
						})
				}
				flush(n = -1) {
					let e = []
					if (
						(this.newHostElements.size &&
							(this.newHostElements.forEach((i, r) => this._balanceNamespaceList(i, r)), this.newHostElements.clear()),
						this.totalAnimations && this.collectedEnterElements.length)
					)
						for (let i = 0; i < this.collectedEnterElements.length; i++) zc(this.collectedEnterElements[i], "ng-star-inserted")
					if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
						const i = []
						try {
							e = this._flushAnimations(i, n)
						} finally {
							for (let r = 0; r < i.length; r++) i[r]()
						}
					} else
						for (let i = 0; i < this.collectedLeaveElements.length; i++) this.processLeaveNode(this.collectedLeaveElements[i])
					if (
						((this.totalQueuedPlayers = 0),
						(this.collectedEnterElements.length = 0),
						(this.collectedLeaveElements.length = 0),
						this._flushFns.forEach(i => i()),
						(this._flushFns = []),
						this._whenQuietFns.length)
					) {
						const i = this._whenQuietFns
						;(this._whenQuietFns = []),
							e.length
								? Ef(e).onDone(() => {
										i.forEach(r => r())
								  })
								: i.forEach(r => r())
					}
				}
				reportError(n) {
					throw (function XUe(t) {
						return new ht(3402, !1)
					})()
				}
				_flushAnimations(n, e) {
					const i = new rT(),
						r = [],
						o = new Map(),
						s = [],
						a = new Map(),
						c = new Map(),
						l = new Map(),
						d = new Set()
					this.disabledNodes.forEach(Z => {
						d.add(Z)
						const Ae = this.driver.query(Z, ".ng-animate-queued", !0)
						for (let Ie = 0; Ie < Ae.length; Ie++) d.add(Ae[Ie])
					})
					const u = this.bodyNode,
						h = Array.from(this.statesByElement.keys()),
						f = vJ(h, this.collectedEnterElements),
						_ = new Map()
					let y = 0
					f.forEach((Z, Ae) => {
						const Ie = v3 + y++
						_.set(Ae, Ie), Z.forEach(Pe => zc(Pe, Ie))
					})
					const C = [],
						x = new Set(),
						w = new Set()
					for (let Z = 0; Z < this.collectedLeaveElements.length; Z++) {
						const Ae = this.collectedLeaveElements[Z],
							Ie = Ae[Bl]
						Ie &&
							Ie.setForRemoval &&
							(C.push(Ae),
							x.add(Ae),
							Ie.hasAnimation ? this.driver.query(Ae, ".ng-star-inserted", !0).forEach(Pe => x.add(Pe)) : w.add(Ae))
					}
					const S = new Map(),
						M = vJ(h, Array.from(x))
					M.forEach((Z, Ae) => {
						const Ie = Yk + y++
						S.set(Ae, Ie), Z.forEach(Pe => zc(Pe, Ie))
					}),
						n.push(() => {
							f.forEach((Z, Ae) => {
								const Ie = _.get(Ae)
								Z.forEach(Pe => Qb(Pe, Ie))
							}),
								M.forEach((Z, Ae) => {
									const Ie = S.get(Ae)
									Z.forEach(Pe => Qb(Pe, Ie))
								}),
								C.forEach(Z => {
									this.processLeaveNode(Z)
								})
						})
					const O = [],
						N = []
					for (let Z = this._namespaceList.length - 1; Z >= 0; Z--)
						this._namespaceList[Z].drainQueuedTransitions(e).forEach(Ie => {
							const Pe = Ie.player,
								nt = Ie.element
							if ((O.push(Pe), this.collectedEnterElements.length)) {
								const nn = nt[Bl]
								if (nn && nn.setForMove) {
									if (nn.previousTriggersValues && nn.previousTriggersValues.has(Ie.triggerName)) {
										const Sn = nn.previousTriggersValues.get(Ie.triggerName),
											Hn = this.statesByElement.get(Ie.element)
										if (Hn && Hn.has(Ie.triggerName)) {
											const kn = Hn.get(Ie.triggerName)
											;(kn.value = Sn), Hn.set(Ie.triggerName, kn)
										}
									}
									return void Pe.destroy()
								}
							}
							const pt = !u || !this.driver.containsElement(u, nt),
								kt = S.get(nt),
								tn = _.get(nt),
								Kt = this._buildInstruction(Ie, i, tn, kt, pt)
							if (Kt.errors && Kt.errors.length) return void N.push(Kt)
							if (pt) return Pe.onStart(() => Up(nt, Kt.fromStyles)), Pe.onDestroy(() => Pd(nt, Kt.toStyles)), void r.push(Pe)
							if (Ie.isFallbackTransition)
								return Pe.onStart(() => Up(nt, Kt.fromStyles)), Pe.onDestroy(() => Pd(nt, Kt.toStyles)), void r.push(Pe)
							const Un = []
							Kt.timelines.forEach(nn => {
								;(nn.stretchStartingKeyframe = !0), this.disabledNodes.has(nn.element) || Un.push(nn)
							}),
								(Kt.timelines = Un),
								i.append(nt, Kt.timelines),
								s.push({ instruction: Kt, player: Pe, element: nt }),
								Kt.queriedElements.forEach(nn => uc(a, nn, []).push(Pe)),
								Kt.preStyleProps.forEach((nn, Sn) => {
									if (nn.size) {
										let Hn = c.get(Sn)
										Hn || c.set(Sn, (Hn = new Set())), nn.forEach((kn, Ii) => Hn.add(Ii))
									}
								}),
								Kt.postStyleProps.forEach((nn, Sn) => {
									let Hn = l.get(Sn)
									Hn || l.set(Sn, (Hn = new Set())), nn.forEach((kn, Ii) => Hn.add(Ii))
								})
						})
					if (N.length) {
						const Z = []
						N.forEach(Ae => {
							Z.push(
								(function YUe(t, n) {
									return new ht(3505, !1)
								})()
							)
						}),
							O.forEach(Ae => Ae.destroy()),
							this.reportError(Z)
					}
					const j = new Map(),
						le = new Map()
					s.forEach(Z => {
						const Ae = Z.element
						i.has(Ae) && (le.set(Ae, Ae), this._beforeAnimationBuild(Z.player.namespaceId, Z.instruction, j))
					}),
						r.forEach(Z => {
							const Ae = Z.element
							this._getPreviousPlayers(Ae, !1, Z.namespaceId, Z.triggerName, null).forEach(Pe => {
								uc(j, Ae, []).push(Pe), Pe.destroy()
							})
						})
					const ae = C.filter(Z => wJ(Z, c, l)),
						ce = new Map()
					_J(ce, this.driver, w, l, Eu).forEach(Z => {
						wJ(Z, c, l) && ae.push(Z)
					})
					const Se = new Map()
					f.forEach((Z, Ae) => {
						_J(Se, this.driver, new Set(Z), c, "!")
					}),
						ae.forEach(Z => {
							const Ae = ce.get(Z),
								Ie = Se.get(Z)
							ce.set(Z, new Map([...(Ae?.entries() ?? []), ...(Ie?.entries() ?? [])]))
						})
					const ve = [],
						W = [],
						me = {}
					s.forEach(Z => {
						const { element: Ae, player: Ie, instruction: Pe } = Z
						if (i.has(Ae)) {
							if (d.has(Ae))
								return (
									Ie.onDestroy(() => Pd(Ae, Pe.toStyles)),
									(Ie.disabled = !0),
									Ie.overrideTotalTime(Pe.totalTime),
									void r.push(Ie)
								)
							let nt = me
							if (le.size > 1) {
								let kt = Ae
								const tn = []
								for (; (kt = kt.parentNode); ) {
									const Kt = le.get(kt)
									if (Kt) {
										nt = Kt
										break
									}
									tn.push(kt)
								}
								tn.forEach(Kt => le.set(Kt, nt))
							}
							const pt = this._buildAnimation(Ie.namespaceId, Pe, j, o, Se, ce)
							if ((Ie.setRealPlayer(pt), nt === me)) ve.push(Ie)
							else {
								const kt = this.playersByElement.get(nt)
								kt && kt.length && (Ie.parentPlayer = Ef(kt)), r.push(Ie)
							}
						} else Up(Ae, Pe.fromStyles), Ie.onDestroy(() => Pd(Ae, Pe.toStyles)), W.push(Ie), d.has(Ae) && r.push(Ie)
					}),
						W.forEach(Z => {
							const Ae = o.get(Z.element)
							if (Ae && Ae.length) {
								const Ie = Ef(Ae)
								Z.setRealPlayer(Ie)
							}
						}),
						r.forEach(Z => {
							Z.parentPlayer ? Z.syncPlayerEvents(Z.parentPlayer) : Z.destroy()
						})
					for (let Z = 0; Z < C.length; Z++) {
						const Ae = C[Z],
							Ie = Ae[Bl]
						if ((Qb(Ae, Yk), Ie && Ie.hasAnimation)) continue
						let Pe = []
						if (a.size) {
							let pt = a.get(Ae)
							pt && pt.length && Pe.push(...pt)
							let kt = this.driver.query(Ae, y3, !0)
							for (let tn = 0; tn < kt.length; tn++) {
								let Kt = a.get(kt[tn])
								Kt && Kt.length && Pe.push(...Kt)
							}
						}
						const nt = Pe.filter(pt => !pt.destroyed)
						nt.length ? X4e(this, Ae, nt) : this.processLeaveNode(Ae)
					}
					return (
						(C.length = 0),
						ve.forEach(Z => {
							this.players.push(Z),
								Z.onDone(() => {
									Z.destroy()
									const Ae = this.players.indexOf(Z)
									this.players.splice(Ae, 1)
								}),
								Z.play()
						}),
						ve
					)
				}
				afterFlush(n) {
					this._flushFns.push(n)
				}
				afterFlushAnimationsDone(n) {
					this._whenQuietFns.push(n)
				}
				_getPreviousPlayers(n, e, i, r, o) {
					let s = []
					if (e) {
						const a = this.playersByQueriedElement.get(n)
						a && (s = a)
					} else {
						const a = this.playersByElement.get(n)
						if (a) {
							const c = !o || o == Gw
							a.forEach(l => {
								l.queued || (!c && l.triggerName != r) || s.push(l)
							})
						}
					}
					return (i || r) && (s = s.filter(a => !((i && i != a.namespaceId) || (r && r != a.triggerName)))), s
				}
				_beforeAnimationBuild(n, e, i) {
					const o = e.element,
						s = e.isRemovalTransition ? void 0 : n,
						a = e.isRemovalTransition ? void 0 : e.triggerName
					for (const c of e.timelines) {
						const l = c.element,
							d = l !== o,
							u = uc(i, l, [])
						this._getPreviousPlayers(l, d, s, a, e.toState).forEach(f => {
							const _ = f.getRealPlayer()
							_.beforeDestroy && _.beforeDestroy(), f.destroy(), u.push(f)
						})
					}
					Up(o, e.fromStyles)
				}
				_buildAnimation(n, e, i, r, o, s) {
					const a = e.triggerName,
						c = e.element,
						l = [],
						d = new Set(),
						u = new Set(),
						h = e.timelines.map(_ => {
							const y = _.element
							d.add(y)
							const C = y[Bl]
							if (C && C.removedBeforeQueried) return new Fv(_.duration, _.delay)
							const x = y !== c,
								w = (function Y4e(t) {
									const n = []
									return yJ(t, n), n
								})((i.get(y) || Q4e).map(j => j.getRealPlayer())).filter(j => !!j.element && j.element === y),
								S = o.get(y),
								M = s.get(y),
								O = qZ(this._normalizer, _.keyframes, S, M),
								N = this._buildPlayer(_, O, w)
							if ((_.subTimeline && r && u.add(y), x)) {
								const j = new R3(n, a, y)
								j.setRealPlayer(N), l.push(j)
							}
							return N
						})
					l.forEach(_ => {
						uc(this.playersByQueriedElement, _.element, []).push(_),
							_.onDone(() =>
								(function W4e(t, n, e) {
									let i = t.get(n)
									if (i) {
										if (i.length) {
											const r = i.indexOf(e)
											i.splice(r, 1)
										}
										0 == i.length && t.delete(n)
									}
									return i
								})(this.playersByQueriedElement, _.element, _)
							)
					}),
						d.forEach(_ => zc(_, rJ))
					const f = Ef(h)
					return (
						f.onDestroy(() => {
							d.forEach(_ => Qb(_, rJ)), Pd(c, e.toStyles)
						}),
						u.forEach(_ => {
							uc(r, _, []).push(f)
						}),
						f
					)
				}
				_buildPlayer(n, e, i) {
					return e.length > 0 ? this.driver.animate(n.element, e, n.duration, n.delay, n.easing, i) : new Fv(n.duration, n.delay)
				}
			}
			class R3 {
				constructor(n, e, i) {
					;(this.namespaceId = n),
						(this.triggerName = e),
						(this.element = i),
						(this._player = new Fv()),
						(this._containsRealPlayer = !1),
						(this._queuedCallbacks = new Map()),
						(this.destroyed = !1),
						(this.parentPlayer = null),
						(this.markedForDestroy = !1),
						(this.disabled = !1),
						(this.queued = !0),
						(this.totalTime = 0)
				}
				setRealPlayer(n) {
					this._containsRealPlayer ||
						((this._player = n),
						this._queuedCallbacks.forEach((e, i) => {
							e.forEach(r => p3(n, i, void 0, r))
						}),
						this._queuedCallbacks.clear(),
						(this._containsRealPlayer = !0),
						this.overrideTotalTime(n.totalTime),
						(this.queued = !1))
				}
				getRealPlayer() {
					return this._player
				}
				overrideTotalTime(n) {
					this.totalTime = n
				}
				syncPlayerEvents(n) {
					const e = this._player
					e.triggerCallback && n.onStart(() => e.triggerCallback("start")),
						n.onDone(() => this.finish()),
						n.onDestroy(() => this.destroy())
				}
				_queueEvent(n, e) {
					uc(this._queuedCallbacks, n, []).push(e)
				}
				onDone(n) {
					this.queued && this._queueEvent("done", n), this._player.onDone(n)
				}
				onStart(n) {
					this.queued && this._queueEvent("start", n), this._player.onStart(n)
				}
				onDestroy(n) {
					this.queued && this._queueEvent("destroy", n), this._player.onDestroy(n)
				}
				init() {
					this._player.init()
				}
				hasStarted() {
					return !this.queued && this._player.hasStarted()
				}
				play() {
					!this.queued && this._player.play()
				}
				pause() {
					!this.queued && this._player.pause()
				}
				restart() {
					!this.queued && this._player.restart()
				}
				finish() {
					this._player.finish()
				}
				destroy() {
					;(this.destroyed = !0), this._player.destroy()
				}
				reset() {
					!this.queued && this._player.reset()
				}
				setPosition(n) {
					this.queued || this._player.setPosition(n)
				}
				getPosition() {
					return this.queued ? 0 : this._player.getPosition()
				}
				triggerCallback(n) {
					const e = this._player
					e.triggerCallback && e.triggerCallback(n)
				}
			}
			function aT(t) {
				return t && 1 === t.nodeType
			}
			function bJ(t, n) {
				const e = t.style.display
				return (t.style.display = n ?? "none"), e
			}
			function _J(t, n, e, i, r) {
				const o = []
				e.forEach(c => o.push(bJ(c)))
				const s = []
				i.forEach((c, l) => {
					const d = new Map()
					c.forEach(u => {
						const h = n.computeStyle(l, u, r)
						d.set(u, h), (!h || 0 == h.length) && ((l[Bl] = z4e), s.push(l))
					}),
						t.set(l, d)
				})
				let a = 0
				return e.forEach(c => bJ(c, o[a++])), s
			}
			function vJ(t, n) {
				const e = new Map()
				if ((t.forEach(a => e.set(a, [])), 0 == n.length)) return e
				const r = new Set(n),
					o = new Map()
				function s(a) {
					if (!a) return 1
					let c = o.get(a)
					if (c) return c
					const l = a.parentNode
					return (c = e.has(l) ? l : r.has(l) ? 1 : s(l)), o.set(a, c), c
				}
				return (
					n.forEach(a => {
						const c = s(a)
						1 !== c && e.get(c).push(a)
					}),
					e
				)
			}
			function zc(t, n) {
				t.classList?.add(n)
			}
			function Qb(t, n) {
				t.classList?.remove(n)
			}
			function X4e(t, n, e) {
				Ef(e).onDone(() => t.processLeaveNode(n))
			}
			function yJ(t, n) {
				for (let e = 0; e < t.length; e++) {
					const i = t[e]
					i instanceof u9 ? yJ(i.players, n) : n.push(i)
				}
			}
			function wJ(t, n, e) {
				const i = e.get(t)
				if (!i) return !1
				let r = n.get(t)
				return r ? i.forEach(o => r.add(o)) : n.set(t, i), e.delete(t), !0
			}
			class cT {
				constructor(n, e, i) {
					;(this.bodyNode = n),
						(this._driver = e),
						(this._normalizer = i),
						(this._triggerCache = {}),
						(this.onRemovalComplete = (r, o) => {}),
						(this._transitionEngine = new $4e(n, e, i)),
						(this._timelineEngine = new O4e(n, e, i)),
						(this._transitionEngine.onRemovalComplete = (r, o) => this.onRemovalComplete(r, o))
				}
				registerTrigger(n, e, i, r, o) {
					const s = n + "-" + r
					let a = this._triggerCache[s]
					if (!a) {
						const c = [],
							d = E3(this._driver, o, c, [])
						if (c.length)
							throw (function UUe(t, n) {
								return new ht(3404, !1)
							})()
						;(a = (function D4e(t, n, e) {
							return new L4e(t, n, e)
						})(r, d, this._normalizer)),
							(this._triggerCache[s] = a)
					}
					this._transitionEngine.registerTrigger(e, r, a)
				}
				register(n, e) {
					this._transitionEngine.register(n, e)
				}
				destroy(n, e) {
					this._transitionEngine.destroy(n, e)
				}
				onInsert(n, e, i, r) {
					this._transitionEngine.insertNode(n, e, i, r)
				}
				onRemove(n, e, i) {
					this._transitionEngine.removeNode(n, e, i)
				}
				disableAnimations(n, e) {
					this._transitionEngine.markElementAsDisabled(n, e)
				}
				process(n, e, i, r) {
					if ("@" == i.charAt(0)) {
						const [o, s] = ZZ(i)
						this._timelineEngine.command(o, e, s, r)
					} else this._transitionEngine.trigger(n, e, i, r)
				}
				listen(n, e, i, r, o) {
					if ("@" == i.charAt(0)) {
						const [s, a] = ZZ(i)
						return this._timelineEngine.listen(s, e, a, o)
					}
					return this._transitionEngine.listen(n, e, i, r, o)
				}
				flush(n = -1) {
					this._transitionEngine.flush(n)
				}
				get players() {
					return [...this._transitionEngine.players, ...this._timelineEngine.players]
				}
				whenRenderingDone() {
					return this._transitionEngine.whenRenderingDone()
				}
				afterFlushAnimationsDone(n) {
					this._transitionEngine.afterFlushAnimationsDone(n)
				}
			}
			let nHe = (() => {
				class t extends c9 {
					constructor(e, i) {
						super(),
							(this._nextAnimationId = 0),
							(this._renderer = e.createRenderer(i.body, {
								id: "0",
								encapsulation: Zs.None,
								styles: [],
								data: { animation: [] }
							}))
					}
					build(e) {
						const i = this._nextAnimationId.toString()
						this._nextAnimationId++
						const r = Array.isArray(e) ? d9(e) : e
						return CJ(this._renderer, null, i, "register", [r]), new iHe(i, this._renderer)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Y_), re(wi))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			class iHe extends dge {
				constructor(n, e) {
					super(), (this._id = n), (this._renderer = e)
				}
				create(n, e) {
					return new rHe(this._id, n, e || {}, this._renderer)
				}
			}
			class rHe {
				constructor(n, e, i, r) {
					;(this.id = n),
						(this.element = e),
						(this._renderer = r),
						(this.parentPlayer = null),
						(this._started = !1),
						(this.totalTime = 0),
						this._command("create", i)
				}
				_listen(n, e) {
					return this._renderer.listen(this.element, `@@${this.id}:${n}`, e)
				}
				_command(n, ...e) {
					return CJ(this._renderer, this.element, this.id, n, e)
				}
				onDone(n) {
					this._listen("done", n)
				}
				onStart(n) {
					this._listen("start", n)
				}
				onDestroy(n) {
					this._listen("destroy", n)
				}
				init() {
					this._command("init")
				}
				hasStarted() {
					return this._started
				}
				play() {
					this._command("play"), (this._started = !0)
				}
				pause() {
					this._command("pause")
				}
				restart() {
					this._command("restart")
				}
				finish() {
					this._command("finish")
				}
				destroy() {
					this._command("destroy")
				}
				reset() {
					this._command("reset"), (this._started = !1)
				}
				setPosition(n) {
					this._command("setPosition", n)
				}
				getPosition() {
					return this._renderer.engine.players[+this.id]?.getPosition() ?? 0
				}
			}
			function CJ(t, n, e, i, r) {
				return t.setProperty(n, `@@${e}:${i}`, r)
			}
			const EJ = "@.disabled"
			let oHe = (() => {
				class t {
					constructor(e, i, r) {
						;(this.delegate = e),
							(this.engine = i),
							(this._zone = r),
							(this._currentId = 0),
							(this._microtaskId = 1),
							(this._animationCallbacksBuffer = []),
							(this._rendererCache = new Map()),
							(this._cdRecurDepth = 0),
							(i.onRemovalComplete = (o, s) => {
								const a = s?.parentNode(o)
								a && s.removeChild(a, o)
							})
					}
					createRenderer(e, i) {
						const o = this.delegate.createRenderer(e, i)
						if (!(e && i && i.data && i.data.animation)) {
							let d = this._rendererCache.get(o)
							return (
								d || ((d = new MJ("", o, this.engine, () => this._rendererCache.delete(o))), this._rendererCache.set(o, d)),
								d
							)
						}
						const s = i.id,
							a = i.id + "-" + this._currentId
						this._currentId++, this.engine.register(a, e)
						const c = d => {
							Array.isArray(d) ? d.forEach(c) : this.engine.registerTrigger(s, a, e, d.name, d)
						}
						return i.data.animation.forEach(c), new sHe(this, a, o, this.engine)
					}
					begin() {
						this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
					}
					_scheduleCountTask() {
						queueMicrotask(() => {
							this._microtaskId++
						})
					}
					scheduleListenerCallback(e, i, r) {
						e >= 0 && e < this._microtaskId
							? this._zone.run(() => i(r))
							: (0 == this._animationCallbacksBuffer.length &&
									queueMicrotask(() => {
										this._zone.run(() => {
											this._animationCallbacksBuffer.forEach(o => {
												const [s, a] = o
												s(a)
											}),
												(this._animationCallbacksBuffer = [])
										})
									}),
							  this._animationCallbacksBuffer.push([i, r]))
					}
					end() {
						this._cdRecurDepth--,
							0 == this._cdRecurDepth &&
								this._zone.runOutsideAngular(() => {
									this._scheduleCountTask(), this.engine.flush(this._microtaskId)
								}),
							this.delegate.end && this.delegate.end()
					}
					whenRenderingDone() {
						return this.engine.whenRenderingDone()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(Y_), re(cT), re(mn))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			class MJ {
				constructor(n, e, i, r) {
					;(this.namespaceId = n), (this.delegate = e), (this.engine = i), (this._onDestroy = r)
				}
				get data() {
					return this.delegate.data
				}
				destroyNode(n) {
					this.delegate.destroyNode?.(n)
				}
				destroy() {
					this.engine.destroy(this.namespaceId, this.delegate),
						this.engine.afterFlushAnimationsDone(() => {
							queueMicrotask(() => {
								this.delegate.destroy()
							})
						}),
						this._onDestroy?.()
				}
				createElement(n, e) {
					return this.delegate.createElement(n, e)
				}
				createComment(n) {
					return this.delegate.createComment(n)
				}
				createText(n) {
					return this.delegate.createText(n)
				}
				appendChild(n, e) {
					this.delegate.appendChild(n, e), this.engine.onInsert(this.namespaceId, e, n, !1)
				}
				insertBefore(n, e, i, r = !0) {
					this.delegate.insertBefore(n, e, i), this.engine.onInsert(this.namespaceId, e, n, r)
				}
				removeChild(n, e, i) {
					this.engine.onRemove(this.namespaceId, e, this.delegate)
				}
				selectRootElement(n, e) {
					return this.delegate.selectRootElement(n, e)
				}
				parentNode(n) {
					return this.delegate.parentNode(n)
				}
				nextSibling(n) {
					return this.delegate.nextSibling(n)
				}
				setAttribute(n, e, i, r) {
					this.delegate.setAttribute(n, e, i, r)
				}
				removeAttribute(n, e, i) {
					this.delegate.removeAttribute(n, e, i)
				}
				addClass(n, e) {
					this.delegate.addClass(n, e)
				}
				removeClass(n, e) {
					this.delegate.removeClass(n, e)
				}
				setStyle(n, e, i, r) {
					this.delegate.setStyle(n, e, i, r)
				}
				removeStyle(n, e, i) {
					this.delegate.removeStyle(n, e, i)
				}
				setProperty(n, e, i) {
					"@" == e.charAt(0) && e == EJ ? this.disableAnimations(n, !!i) : this.delegate.setProperty(n, e, i)
				}
				setValue(n, e) {
					this.delegate.setValue(n, e)
				}
				listen(n, e, i) {
					return this.delegate.listen(n, e, i)
				}
				disableAnimations(n, e) {
					this.engine.disableAnimations(n, e)
				}
			}
			class sHe extends MJ {
				constructor(n, e, i, r, o) {
					super(e, i, r, o), (this.factory = n), (this.namespaceId = e)
				}
				setProperty(n, e, i) {
					"@" == e.charAt(0)
						? "." == e.charAt(1) && e == EJ
							? this.disableAnimations(n, (i = void 0 === i || !!i))
							: this.engine.process(this.namespaceId, n, e.slice(1), i)
						: this.delegate.setProperty(n, e, i)
				}
				listen(n, e, i) {
					if ("@" == e.charAt(0)) {
						const r = (function aHe(t) {
							switch (t) {
								case "body":
									return document.body
								case "document":
									return document
								case "window":
									return window
								default:
									return t
							}
						})(n)
						let o = e.slice(1),
							s = ""
						return (
							"@" != o.charAt(0) &&
								([o, s] = (function cHe(t) {
									const n = t.indexOf(".")
									return [t.substring(0, n), t.slice(n + 1)]
								})(o)),
							this.engine.listen(this.namespaceId, r, o, s, a => {
								this.factory.scheduleListenerCallback(a._data || -1, i, a)
							})
						)
					}
					return this.delegate.listen(n, e, i)
				}
			}
			let lHe = (() => {
				class t extends cT {
					constructor(e, i, r, o) {
						super(e.body, i, r)
					}
					ngOnDestroy() {
						this.flush()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(wi), re(_3), re(F3), re(wm))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const SJ = [
					{ provide: c9, useClass: nHe },
					{
						provide: F3,
						useFactory: function dHe() {
							return new T4e()
						}
					},
					{ provide: cT, useClass: lHe },
					{
						provide: Y_,
						useFactory: function uHe(t, n, e) {
							return new oHe(t, n, e)
						},
						deps: [W2, cT, mn]
					}
				],
				kJ = [{ provide: _3, useClass: nJ }, { provide: Bo, useValue: "NoopAnimations" }, ...SJ]
			let O3 = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵmod = at({ type: t })
					}
					static {
						this.ɵinj = rt({ providers: kJ, imports: [bz] })
					}
				}
				return t
			})()
			const TJ = ["*"],
				BJ = ["unscopedContent"],
				fHe = ["text"],
				mHe = [
					[
						["", "matListItemAvatar", ""],
						["", "matListItemIcon", ""]
					],
					[["", "matListItemTitle", ""]],
					[["", "matListItemLine", ""]],
					"*",
					[["", "matListItemMeta", ""]],
					[["mat-divider"]]
				],
				pHe = [
					"[matListItemAvatar],[matListItemIcon]",
					"[matListItemTitle]",
					"[matListItemLine]",
					"*",
					"[matListItemMeta]",
					"mat-divider"
				],
				IJ = new He("ListOption")
			let DJ = (() => {
					class t {
						constructor(e) {
							this._elementRef = e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "matListItemTitle", ""]],
								hostAttrs: [1, "mat-mdc-list-item-title", "mdc-list-item__primary-text"]
							})
						}
					}
					return t
				})(),
				LJ = (() => {
					class t {
						constructor(e) {
							this._elementRef = e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "matListItemLine", ""]],
								hostAttrs: [1, "mat-mdc-list-item-line", "mdc-list-item__secondary-text"]
							})
						}
					}
					return t
				})(),
				DHe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "matListItemMeta", ""]],
								hostAttrs: [1, "mat-mdc-list-item-meta", "mdc-list-item__end"]
							})
						}
					}
					return t
				})(),
				RJ = (() => {
					class t {
						constructor(e) {
							this._listOption = e
						}
						_isAlignedAtStart() {
							return !this._listOption || "after" === this._listOption?._getTogglePosition()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(IJ, 8))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								hostVars: 4,
								hostBindings: function (i, r) {
									2 & i && Zt("mdc-list-item__start", r._isAlignedAtStart())("mdc-list-item__end", !r._isAlignedAtStart())
								}
							})
						}
					}
					return t
				})(),
				LHe = (() => {
					class t extends RJ {
						static {
							this.ɵfac = (function () {
								let e
								return function (r) {
									return (e || (e = gr(t)))(r || t)
								}
							})()
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "matListItemAvatar", ""]],
								hostAttrs: [1, "mat-mdc-list-item-avatar"],
								features: [pn]
							})
						}
					}
					return t
				})(),
				RHe = (() => {
					class t extends RJ {
						static {
							this.ɵfac = (function () {
								let e
								return function (r) {
									return (e || (e = gr(t)))(r || t)
								}
							})()
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["", "matListItemIcon", ""]],
								hostAttrs: [1, "mat-mdc-list-item-icon"],
								features: [pn]
							})
						}
					}
					return t
				})()
			const PHe = new He("MAT_LIST_CONFIG")
			let zb = (() => {
					class t {
						constructor() {
							;(this._isNonInteractive = !0),
								(this._disableRipple = !1),
								(this._disabled = !1),
								(this._defaultOptions = Rt(PHe, { optional: !0 }))
						}
						get disableRipple() {
							return this._disableRipple
						}
						set disableRipple(e) {
							this._disableRipple = Mn(e)
						}
						get disabled() {
							return this._disabled
						}
						set disabled(e) {
							this._disabled = Mn(e)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								hostVars: 1,
								hostBindings: function (i, r) {
									2 & i && qn("aria-disabled", r.disabled)
								},
								inputs: { disableRipple: "disableRipple", disabled: "disabled" }
							})
						}
					}
					return t
				})(),
				N3 = (() => {
					class t {
						set lines(e) {
							;(this._explicitLines = to(e, null)), this._updateItemLines(!1)
						}
						get disableRipple() {
							return this.disabled || this._disableRipple || this._noopAnimations || !!this._listBase?.disableRipple
						}
						set disableRipple(e) {
							this._disableRipple = Mn(e)
						}
						get disabled() {
							return this._disabled || !!this._listBase?.disabled
						}
						set disabled(e) {
							this._disabled = Mn(e)
						}
						get rippleDisabled() {
							return this.disableRipple || !!this.rippleConfig.disabled
						}
						constructor(e, i, r, o, s, a) {
							;(this._elementRef = e),
								(this._ngZone = i),
								(this._listBase = r),
								(this._platform = o),
								(this._explicitLines = null),
								(this._disableRipple = !1),
								(this._disabled = !1),
								(this._subscriptions = new D()),
								(this._rippleRenderer = null),
								(this._hasUnscopedTextContent = !1),
								(this.rippleConfig = s || {}),
								(this._hostElement = this._elementRef.nativeElement),
								(this._isButtonElement = "button" === this._hostElement.nodeName.toLowerCase()),
								(this._noopAnimations = "NoopAnimations" === a),
								r && !r._isNonInteractive && this._initInteractiveListItem(),
								this._isButtonElement &&
									!this._hostElement.hasAttribute("type") &&
									this._hostElement.setAttribute("type", "button")
						}
						ngAfterViewInit() {
							this._monitorProjectedLinesAndTitle(), this._updateItemLines(!0)
						}
						ngOnDestroy() {
							this._subscriptions.unsubscribe(), null !== this._rippleRenderer && this._rippleRenderer._removeTriggerEvents()
						}
						_hasIconOrAvatar() {
							return !(!this._avatars.length && !this._icons.length)
						}
						_initInteractiveListItem() {
							this._hostElement.classList.add("mat-mdc-list-item-interactive"),
								(this._rippleRenderer = new Tv(this, this._ngZone, this._hostElement, this._platform)),
								this._rippleRenderer.setupTriggerEvents(this._hostElement)
						}
						_monitorProjectedLinesAndTitle() {
							this._ngZone.runOutsideAngular(() => {
								this._subscriptions.add(
									oo(this._lines.changes, this._titles.changes).subscribe(() => this._updateItemLines(!1))
								)
							})
						}
						_updateItemLines(e) {
							if (!this._lines || !this._titles || !this._unscopedContent) return
							e && this._checkDomForUnscopedTextContent()
							const i = this._explicitLines ?? this._inferLinesFromContent(),
								r = this._unscopedContent.nativeElement
							if (
								(this._hostElement.classList.toggle("mat-mdc-list-item-single-line", i <= 1),
								this._hostElement.classList.toggle("mdc-list-item--with-one-line", i <= 1),
								this._hostElement.classList.toggle("mdc-list-item--with-two-lines", 2 === i),
								this._hostElement.classList.toggle("mdc-list-item--with-three-lines", 3 === i),
								this._hasUnscopedTextContent)
							) {
								const o = 0 === this._titles.length && 1 === i
								r.classList.toggle("mdc-list-item__primary-text", o),
									r.classList.toggle("mdc-list-item__secondary-text", !o)
							} else r.classList.remove("mdc-list-item__primary-text"), r.classList.remove("mdc-list-item__secondary-text")
						}
						_inferLinesFromContent() {
							let e = this._titles.length + this._lines.length
							return this._hasUnscopedTextContent && (e += 1), e
						}
						_checkDomForUnscopedTextContent() {
							this._hasUnscopedTextContent = Array.from(this._unscopedContent.nativeElement.childNodes)
								.filter(e => e.nodeType !== e.COMMENT_NODE)
								.some(e => !(!e.textContent || !e.textContent.trim()))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(mn), P(zb, 8), P(Wr), P(vg, 8), P(Bo, 8))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								contentQueries: function (i, r, o) {
									if ((1 & i && (yr(o, LHe, 4), yr(o, RHe, 4)), 2 & i)) {
										let s
										sn((s = an())) && (r._avatars = s), sn((s = an())) && (r._icons = s)
									}
								},
								hostVars: 4,
								hostBindings: function (i, r) {
									2 & i &&
										(qn("aria-disabled", r.disabled)("disabled", (r._isButtonElement && r.disabled) || null),
										Zt("mdc-list-item--disabled", r.disabled))
								},
								inputs: { lines: "lines", disableRipple: "disableRipple", disabled: "disabled" }
							})
						}
					}
					return t
				})(),
				PJ = (() => {
					class t extends zb {
						static {
							this.ɵfac = (function () {
								let e
								return function (r) {
									return (e || (e = gr(t)))(r || t)
								}
							})()
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-list"]],
								hostAttrs: [1, "mat-mdc-list", "mat-mdc-list-base", "mdc-list"],
								exportAs: ["matList"],
								features: [Xn([{ provide: zb, useExisting: t }]), pn],
								ngContentSelectors: TJ,
								decls: 1,
								vars: 0,
								template: function (i, r) {
									1 & i && (co(), Ln(0))
								},
								styles: [
									'@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-list-divider::after{content:"";display:block;border-bottom-width:1px;border-bottom-style:solid}}.mdc-list{margin:0;padding:8px 0;list-style-type:none}.mdc-list:focus{outline:none}.mdc-list-item__wrapper{display:block}.mdc-list-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;align-items:stretch;cursor:pointer}.mdc-list-item:focus{outline:none}.mdc-list-item.mdc-list-item--with-one-line{height:48px}.mdc-list-item.mdc-list-item--with-two-lines{height:64px}.mdc-list-item.mdc-list-item--with-three-lines{height:88px}.mdc-list-item.mdc-list-item--with-one-line .mdc-list-item__start{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--with-three-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--with-one-line .mdc-list-item__end{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-two-lines .mdc-list-item__end{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--disabled,.mdc-list-item.mdc-list-item--non-interactive{cursor:auto}.mdc-list-item:not(.mdc-list-item--selected):focus::before,.mdc-list-item.mdc-ripple-upgraded--background-focused::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-list-item:not(.mdc-list-item--selected):focus::before,.mdc-list-item.mdc-ripple-upgraded--background-focused::before{border-color:CanvasText}}.mdc-list-item.mdc-list-item--selected::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:3px double rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-list-item.mdc-list-item--selected::before{border-color:CanvasText}}.mdc-list-item.mdc-list-item--selected:focus::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:3px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-list-item.mdc-list-item--selected:focus::before{border-color:CanvasText}}a.mdc-list-item{color:inherit;text-decoration:none}.mdc-list-item__start{fill:currentColor;flex-shrink:0;pointer-events:none}.mdc-list-item__end{flex-shrink:0;pointer-events:none}.mdc-list-item__content{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;align-self:center;flex:1;pointer-events:none}.mdc-list-item--with-two-lines .mdc-list-item__content,.mdc-list-item--with-three-lines .mdc-list-item__content{align-self:stretch}.mdc-list-item__content[for]{pointer-events:none}.mdc-list-item__primary-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.mdc-list-item--with-two-lines .mdc-list-item__primary-text,.mdc-list-item--with-three-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before,.mdc-list-item--with-three-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after,.mdc-list-item--with-three-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item__secondary-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;display:block;margin-top:0;line-height:normal}.mdc-list-item__secondary-text::before{display:inline-block;width:0;height:20px;content:"";vertical-align:0}.mdc-list-item--with-three-lines .mdc-list-item__secondary-text{white-space:normal;line-height:20px}.mdc-list-item--with-overline .mdc-list-item__secondary-text{white-space:nowrap;line-height:auto}.mdc-list-item__overline-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:24px;content:"";vertical-align:0}.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-three-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-three-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-three-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-avatar.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-list-item--with-leading-avatar.mdc-list-item,.mdc-list-item--with-leading-avatar.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-avatar .mdc-list-item__start{margin-left:16px;margin-right:16px}[dir=rtl] .mdc-list-item--with-leading-avatar .mdc-list-item__start,.mdc-list-item--with-leading-avatar .mdc-list-item__start[dir=rtl]{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-avatar .mdc-list-item__start{border-radius:50%}.mdc-list-item--with-leading-icon.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-list-item--with-leading-icon.mdc-list-item,.mdc-list-item--with-leading-icon.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-icon .mdc-list-item__start{margin-left:16px;margin-right:32px}[dir=rtl] .mdc-list-item--with-leading-icon .mdc-list-item__start,.mdc-list-item--with-leading-icon .mdc-list-item__start[dir=rtl]{margin-left:32px;margin-right:16px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-thumbnail.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-list-item--with-leading-thumbnail.mdc-list-item,.mdc-list-item--with-leading-thumbnail.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-thumbnail .mdc-list-item__start{margin-left:16px;margin-right:16px}[dir=rtl] .mdc-list-item--with-leading-thumbnail .mdc-list-item__start,.mdc-list-item--with-leading-thumbnail .mdc-list-item__start[dir=rtl]{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-image.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-list-item--with-leading-image.mdc-list-item,.mdc-list-item--with-leading-image.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-image .mdc-list-item__start{margin-left:16px;margin-right:16px}[dir=rtl] .mdc-list-item--with-leading-image .mdc-list-item__start,.mdc-list-item--with-leading-image .mdc-list-item__start[dir=rtl]{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-image.mdc-list-item--with-one-line{height:72px}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-video.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-list-item--with-leading-video.mdc-list-item,.mdc-list-item--with-leading-video.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-video .mdc-list-item__start{margin-left:0;margin-right:16px}[dir=rtl] .mdc-list-item--with-leading-video .mdc-list-item__start,.mdc-list-item--with-leading-video .mdc-list-item__start[dir=rtl]{margin-left:16px;margin-right:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-video.mdc-list-item--with-one-line{height:72px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-checkbox.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-list-item--with-leading-checkbox.mdc-list-item,.mdc-list-item--with-leading-checkbox.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-checkbox .mdc-list-item__start{margin-left:8px;margin-right:24px}[dir=rtl] .mdc-list-item--with-leading-checkbox .mdc-list-item__start,.mdc-list-item--with-leading-checkbox .mdc-list-item__start[dir=rtl]{margin-left:24px;margin-right:8px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-radio.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-list-item--with-leading-radio.mdc-list-item,.mdc-list-item--with-leading-radio.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-radio .mdc-list-item__start{margin-left:8px;margin-right:24px}[dir=rtl] .mdc-list-item--with-leading-radio .mdc-list-item__start,.mdc-list-item--with-leading-radio .mdc-list-item__start[dir=rtl]{margin-left:24px;margin-right:8px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-switch.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-list-item--with-leading-switch.mdc-list-item,.mdc-list-item--with-leading-switch.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-switch .mdc-list-item__start{margin-left:16px;margin-right:16px}[dir=rtl] .mdc-list-item--with-leading-switch .mdc-list-item__start,.mdc-list-item--with-leading-switch .mdc-list-item__start[dir=rtl]{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-trailing-icon.mdc-list-item{padding-left:auto;padding-right:0}[dir=rtl] .mdc-list-item--with-trailing-icon.mdc-list-item,.mdc-list-item--with-trailing-icon.mdc-list-item[dir=rtl]{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-icon .mdc-list-item__end{margin-left:16px;margin-right:16px}[dir=rtl] .mdc-list-item--with-trailing-icon .mdc-list-item__end,.mdc-list-item--with-trailing-icon .mdc-list-item__end[dir=rtl]{margin-left:16px;margin-right:16px}.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end{align-self:flex-start;margin-top:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:0}.mdc-list-item--with-trailing-meta.mdc-list-item{padding-left:auto;padding-right:0}[dir=rtl] .mdc-list-item--with-trailing-meta.mdc-list-item,.mdc-list-item--with-trailing-meta.mdc-list-item[dir=rtl]{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-meta .mdc-list-item__end{margin-left:28px;margin-right:16px}[dir=rtl] .mdc-list-item--with-trailing-meta .mdc-list-item__end,.mdc-list-item--with-trailing-meta .mdc-list-item__end[dir=rtl]{margin-left:16px;margin-right:28px}.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-trailing-meta .mdc-list-item__end{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mdc-typography-caption-font-family);font-size:var(--mdc-typography-caption-font-size);line-height:var(--mdc-typography-caption-line-height);font-weight:var(--mdc-typography-caption-font-weight);letter-spacing:var(--mdc-typography-caption-letter-spacing);text-decoration:var(--mdc-typography-caption-text-decoration);text-transform:var(--mdc-typography-caption-text-transform)}.mdc-list-item--with-trailing-checkbox.mdc-list-item{padding-left:auto;padding-right:0}[dir=rtl] .mdc-list-item--with-trailing-checkbox.mdc-list-item,.mdc-list-item--with-trailing-checkbox.mdc-list-item[dir=rtl]{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-checkbox .mdc-list-item__end{margin-left:24px;margin-right:8px}[dir=rtl] .mdc-list-item--with-trailing-checkbox .mdc-list-item__end,.mdc-list-item--with-trailing-checkbox .mdc-list-item__end[dir=rtl]{margin-left:8px;margin-right:24px}.mdc-list-item--with-trailing-checkbox.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:8px}.mdc-list-item--with-trailing-radio.mdc-list-item{padding-left:auto;padding-right:0}[dir=rtl] .mdc-list-item--with-trailing-radio.mdc-list-item,.mdc-list-item--with-trailing-radio.mdc-list-item[dir=rtl]{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-radio .mdc-list-item__end{margin-left:24px;margin-right:8px}[dir=rtl] .mdc-list-item--with-trailing-radio .mdc-list-item__end,.mdc-list-item--with-trailing-radio .mdc-list-item__end[dir=rtl]{margin-left:8px;margin-right:24px}.mdc-list-item--with-trailing-radio.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:8px}.mdc-list-item--with-trailing-switch.mdc-list-item{padding-left:auto;padding-right:0}[dir=rtl] .mdc-list-item--with-trailing-switch.mdc-list-item,.mdc-list-item--with-trailing-switch.mdc-list-item[dir=rtl]{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-switch .mdc-list-item__end{margin-left:16px;margin-right:16px}[dir=rtl] .mdc-list-item--with-trailing-switch .mdc-list-item__end,.mdc-list-item--with-trailing-switch .mdc-list-item__end[dir=rtl]{margin-left:16px;margin-right:16px}.mdc-list-item--with-trailing-switch.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:16px}.mdc-list-item--with-overline.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-overline.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:20px;content:"";vertical-align:0}.mdc-list-item--with-overline.mdc-list-item--with-three-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-overline.mdc-list-item--with-three-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:20px;content:"";vertical-align:0}.mdc-list-item{padding-left:16px;padding-right:16px}[dir=rtl] .mdc-list-item,.mdc-list-item[dir=rtl]{padding-left:16px;padding-right:16px}.mdc-list-group .mdc-deprecated-list{padding:0}.mdc-list-group__subheader{margin:calc((3rem - 1.5rem)/2) 16px}.mdc-list-divider{padding:0;background-clip:content-box}.mdc-list-divider.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset{padding-left:16px;padding-right:auto}[dir=rtl] .mdc-list-divider.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset,.mdc-list-divider.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset[dir=rtl]{padding-left:auto;padding-right:16px}.mdc-list-divider.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset{padding-left:auto;padding-right:16px}[dir=rtl] .mdc-list-divider.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset,.mdc-list-divider.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset[dir=rtl]{padding-left:16px;padding-right:auto}.mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset{padding-left:0px;padding-right:auto}[dir=rtl] .mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset[dir=rtl]{padding-left:auto;padding-right:0px}[dir=rtl] .mdc-list-divider,.mdc-list-divider[dir=rtl]{padding:0}.mdc-list-item{background-color:var(--mdc-list-list-item-container-color)}.mdc-list-item.mdc-list-item--selected{background-color:var(--mdc-list-list-item-selected-container-color)}.mdc-list-item--with-one-line{border-radius:var(--mdc-list-list-item-container-shape)}.mdc-list-item--with-one-line.mdc-list-item--with-leading-avatar,.mdc-list-item--with-one-line.mdc-list-item--with-leading-icon,.mdc-list-item--with-one-line.mdc-list-item--with-leading-thumbnail,.mdc-list-item--with-one-line.mdc-list-item--with-leading-checkbox,.mdc-list-item--with-one-line.mdc-list-item--with-leading-radio,.mdc-list-item--with-one-line.mdc-list-item--with-leading-switch{border-radius:var(--mdc-list-list-item-container-shape)}.mdc-list-item--with-one-line.mdc-list-item--with-leading-image,.mdc-list-item--with-one-line.mdc-list-item--with-leading-video{border-radius:var(--mdc-list-list-item-container-shape)}.mdc-list-item--with-two-lines{border-radius:var(--mdc-list-list-item-container-shape)}.mdc-list-item--with-two-lines.mdc-list-item--with-leading-avatar,.mdc-list-item--with-two-lines.mdc-list-item--with-leading-icon,.mdc-list-item--with-two-lines.mdc-list-item--with-leading-thumbnail,.mdc-list-item--with-two-lines.mdc-list-item--with-leading-checkbox,.mdc-list-item--with-two-lines.mdc-list-item--with-leading-radio,.mdc-list-item--with-two-lines.mdc-list-item--with-leading-switch,.mdc-list-item--with-two-lines.mdc-list-item--with-leading-image,.mdc-list-item--with-two-lines.mdc-list-item--with-leading-video{border-radius:var(--mdc-list-list-item-container-shape)}.mdc-list-item--with-three-lines{border-radius:var(--mdc-list-list-item-container-shape)}.mdc-list-item.mdc-list-item--with-one-line{height:var(--mdc-list-list-item-one-line-container-height)}.mdc-list-item.mdc-list-item--with-two-lines{height:var(--mdc-list-list-item-two-line-container-height)}.mdc-list-item.mdc-list-item--with-three-lines{height:var(--mdc-list-list-item-three-line-container-height)}.mdc-list-item__primary-text{color:var(--mdc-list-list-item-label-text-color)}.mdc-list-item__primary-text{font-family:var(--mdc-list-list-item-label-text-font);line-height:var(--mdc-list-list-item-label-text-line-height);font-size:var(--mdc-list-list-item-label-text-size);font-weight:var(--mdc-list-list-item-label-text-weight);letter-spacing:var(--mdc-list-list-item-label-text-tracking)}.mdc-list-item__secondary-text{color:var(--mdc-list-list-item-supporting-text-color)}.mdc-list-item__secondary-text{font-family:var(--mdc-list-list-item-supporting-text-font);line-height:var(--mdc-list-list-item-supporting-text-line-height);font-size:var(--mdc-list-list-item-supporting-text-size);font-weight:var(--mdc-list-list-item-supporting-text-weight);letter-spacing:var(--mdc-list-list-item-supporting-text-tracking)}.mdc-list-item--with-leading-icon .mdc-list-item__start{color:var(--mdc-list-list-item-leading-icon-color)}.mdc-list-item--with-leading-icon .mdc-list-item__start{width:var(--mdc-list-list-item-leading-icon-size);height:var(--mdc-list-list-item-leading-icon-size)}.mdc-list-item--with-leading-icon .mdc-list-item__start>i{font-size:var(--mdc-list-list-item-leading-icon-size)}.mdc-list-item--with-leading-icon .mdc-list-item__start .mdc-list-item__icon{font-size:var(--mdc-list-list-item-leading-icon-size);width:var(--mdc-list-list-item-leading-icon-size);height:var(--mdc-list-list-item-leading-icon-size)}.mdc-list-item--with-leading-icon .mdc-list-item__start .mdc-list-item__icon,.mdc-list-item--with-leading-icon .mdc-list-item__start .mdc-list-item__icon>.materialdesignWizIconSvgsSvgIcon{display:block}.mdc-list-item--with-leading-avatar .mdc-list-item__start{width:var(--mdc-list-list-item-leading-avatar-size);height:var(--mdc-list-list-item-leading-avatar-size)}.mdc-list-item.mdc-list-item--with-trailing-meta .mdc-list-item__end{color:var(--mdc-list-list-item-trailing-supporting-text-color)}.mdc-list-item--with-trailing-meta .mdc-list-item__end{font-family:var(--mdc-list-list-item-trailing-supporting-text-font);line-height:var(--mdc-list-list-item-trailing-supporting-text-line-height);font-size:var(--mdc-list-list-item-trailing-supporting-text-size);font-weight:var(--mdc-list-list-item-trailing-supporting-text-weight);letter-spacing:var(--mdc-list-list-item-trailing-supporting-text-tracking)}.mdc-list-item--with-trailing-icon .mdc-list-item__end{color:var(--mdc-list-list-item-trailing-icon-color)}.mdc-list-item--with-trailing-icon .mdc-list-item__end{width:var(--mdc-list-list-item-trailing-icon-size);height:var(--mdc-list-list-item-trailing-icon-size)}.mdc-list-item--with-trailing-icon .mdc-list-item__end>i{font-size:var(--mdc-list-list-item-trailing-icon-size)}.mdc-list-item--with-trailing-icon .mdc-list-item__end .mdc-list-item__icon{font-size:var(--mdc-list-list-item-trailing-icon-size);width:var(--mdc-list-list-item-trailing-icon-size);height:var(--mdc-list-list-item-trailing-icon-size)}.mdc-list-item--with-trailing-icon .mdc-list-item__end .mdc-list-item__icon,.mdc-list-item--with-trailing-icon .mdc-list-item__end .mdc-list-item__icon>.materialdesignWizIconSvgsSvgIcon{display:block}.mdc-list-item--selected.mdc-list-item--with-trailing-icon .mdc-list-item__end{color:var(--mdc-list-list-item-selected-trailing-icon-color)}.mdc-list-item--disabled .mdc-list-item__start,.mdc-list-item--disabled .mdc-list-item__content,.mdc-list-item--disabled .mdc-list-item__end{opacity:1}.mdc-list-item--disabled .mdc-list-item__primary-text,.mdc-list-item--disabled .mdc-list-item__secondary-text,.mdc-list-item--disabled .mdc-list-item__overline-text{opacity:var(--mdc-list-list-item-disabled-label-text-opacity)}.mdc-list-item--disabled.mdc-list-item--with-leading-icon .mdc-list-item__start{color:var(--mdc-list-list-item-disabled-leading-icon-color)}.mdc-list-item--disabled.mdc-list-item--with-leading-icon .mdc-list-item__start{opacity:var(--mdc-list-list-item-disabled-leading-icon-opacity)}.mdc-list-item--disabled.mdc-list-item--with-trailing-icon .mdc-list-item__end{color:var(--mdc-list-list-item-disabled-trailing-icon-color)}.mdc-list-item--disabled.mdc-list-item--with-trailing-icon .mdc-list-item__end{opacity:var(--mdc-list-list-item-disabled-trailing-icon-opacity)}.mdc-list-item:hover .mdc-list-item__primary-text{color:var(--mdc-list-list-item-hover-label-text-color)}.mdc-list-item--with-leading-icon:hover .mdc-list-item__start{color:var(--mdc-list-list-item-hover-leading-icon-color)}.mdc-list-item--with-trailing-icon:hover .mdc-list-item__end{color:var(--mdc-list-list-item-hover-trailing-icon-color)}.mdc-list-item:focus .mdc-list-item__primary-text{color:var(--mdc-list-list-item-focus-label-text-color)}.mdc-list-item.mdc-list-item--disabled .mdc-list-item__primary-text{color:var(--mdc-list-list-item-disabled-label-text-color)}.mdc-list-item:hover::before{background-color:var(--mdc-list-list-item-hover-state-layer-color);opacity:var(--mdc-list-list-item-hover-state-layer-opacity)}.mdc-list-item.mdc-list-item--disabled::before{background-color:var(--mdc-list-list-item-disabled-state-layer-color);opacity:var(--mdc-list-list-item-disabled-state-layer-opacity)}.mdc-list-item:focus::before{background-color:var(--mdc-list-list-item-focus-state-layer-color);opacity:var(--mdc-list-list-item-focus-state-layer-opacity)}.mdc-list-item--disabled .mdc-radio,.mdc-list-item--disabled .mdc-checkbox{opacity:var(--mdc-list-list-item-disabled-label-text-opacity)}.mdc-list-item--with-leading-avatar .mat-mdc-list-item-avatar{border-radius:var(--mdc-list-list-item-leading-avatar-shape);background-color:var(--mdc-list-list-item-leading-avatar-color)}.mat-mdc-list-base{--mdc-list-list-item-container-shape:0;--mdc-list-list-item-leading-avatar-shape:50%;--mdc-list-list-item-container-color:transparent;--mdc-list-list-item-selected-container-color:transparent;--mdc-list-list-item-leading-avatar-color:transparent;--mdc-list-list-item-leading-icon-size:24px;--mdc-list-list-item-leading-avatar-size:40px;--mdc-list-list-item-trailing-icon-size:24px;--mdc-list-list-item-disabled-state-layer-color:transparent;--mdc-list-list-item-disabled-state-layer-opacity:0;--mdc-list-list-item-disabled-label-text-opacity:0.38;--mdc-list-list-item-disabled-leading-icon-opacity:0.38;--mdc-list-list-item-disabled-trailing-icon-opacity:0.38}.cdk-high-contrast-active a.mdc-list-item--activated::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active a.mdc-list-item--activated [dir=rtl]::after{right:auto;left:16px}.mat-mdc-list-base{display:block}.mat-mdc-list-base .mdc-list-item__start,.mat-mdc-list-base .mdc-list-item__end,.mat-mdc-list-base .mdc-list-item__content{pointer-events:auto}.mat-mdc-list-item,.mat-mdc-list-option{width:100%;box-sizing:border-box;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-list-item:not(.mat-mdc-list-item-interactive),.mat-mdc-list-option:not(.mat-mdc-list-item-interactive){cursor:default}.mat-mdc-list-item .mat-divider-inset,.mat-mdc-list-option .mat-divider-inset{position:absolute;left:0;right:0;bottom:0}.mat-mdc-list-item .mat-mdc-list-item-avatar~.mat-divider-inset,.mat-mdc-list-option .mat-mdc-list-item-avatar~.mat-divider-inset{margin-left:72px}[dir=rtl] .mat-mdc-list-item .mat-mdc-list-item-avatar~.mat-divider-inset,[dir=rtl] .mat-mdc-list-option .mat-mdc-list-item-avatar~.mat-divider-inset{margin-right:72px}.mat-mdc-list-item-interactive::before{top:0;left:0;right:0;bottom:0;position:absolute;content:"";opacity:0;pointer-events:none}.mat-mdc-list-item>.mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-list-item:focus>.mat-mdc-focus-indicator::before{content:""}.mat-mdc-list-item.mdc-list-item--with-three-lines .mat-mdc-list-item-line.mdc-list-item__secondary-text{white-space:nowrap;line-height:normal}.mat-mdc-list-item.mdc-list-item--with-three-lines .mat-mdc-list-item-unscoped-content.mdc-list-item__secondary-text{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:rgba(0,0,0,0);text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}'
								],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				OJ = (() => {
					class t extends N3 {
						get activated() {
							return this._activated
						}
						set activated(e) {
							this._activated = Mn(e)
						}
						constructor(e, i, r, o, s, a) {
							super(e, i, r, o, s, a), (this._activated = !1)
						}
						_getAriaCurrent() {
							return "A" === this._hostElement.nodeName && this._activated ? "page" : null
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(wn), P(mn), P(zb, 8), P(Wr), P(vg, 8), P(Bo, 8))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-list-item"], ["a", "mat-list-item", ""], ["button", "mat-list-item", ""]],
								contentQueries: function (i, r, o) {
									if ((1 & i && (yr(o, LJ, 5), yr(o, DJ, 5), yr(o, DHe, 5)), 2 & i)) {
										let s
										sn((s = an())) && (r._lines = s), sn((s = an())) && (r._titles = s), sn((s = an())) && (r._meta = s)
									}
								},
								viewQuery: function (i, r) {
									if ((1 & i && (_i(BJ, 5), _i(fHe, 5)), 2 & i)) {
										let o
										sn((o = an())) && (r._unscopedContent = o.first), sn((o = an())) && (r._itemText = o.first)
									}
								},
								hostAttrs: [1, "mat-mdc-list-item", "mdc-list-item"],
								hostVars: 11,
								hostBindings: function (i, r) {
									2 & i &&
										(qn("aria-current", r._getAriaCurrent()),
										Zt("mdc-list-item--activated", r.activated)(
											"mdc-list-item--with-leading-avatar",
											0 !== r._avatars.length
										)("mdc-list-item--with-leading-icon", 0 !== r._icons.length)(
											"mdc-list-item--with-trailing-meta",
											0 !== r._meta.length
										)("_mat-animation-noopable", r._noopAnimations))
								},
								inputs: { activated: "activated" },
								exportAs: ["matListItem"],
								features: [pn],
								ngContentSelectors: pHe,
								decls: 10,
								vars: 0,
								consts: [
									[1, "mdc-list-item__content"],
									[1, "mat-mdc-list-item-unscoped-content", 3, "cdkObserveContent"],
									["unscopedContent", ""],
									[1, "mat-mdc-focus-indicator"]
								],
								template: function (i, r) {
									1 & i &&
										(co(mHe),
										Ln(0),
										F(1, "span", 0),
										Ln(2, 1),
										Ln(3, 2),
										F(4, "span", 1, 2),
										Le("cdkObserveContent", function () {
											return r._updateItemLines(!0)
										}),
										Ln(6, 3),
										L()(),
										Ln(7, 4),
										Ln(8, 5),
										fe(9, "div", 3))
								},
								dependencies: [kG],
								encapsulation: 2,
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				UJ = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [zD, Ot, Yi, Vh, t9, kO] })
						}
					}
					return t
				})(),
				VHe = 0
			const U3 = new He("CdkAccordion")
			let QHe = (() => {
					class t {
						constructor() {
							;(this._stateChanges = new vt()),
								(this._openCloseAllActions = new vt()),
								(this.id = "cdk-accordion-" + VHe++),
								(this._multi = !1)
						}
						get multi() {
							return this._multi
						}
						set multi(e) {
							this._multi = Mn(e)
						}
						openAll() {
							this._multi && this._openCloseAllActions.next(!0)
						}
						closeAll() {
							this._openCloseAllActions.next(!1)
						}
						ngOnChanges(e) {
							this._stateChanges.next(e)
						}
						ngOnDestroy() {
							this._stateChanges.complete(), this._openCloseAllActions.complete()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["cdk-accordion"], ["", "cdkAccordion", ""]],
								inputs: { multi: "multi" },
								exportAs: ["cdkAccordion"],
								features: [Xn([{ provide: U3, useExisting: t }]), Ar]
							})
						}
					}
					return t
				})(),
				zHe = 0,
				GHe = (() => {
					class t {
						get expanded() {
							return this._expanded
						}
						set expanded(e) {
							;(e = Mn(e)),
								this._expanded !== e &&
									((this._expanded = e),
									this.expandedChange.emit(e),
									e
										? (this.opened.emit(),
										  this._expansionDispatcher.notify(this.id, this.accordion ? this.accordion.id : this.id))
										: this.closed.emit(),
									this._changeDetectorRef.markForCheck())
						}
						get disabled() {
							return this._disabled
						}
						set disabled(e) {
							this._disabled = Mn(e)
						}
						constructor(e, i, r) {
							;(this.accordion = e),
								(this._changeDetectorRef = i),
								(this._expansionDispatcher = r),
								(this._openCloseAllSubscription = D.EMPTY),
								(this.closed = new _n()),
								(this.opened = new _n()),
								(this.destroyed = new _n()),
								(this.expandedChange = new _n()),
								(this.id = "cdk-accordion-child-" + zHe++),
								(this._expanded = !1),
								(this._disabled = !1),
								(this._removeUniqueSelectionListener = () => {}),
								(this._removeUniqueSelectionListener = r.listen((o, s) => {
									this.accordion &&
										!this.accordion.multi &&
										this.accordion.id === s &&
										this.id !== o &&
										(this.expanded = !1)
								})),
								this.accordion && (this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions())
						}
						ngOnDestroy() {
							this.opened.complete(),
								this.closed.complete(),
								this.destroyed.emit(),
								this.destroyed.complete(),
								this._removeUniqueSelectionListener(),
								this._openCloseAllSubscription.unsubscribe()
						}
						toggle() {
							this.disabled || (this.expanded = !this.expanded)
						}
						close() {
							this.disabled || (this.expanded = !1)
						}
						open() {
							this.disabled || (this.expanded = !0)
						}
						_subscribeToOpenCloseAllActions() {
							return this.accordion._openCloseAllActions.subscribe(e => {
								this.disabled || (this.expanded = e)
							})
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(U3, 12), P(Jr), P(AX))
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["cdk-accordion-item"], ["", "cdkAccordionItem", ""]],
								inputs: { expanded: "expanded", disabled: "disabled" },
								outputs: { closed: "closed", opened: "opened", destroyed: "destroyed", expandedChange: "expandedChange" },
								exportAs: ["cdkAccordionItem"],
								features: [Xn([{ provide: U3, useValue: void 0 }])]
							})
						}
					}
					return t
				})(),
				$He = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})()
			const WHe = ["body"]
			function jHe(t, n) {}
			const KHe = [[["mat-expansion-panel-header"]], "*", [["mat-action-row"]]],
				XHe = ["mat-expansion-panel-header", "*", "mat-action-row"]
			function YHe(t, n) {
				1 & t && fe(0, "span", 2), 2 & t && U("@indicatorRotate", Te()._getExpandedState())
			}
			const qHe = [[["mat-panel-title"]], [["mat-panel-description"]], "*"],
				ZHe = ["mat-panel-title", "mat-panel-description", "*"],
				H3 = new He("MAT_ACCORDION"),
				HJ = "225ms cubic-bezier(0.4,0.0,0.2,1)",
				VJ = {
					indicatorRotate: Mu("indicatorRotate", [
						Pc("collapsed, void", wo({ transform: "rotate(0deg)" })),
						Pc("expanded", wo({ transform: "rotate(180deg)" })),
						tc("expanded <=> collapsed, void => collapsed", Rc(HJ))
					]),
					bodyExpansion: Mu("bodyExpansion", [
						Pc("collapsed, void", wo({ height: "0px", visibility: "hidden" })),
						Pc("expanded", wo({ height: "*", visibility: "" })),
						tc("expanded <=> collapsed, void => collapsed", Rc(HJ))
					])
				},
				QJ = new He("MAT_EXPANSION_PANEL")
			let JHe = (() => {
					class t {
						constructor(e, i) {
							;(this._template = e), (this._expansionPanel = i)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Za), P(QJ, 8))
							}
						}
						static {
							this.ɵdir = yt({ type: t, selectors: [["ng-template", "matExpansionPanelContent", ""]] })
						}
					}
					return t
				})(),
				e5e = 0
			const zJ = new He("MAT_EXPANSION_PANEL_DEFAULT_OPTIONS")
			let GJ = (() => {
				class t extends GHe {
					get hideToggle() {
						return this._hideToggle || (this.accordion && this.accordion.hideToggle)
					}
					set hideToggle(e) {
						this._hideToggle = Mn(e)
					}
					get togglePosition() {
						return this._togglePosition || (this.accordion && this.accordion.togglePosition)
					}
					set togglePosition(e) {
						this._togglePosition = e
					}
					constructor(e, i, r, o, s, a, c) {
						super(e, i, r),
							(this._viewContainerRef = o),
							(this._animationMode = a),
							(this._hideToggle = !1),
							(this.afterExpand = new _n()),
							(this.afterCollapse = new _n()),
							(this._inputChanges = new vt()),
							(this._headerId = "mat-expansion-panel-header-" + e5e++),
							(this._bodyAnimationDone = new vt()),
							(this.accordion = e),
							(this._document = s),
							this._bodyAnimationDone
								.pipe(Ys((l, d) => l.fromState === d.fromState && l.toState === d.toState))
								.subscribe(l => {
									"void" !== l.fromState &&
										("expanded" === l.toState
											? this.afterExpand.emit()
											: "collapsed" === l.toState && this.afterCollapse.emit())
								}),
							c && (this.hideToggle = c.hideToggle)
					}
					_hasSpacing() {
						return !!this.accordion && this.expanded && "default" === this.accordion.displayMode
					}
					_getExpandedState() {
						return this.expanded ? "expanded" : "collapsed"
					}
					toggle() {
						this.expanded = !this.expanded
					}
					close() {
						this.expanded = !1
					}
					open() {
						this.expanded = !0
					}
					ngAfterContentInit() {
						this._lazyContent &&
							this._lazyContent._expansionPanel === this &&
							this.opened
								.pipe(
									hd(null),
									xi(() => this.expanded && !this._portal),
									Do(1)
								)
								.subscribe(() => {
									this._portal = new yv(this._lazyContent._template, this._viewContainerRef)
								})
					}
					ngOnChanges(e) {
						this._inputChanges.next(e)
					}
					ngOnDestroy() {
						super.ngOnDestroy(), this._bodyAnimationDone.complete(), this._inputChanges.complete()
					}
					_containsFocus() {
						if (this._body) {
							const e = this._document.activeElement,
								i = this._body.nativeElement
							return e === i || i.contains(e)
						}
						return !1
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(H3, 12), P(Jr), P(AX), P(ra), P(wi), P(Bo, 8), P(zJ, 8))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["mat-expansion-panel"]],
							contentQueries: function (i, r, o) {
								if ((1 & i && yr(o, JHe, 5), 2 & i)) {
									let s
									sn((s = an())) && (r._lazyContent = s.first)
								}
							},
							viewQuery: function (i, r) {
								if ((1 & i && _i(WHe, 5), 2 & i)) {
									let o
									sn((o = an())) && (r._body = o.first)
								}
							},
							hostAttrs: [1, "mat-expansion-panel"],
							hostVars: 6,
							hostBindings: function (i, r) {
								2 & i &&
									Zt("mat-expanded", r.expanded)("_mat-animation-noopable", "NoopAnimations" === r._animationMode)(
										"mat-expansion-panel-spacing",
										r._hasSpacing()
									)
							},
							inputs: {
								disabled: "disabled",
								expanded: "expanded",
								hideToggle: "hideToggle",
								togglePosition: "togglePosition"
							},
							outputs: {
								opened: "opened",
								closed: "closed",
								expandedChange: "expandedChange",
								afterExpand: "afterExpand",
								afterCollapse: "afterCollapse"
							},
							exportAs: ["matExpansionPanel"],
							features: [
								Xn([
									{ provide: H3, useValue: void 0 },
									{ provide: QJ, useExisting: t }
								]),
								pn,
								Ar
							],
							ngContentSelectors: XHe,
							decls: 7,
							vars: 4,
							consts: [
								["role", "region", 1, "mat-expansion-panel-content", 3, "id"],
								["body", ""],
								[1, "mat-expansion-panel-body"],
								[3, "cdkPortalOutlet"]
							],
							template: function (i, r) {
								1 & i &&
									(co(KHe),
									Ln(0),
									F(1, "div", 0, 1),
									Le("@bodyExpansion.done", function (s) {
										return r._bodyAnimationDone.next(s)
									}),
									F(3, "div", 2),
									Ln(4, 1),
									Ee(5, jHe, 0, 0, "ng-template", 3),
									L(),
									Ln(6, 2),
									L()),
									2 & i &&
										(T(1),
										U("@bodyExpansion", r._getExpandedState())("id", r.id),
										qn("aria-labelledby", r._headerId),
										T(4),
										U("cdkPortalOutlet", r._portal))
							},
							dependencies: [BE],
							styles: [
								'.mat-expansion-panel{--mat-expansion-container-shape:4px;box-sizing:content-box;display:block;margin:0;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);position:relative;background:var(--mat-expansion-container-background-color);color:var(--mat-expansion-container-text-color);border-radius:var(--mat-expansion-container-shape)}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:var(--mat-expansion-container-shape);border-top-left-radius:var(--mat-expansion-container-shape)}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:var(--mat-expansion-container-shape);border-bottom-left-radius:var(--mat-expansion-container-shape)}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible;font-family:var(--mat-expansion-container-text-font);font-size:var(--mat-expansion-container-text-size);font-weight:var(--mat-expansion-container-text-weight);line-height:var(--mat-expansion-container-text-line-height);letter-spacing:var(--mat-expansion-container-text-tracking)}.mat-expansion-panel-content[style*="visibility: hidden"] *{visibility:hidden !important}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px;border-top-color:var(--mat-expansion-actions-divider-color)}.mat-action-row .mat-button-base,.mat-action-row .mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row .mat-button-base,[dir=rtl] .mat-action-row .mat-mdc-button-base{margin-left:0;margin-right:8px}'
							],
							encapsulation: 2,
							data: { animation: [VJ.bodyExpansion] },
							changeDetection: 0
						})
					}
				}
				return t
			})()
			class t5e {}
			const n5e = GE(t5e)
			let $J = (() => {
					class t extends n5e {
						constructor(e, i, r, o, s, a, c) {
							super(),
								(this.panel = e),
								(this._element = i),
								(this._focusMonitor = r),
								(this._changeDetectorRef = o),
								(this._animationMode = a),
								(this._parentChangeSubscription = D.EMPTY)
							const l = e.accordion ? e.accordion._stateChanges.pipe(xi(d => !(!d.hideToggle && !d.togglePosition))) : Ai
							;(this.tabIndex = parseInt(c || "") || 0),
								(this._parentChangeSubscription = oo(
									e.opened,
									e.closed,
									l,
									e._inputChanges.pipe(xi(d => !!(d.hideToggle || d.disabled || d.togglePosition)))
								).subscribe(() => this._changeDetectorRef.markForCheck())),
								e.closed.pipe(xi(() => e._containsFocus())).subscribe(() => r.focusVia(i, "program")),
								s && ((this.expandedHeight = s.expandedHeight), (this.collapsedHeight = s.collapsedHeight))
						}
						get disabled() {
							return this.panel.disabled
						}
						_toggle() {
							this.disabled || this.panel.toggle()
						}
						_isExpanded() {
							return this.panel.expanded
						}
						_getExpandedState() {
							return this.panel._getExpandedState()
						}
						_getPanelId() {
							return this.panel.id
						}
						_getTogglePosition() {
							return this.panel.togglePosition
						}
						_showToggle() {
							return !this.panel.hideToggle && !this.panel.disabled
						}
						_getHeaderHeight() {
							const e = this._isExpanded()
							return e && this.expandedHeight ? this.expandedHeight : !e && this.collapsedHeight ? this.collapsedHeight : null
						}
						_keydown(e) {
							switch (e.keyCode) {
								case 32:
								case 13:
									fl(e) || (e.preventDefault(), this._toggle())
									break
								default:
									return void (this.panel.accordion && this.panel.accordion._handleHeaderKeydown(e))
							}
						}
						focus(e, i) {
							e ? this._focusMonitor.focusVia(this._element, e, i) : this._element.nativeElement.focus(i)
						}
						ngAfterViewInit() {
							this._focusMonitor.monitor(this._element).subscribe(e => {
								e && this.panel.accordion && this.panel.accordion._handleHeaderFocus(this)
							})
						}
						ngOnDestroy() {
							this._parentChangeSubscription.unsubscribe(), this._focusMonitor.stopMonitoring(this._element)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(GJ, 1), P(wn), P(fd), P(Jr), P(zJ, 8), P(Bo, 8), Ma("tabindex"))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["mat-expansion-panel-header"]],
								hostAttrs: ["role", "button", 1, "mat-expansion-panel-header", "mat-focus-indicator"],
								hostVars: 15,
								hostBindings: function (i, r) {
									1 & i &&
										Le("click", function () {
											return r._toggle()
										})("keydown", function (s) {
											return r._keydown(s)
										}),
										2 & i &&
											(qn("id", r.panel._headerId)("tabindex", r.tabIndex)("aria-controls", r._getPanelId())(
												"aria-expanded",
												r._isExpanded()
											)("aria-disabled", r.panel.disabled),
											bi("height", r._getHeaderHeight()),
											Zt("mat-expanded", r._isExpanded())(
												"mat-expansion-toggle-indicator-after",
												"after" === r._getTogglePosition()
											)("mat-expansion-toggle-indicator-before", "before" === r._getTogglePosition())(
												"_mat-animation-noopable",
												"NoopAnimations" === r._animationMode
											))
								},
								inputs: { tabIndex: "tabIndex", expandedHeight: "expandedHeight", collapsedHeight: "collapsedHeight" },
								features: [pn],
								ngContentSelectors: ZHe,
								decls: 5,
								vars: 3,
								consts: [
									[1, "mat-content"],
									["class", "mat-expansion-indicator", 4, "ngIf"],
									[1, "mat-expansion-indicator"]
								],
								template: function (i, r) {
									1 & i && (co(qHe), F(0, "span", 0), Ln(1), Ln(2, 1), Ln(3, 2), L(), Ee(4, YHe, 1, 1, "span", 1)),
										2 & i && (Zt("mat-content-hide-toggle", !r._showToggle()), T(4), U("ngIf", r._showToggle()))
								},
								dependencies: [En],
								styles: [
									'.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit;transition:height 225ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mat-expansion-header-collapsed-state-height);font-family:var(--mat-expansion-header-text-font);font-size:var(--mat-expansion-header-text-size);font-weight:var(--mat-expansion-header-text-weight);line-height:var(--mat-expansion-header-text-line-height);letter-spacing:var(--mat-expansion-header-text-tracking)}.mat-expansion-panel-header.mat-expanded{height:var(--mat-expansion-header-expanded-state-height)}.mat-expansion-panel-header[aria-disabled=true]{color:var(--mat-expansion-header-disabled-state-text-color)}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:var(--mat-expansion-header-hover-state-layer-color)}@media(hover: none){.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:var(--mat-expansion-container-background-color)}}.mat-expansion-panel .mat-expansion-panel-header:not([aria-disabled=true]).cdk-keyboard-focused,.mat-expansion-panel .mat-expansion-panel-header:not([aria-disabled=true]).cdk-program-focused{background:var(--mat-expansion-header-focus-state-layer-color)}.mat-expansion-panel-header._mat-animation-noopable{transition:none}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-content.mat-content-hide-toggle{margin-right:8px}[dir=rtl] .mat-content.mat-content-hide-toggle{margin-right:0;margin-left:8px}.mat-expansion-toggle-indicator-before .mat-content.mat-content-hide-toggle{margin-left:24px;margin-right:0}[dir=rtl] .mat-expansion-toggle-indicator-before .mat-content.mat-content-hide-toggle{margin-right:24px;margin-left:0}.mat-expansion-panel-header-title{color:var(--mat-expansion-header-text-color)}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;flex-basis:0;margin-right:16px;align-items:center}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description{color:inherit}.mat-expansion-panel-header-description{flex-grow:2;color:var(--mat-expansion-header-description-color)}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle;color:var(--mat-expansion-header-indicator-color)}.cdk-high-contrast-active .mat-expansion-panel-content{border-top:1px solid;border-top-left-radius:0;border-top-right-radius:0}'
								],
								encapsulation: 2,
								data: { animation: [VJ.indicatorRotate] },
								changeDetection: 0
							})
						}
					}
					return t
				})(),
				i5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["mat-panel-title"]],
								hostAttrs: [1, "mat-expansion-panel-header-title"]
							})
						}
					}
					return t
				})(),
				r5e = (() => {
					class t extends QHe {
						constructor() {
							super(...arguments),
								(this._ownHeaders = new ym()),
								(this._hideToggle = !1),
								(this.displayMode = "default"),
								(this.togglePosition = "after")
						}
						get hideToggle() {
							return this._hideToggle
						}
						set hideToggle(e) {
							this._hideToggle = Mn(e)
						}
						ngAfterContentInit() {
							this._headers.changes.pipe(hd(this._headers)).subscribe(e => {
								this._ownHeaders.reset(e.filter(i => i.panel.accordion === this)), this._ownHeaders.notifyOnChanges()
							}),
								(this._keyManager = new jD(this._ownHeaders).withWrap().withHomeAndEnd())
						}
						_handleHeaderKeydown(e) {
							this._keyManager.onKeydown(e)
						}
						_handleHeaderFocus(e) {
							this._keyManager.updateActiveItem(e)
						}
						ngOnDestroy() {
							super.ngOnDestroy(), this._keyManager?.destroy(), this._ownHeaders.destroy()
						}
						static {
							this.ɵfac = (function () {
								let e
								return function (r) {
									return (e || (e = gr(t)))(r || t)
								}
							})()
						}
						static {
							this.ɵdir = yt({
								type: t,
								selectors: [["mat-accordion"]],
								contentQueries: function (i, r, o) {
									if ((1 & i && yr(o, $J, 5), 2 & i)) {
										let s
										sn((s = an())) && (r._headers = s)
									}
								},
								hostAttrs: [1, "mat-accordion"],
								hostVars: 2,
								hostBindings: function (i, r) {
									2 & i && Zt("mat-accordion-multi", r.multi)
								},
								inputs: {
									multi: "multi",
									hideToggle: "hideToggle",
									displayMode: "displayMode",
									togglePosition: "togglePosition"
								},
								exportAs: ["matAccordion"],
								features: [Xn([{ provide: H3, useExisting: t }]), pn]
							})
						}
					}
					return t
				})(),
				WJ = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Yi, $He, wv] })
						}
					}
					return t
				})()
			const o5e = [yY, UX, y9, kO, pX, jE, zX, yX, jE, QY, rY, ww, MO, $Z, UJ, WJ, WY, lY, O3, od]
			let Qi = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({
								imports: [O3, o5e, yY, UX, y9, kO, pX, jE, zX, yX, jE, QY, rY, ww, MO, $Z, UJ, WJ, WY, lY, O3, od]
							})
						}
					}
					return t
				})(),
				s5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				a5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot] })
						}
					}
					return t
				})(),
				jJ = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				V3 = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				c5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi, s5e, a5e, jJ, V3] })
						}
					}
					return t
				})(),
				l5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, gUe, c5e] })
						}
					}
					return t
				})(),
				$w = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [hk], imports: [Ot, Qi, od, V3] })
						}
					}
					return t
				})(),
				d5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, $w] })
						}
					}
					return t
				})(),
				u5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, d5e] })
						}
					}
					return t
				})(),
				KJ = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, OSe, Qi] })
						}
					}
					return t
				})(),
				XJ = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, KJ] })
						}
					}
					return t
				})(),
				h5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, XJ] })
						}
					}
					return t
				})(),
				Q3 = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, XJ] })
						}
					}
					return t
				})(),
				f5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi, h5e, Q3, V3] })
						}
					}
					return t
				})(),
				m5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				p5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot] })
						}
					}
					return t
				})(),
				YJ = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot] })
						}
					}
					return t
				})(),
				z3 = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, YJ] })
						}
					}
					return t
				})(),
				A5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, $w, z3] })
						}
					}
					return t
				})(),
				g5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, $w, z3] })
						}
					}
					return t
				})(),
				b5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, $w, z3] })
						}
					}
					return t
				})(),
				_5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, $w, YJ] })
						}
					}
					return t
				})(),
				v5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, od, N0, Qi] })
						}
					}
					return t
				})(),
				y5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [wO], imports: [Ot, Qi, v5e] })
						}
					}
					return t
				})(),
				Ww = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				dT = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Qi, Ot] })
						}
					}
					return t
				})(),
				w5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Ww, dT, Qi, Q3] })
						}
					}
					return t
				})(),
				x5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})()
			const C5e = Mt(cd, t => 0 === t.length)
			let E5e = (() => {
				class t {
					constructor(e) {
						this.hideBlacklistItemsIndicator$ = e.select(C5e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-search-panel-mode-selector"]],
							inputs: { searchPanelMode: "searchPanelMode", updateSearchPanelMode: "updateSearchPanelMode" },
							decls: 7,
							vars: 4,
							consts: [
								[3, "value"],
								["id", "tree-view", "value", "tree-view", 3, "click"],
								[1, "fa", "fa-sitemap"],
								["id", "blacklist", "value", "blacklist", 3, "click"],
								[1, "fa", "fa-eye-slash"],
								[1, "has-blacklist-items-indicator", 3, "hidden"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-button-toggle-group", 0)(1, "mat-button-toggle", 1),
									Le("click", function () {
										return r.updateSearchPanelMode("treeView")
									}),
									fe(2, "i", 2),
									L(),
									F(3, "mat-button-toggle", 3),
									Le("click", function () {
										return r.updateSearchPanelMode("blacklist")
									}),
									fe(4, "i", 4)(5, "div", 5),
									Me(6, "async"),
									L()()),
									2 & i && (U("value", r.searchPanelMode), T(5), U("hidden", De(6, 2, r.hideBlacklistItemsIndicator$)))
							},
							dependencies: [aO, cO, Bn],
							styles: [
								"cc-search-panel-mode-selector mat-button-toggle-group{height:100%;align-items:center;font-size:12px}cc-search-panel-mode-selector .has-blacklist-items-indicator{position:absolute;margin-left:18px;margin-top:-32px;border-radius:50%;background-color:red;width:5px;height:5px}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const qJ = t => Mt(cd, n => M5e(t, n)),
				M5e = (t, n) => {
					const e = n.filter(i => i.type === t)
					return e.sort((i, r) => i.path.localeCompare(r.path)), e
				}
			function S5e(t, n) {
				1 & t && (F(0, "mat-list-item"), ge(1, "Add pattern via search or node context-menu"), L())
			}
			function k5e(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-list-item", 5)(1, "button", 6),
						Le("click", function () {
							const o = rn(e).$implicit
							return on(Te(2).removeBlacklistEntry(o))
						}),
						fe(2, "em", 7),
						ge(3),
						L()()
				}
				if (2 & t) {
					const e = n.$implicit
					U("title", e.path), T(3), Vt(" ", e.path, " ")
				}
			}
			function T5e(t, n) {
				if ((1 & t && (F(0, "div"), Ee(1, S5e, 2, 0, "mat-list-item", 2), Ee(2, k5e, 4, 2, "mat-list-item", 4), L()), 2 & t)) {
					const e = n.$implicit
					T(1), U("ngIf", 0 === e.length), T(1), U("ngForOf", e)
				}
			}
			function F5e(t, n) {
				1 & t && (F(0, "mat-list-item"), ge(1, "Add pattern via search or node context-menu"), L())
			}
			function B5e(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-list-item", 5)(1, "button", 6),
						Le("click", function () {
							const o = rn(e).$implicit
							return on(Te(2).removeBlacklistEntry(o))
						}),
						fe(2, "em", 7),
						ge(3),
						L()()
				}
				if (2 & t) {
					const e = n.$implicit
					U("title", e.path), T(3), Vt(" ", e.path, " ")
				}
			}
			function I5e(t, n) {
				if ((1 & t && (F(0, "div"), Ee(1, F5e, 2, 0, "mat-list-item", 2), Ee(2, B5e, 4, 2, "mat-list-item", 4), L()), 2 & t)) {
					const e = n.$implicit
					T(1), U("ngIf", 0 === e.length), T(1), U("ngForOf", e)
				}
			}
			let D5e = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.flattenedItems$ = this.store.select(qJ("flatten"))),
								(this.excludedItems$ = this.store.select(qJ("exclude")))
						}
						removeBlacklistEntry(e) {
							this.store.dispatch(uE({ item: e }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-blacklist-panel"]],
								decls: 14,
								vars: 6,
								consts: [
									[1, "header-text"],
									[
										"matTooltip",
										"Flattened nodes are shown as flat/short buildings and are included in folder metrics",
										1,
										"fa",
										"fa-question-circle-o"
									],
									[4, "ngIf"],
									[
										"matTooltip",
										"Excluded buildings are not shown in the map and are not included in folder metrics",
										1,
										"fa",
										"fa-question-circle-o"
									],
									[3, "title", 4, "ngFor", "ngForOf"],
									[3, "title"],
									["mat-button", "", 3, "click"],
									["title", "Remove list item", 1, "fa", "fa-minus-square"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "mat-list")(1, "div")(2, "h3", 0),
										ge(3, "Flattened"),
										L(),
										fe(4, "em", 1),
										L(),
										Ee(5, T5e, 3, 2, "div", 2),
										Me(6, "async"),
										L(),
										F(7, "mat-list")(8, "div")(9, "h3", 0),
										ge(10, "Excluded"),
										L(),
										fe(11, "em", 3),
										L(),
										Ee(12, I5e, 3, 2, "div", 2),
										Me(13, "async"),
										L()),
										2 & i &&
											(T(5), U("ngIf", De(6, 2, r.flattenedItems$)), T(7), U("ngIf", De(13, 4, r.excludedItems$)))
								},
								dependencies: [_o, En, Qs, mX, PJ, OJ, Bn],
								styles: [
									"cc-blacklist-panel .header-text{display:inline-block;margin:0 .25em 0 0}cc-blacklist-panel mat-list.mat-mdc-list.mat-mdc-list-base mat-list-item{border-top:1px solid rgba(0,0,0,.12)}cc-blacklist-panel mat-list.mat-mdc-list.mat-mdc-list-base mat-list-item .mdc-list-item__content{padding:0}cc-blacklist-panel mat-list.mat-mdc-list.mat-mdc-list-base mat-list-item .mdc-list-item__content button{width:100%;text-align:start}cc-blacklist-panel mat-list.mat-mdc-list.mat-mdc-list-base mat-list-item .mdc-list-item__content button .fa{padding-right:8px}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				L5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				R5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				P5e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot] })
						}
					}
					return t
				})()
			const G3 = Mt(yb, t => "" === t || "!" === t || "," === t),
				uT = t =>
					(t = t.trim()).startsWith("*") ||
					t.endsWith("*") ||
					t.startsWith("/") ||
					t.startsWith("./") ||
					t.startsWith('"') ||
					t.endsWith('"') ||
					t.startsWith("!")
						? t
						: `*${t}*`,
				ZJ = (t, n, e) => {
					const i = e.trim().split(",")
					if (e.trim().startsWith("!")) {
						i[0] = i[0].slice(1)
						for (const r of i) {
							const o = `!${uT(r)}`
							if (t.some(s => o === s.path && n === s.type)) return !0
						}
						return !1
					}
					for (const r of i) if (t.some(o => uT(r) === o.path && n === o.type)) return !0
					return !1
				},
				O5e = Mt(yb, G3, cd, (t, n, e) => !!n || ZJ(e, "flatten", t)),
				N5e = Mt(yb, G3, cd, (t, n, e) => !!n || ZJ(e, "exclude", t)),
				U5e = (t, n) => {
					const e = [],
						i = n.split(",")
					if (i[0].startsWith("!")) {
						i[0] = i[0].slice(1)
						for (const r of i) r.length > 0 && e.push({ path: `!${uT(r)}`, type: t })
					} else
						for (let r of i)
							if (r.length > 0) {
								if (r.startsWith("!")) break
								;(r = uT(r)), e.push({ path: r, type: t })
							}
					return e
				},
				H5e = (t, n, e) => {
					const i = [...n, ...e]
					for (const { file: r } of t) if (!V5e(r, i)) return !1
					return !0
				},
				V5e = (t, n) => {
					for (const e of $r(t.map)) if (Q5e(e, n)) return !1
					return !0
				},
				Q5e = (t, n) => uo(t) && t.data.path && !vu(t.data.path, n, "exclude")
			let JJ = (() => {
					class t {
						constructor(e, i, r) {
							;(this.actions$ = e),
								(this.store = i),
								(this.dialog = r),
								(this.doBlacklistItemsResultInEmptyMap$ = this.actions$.pipe(
									dl(iD),
									mu(this.store.select(ld), this.store.select(cd)),
									Ke(([o, s, a]) => ({ items: o.items, resultsInEmptyMap: H5e(s, a, o.items) })),
									Rl()
								)),
								(this.showErrorDialogIfBlacklistItemsResultInEmptyMap$ = yo(
									() =>
										this.doBlacklistItemsResultInEmptyMap$.pipe(
											xi(o => o.resultsInEmptyMap),
											eo(() => {
												this.dialog.open(yg, {
													data: { title: "Blacklist Error", message: "Excluding all buildings is not possible." }
												})
											})
										),
									{ dispatch: !1 }
								)),
								(this.addBlacklistItems$ = yo(() =>
									this.doBlacklistItemsResultInEmptyMap$.pipe(
										xi(o => !o.resultsInEmptyMap),
										Ke(o => dE({ items: o.items }))
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(pu), re(Ct), re(la))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				G5e = (() => {
					class t {
						constructor(e, i, r) {
							;(this.actions$ = e),
								(this.store = i),
								(this.addBlacklistItemsIfNotResultsInEmptyMapEffect = r),
								(this.searchPattern2BlacklistItems$ = this.actions$.pipe(
									dl("BlacklistSearchPatternAction"),
									mu(this.store.select(yb)),
									Ke(([o, s]) => ({ type: o.action.type, blacklistItems: U5e(o.action.type, s) })),
									Rl()
								)),
								(this.flattenSearchPattern$ = yo(
									() =>
										this.searchPattern2BlacklistItems$.pipe(
											xi(o => "flatten" === o.type),
											eo(o => {
												this.store.dispatch(dE({ items: o.blacklistItems })), this.store.dispatch(Nh({ value: "" }))
											})
										),
									{ dispatch: !1 }
								)),
								(this.excludeSearchPattern$ = yo(() =>
									this.searchPattern2BlacklistItems$.pipe(
										xi(o => "exclude" === o.type),
										eo(() => {
											this.addBlacklistItemsIfNotResultsInEmptyMapEffect.doBlacklistItemsResultInEmptyMap$
												.pipe(
													Do(1),
													xi(o => !o.resultsInEmptyMap),
													eo(() => {
														this.store.dispatch(Nh({ value: "" }))
													})
												)
												.subscribe()
										}),
										Ke(o => iD({ items: o.blacklistItems }))
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(pu), re(Ct), re(JJ))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})()
			function $5e(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "button", 12),
						Le("click", function () {
							return rn(e), on(Te().resetSearchPattern())
						}),
						fe(1, "i", 13),
						L()
				}
			}
			let W5e = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.searchPattern$ = this.store.select(yb)),
							(this.isSearchPatternEmpty$ = this.store.select(G3)),
							(this.isFlattenPatternDisabled$ = this.store.select(O5e)),
							(this.isExcludePatternDisabled$ = this.store.select(N5e)),
							(this.setSearchPatternDebounced = Fd(i => this.setSearchPattern(i), 400))
					}
					setSearchPattern(e) {
						this.store.dispatch(Nh({ value: e.target.value }))
					}
					resetSearchPattern() {
						this.store.dispatch(Nh({ value: "" }))
					}
					blacklistSearchPattern(e) {
						this.store.dispatch((t => ({ type: "BlacklistSearchPatternAction", action: { type: t } }))(e))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-search-bar"]],
							decls: 21,
							vars: 13,
							consts: [
								[1, "fa", "fa-search", "search-icon"],
								[1, "ccSearchInput"],
								["type", "text", "placeholder", "Search: *.js, **/app/*", 3, "value", "input"],
								[
									"class",
									"small-action-button clear-icon",
									"data-testid",
									"search-bar-clear-button",
									3,
									"click",
									4,
									"ngIf"
								],
								["title", "Add to Blacklist", 1, "small-action-button", 3, "matMenuTriggerFor"],
								[1, "fa", "fa-ellipsis-h"],
								["menu", "matMenu"],
								["mat-menu-item", "", "disabled", ""],
								["mat-menu-item", "", "data-testid", "search-bar-flatten-button", 3, "disabled", "click"],
								[1, "fa", "fa-eye-slash"],
								["mat-menu-item", "", "data-testid", "search-bar-exclude-button", 3, "disabled", "click"],
								[1, "fa", "fa-ban"],
								["data-testid", "search-bar-clear-button", 1, "small-action-button", "clear-icon", 3, "click"],
								[1, "fa", "fa-times"]
							],
							template: function (i, r) {
								if (
									(1 & i &&
										(fe(0, "i", 0),
										F(1, "div", 1)(2, "input", 2),
										Le("input", function (s) {
											return r.setSearchPatternDebounced(s)
										}),
										Me(3, "async"),
										L(),
										Ee(4, $5e, 2, 0, "button", 3),
										Me(5, "async"),
										L(),
										F(6, "button", 4),
										fe(7, "i", 5),
										L(),
										F(8, "mat-menu", null, 6)(10, "button", 7),
										ge(11, "Add Pattern to Blacklist"),
										L(),
										fe(12, "mat-divider"),
										F(13, "button", 8),
										Le("click", function () {
											return r.blacklistSearchPattern("flatten")
										}),
										Me(14, "async"),
										fe(15, "i", 9),
										ge(16, " Flatten "),
										L(),
										F(17, "button", 10),
										Le("click", function () {
											return r.blacklistSearchPattern("exclude")
										}),
										Me(18, "async"),
										fe(19, "i", 11),
										ge(20, " Exclude "),
										L()()),
									2 & i)
								) {
									const o = br(9)
									T(2),
										U("value", De(3, 5, r.searchPattern$)),
										T(2),
										U("ngIf", !De(5, 7, r.isSearchPatternEmpty$)),
										T(2),
										U("matMenuTriggerFor", o),
										T(7),
										U("disabled", De(14, 9, r.isFlattenPatternDisabled$)),
										T(4),
										U("disabled", De(18, 11, r.isExcludePatternDisabled$))
								}
							},
							dependencies: [En, vw, nk, yw, SO, Bn],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-search-bar{display:inline-block}cc-search-bar .search-icon{margin-right:8px;min-width:16px}cc-search-bar .ccSearchInput{display:inline-block;position:relative}cc-search-bar .ccSearchInput input{width:204px;border-width:0 0 1px;border-color:#d3d3d3;outline:0;font-size:11pt;height:24px}cc-search-bar .ccSearchInput input:focus{border-color:#0374c9;box-shadow:0 1px #0374c9}cc-search-bar .ccSearchInput>*{vertical-align:middle;display:inline-block;position:relative;height:30px}cc-search-bar .ccSearchInput .clear-icon{position:absolute;right:0;margin:0;height:24px;width:24px;display:flex;justify-content:center;align-items:center;top:0}cc-search-bar .small-action-button{margin:0 5px}cc-search-bar button{background-color:transparent;box-shadow:none;margin-top:2px;font-size:14px}cc-search-bar button:hover{background-color:#d3d3d3;border-radius:50%}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const hT = (t, n, e) => n.reduce((i, r) => (vu(r.path, e, t) ? i + 1 : i), 0),
				j5e = Mt(jK, cd, VO, (t, n, e) => {
					const i = t.filter(r => uo(r))
					return {
						fileCount: `${i.length}/${e.length}`,
						flattenCount: `${hT("flatten", i, n)}/${hT("flatten", e, n)}`,
						excludeCount: `${hT("exclude", i, n)}/${hT("exclude", e, n)}`
					}
				}),
				eee = Mt(Tr, t => t.sortingOrderAscending)
			let K5e = (() => {
				class t {
					constructor(e) {
						this.store = e
					}
					ngOnInit() {
						this.sortingOrderAscending$ = this.store.select(eee)
					}
					onClick() {
						this.store.dispatch($O())
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-sorting-button"]],
							decls: 4,
							vars: 6,
							consts: [
								[1, "box-rounded", "submenu-button", 3, "title", "click"],
								[3, "className"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "button", 0),
									Le("click", function () {
										return r.onClick()
									}),
									Me(1, "async"),
									fe(2, "i", 1),
									Me(3, "async"),
									L()),
									2 & i &&
										(lu(
											"title",
											"Toggle sort order (currently ",
											De(1, 2, r.sortingOrderAscending$) ? "ascending" : "descending",
											")"
										),
										T(2),
										U(
											"className",
											De(3, 4, r.sortingOrderAscending$) ? "fa fa-sort-amount-asc" : "fa fa-sort-amount-desc"
										))
							},
							dependencies: [Bn],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const tee = Mt(cc, t => t.sortingOption)
			function X5e(t, n) {
				if ((1 & t && (F(0, "mat-option", 2), ge(1), L()), 2 & t)) {
					const e = n.$implicit
					U("value", e), T(1), Vt(" ", e, " ")
				}
			}
			let Y5e = (() => {
					class t {
						constructor(e) {
							;(this.store = e), (this.sortingOptions = Object.values(XE)), (this.selectedSortingOption$ = e.select(tee))
						}
						handleSelectedSortingOptionChanged(e) {
							this.store.dispatch(lE(e.value))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-sorting-option"]],
								decls: 3,
								vars: 4,
								consts: [
									["title", "Sort by", 1, "sorting-option-select", 3, "value", "selectionChange"],
									[3, "value", 4, "ngFor", "ngForOf"],
									[3, "value"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "mat-select", 0),
										Le("selectionChange", function (s) {
											return r.handleSelectedSortingOptionChanged(s)
										}),
										Me(1, "async"),
										Ee(2, X5e, 2, 2, "mat-option", 1),
										L()),
										2 & i && (U("value", De(1, 2, r.selectedSortingOption$)), T(2), U("ngForOf", r.sortingOptions))
								},
								dependencies: [_o, Fp, Qh, Bn],
								styles: [".sorting-option-select{max-width:88px}\n"],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				q5e = (() => {
					class t {
						constructor(e) {
							this.store = e
						}
						ngOnInit() {
							this.isSearchPanelPinned$ = this.store.select(GX)
						}
						onClick() {
							this.store.dispatch(dN())
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-thumb-tack-button"]],
								decls: 3,
								vars: 3,
								consts: [
									["title", "Pin file explorer", 1, "box-rounded", "submenu-button", 3, "ngClass", "click"],
									[1, "fa", "fa-thumb-tack"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.onClick()
										}),
										Me(1, "async"),
										fe(2, "i", 1),
										L()),
										2 & i && U("ngClass", De(1, 1, r.isSearchPanelPinned$) ? "pinned" : "")
								},
								dependencies: [Em, Bn],
								styles: [".pinned{background-color:#979797}\n"],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function Z5e(t, n) {
				if (
					(1 & t &&
						(Cr(0),
						F(1, "span", 1),
						ge(2),
						fe(3, "i", 2),
						L(),
						F(4, "span", 3),
						ge(5),
						fe(6, "img", 4),
						L(),
						F(7, "span", 5),
						ge(8),
						fe(9, "i", 6),
						L(),
						F(10, "div", 7),
						fe(11, "cc-thumb-tack-button"),
						L(),
						F(12, "div", 7),
						fe(13, "cc-sorting-button")(14, "cc-sorting-option"),
						L(),
						Er()),
					2 & t)
				) {
					const e = n.ngIf
					T(2), cr(e.fileCount), T(3), cr(e.flattenCount), T(3), cr(e.excludeCount)
				}
			}
			let J5e = (() => {
				class t {
					constructor(e) {
						this.matchingFileCounters$ = e.select(j5e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-matching-files-counter"]],
							decls: 2,
							vars: 3,
							consts: [
								[4, "ngIf"],
								["title", "Files matching search pattern", 1, "box-rounded", "node-count"],
								[1, "fa", "fa-file"],
								["title", "Files flattened", 1, "box-rounded", "node-count", 2, "display", "inline-flex"],
								["alt", "flattenIcon", "src", "codeCharta/assets/flatten.png", 1, "fa", "png-icon-files-counter"],
								["title", "Files excluded", 1, "box-rounded", "node-count"],
								[1, "fa", "fa-ban"],
								[1, "clickable-component"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, Z5e, 15, 3, "ng-container", 0), Me(1, "async")),
									2 & i && U("ngIf", De(1, 1, r.matchingFileCounters$))
							},
							dependencies: [En, K5e, Y5e, q5e, Bn],
							styles: [
								"cc-matching-files-counter .node-count{background:#eee;color:#000;padding:4px 8px;margin-right:8px}cc-matching-files-counter .node-count i{margin-left:6px}cc-matching-files-counter .box-rounded{display:inline-block;font-weight:400;line-height:17px;font-size:10pt;margin-top:2px;min-width:20px;border-radius:4px;text-align:center}cc-matching-files-counter .png-icon-files-counter{width:19px;height:16px;margin-left:6px}cc-matching-files-counter cc-thumb-tack-button button{height:25px;background:#e6e6e6;padding:1px 8px}cc-matching-files-counter cc-sorting-button button{height:25px;background:#e6e6e6;padding:1px 8px}cc-matching-files-counter cc-sorting-option .mat-mdc-select{width:105px;padding:2px 8px;font-weight:400;line-height:17px;font-size:10pt}cc-matching-files-counter .clickable-component{display:inline-block;color:#000;margin-left:-9px}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function qu(t) {
				if ("object" != typeof t) return t
				var n,
					e,
					i = Object.prototype.toString.call(t)
				if ("[object Object]" === i) {
					if (t.constructor !== Object && "function" == typeof t.constructor)
						for (n in ((e = new t.constructor()), t)) t.hasOwnProperty(n) && e[n] !== t[n] && (e[n] = qu(t[n]))
					else
						for (n in ((e = {}), t))
							"__proto__" === n
								? Object.defineProperty(e, n, { value: qu(t[n]), configurable: !0, enumerable: !0, writable: !0 })
								: (e[n] = qu(t[n]))
					return e
				}
				if ("[object Array]" === i) {
					for (n = t.length, e = Array(n); n--; ) e[n] = qu(t[n])
					return e
				}
				return "[object Set]" === i
					? ((e = new Set()),
					  t.forEach(function (r) {
							e.add(qu(r))
					  }),
					  e)
					: "[object Map]" === i
					? ((e = new Map()),
					  t.forEach(function (r, o) {
							e.set(qu(o), qu(r))
					  }),
					  e)
					: "[object Date]" === i
					? new Date(+t)
					: "[object RegExp]" === i
					? (((e = new RegExp(t.source, t.flags)).lastIndex = t.lastIndex), e)
					: "[object DataView]" === i
					? new t.constructor(qu(t.buffer))
					: "[object ArrayBuffer]" === i
					? t.slice(0)
					: "Array]" === i.slice(-6)
					? new t.constructor(t)
					: t
			}
			const eVe = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" }),
				tVe = (t, n) => eVe.compare(t.name, n.name),
				nVe = (t, n) => t.attributes.unary - n.attributes.unary,
				nee = (t, n, e) => {
					if (!t) return
					for (let r = 0; r < t.children.length; r++)
						t.children[r].type === Da.FOLDER && (t.children[r] = nee(t.children[r], n, e))
					const i = ((t, n) => {
						const e = t === XE.NUMBER_OF_FILES ? nVe : tVe
						return n ? e : (i, r) => -1 * e(i, r)
					})(n, e)
					return (
						(t.children = ((t, n) => {
							const e = [],
								i = []
							for (const r of n.children) r.type === Da.FOLDER ? e.push(r) : i.push(r)
							return e.sort(t), i.sort(t), [...e, ...i]
						})(i, t)),
						t
					)
				},
				oVe = Mt(Vc, tee, eee, (t, n, e) => nee(qu(t.unifiedMapNode), n, e)),
				iee = Mt(nO, t => t.rightClickedNodeData)
			let ree = (() => {
				class t {
					transform(e, i) {
						return $3(e, i)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵpipe = Zi({ name: "areaMetricValid", type: t, pure: !0 })
					}
				}
				return t
			})()
			function $3(t, n) {
				return t.deltas?.[n] < 0 || t.attributes?.[n] > 0
			}
			let sVe = (() => {
					class t {
						transform(e, i) {
							return uo(e) ? "fa fa-file-o" : i ? "fa fa-folder-open" : "fa fa-folder"
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "mapTreeViewItemIconClass", type: t, pure: !0 })
						}
					}
					return t
				})(),
				aVe = (() => {
					class t {
						static {
							this.defaultColor = "#000000"
						}
						static {
							this.areMetricZeroColor = "#BDBDBD"
						}
						constructor(e) {
							this.state = e
						}
						transform(e) {
							const { areaMetric: i } = this.state.getValue().dynamicSettings
							return $3(e, i)
								? uo(e)
									? void 0
									: vE(e, this.state.getValue().fileSettings.markedPackages) || t.defaultColor
								: t.areMetricZeroColor
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Sr, 16))
							}
						}
						static {
							this.ɵpipe = Zi({ name: "mapTreeViewItemIconColor", type: t, pure: !1 })
						}
					}
					return t
				})(),
				cVe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-map-tree-view-item-icon"]],
								inputs: { node: "node", isOpen: "isOpen" },
								decls: 3,
								vars: 9,
								consts: [["role", "img", "aria-hidden", "true"]],
								template: function (i, r) {
									1 & i && (F(0, "span", 0), Me(1, "mapTreeViewItemIconClass"), Me(2, "mapTreeViewItemIconColor"), L()),
										2 & i && (c0(lo(1, 4, r.node, r.isOpen)), bi("color", De(2, 7, r.node)))
								},
								dependencies: [sVe, aVe],
								encapsulation: 2
							})
						}
					}
					return t
				})()
			const lVe = Mt(Vc, t => t.unifiedMapNode?.attributes.unary)
			let oee = (() => {
				class t {
					transform(e) {
						return uo(e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵpipe = Zi({ name: "isNodeLeaf", type: t, pure: !0 })
					}
				}
				return t
			})()
			function dVe(t, n) {
				if ((1 & t && (F(0, "span"), ge(1), Me(2, "async"), L()), 2 & t)) {
					const e = Te(2)
					T(1), Vt("", ((100 * e.unaryValue) / De(2, 1, e.rootUnary$)).toFixed(0), "%")
				}
			}
			function uVe(t, n) {
				1 & t && ge(0, "File")
			}
			function hVe(t, n) {
				1 & t && ge(0, "Files")
			}
			function fVe(t, n) {
				if (
					(1 & t && (F(0, "span", 5), ge(1), Ee(2, uVe, 1, 0, "ng-template", 6), Ee(3, hVe, 1, 0, "ng-template", 7), L()), 2 & t)
				) {
					const e = Te(2)
					U("ngPlural", e.unaryValue), T(1), Vt(" ", e.unaryValue, " ")
				}
			}
			function mVe(t, n) {
				if ((1 & t && (F(0, "span", 2), Ee(1, dVe, 3, 3, "span", 3), Ee(2, fVe, 4, 2, "span", 4), L()), 2 & t)) {
					const e = Te()
					T(1), U("ngIf", !e.isHovered), T(1), U("ngIf", e.isHovered)
				}
			}
			let pVe = (() => {
				class t {
					constructor(e) {
						;(this.searchedNodePaths$ = e.select(XP)), (this.rootUnary$ = e.select(lVe)), (this.areaMetric$ = e.select(Cb))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-map-tree-view-item-name"]],
							inputs: { node: "node", isHovered: "isHovered", unaryValue: "unaryValue", unaryPercentage: "unaryPercentage" },
							decls: 7,
							vars: 17,
							consts: [
								[1, "node-name"],
								["class", "unary-number", 4, "ngIf"],
								[1, "unary-number"],
								[4, "ngIf"],
								[3, "ngPlural", 4, "ngIf"],
								[3, "ngPlural"],
								["ngPluralCase", "=1"],
								["ngPluralCase", "other"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "span", 0),
									Me(1, "areaMetricValid"),
									Me(2, "async"),
									Me(3, "async"),
									ge(4),
									L(),
									Ee(5, mVe, 3, 2, "span", 1),
									Me(6, "isNodeLeaf")),
									2 & i &&
										(Zt("flattened", r.node.isFlattened)("noAreaMetric", !lo(1, 8, r.node, De(2, 11, r.areaMetric$)))(
											"tree-search-result",
											De(3, 13, r.searchedNodePaths$).has(r.node.path)
										),
										T(4),
										Vt(" ", r.node.name, "\n"),
										T(1),
										U("ngIf", !De(6, 15, r.node)))
							},
							dependencies: [En, P2, XQ, Bn, ree, oee],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function AVe(t, n) {
				1 & t && fe(0, "i", 5)
			}
			let gVe = (() => {
				class t {
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-map-tree-view-item-option-buttons"]],
							inputs: { isFlattened: "isFlattened", openNodeContextMenu: "openNodeContextMenu" },
							decls: 5,
							vars: 1,
							consts: [
								["role", "button", "aria-hidden", "true", 1, "right-aligned"],
								["class", "flattened fa fa-eye-slash", "title", "Flattened", 4, "ngIf"],
								[1, "small-action-button"],
								["title", "Open Node-Context-Menu", 3, "click"],
								[1, "fa", "fa-ellipsis-h"],
								["title", "Flattened", 1, "flattened", "fa", "fa-eye-slash"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "span", 0),
									Ee(1, AVe, 1, 0, "i", 1),
									F(2, "div", 2)(3, "button", 3),
									Le("click", function (s) {
										return r.openNodeContextMenu(s)
									}),
									fe(4, "i", 4),
									L()()()),
									2 & i && (T(1), U("ngIf", r.isFlattened))
							},
							dependencies: [En],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function bVe(t, n) {
				if ((1 & t && fe(0, "cc-map-tree-view-item-option-buttons", 6), 2 & t)) {
					const e = Te(2)
					U("isFlattened", e.node.isFlattened)("openNodeContextMenu", e.openNodeContextMenu)
				}
			}
			function _Ve(t, n) {
				if ((1 & t && (F(0, "div"), fe(1, "cc-map-tree-view-level", 8), L()), 2 & t)) {
					const e = n.$implicit,
						i = Te(3)
					T(1), U("node", e)("depth", i.depth + 1)
				}
			}
			function vVe(t, n) {
				if ((1 & t && (Cr(0), Ee(1, _Ve, 2, 2, "div", 7), Er()), 2 & t)) {
					const e = Te(2)
					T(1), U("ngForOf", e.node.children)
				}
			}
			function yVe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div"),
						Me(1, "isNodeLeaf"),
						F(2, "div", 1),
						Le("mouseenter", function () {
							return rn(e), on(Te().onMouseEnter())
						})("mouseleave", function () {
							return rn(e), on(Te().onMouseLeave())
						})("click", function () {
							return rn(e), on(Te().onClick())
						})("contextmenu", function (r) {
							return rn(e), on(Te().openNodeContextMenu(r))
						}),
						Me(3, "async"),
						Me(4, "async"),
						Me(5, "areaMetricValid"),
						Me(6, "async"),
						fe(7, "cc-map-tree-view-item-icon", 2)(8, "cc-map-tree-view-item-name", 3),
						Me(9, "async"),
						Ee(10, bVe, 1, 2, "cc-map-tree-view-item-option-buttons", 4),
						Me(11, "async"),
						Me(12, "areaMetricValid"),
						Me(13, "async"),
						L(),
						F(14, "div"),
						Ee(15, vVe, 2, 1, "ng-container", 5),
						L()()
				}
				if (2 & t) {
					const e = Te()
					let i
					;(function v5(t, n, e, i, r) {
						sl(Es, ed, GA(bt(), t, n, e, i, r), !0)
					})("tree-element-", e.depth, " ", De(1, 23, e.node) ? "tree-leaf" : "tree-parent", ""),
						T(2),
						du("tree-element-label-", e.depth, " tree-element-label"),
						Zt("hovered", De(3, 25, e.hoveredNodeId$) === e.node.id)(
							"marked",
							(null == (i = De(4, 27, e.rightClickedNodeData$)) ? null : i.nodeId) === e.node.id
						),
						Fa("id", e.node.path),
						U("title", lo(5, 29, e.node, De(6, 32, e.areaMetric$)) ? "" : "No Node Area for Chosen Metric"),
						T(5),
						U("node", e.node)("isOpen", e.isOpen),
						T(1),
						U("node", e.node)("isHovered", De(9, 34, e.hoveredNodeId$) === e.node.id)("unaryValue", e.node.attributes.unary),
						T(2),
						U("ngIf", De(11, 36, e.hoveredNodeId$) === e.node.id && lo(12, 38, e.node, De(13, 41, e.areaMetric$))),
						T(4),
						du("tree-element-children tree-element-children-", e.depth, ""),
						T(1),
						U("ngIf", e.isOpen)
				}
			}
			let wVe = (() => {
				class t {
					constructor(e, i, r, o, s) {
						;(this.store = e),
							(this.threeSceneService = i),
							(this.idToBuildingService = r),
							(this.threeRendererService = o),
							(this.codeMapMouseEventService = s),
							(this.hoveredNodeId$ = this.store.select(mw)),
							(this.rightClickedNodeData$ = this.store.select(iee)),
							(this.areaMetric$ = this.store.select(Cb)),
							(this.isOpen = !1),
							(this.areMetricValid = !1),
							(this.openNodeContextMenu = a => {
								a.preventDefault(),
									a.stopPropagation(),
									this.areaMetric$.subscribe(c => (this.areMetricValid = $3(this.node, c))).unsubscribe(),
									this.areMetricValid &&
										(this.store.dispatch(
											xb({
												value: {
													nodeId: this.node.id,
													xPositionOfRightClickEvent: a.clientX,
													yPositionOfRightClickEvent: a.clientY
												}
											})
										),
										document.querySelector(".tree-element-0").addEventListener("scroll", this.scrollFunction))
							}),
							(this.scrollFunction = () => {
								this.store.dispatch(xb({ value: null })),
									document.querySelector(".tree-element-0").removeEventListener("scroll", this.scrollFunction)
							})
					}
					ngOnInit() {
						this.isOpen = 0 === this.depth
					}
					onMouseEnter() {
						const e = this.idToBuildingService.get(this.node.id),
							i = this.threeSceneService.labels?.children
						this.codeMapMouseEventService.setLabelHoveredLeaf(e, i),
							this.codeMapMouseEventService.hoverNode(this.node.id),
							this.store.dispatch(wb({ value: this.node.id }))
					}
					onMouseLeave() {
						this.threeSceneService.resetLabel(),
							this.codeMapMouseEventService.unhoverNode(),
							this.codeMapMouseEventService.clearLabelHoveredBuilding(),
							this.store.dispatch(wb({ value: null }))
					}
					onClick() {
						this.isOpen = !this.isOpen
						const e = this.idToBuildingService.get(this.node.id)
						this.codeMapMouseEventService.drawLabelSelectedBuilding(e),
							this.threeSceneService.selectBuilding(e),
							this.threeSceneService.clearConstantHighlight(),
							this.threeRendererService.render()
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct), P(Qc), P(lw), P(Ri), P(pw))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-map-tree-view-level"]],
							inputs: { node: "node", depth: "depth" },
							decls: 1,
							vars: 1,
							consts: [
								[3, "class", 4, "ngIf"],
								[3, "id", "title", "mouseenter", "mouseleave", "click", "contextmenu"],
								[3, "node", "isOpen"],
								[3, "node", "isHovered", "unaryValue"],
								[3, "isFlattened", "openNodeContextMenu", 4, "ngIf"],
								[4, "ngIf"],
								[3, "isFlattened", "openNodeContextMenu"],
								[4, "ngFor", "ngForOf"],
								[3, "node", "depth"]
							],
							template: function (i, r) {
								1 & i && Ee(0, yVe, 16, 43, "div", 0), 2 & i && U("ngIf", !r.node.isExcluded)
							},
							dependencies: [_o, En, cVe, pVe, gVe, t, Bn, ree, oee],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function xVe(t, n) {
				1 & t && fe(0, "cc-map-tree-view-level", 1), 2 & t && U("node", n.ngIf)("depth", 0)
			}
			let CVe = (() => {
					class t {
						constructor(e) {
							this.mapTreeViewNode$ = e.select(oVe)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-map-tree-view"]],
								decls: 2,
								vars: 3,
								consts: [
									[3, "node", "depth", 4, "ngIf"],
									[3, "node", "depth"]
								],
								template: function (i, r) {
									1 & i && (Ee(0, xVe, 1, 2, "cc-map-tree-view-level", 0), Me(1, "async")),
										2 & i && U("ngIf", De(1, 1, r.mapTreeViewNode$))
								},
								dependencies: [En, wVe, Bn],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-map-tree-view .tree-element-0{overflow-y:auto;max-height:400px;margin-left:3px;margin-top:10px}cc-map-tree-view .tree-element-0 div{margin:0;padding:0;position:relative}cc-map-tree-view .tree-element-0 .tree-element-children{margin-left:19px}cc-map-tree-view .tree-element-label{cursor:default}cc-map-tree-view .tree-element-label{cursor:pointer}cc-map-tree-view .tree-element-label:focus{outline:none}cc-map-tree-view .tree-element-label:hover,cc-map-tree-view .tree-element-label.hovered{background-color:#efefef;border-radius:2px}cc-map-tree-view .tree-element-label.marked{background-color:#efefef;border-radius:2px}cc-map-tree-view .tree-element-label .unary-number{color:#a3a3a3;font-size:.8em;margin-top:1px}cc-map-tree-view .tree-element-label .node-type-icon{display:inline-block;width:14px;margin-left:2px}cc-map-tree-view .tree-element-label .node-name.flattened{color:gray}cc-map-tree-view .tree-element-label .node-name.noAreaMetric{color:#bdbdbd}cc-map-tree-view .tree-element-label .right-aligned{position:absolute;right:6px}cc-map-tree-view .tree-element-label .right-aligned i.flattened{color:gray}cc-map-tree-view .tree-element-label .right-aligned .small-action-button button{min-height:0;width:100%;height:100%;margin:0;background-color:transparent;box-shadow:none}cc-map-tree-view .tree-element-label .right-aligned .small-action-button button:hover{background-color:#ddd}cc-map-tree-view .tree-element-label .right-aligned .small-action-button button i{position:absolute;top:2px;left:6px}cc-map-tree-view .tree-search-result{background-color:#fc801bab}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				EVe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi, L5e, R5e, P5e] })
						}
					}
					return t
				})()
			Uf($X, [rk, W5e, J5e, CVe, E5e, D5e], [])
			let MVe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi, dT, Ww] })
						}
					}
					return t
				})(),
				SVe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})(),
				see = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Qi, N0, od, Ot, ZD] })
						}
					}
					return t
				})(),
				kVe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Qi, N0, od, Ot, see] })
						}
					}
					return t
				})(),
				TVe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [FO] })
						}
					}
					return t
				})(),
				FVe = (() => {
					class t {
						constructor(e) {
							this.data = e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Bv))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-custom-config-note-dialog"]],
								decls: 11,
								vars: 2,
								consts: [
									[1, "custom-config-note-dialog-container"],
									["mat-dialog-content", "", 1, "note-input-container"],
									["appearance", "fill", 1, "note-input"],
									["matInput", "", "cdkAutosizeMinRows", "10", "cdkTextareaAutosize", "", 3, "ngModel", "ngModelChange"],
									["mat-dialog-actions", "", 1, "note-dialog-action-buttons"],
									[3, "mat-dialog-close"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "div", 0)(1, "div", 1)(2, "mat-form-field", 2)(3, "mat-label"),
										ge(4, "Custom Note"),
										L(),
										F(5, "textarea", 3),
										Le("ngModelChange", function (s) {
											return (r.data = s)
										}),
										L()()(),
										F(6, "div", 4)(7, "button", 5),
										ge(8, "Cancel"),
										L(),
										F(9, "button", 5),
										ge(10, "Ok"),
										L()()()),
										2 & i && (T(5), U("ngModel", r.data), T(4), U("mat-dialog-close", r.data))
								},
								dependencies: [Bd, yf, md, Hm, Vm, kp, sY, km, T0, P0],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-custom-config-note-dialog .custom-config-note-dialog-container{padding:20px 24px}cc-custom-config-note-dialog .custom-config-note-dialog-container .note-input-container{padding:0}cc-custom-config-note-dialog .custom-config-note-dialog-container .note-input-container .note-input{width:100%}cc-custom-config-note-dialog .custom-config-note-dialog-container .note-dialog-action-buttons{justify-content:flex-end;padding:0}cc-custom-config-note-dialog .custom-config-note-dialog-container button{padding:12px;margin:0 0 0 10px;color:#1b9cfc;background-color:#8a848414}cc-custom-config-note-dialog .custom-config-note-dialog-container button:hover{background-color:#0000000d;color:#1b9cfc}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				BVe = (() => {
					class t {
						constructor(e) {
							this.dialog = e
						}
						openDialog() {
							;(this.customConfigNote = this.customConfigItem.note),
								this.dialog
									.open(FVe, { width: "600px", data: this.customConfigNote })
									.afterClosed()
									.subscribe(i => {
										void 0 !== i &&
											this.customConfigNote !== i &&
											((this.customConfigNote = i), ki.editCustomConfigNote(this.customConfigItem.id, i))
									})
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(la))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-custom-config-note-dialog-button"]],
								inputs: { customConfigItem: "customConfigItem" },
								decls: 2,
								vars: 0,
								consts: [
									["title", "Edit/View Note", 1, "custom-config-note-dialog-button", 3, "click"],
									[1, "fa", "fa-pencil"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.openDialog()
										}),
										fe(1, "i", 1),
										L())
								},
								encapsulation: 2
							})
						}
					}
					return t
				})()
			function aee(t, n) {
				const { mapSelectionMode: e, assignedMaps: i } = xw(n),
					r = []
				for (const o of t.assignedMaps.keys()) i.has(o) || r.push(t.assignedMaps.get(o))
				return { mapSelectionMode: t.mapSelectionMode !== e ? t.mapSelectionMode : "", mapNames: r }
			}
			let IVe = (() => {
					class t {
						constructor(e) {
							this.state = e
						}
						transform(e) {
							const { mapSelectionMode: i, mapNames: r } = aee(e, this.state.getValue())
							return r.length > 0 || i.length > 0 ? "rgb(204, 204, 204)" : "rgba(0, 0, 0, 0.87)"
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Sr, 16))
							}
						}
						static {
							this.ɵpipe = Zi({ name: "customConfig2ApplicableColor", type: t, pure: !0 })
						}
					}
					return t
				})(),
				DVe = (() => {
					class t {
						transform(e) {
							const { mapColors: i, mapSelectionMode: r } = e
							return r === ak.MULTIPLE
								? [i.positive, i.neutral, i.negative, i.selected]
								: [i.positiveDelta, i.negativeDelta, i.selected]
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "customConfigColorSchemaBySelectionMode", type: t, pure: !0 })
						}
					}
					return t
				})()
			function LVe(t, n) {
				if ((1 & t && (F(0, "p", 2), fe(1, "i", 9), ge(2), L()), 2 & t)) {
					const e = Te()
					T(2), Vt(" ", e.customConfigItem.metrics.edgeMetric, " ")
				}
			}
			function RVe(t, n) {
				if ((1 & t && (F(0, "div", 10), fe(1, "span", 11), L()), 2 & t)) {
					const e = n.$implicit,
						i = Te()
					T(1), bi("background-color", i.customConfigItem.isApplicable ? e : "rgb(204, 204, 204)")
				}
			}
			let PVe = (() => {
					class t {
						constructor(e, i, r) {
							;(this.store = e), (this.threeCameraService = i), (this.threeOrbitControlsService = r)
						}
						applyCustomConfig() {
							ki.applyCustomConfig(
								this.customConfigItem.id,
								this.store,
								this.threeCameraService,
								this.threeOrbitControlsService
							)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct), P(Td), P(El))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-apply-custom-config-button"]],
								inputs: { customConfigItem: "customConfigItem" },
								decls: 16,
								vars: 13,
								consts: [
									["mat-dialog-close", "", 3, "disabled", "title", "click"],
									[1, "config-metric-list"],
									[1, "config-metric"],
									[1, "fa", "fa-arrows-alt"],
									[1, "fa", "fa-arrows-v"],
									[1, "fa", "fa-paint-brush"],
									["class", "config-metric", 4, "ngIf"],
									[1, "color-schema-container"],
									["class", "color-swatch-container", 4, "ngFor", "ngForOf"],
									[1, "fa", "fa-exchange"],
									[1, "color-swatch-container"],
									[1, "color-swatch"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.applyCustomConfig()
										}),
										Me(1, "customConfig2ApplicableColor"),
										F(2, "div", 1)(3, "p", 2),
										fe(4, "i", 3),
										ge(5),
										L(),
										F(6, "p", 2),
										fe(7, "i", 4),
										ge(8),
										L(),
										F(9, "p", 2),
										fe(10, "i", 5),
										ge(11),
										L(),
										Ee(12, LVe, 3, 1, "p", 6),
										F(13, "div", 7),
										Ee(14, RVe, 2, 2, "div", 8),
										Me(15, "customConfigColorSchemaBySelectionMode"),
										L()()()),
										2 & i &&
											(bi("color", De(1, 9, r.customConfigItem)),
											Fa("title", r.customConfigItem.name),
											U("disabled", !r.customConfigItem.isApplicable),
											T(5),
											Vt(" ", r.customConfigItem.metrics.areaMetric, ""),
											T(3),
											Vt(" ", r.customConfigItem.metrics.heightMetric, ""),
											T(3),
											Vt(" ", r.customConfigItem.metrics.colorMetric, ""),
											T(1),
											U("ngIf", r.customConfigItem.metrics.edgeMetric),
											T(2),
											U("ngForOf", De(15, 11, r.customConfigItem)))
								},
								dependencies: [md, _o, En, IVe, DVe],
								styles: [
									"cc-apply-custom-config-button{display:flex;flex:1}cc-apply-custom-config-button button{flex-direction:row;width:100%;margin:0}cc-apply-custom-config-button button:disabled{cursor:default}cc-apply-custom-config-button button .config-metric-list{display:flex;flex-wrap:wrap;gap:10px}cc-apply-custom-config-button button p{white-space:nowrap;text-overflow:ellipsis;overflow:hidden;font-size:15px;margin:0;text-align:left}cc-apply-custom-config-button button p.config-name{flex:1 1 auto;width:100%}cc-apply-custom-config-button button p.config-metric{flex:0 0 9em}cc-apply-custom-config-button button .color-schema-container{display:flex;align-items:center;gap:2px}cc-apply-custom-config-button button .color-schema-container .color-swatch-container .color-swatch{display:inline-block;width:16px;height:16px}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				OVe = (() => {
					class t {
						transform(e, i, r = "...") {
							return e.length > i ? e.slice(0, i) + r : e
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "truncateText", type: t, pure: !0 })
						}
					}
					return t
				})(),
				NVe = (() => {
					class t {
						constructor(e) {
							this.state = e
						}
						transform(e) {
							const { mapSelectionMode: i, mapNames: r } = aee(e, this.state.getValue())
							return r.length > 0 && i.length > 0
								? `This view is partially applicable. To complete your view, please switch to the ${i} mode and select the following map(s): ${r.join(
										", "
								  )}.`
								: r.length > 0
								? `To fulfill your view, please select the following map(s): ${r.join(", ")}.`
								: i.length > 0
								? `This view is partially applicable. To complete your view, please switch to the ${i} mode.`
								: "Apply Custom View"
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Sr, 16))
							}
						}
						static {
							this.ɵpipe = Zi({ name: "customConfig2ApplicableMessage", type: t, pure: !0 })
						}
					}
					return t
				})(),
				UVe = (() => {
					class t {
						transform(e, i) {
							const r = i.toLocaleLowerCase().trimEnd()
							return e.filter(o => this.isItemMatchingSearchTerm(o, r))
						}
						isItemMatchingSearchTerm(e, i) {
							const r = e.name.toLocaleLowerCase().includes(i),
								o = e.mapSelectionMode.toLocaleLowerCase().includes(i),
								s = Object.values(e.metrics).some(a => a?.toLocaleLowerCase().includes(i))
							return r || o || s
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "filterCustomConfigDataBySearchTerm", type: t, pure: !0 })
						}
					}
					return t
				})()
			const HVe = ["matExpansionPanel"]
			function VVe(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-list-item", 8),
						Me(1, "customConfig2ApplicableMessage"),
						F(2, "div", 9)(3, "p", 10)(4, "strong")(5, "span", 11),
						Le("click", function () {
							const o = rn(e).$implicit
							return on(Te(4).applyCustomConfig(o.id))
						}),
						ge(6),
						Me(7, "truncateText"),
						L()()()(),
						F(8, "div", 12)(9, "p", 13)(10, "span", 11),
						Le("click", function () {
							const o = rn(e).$implicit
							return on(Te(4).applyCustomConfig(o.id))
						}),
						ge(11),
						Me(12, "truncateText"),
						L()(),
						fe(13, "cc-custom-config-note-dialog-button", 14),
						L(),
						F(14, "div", 15),
						fe(15, "cc-apply-custom-config-button", 14),
						F(16, "button", 16),
						Le("click", function () {
							const o = rn(e).$implicit,
								s = Te(3).$implicit
							return on(Te().removeCustomConfig(o.id, s.key))
						}),
						fe(17, "i", 17),
						L()()()
				}
				if (2 & t) {
					const e = n.$implicit
					Fa("title", De(1, 6, e)),
						T(3),
						Fa("title", e.name),
						T(3),
						Vt(" ", lo(7, 8, e.name, 75), " "),
						T(5),
						Vt(" ", e.note ? lo(12, 11, e.note, 95) : "Add Note", " "),
						T(2),
						U("customConfigItem", e),
						T(2),
						U("customConfigItem", e)
				}
			}
			function QVe(t, n) {
				if ((1 & t && (F(0, "mat-list"), Ee(1, VVe, 18, 14, "mat-list-item", 7), L()), 2 & t)) {
					const e = Te().ngIf
					T(1), U("ngForOf", e)
				}
			}
			function zVe(t, n) {
				1 & t && (F(0, "div", 18)(1, "p"), ge(2, "No configurations found."), L()())
			}
			function GVe(t, n) {
				if ((1 & t && (Cr(0), Ee(1, QVe, 2, 1, "mat-list", 5), Ee(2, zVe, 3, 0, "div", 6), Er()), 2 & t)) {
					const e = n.ngIf
					T(1), U("ngIf", e.length > 0), T(1), U("ngIf", 0 === e.length)
				}
			}
			function $Ve(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "mat-expansion-panel", 1, 2)(2, "mat-expansion-panel-header", 3),
						Le("click", function () {
							const o = rn(e).$implicit
							return on(Te().toggleGroupExpansion(o.key))
						}),
						F(3, "mat-panel-title", 4),
						ge(4, " Custom View(s) in "),
						F(5, "strong"),
						ge(6),
						Me(7, "titlecase"),
						L(),
						ge(8),
						L()(),
						Ee(9, GVe, 3, 2, "ng-container", 5),
						Me(10, "filterCustomConfigDataBySearchTerm"),
						L()
				}
				if (2 & t) {
					const e = n.$implicit,
						i = Te()
					U("expanded", i.isGroupExpanded(e.key) || i.searchTerm.length > 0),
						T(6),
						Vt(" ", De(7, 4, e.value.mapSelectionMode), " "),
						T(2),
						Vt(" mode for ", e.value.mapNames, " "),
						T(1),
						U("ngIf", lo(10, 6, e.value.customConfigItems, i.searchTerm))
				}
			}
			let WVe = (() => {
					class t {
						constructor(e, i, r) {
							;(this.store = e),
								(this.threeCameraService = i),
								(this.threeOrbitControlsService = r),
								(this.searchTerm = ""),
								(this.expandedStates = {}),
								(this.manuallyToggled = new Set())
						}
						ngOnChanges(e) {
							if (e.searchTerm)
								if (e.searchTerm.currentValue.length > 0)
									for (const i of Object.keys(this.expandedStates)) this.expandedStates[i] = !0
								else
									for (const i of Object.keys(this.expandedStates))
										this.manuallyToggled.has(i) || (this.expandedStates[i] = !1)
						}
						isGroupExpanded(e) {
							return this.searchTerm.length > 0
								? !this.manuallyToggled.has(e) || this.expandedStates[e]
								: this.expandedStates[e] || !1
						}
						toggleGroupExpansion(e) {
							;(this.expandedStates[e] = !this.isGroupExpanded(e)), this.manuallyToggled.add(e)
						}
						removeCustomConfig(e, i) {
							ki.deleteCustomConfig(e), (this.expandedStates[i] = !0)
						}
						applyCustomConfig(e) {
							ki.applyCustomConfig(e, this.store, this.threeCameraService, this.threeOrbitControlsService)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct), P(Td), P(El))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-custom-config-item-group"]],
								viewQuery: function (i, r) {
									if ((1 & i && _i(HVe, 5), 2 & i)) {
										let o
										sn((o = an())) && (r.matExpansionPanel = o.first)
									}
								},
								inputs: { customConfigItemGroups: "customConfigItemGroups", searchTerm: "searchTerm" },
								features: [Ar],
								decls: 2,
								vars: 3,
								consts: [
									[3, "expanded", 4, "ngFor", "ngForOf"],
									[3, "expanded"],
									["matExpansionPanel", ""],
									[3, "click"],
									[1, "custom-config-item-group-title"],
									[4, "ngIf"],
									["class", "no-configs-found-message", 4, "ngIf"],
									[3, "title", 4, "ngFor", "ngForOf"],
									[3, "title"],
									[1, "metrics-box"],
									[1, "config-item-name", 3, "title"],
									["mat-dialog-close", "", 3, "click"],
									[1, "custom-config-note"],
									[1, "custom-config-note-content"],
									[3, "customConfigItem"],
									[1, "custom-config-action-buttons"],
									["title", "Remove Custom View", 1, "remove-button", 3, "click"],
									[1, "fa", "fa-trash"],
									[1, "no-configs-found-message"]
								],
								template: function (i, r) {
									1 & i && (Ee(0, $Ve, 11, 9, "mat-expansion-panel", 0), Me(1, "keyvalue")),
										2 & i && U("ngForOf", De(1, 1, r.customConfigItemGroups))
								},
								dependencies: [md, PJ, OJ, GJ, $J, i5e, _o, En, BVe, PVe, YQ, wC, OVe, NVe, UVe],
								styles: [
									'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}cc-custom-config-item-group .custom-config-item-group-title{color:#000000de;display:inline-block}cc-custom-config-item-group div .metrics-box{margin-top:10px}cc-custom-config-item-group div .custom-config-note{display:flex;flex-wrap:wrap;align-items:center;margin-top:5px}cc-custom-config-item-group div .custom-config-action-buttons{display:flex;align-items:center;margin-bottom:5px}cc-custom-config-item-group p{font-size:15px;margin:0;white-space:pre-line}cc-custom-config-item-group p.custom-config-note-content{margin-right:7px;font-size:13px}\n'
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				jVe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({})
						}
					}
					return t
				})()
			function XVe(t, n, e, i) {
				const { mapSelectionMode: r, assignedMaps: o } = xw(n),
					s = {
						id: "",
						name: t,
						creationTime: Date.now(),
						mapSelectionMode: r,
						assignedMaps: o,
						customConfigVersion: "1.0.0",
						stateSettings: { appSettings: void 0, dynamicSettings: void 0, fileSettings: void 0 },
						camera: e,
						...(i && { note: i })
					}
				return (
					(function YVe(t) {
						t.stateSettings.appSettings = {
							showMetricLabelNameValue: !1,
							showMetricLabelNodeName: !1,
							colorLabels: { positive: !1, negative: !1, neutral: !1 },
							amountOfEdgePreviews: 0,
							amountOfTopLabels: 0,
							edgeHeight: 0,
							hideFlatBuildings: !1,
							invertHeight: !1,
							invertArea: !1,
							isLoadingFile: !1,
							isLoadingMap: !1,
							isPresentationMode: !1,
							isWhiteBackground: !1,
							resetCameraIfNewFileIsLoaded: !1,
							scaling: void 0,
							showOnlyBuildingsWithEdges: !1,
							isEdgeMetricVisible: !0,
							sortingOrderAscending: !1,
							isSearchPanelPinned: !1,
							experimentalFeaturesEnabled: !1,
							screenshotToClipboardEnabled: !1,
							layoutAlgorithm: void 0,
							maxTreeMapFiles: 0,
							sharpnessMode: void 0,
							isColorMetricLinkedToHeightMetric: !1,
							enableFloorLabels: !0,
							mapColors: {
								labelColorAndAlpha: { alpha: 0, rgb: "" },
								base: "",
								flat: "",
								incomingEdge: "",
								markingColors: [],
								negative: "",
								negativeDelta: "",
								neutral: "",
								outgoingEdge: "",
								positive: "",
								positiveDelta: "",
								selected: ""
							}
						}
					})(s),
					(function qVe(t) {
						t.stateSettings.dynamicSettings = {
							areaMetric: "",
							colorMetric: "",
							distributionMetric: "",
							edgeMetric: "",
							focusedNodePath: [],
							heightMetric: "",
							margin: 0,
							searchPattern: "",
							sortingOption: void 0,
							colorRange: { from: 0, to: 0 },
							colorMode: void 0
						}
					})(s),
					(function ZVe(t) {
						t.stateSettings.fileSettings = { blacklist: void 0, edges: [], attributeDescriptors: {}, markedPackages: [] }
					})(s),
					cee(n, s.stateSettings),
					(s.id = bE()(JSON.stringify(s, YE))),
					s
				)
			}
			function cee(t, n) {
				for (const [e, i] of Object.entries(t))
					Object.prototype.hasOwnProperty.call(n, e) &&
						("object" != typeof i || Array.isArray(i) || null === i || void 0 === n[e] ? (n[e] = i) : cee(i, n[e]))
			}
			let JVe = (() => {
				class t {
					constructor(e) {
						this.data = e
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Bv))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["ng-component"]],
							decls: 10,
							vars: 4,
							consts: [
								[1, "confirmation-message"],
								["mat-dialog-title", ""],
								["mat-dialog-content", ""],
								["mat-dialog-actions", ""],
								["mat-button", "", 3, "mat-dialog-close"],
								["mat-button", "", "cdkFocusInitial", "", 1, "submit-button", 3, "mat-dialog-close"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "div", 0)(1, "h1", 1),
									ge(2),
									L(),
									F(3, "div", 2),
									ge(4),
									L()(),
									F(5, "div", 3)(6, "button", 4),
									ge(7, "CANCEL"),
									L(),
									F(8, "button", 5),
									ge(9, "OK"),
									L()()),
									2 & i &&
										(T(2),
										cr(r.data.title),
										T(2),
										cr(r.data.message),
										T(2),
										U("mat-dialog-close", !1),
										T(2),
										U("mat-dialog-close", !0))
							},
							dependencies: [Qs, md, b9, Hm, Vm],
							styles: [
								".cc-confirmation-dialog .mat-mdc-dialog-container .confirmation-message{padding:10px}.cc-confirmation-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions{justify-content:flex-end}.cc-confirmation-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions .mat-mdc-button{background-color:#8a848414}.cc-confirmation-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions .mat-mdc-button.submit-button{color:#009688}\n"
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function iQe(t, n) {
				if (1 & t) {
					const e = ri()
					Cr(0),
						F(1, "span", 1),
						ge(2, "Do you want to download and then purge old unused Configs to make space for new ones?"),
						L(),
						F(3, "button", 2),
						Le("click", function () {
							return rn(e), on(Te().showPurgeConfirmDialog())
						}),
						ge(4, " DOWNLOAD & PURGE... "),
						L(),
						Er()
				}
			}
			let rQe = (() => {
				class t {
					constructor(e) {
						;(this.dialog = e), (this.isLocalStorageSizeValid = !0)
					}
					ngOnInit() {
						this.isLocalStorageSizeValid = (() => {
							let n = ""
							for (const [i, r] of Object.entries(localStorage)) n += i + r
							return 3 + (16 * n.length) / 8 / 1024 <= 768
						})()
					}
					showPurgeConfirmDialog() {
						const e = (function nQe() {
							const t = new Set(),
								n = ki.getCustomConfigs(),
								e = new Map()
							for (const [r, o] of n.entries())
								void 0 === o?.creationTime && (o.creationTime = Date.now()),
									(Date.now() - o.creationTime) / 2592e6 >= 6 &&
										(e.set(r, ki.createExportCustomConfigFromConfig(o)), t.add(o))
							return e.size > 0 && ki.downloadCustomConfigs(e), t
						})()
						0 !== e.size
							? this.dialog
									.open(JVe, {
										panelClass: "cc-confirmation-dialog",
										data: { title: "Confirm to purge old Configs", message: "Are you sure to delete old Configs now?" }
									})
									.afterClosed()
									.subscribe(r => {
										r && ki.deleteCustomConfigs([...e])
									})
							: this.dialog.open(yg, {
									data: {
										title: "Download Error",
										message: "Could not download and purge old configs automatically! Please try it by yourself."
									}
							  })
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(la))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-download-and-purge-configs"]],
							decls: 1,
							vars: 1,
							consts: [
								[4, "ngIf"],
								[1, "exceed-local-storage-message"],
								[
									"mat-button",
									"",
									"title",
									"Download old unused Custom Views as a backup file and then delete them in the browser.",
									1,
									"exceed-local-storage-button",
									3,
									"click"
								]
							],
							template: function (i, r) {
								1 & i && Ee(0, iQe, 5, 0, "ng-container", 0), 2 & i && U("ngIf", !r.isLocalStorageSizeValid)
							},
							dependencies: [Qs, En],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function oQe(t, n) {
				if ((1 & t && (F(0, "mat-error"), ge(1), L()), 2 & t)) {
					const e = Te()
					T(1), cr(e.getErrorMessage())
				}
			}
			let sQe = (() => {
				class t {
					constructor(e, i, r) {
						;(this.state = e), (this.threeCameraService = i), (this.threeOrbitControlsService = r)
					}
					ngOnInit() {
						const e = xw(this.state.getValue())
						;(this.customConfigName = new y8("", [nI.required, aQe(e)])),
							this.customConfigName.setValue(ki.getConfigNameSuggestionByFileState(e))
					}
					getErrorMessage() {
						return this.customConfigName.hasError("required")
							? "Please enter a view name."
							: this.customConfigName.hasError("Error")
							? this.customConfigName.getError("Error")
							: ""
					}
					addCustomConfig() {
						const e = XVe(
							this.customConfigName.value,
							this.state.getValue(),
							{
								camera: this.threeCameraService.camera.position,
								cameraTarget: this.threeOrbitControlsService.controls.target
							},
							this.customConfigNote
						)
						ki.addCustomConfig(e)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Sr), P(Td), P(El))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["ng-component"]],
							decls: 22,
							vars: 4,
							consts: [
								["xmlns", "http://www.w3.org/1999/html", 1, "header"],
								[1, "dialog-content"],
								["matInput", "", "required", "", 1, "custom-config-input", 3, "formControl"],
								["align", "start"],
								[4, "ngIf"],
								[1, "custom-config-note"],
								[
									"cdkAutosizeMinRows",
									"8",
									"cdkTextareaAutosize",
									"",
									"matInput",
									"",
									"required",
									"",
									1,
									"custom-config-input",
									3,
									"ngModel",
									"ngModelChange"
								],
								["mat-button", "", "mat-dialog-close", "", 1, "add-custom-config-button", 3, "disabled", "click"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-toolbar", 0)(1, "h2"),
									ge(2, "Add Custom View"),
									L()(),
									F(3, "mat-dialog-content")(4, "div", 1)(5, "mat-form-field")(6, "label"),
									ge(7, "Save individual configurations for your map."),
									L(),
									fe(8, "input", 2),
									F(9, "mat-hint", 3),
									ge(10, "Config View Name"),
									L(),
									Ee(11, oQe, 2, 1, "mat-error", 4),
									L(),
									F(12, "mat-form-field", 5)(13, "label"),
									ge(14, "Provide custom note for configuration (optional)"),
									L(),
									F(15, "textarea", 6),
									Le("ngModelChange", function (s) {
										return (r.customConfigNote = s)
									}),
									L(),
									F(16, "mat-hint", 3),
									ge(17, "Config Note"),
									L()()()(),
									F(18, "mat-dialog-actions"),
									fe(19, "cc-download-and-purge-configs"),
									F(20, "button", 7),
									Le("click", function () {
										return r.addCustomConfig()
									}),
									ge(21, " ADD "),
									L()()),
									2 & i &&
										(T(8),
										U("formControl", r.customConfigName),
										T(3),
										U("ngIf", r.customConfigName.invalid),
										T(4),
										U("ngModel", r.customConfigNote),
										T(5),
										U("disabled", r.customConfigName.invalid))
							},
							dependencies: [Bd, xO, jX, Qs, md, Hm, Vm, Mb, kp, sY, En, km, T0, HC, P0, UC, rQe],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}.cc-add-custom-config-dialog .mat-mdc-dialog-container{padding:0;width:500px;overflow:hidden}.cc-add-custom-config-dialog .mat-mdc-dialog-container mat-toolbar.header{background-color:#1b9cfc}.cc-add-custom-config-dialog .mat-mdc-dialog-container mat-toolbar.header h2{color:#fff}.cc-add-custom-config-dialog .mat-mdc-dialog-container .dialog-content mat-form-field{width:100%}.cc-add-custom-config-dialog .mat-mdc-dialog-container .dialog-content mat-form-field.custom-config-note{padding-top:30px}.cc-add-custom-config-dialog .mat-mdc-dialog-container .dialog-content label{color:#0000008a;font-size:13px}.cc-add-custom-config-dialog .mat-mdc-dialog-container .dialog-content input{margin-top:12px}.cc-add-custom-config-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions{margin:0;padding:0 8px;position:relative}.cc-add-custom-config-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions cc-download-and-purge-configs{text-align:right}.cc-add-custom-config-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions cc-download-and-purge-configs .exceed-local-storage-message{display:block;text-align:left;padding:0 16px;color:#b02929}.cc-add-custom-config-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions cc-download-and-purge-configs .exceed-local-storage-button{margin-right:89px}.cc-add-custom-config-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions .mat-mdc-button{padding:0 8px;margin:8px 0 8px 8px}.cc-add-custom-config-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions .mat-mdc-button.exceed-local-storage-button{color:#fff;background-color:#b02929}.cc-add-custom-config-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions .mat-mdc-button.add-custom-config-button{color:#1b9cfc;background-color:#8a848414;position:absolute;right:16px;bottom:0}.cc-add-custom-config-dialog .mat-mdc-dialog-container .mat-mdc-dialog-actions .mat-mdc-button.add-custom-config-button[disabled]{color:gray}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function aQe(t) {
				return n =>
					ki.hasCustomConfigByName(t.mapSelectionMode, t.assignedMaps, n.value)
						? { Error: "A Custom View with this name already exists." }
						: null
			}
			let lee = (() => {
					class t {
						constructor(e) {
							this.dialog = e
						}
						showAddCustomConfigDialog() {
							this.dialog.open(sQe, { panelClass: "cc-add-custom-config-dialog" })
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(la))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-add-custom-config-button"]],
								decls: 2,
								vars: 0,
								consts: [
									["title", "Create new Custom View", 1, "cc-ribbon-bar-menu-button", 3, "click"],
									[1, "fa", "fa-plus"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.showAddCustomConfigDialog()
										}),
										fe(1, "i", 1),
										L())
								},
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				cQe = (() => {
					class t {
						upload() {
							const e = wZ()
							e.addEventListener("change", () => {
								this.uploadOnEvent(e)
							}),
								e.click()
						}
						uploadOnEvent(e) {
							return _r(function* () {
								const i = yield Promise.all(MZ(e.files))
								for (const r of i)
									try {
										ki.importCustomConfigs(r)
									} catch {}
							})()
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-upload-custom-config-button"]],
								decls: 2,
								vars: 0,
								consts: [
									["title", "Upload Custom View (.cc.config.json file).", 1, "action-button", 3, "click"],
									[1, "fa", "fa-folder-open"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.upload()
										}),
										fe(1, "i", 1),
										L())
								},
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				hQe = (() => {
					class t {
						constructor(e) {
							this.downloadCustomConfigService = e
						}
						ngOnInit() {
							this.subscription = this.downloadCustomConfigService.downloadableCustomConfigs$.subscribe(e => {
								this.downloadableConfigs = e
							})
						}
						ngOnDestroy() {
							this.subscription.unsubscribe()
						}
						downloadPreloadedCustomConfigs() {
							!(function uQe(t) {
								const n = { downloadApiVersion: "1.0.1", timestamp: Date.now(), customConfigs: t },
									e = pf.getNewTimestamp() + ".cc.config.json"
								TO.downloadData(JSON.stringify(n, YE), e)
							})(this.downloadableConfigs)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(FO))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-download-custom-configs-button"]],
								decls: 2,
								vars: 1,
								consts: [
									["title", "Download Custom View related to currently uploaded maps, if any.", 3, "disabled", "click"],
									[1, "fa", "fa-download"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.downloadPreloadedCustomConfigs()
										}),
										fe(1, "i", 1),
										L()),
										2 & i && U("disabled", 0 === r.downloadableConfigs.size)
								},
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				fQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Qi, Ot, see, SVe, kVe, TVe, od, jVe] })
						}
					}
					return t
				})()
			Uf(fY, [lee], []), Uf(hY, [Bd, yf, XX, Hm, Mb, kp, r5e, Em, En, cQe, lee, hQe, WVe], [Bn])
			let mQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi, dT, Ww] })
						}
					}
					return t
				})(),
				pQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, MO] })
						}
					}
					return t
				})(),
				AQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				gQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Q3, pQe, AQe, Ww, Qi] })
						}
					}
					return t
				})(),
				bQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot] })
						}
					}
					return t
				})(),
				_Qe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi, EVe, y5e, fQe, x5e, A5e, MVe, mQe, g5e, bQe, b5e, gQe, _5e, w5e] })
						}
					}
					return t
				})(),
				Gb = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot] })
						}
					}
					return t
				})(),
				vQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Gb] })
						}
					}
					return t
				})(),
				yQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				wQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi, dT] })
						}
					}
					return t
				})(),
				xQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Qi, Ww, wQe, yQe, Gb] })
						}
					}
					return t
				})(),
				CQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot] })
						}
					}
					return t
				})(),
				EQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Gb] })
						}
					}
					return t
				})(),
				MQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [QZ], imports: [Ot, Qi, od, jJ] })
						}
					}
					return t
				})(),
				SQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ providers: [OZ], imports: [Ot, Gb] })
						}
					}
					return t
				})(),
				kQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				TQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Gb] })
						}
					}
					return t
				})(),
				FQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				BQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Gb, Qi, N0, od] })
						}
					}
					return t
				})(),
				IQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, vQe, EQe, SQe, TQe, BQe, MQe, CQe, FQe, kQe, xQe] })
						}
					}
					return t
				})(),
				DQe = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [p5e, Ot, l5e, f5e, _Qe, IQe, u5e, m5e] })
						}
					}
					return t
				})()
			let Vp = {
				async: !1,
				baseUrl: null,
				breaks: !1,
				extensions: null,
				gfm: !0,
				headerIds: !0,
				headerPrefix: "",
				highlight: null,
				hooks: null,
				langPrefix: "language-",
				mangle: !0,
				pedantic: !1,
				renderer: null,
				sanitize: !1,
				sanitizer: null,
				silent: !1,
				smartypants: !1,
				tokenizer: null,
				walkTokens: null,
				xhtml: !1
			}
			const uee = /[&<>"']/,
				PQe = new RegExp(uee.source, "g"),
				hee = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
				OQe = new RegExp(hee.source, "g"),
				NQe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" },
				fee = t => NQe[t]
			function Ks(t, n) {
				if (n) {
					if (uee.test(t)) return t.replace(PQe, fee)
				} else if (hee.test(t)) return t.replace(OQe, fee)
				return t
			}
			const UQe = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi
			function mee(t) {
				return t.replace(UQe, (n, e) =>
					"colon" === (e = e.toLowerCase())
						? ":"
						: "#" === e.charAt(0)
						? "x" === e.charAt(1)
							? String.fromCharCode(parseInt(e.substring(2), 16))
							: String.fromCharCode(+e.substring(1))
						: ""
				)
			}
			const HQe = /(^|[^\[])\^/g
			function Fr(t, n) {
				;(t = "string" == typeof t ? t : t.source), (n = n || "")
				const e = {
					replace: (i, r) => ((r = (r = r.source || r).replace(HQe, "$1")), (t = t.replace(i, r)), e),
					getRegex: () => new RegExp(t, n)
				}
				return e
			}
			const VQe = /[^\w:]/g,
				QQe = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i
			function pee(t, n, e) {
				if (t) {
					let i
					try {
						i = decodeURIComponent(mee(e)).replace(VQe, "").toLowerCase()
					} catch {
						return null
					}
					if (0 === i.indexOf("javascript:") || 0 === i.indexOf("vbscript:") || 0 === i.indexOf("data:")) return null
				}
				n &&
					!QQe.test(e) &&
					(e = (function WQe(t, n) {
						fT[" " + t] || (fT[" " + t] = zQe.test(t) ? t + "/" : pT(t, "/", !0))
						const e = -1 === (t = fT[" " + t]).indexOf(":")
						return "//" === n.substring(0, 2)
							? e
								? n
								: t.replace(GQe, "$1") + n
							: "/" === n.charAt(0)
							? e
								? n
								: t.replace($Qe, "$1") + n
							: t + n
					})(n, e))
				try {
					e = encodeURI(e).replace(/%25/g, "%")
				} catch {
					return null
				}
				return e
			}
			const fT = {},
				zQe = /^[^:]+:\/*[^/]*$/,
				GQe = /^([^:]+:)[\s\S]*$/,
				$Qe = /^([^:]+:\/*[^/]*)[\s\S]*$/,
				mT = { exec: function () {} }
			function Aee(t, n) {
				const i = t
					.replace(/\|/g, (o, s, a) => {
						let c = !1,
							l = s
						for (; --l >= 0 && "\\" === a[l]; ) c = !c
						return c ? "|" : " |"
					})
					.split(/ \|/)
				let r = 0
				if ((i[0].trim() || i.shift(), i.length > 0 && !i[i.length - 1].trim() && i.pop(), i.length > n)) i.splice(n)
				else for (; i.length < n; ) i.push("")
				for (; r < i.length; r++) i[r] = i[r].trim().replace(/\\\|/g, "|")
				return i
			}
			function pT(t, n, e) {
				const i = t.length
				if (0 === i) return ""
				let r = 0
				for (; r < i; ) {
					const o = t.charAt(i - r - 1)
					if (o !== n || e) {
						if (o === n || !e) break
						r++
					} else r++
				}
				return t.slice(0, i - r)
			}
			function gee(t, n) {
				if (n < 1) return ""
				let e = ""
				for (; n > 1; ) 1 & n && (e += t), (n >>= 1), (t += t)
				return e + t
			}
			function bee(t, n, e, i) {
				const r = n.href,
					o = n.title ? Ks(n.title) : null,
					s = t[1].replace(/\\([\[\]])/g, "$1")
				if ("!" !== t[0].charAt(0)) {
					i.state.inLink = !0
					const a = { type: "link", raw: e, href: r, title: o, text: s, tokens: i.inlineTokens(s) }
					return (i.state.inLink = !1), a
				}
				return { type: "image", raw: e, href: r, title: o, text: Ks(s) }
			}
			class W3 {
				constructor(n) {
					this.options = n || Vp
				}
				space(n) {
					const e = this.rules.block.newline.exec(n)
					if (e && e[0].length > 0) return { type: "space", raw: e[0] }
				}
				code(n) {
					const e = this.rules.block.code.exec(n)
					if (e) {
						const i = e[0].replace(/^ {1,4}/gm, "")
						return { type: "code", raw: e[0], codeBlockStyle: "indented", text: this.options.pedantic ? i : pT(i, "\n") }
					}
				}
				fences(n) {
					const e = this.rules.block.fences.exec(n)
					if (e) {
						const i = e[0],
							r = (function XQe(t, n) {
								const e = t.match(/^(\s+)(?:```)/)
								if (null === e) return n
								const i = e[1]
								return n
									.split("\n")
									.map(r => {
										const o = r.match(/^\s+/)
										if (null === o) return r
										const [s] = o
										return s.length >= i.length ? r.slice(i.length) : r
									})
									.join("\n")
							})(i, e[3] || "")
						return { type: "code", raw: i, lang: e[2] ? e[2].trim().replace(this.rules.inline._escapes, "$1") : e[2], text: r }
					}
				}
				heading(n) {
					const e = this.rules.block.heading.exec(n)
					if (e) {
						let i = e[2].trim()
						if (/#$/.test(i)) {
							const r = pT(i, "#")
							;(this.options.pedantic || !r || / $/.test(r)) && (i = r.trim())
						}
						return { type: "heading", raw: e[0], depth: e[1].length, text: i, tokens: this.lexer.inline(i) }
					}
				}
				hr(n) {
					const e = this.rules.block.hr.exec(n)
					if (e) return { type: "hr", raw: e[0] }
				}
				blockquote(n) {
					const e = this.rules.block.blockquote.exec(n)
					if (e) {
						const i = e[0].replace(/^ *>[ \t]?/gm, ""),
							r = this.lexer.state.top
						this.lexer.state.top = !0
						const o = this.lexer.blockTokens(i)
						return (this.lexer.state.top = r), { type: "blockquote", raw: e[0], tokens: o, text: i }
					}
				}
				list(n) {
					let e = this.rules.block.list.exec(n)
					if (e) {
						let i,
							r,
							o,
							s,
							a,
							c,
							l,
							d,
							u,
							h,
							f,
							_,
							y = e[1].trim()
						const C = y.length > 1,
							x = { type: "list", raw: "", ordered: C, start: C ? +y.slice(0, -1) : "", loose: !1, items: [] }
						;(y = C ? `\\d{1,9}\\${y.slice(-1)}` : `\\${y}`), this.options.pedantic && (y = C ? y : "[*+-]")
						const w = new RegExp(`^( {0,3}${y})((?:[\t ][^\\n]*)?(?:\\n|$))`)
						for (; n && ((_ = !1), (e = w.exec(n)) && !this.rules.block.hr.test(n)); ) {
							if (
								((i = e[0]),
								(n = n.substring(i.length)),
								(d = e[2].split("\n", 1)[0].replace(/^\t+/, M => " ".repeat(3 * M.length))),
								(u = n.split("\n", 1)[0]),
								this.options.pedantic
									? ((s = 2), (f = d.trimLeft()))
									: ((s = e[2].search(/[^ ]/)), (s = s > 4 ? 1 : s), (f = d.slice(s)), (s += e[1].length)),
								(c = !1),
								!d && /^ *$/.test(u) && ((i += u + "\n"), (n = n.substring(u.length + 1)), (_ = !0)),
								!_)
							) {
								const M = new RegExp(`^ {0,${Math.min(3, s - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`),
									O = new RegExp(`^ {0,${Math.min(3, s - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
									N = new RegExp(`^ {0,${Math.min(3, s - 1)}}(?:\`\`\`|~~~)`),
									j = new RegExp(`^ {0,${Math.min(3, s - 1)}}#`)
								for (
									;
									n &&
									((h = n.split("\n", 1)[0]),
									(u = h),
									this.options.pedantic && (u = u.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
									!(N.test(u) || j.test(u) || M.test(u) || O.test(n)));

								) {
									if (u.search(/[^ ]/) >= s || !u.trim()) f += "\n" + u.slice(s)
									else {
										if (c || d.search(/[^ ]/) >= 4 || N.test(d) || j.test(d) || O.test(d)) break
										f += "\n" + u
									}
									!c && !u.trim() && (c = !0), (i += h + "\n"), (n = n.substring(h.length + 1)), (d = u.slice(s))
								}
							}
							x.loose || (l ? (x.loose = !0) : /\n *\n *$/.test(i) && (l = !0)),
								this.options.gfm &&
									((r = /^\[[ xX]\] /.exec(f)), r && ((o = "[ ] " !== r[0]), (f = f.replace(/^\[[ xX]\] +/, "")))),
								x.items.push({ type: "list_item", raw: i, task: !!r, checked: o, loose: !1, text: f }),
								(x.raw += i)
						}
						;(x.items[x.items.length - 1].raw = i.trimRight()),
							(x.items[x.items.length - 1].text = f.trimRight()),
							(x.raw = x.raw.trimRight())
						const S = x.items.length
						for (a = 0; a < S; a++)
							if (
								((this.lexer.state.top = !1), (x.items[a].tokens = this.lexer.blockTokens(x.items[a].text, [])), !x.loose)
							) {
								const M = x.items[a].tokens.filter(N => "space" === N.type),
									O = M.length > 0 && M.some(N => /\n.*\n/.test(N.raw))
								x.loose = O
							}
						if (x.loose) for (a = 0; a < S; a++) x.items[a].loose = !0
						return x
					}
				}
				html(n) {
					const e = this.rules.block.html.exec(n)
					if (e) {
						const i = {
							type: "html",
							raw: e[0],
							pre: !this.options.sanitizer && ("pre" === e[1] || "script" === e[1] || "style" === e[1]),
							text: e[0]
						}
						if (this.options.sanitize) {
							const r = this.options.sanitizer ? this.options.sanitizer(e[0]) : Ks(e[0])
							;(i.type = "paragraph"), (i.text = r), (i.tokens = this.lexer.inline(r))
						}
						return i
					}
				}
				def(n) {
					const e = this.rules.block.def.exec(n)
					if (e) {
						const i = e[1].toLowerCase().replace(/\s+/g, " "),
							r = e[2] ? e[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "",
							o = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline._escapes, "$1") : e[3]
						return { type: "def", tag: i, raw: e[0], href: r, title: o }
					}
				}
				table(n) {
					const e = this.rules.block.table.exec(n)
					if (e) {
						const i = {
							type: "table",
							header: Aee(e[1]).map(r => ({ text: r })),
							align: e[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
							rows: e[3] && e[3].trim() ? e[3].replace(/\n[ \t]*$/, "").split("\n") : []
						}
						if (i.header.length === i.align.length) {
							i.raw = e[0]
							let o,
								s,
								a,
								c,
								r = i.align.length
							for (o = 0; o < r; o++)
								i.align[o] = /^ *-+: *$/.test(i.align[o])
									? "right"
									: /^ *:-+: *$/.test(i.align[o])
									? "center"
									: /^ *:-+ *$/.test(i.align[o])
									? "left"
									: null
							for (r = i.rows.length, o = 0; o < r; o++) i.rows[o] = Aee(i.rows[o], i.header.length).map(l => ({ text: l }))
							for (r = i.header.length, s = 0; s < r; s++) i.header[s].tokens = this.lexer.inline(i.header[s].text)
							for (r = i.rows.length, s = 0; s < r; s++)
								for (c = i.rows[s], a = 0; a < c.length; a++) c[a].tokens = this.lexer.inline(c[a].text)
							return i
						}
					}
				}
				lheading(n) {
					const e = this.rules.block.lheading.exec(n)
					if (e)
						return {
							type: "heading",
							raw: e[0],
							depth: "=" === e[2].charAt(0) ? 1 : 2,
							text: e[1],
							tokens: this.lexer.inline(e[1])
						}
				}
				paragraph(n) {
					const e = this.rules.block.paragraph.exec(n)
					if (e) {
						const i = "\n" === e[1].charAt(e[1].length - 1) ? e[1].slice(0, -1) : e[1]
						return { type: "paragraph", raw: e[0], text: i, tokens: this.lexer.inline(i) }
					}
				}
				text(n) {
					const e = this.rules.block.text.exec(n)
					if (e) return { type: "text", raw: e[0], text: e[0], tokens: this.lexer.inline(e[0]) }
				}
				escape(n) {
					const e = this.rules.inline.escape.exec(n)
					if (e) return { type: "escape", raw: e[0], text: Ks(e[1]) }
				}
				tag(n) {
					const e = this.rules.inline.tag.exec(n)
					if (e)
						return (
							!this.lexer.state.inLink && /^<a /i.test(e[0])
								? (this.lexer.state.inLink = !0)
								: this.lexer.state.inLink && /^<\/a>/i.test(e[0]) && (this.lexer.state.inLink = !1),
							!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(e[0])
								? (this.lexer.state.inRawBlock = !0)
								: this.lexer.state.inRawBlock &&
								  /^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0]) &&
								  (this.lexer.state.inRawBlock = !1),
							{
								type: this.options.sanitize ? "text" : "html",
								raw: e[0],
								inLink: this.lexer.state.inLink,
								inRawBlock: this.lexer.state.inRawBlock,
								text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(e[0]) : Ks(e[0])) : e[0]
							}
						)
				}
				link(n) {
					const e = this.rules.inline.link.exec(n)
					if (e) {
						const i = e[2].trim()
						if (!this.options.pedantic && /^</.test(i)) {
							if (!/>$/.test(i)) return
							const s = pT(i.slice(0, -1), "\\")
							if ((i.length - s.length) % 2 == 0) return
						} else {
							const s = (function jQe(t, n) {
								if (-1 === t.indexOf(n[1])) return -1
								const e = t.length
								let i = 0,
									r = 0
								for (; r < e; r++)
									if ("\\" === t[r]) r++
									else if (t[r] === n[0]) i++
									else if (t[r] === n[1] && (i--, i < 0)) return r
								return -1
							})(e[2], "()")
							if (s > -1) {
								const c = (0 === e[0].indexOf("!") ? 5 : 4) + e[1].length + s
								;(e[2] = e[2].substring(0, s)), (e[0] = e[0].substring(0, c).trim()), (e[3] = "")
							}
						}
						let r = e[2],
							o = ""
						if (this.options.pedantic) {
							const s = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r)
							s && ((r = s[1]), (o = s[3]))
						} else o = e[3] ? e[3].slice(1, -1) : ""
						return (
							(r = r.trim()),
							/^</.test(r) && (r = this.options.pedantic && !/>$/.test(i) ? r.slice(1) : r.slice(1, -1)),
							bee(
								e,
								{
									href: r && r.replace(this.rules.inline._escapes, "$1"),
									title: o && o.replace(this.rules.inline._escapes, "$1")
								},
								e[0],
								this.lexer
							)
						)
					}
				}
				reflink(n, e) {
					let i
					if ((i = this.rules.inline.reflink.exec(n)) || (i = this.rules.inline.nolink.exec(n))) {
						let r = (i[2] || i[1]).replace(/\s+/g, " ")
						if (((r = e[r.toLowerCase()]), !r)) {
							const o = i[0].charAt(0)
							return { type: "text", raw: o, text: o }
						}
						return bee(i, r, i[0], this.lexer)
					}
				}
				emStrong(n, e, i = "") {
					let r = this.rules.inline.emStrong.lDelim.exec(n)
					if (!r || (r[3] && i.match(/[\p{L}\p{N}]/u))) return
					const o = r[1] || r[2] || ""
					if (!o || (o && ("" === i || this.rules.inline.punctuation.exec(i)))) {
						const s = r[0].length - 1
						let a,
							c,
							l = s,
							d = 0
						const u = "*" === r[0][0] ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd
						for (u.lastIndex = 0, e = e.slice(-1 * n.length + s); null != (r = u.exec(e)); ) {
							if (((a = r[1] || r[2] || r[3] || r[4] || r[5] || r[6]), !a)) continue
							if (((c = a.length), r[3] || r[4])) {
								l += c
								continue
							}
							if ((r[5] || r[6]) && s % 3 && !((s + c) % 3)) {
								d += c
								continue
							}
							if (((l -= c), l > 0)) continue
							c = Math.min(c, c + l + d)
							const h = n.slice(0, s + r.index + (r[0].length - a.length) + c)
							if (Math.min(s, c) % 2) {
								const _ = h.slice(1, -1)
								return { type: "em", raw: h, text: _, tokens: this.lexer.inlineTokens(_) }
							}
							const f = h.slice(2, -2)
							return { type: "strong", raw: h, text: f, tokens: this.lexer.inlineTokens(f) }
						}
					}
				}
				codespan(n) {
					const e = this.rules.inline.code.exec(n)
					if (e) {
						let i = e[2].replace(/\n/g, " ")
						const r = /[^ ]/.test(i),
							o = /^ /.test(i) && / $/.test(i)
						return r && o && (i = i.substring(1, i.length - 1)), (i = Ks(i, !0)), { type: "codespan", raw: e[0], text: i }
					}
				}
				br(n) {
					const e = this.rules.inline.br.exec(n)
					if (e) return { type: "br", raw: e[0] }
				}
				del(n) {
					const e = this.rules.inline.del.exec(n)
					if (e) return { type: "del", raw: e[0], text: e[2], tokens: this.lexer.inlineTokens(e[2]) }
				}
				autolink(n, e) {
					const i = this.rules.inline.autolink.exec(n)
					if (i) {
						let r, o
						return (
							"@" === i[2]
								? ((r = Ks(this.options.mangle ? e(i[1]) : i[1])), (o = "mailto:" + r))
								: ((r = Ks(i[1])), (o = r)),
							{ type: "link", raw: i[0], text: r, href: o, tokens: [{ type: "text", raw: r, text: r }] }
						)
					}
				}
				url(n, e) {
					let i
					if ((i = this.rules.inline.url.exec(n))) {
						let r, o
						if ("@" === i[2]) (r = Ks(this.options.mangle ? e(i[0]) : i[0])), (o = "mailto:" + r)
						else {
							let s
							do {
								;(s = i[0]), (i[0] = this.rules.inline._backpedal.exec(i[0])[0])
							} while (s !== i[0])
							;(r = Ks(i[0])), (o = "www." === i[1] ? "http://" + i[0] : i[0])
						}
						return { type: "link", raw: i[0], text: r, href: o, tokens: [{ type: "text", raw: r, text: r }] }
					}
				}
				inlineText(n, e) {
					const i = this.rules.inline.text.exec(n)
					if (i) {
						let r
						return (
							(r = this.lexer.state.inRawBlock
								? this.options.sanitize
									? this.options.sanitizer
										? this.options.sanitizer(i[0])
										: Ks(i[0])
									: i[0]
								: Ks(this.options.smartypants ? e(i[0]) : i[0])),
							{ type: "text", raw: i[0], text: r }
						)
					}
				}
			}
			const Nn = {
				newline: /^(?: *(?:\n|$))+/,
				code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
				fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
				hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
				heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
				blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
				list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
				html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
				def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
				table: mT,
				lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
				_paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
				text: /^[^\n]+/,
				_label: /(?!\s*\])(?:\\.|[^\[\]\\])+/,
				_title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/
			}
			;(Nn.def = Fr(Nn.def).replace("label", Nn._label).replace("title", Nn._title).getRegex()),
				(Nn.bullet = /(?:[*+-]|\d{1,9}[.)])/),
				(Nn.listItemStart = Fr(/^( *)(bull) */)
					.replace("bull", Nn.bullet)
					.getRegex()),
				(Nn.list = Fr(Nn.list)
					.replace(/bull/g, Nn.bullet)
					.replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))")
					.replace("def", "\\n+(?=" + Nn.def.source + ")")
					.getRegex()),
				(Nn._tag =
					"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul"),
				(Nn._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/),
				(Nn.html = Fr(Nn.html, "i")
					.replace("comment", Nn._comment)
					.replace("tag", Nn._tag)
					.replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
					.getRegex()),
				(Nn.paragraph = Fr(Nn._paragraph)
					.replace("hr", Nn.hr)
					.replace("heading", " {0,3}#{1,6} ")
					.replace("|lheading", "")
					.replace("|table", "")
					.replace("blockquote", " {0,3}>")
					.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
					.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
					.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
					.replace("tag", Nn._tag)
					.getRegex()),
				(Nn.blockquote = Fr(Nn.blockquote).replace("paragraph", Nn.paragraph).getRegex()),
				(Nn.normal = { ...Nn }),
				(Nn.gfm = {
					...Nn.normal,
					table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
				}),
				(Nn.gfm.table = Fr(Nn.gfm.table)
					.replace("hr", Nn.hr)
					.replace("heading", " {0,3}#{1,6} ")
					.replace("blockquote", " {0,3}>")
					.replace("code", " {4}[^\\n]")
					.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
					.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
					.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
					.replace("tag", Nn._tag)
					.getRegex()),
				(Nn.gfm.paragraph = Fr(Nn._paragraph)
					.replace("hr", Nn.hr)
					.replace("heading", " {0,3}#{1,6} ")
					.replace("|lheading", "")
					.replace("table", Nn.gfm.table)
					.replace("blockquote", " {0,3}>")
					.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
					.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
					.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
					.replace("tag", Nn._tag)
					.getRegex()),
				(Nn.pedantic = {
					...Nn.normal,
					html: Fr(
						"^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))"
					)
						.replace("comment", Nn._comment)
						.replace(
							/tag/g,
							"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b"
						)
						.getRegex(),
					def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
					heading: /^(#{1,6})(.*)(?:\n+|$)/,
					fences: mT,
					lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
					paragraph: Fr(Nn.normal._paragraph)
						.replace("hr", Nn.hr)
						.replace("heading", " *#{1,6} *[^\n]")
						.replace("lheading", Nn.lheading)
						.replace("blockquote", " {0,3}>")
						.replace("|fences", "")
						.replace("|list", "")
						.replace("|html", "")
						.getRegex()
				})
			const hn = {
				escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
				autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
				url: mT,
				tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
				link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
				reflink: /^!?\[(label)\]\[(ref)\]/,
				nolink: /^!?\[(ref)\](?:\[\])?/,
				reflinkSearch: "reflink|nolink(?!\\()",
				emStrong: {
					lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
					rDelimAst:
						/^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
					rDelimUnd:
						/^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
				},
				code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
				br: /^( {2,}|\\)\n(?!\s*$)/,
				del: mT,
				text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
				punctuation: /^([\spunctuation])/
			}
			function YQe(t) {
				return t
					.replace(/---/g, "\u2014")
					.replace(/--/g, "\u2013")
					.replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018")
					.replace(/'/g, "\u2019")
					.replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201c")
					.replace(/"/g, "\u201d")
					.replace(/\.{3}/g, "\u2026")
			}
			function _ee(t) {
				let e,
					i,
					n = ""
				const r = t.length
				for (e = 0; e < r; e++) (i = t.charCodeAt(e)), Math.random() > 0.5 && (i = "x" + i.toString(16)), (n += "&#" + i + ";")
				return n
			}
			;(hn._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"),
				(hn.punctuation = Fr(hn.punctuation)
					.replace(/punctuation/g, hn._punctuation)
					.getRegex()),
				(hn.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g),
				(hn.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g),
				(hn._comment = Fr(Nn._comment).replace("(?:--\x3e|$)", "--\x3e").getRegex()),
				(hn.emStrong.lDelim = Fr(hn.emStrong.lDelim).replace(/punct/g, hn._punctuation).getRegex()),
				(hn.emStrong.rDelimAst = Fr(hn.emStrong.rDelimAst, "g").replace(/punct/g, hn._punctuation).getRegex()),
				(hn.emStrong.rDelimUnd = Fr(hn.emStrong.rDelimUnd, "g").replace(/punct/g, hn._punctuation).getRegex()),
				(hn._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g),
				(hn._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/),
				(hn._email =
					/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/),
				(hn.autolink = Fr(hn.autolink).replace("scheme", hn._scheme).replace("email", hn._email).getRegex()),
				(hn._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/),
				(hn.tag = Fr(hn.tag).replace("comment", hn._comment).replace("attribute", hn._attribute).getRegex()),
				(hn._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/),
				(hn._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/),
				(hn._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/),
				(hn.link = Fr(hn.link).replace("label", hn._label).replace("href", hn._href).replace("title", hn._title).getRegex()),
				(hn.reflink = Fr(hn.reflink).replace("label", hn._label).replace("ref", Nn._label).getRegex()),
				(hn.nolink = Fr(hn.nolink).replace("ref", Nn._label).getRegex()),
				(hn.reflinkSearch = Fr(hn.reflinkSearch, "g").replace("reflink", hn.reflink).replace("nolink", hn.nolink).getRegex()),
				(hn.normal = { ...hn }),
				(hn.pedantic = {
					...hn.normal,
					strong: {
						start: /^__|\*\*/,
						middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
						endAst: /\*\*(?!\*)/g,
						endUnd: /__(?!_)/g
					},
					em: {
						start: /^_|\*/,
						middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
						endAst: /\*(?!\*)/g,
						endUnd: /_(?!_)/g
					},
					link: Fr(/^!?\[(label)\]\((.*?)\)/)
						.replace("label", hn._label)
						.getRegex(),
					reflink: Fr(/^!?\[(label)\]\s*\[([^\]]*)\]/)
						.replace("label", hn._label)
						.getRegex()
				}),
				(hn.gfm = {
					...hn.normal,
					escape: Fr(hn.escape).replace("])", "~|])").getRegex(),
					_extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
					url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
					_backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
					del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
					text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
				}),
				(hn.gfm.url = Fr(hn.gfm.url, "i").replace("email", hn.gfm._extended_email).getRegex()),
				(hn.breaks = {
					...hn.gfm,
					br: Fr(hn.br).replace("{2,}", "*").getRegex(),
					text: Fr(hn.gfm.text)
						.replace("\\b_", "\\b_| {2,}\\n")
						.replace(/\{2,\}/g, "*")
						.getRegex()
				})
			class Sf {
				constructor(n) {
					;(this.tokens = []),
						(this.tokens.links = Object.create(null)),
						(this.options = n || Vp),
						(this.options.tokenizer = this.options.tokenizer || new W3()),
						(this.tokenizer = this.options.tokenizer),
						(this.tokenizer.options = this.options),
						(this.tokenizer.lexer = this),
						(this.inlineQueue = []),
						(this.state = { inLink: !1, inRawBlock: !1, top: !0 })
					const e = { block: Nn.normal, inline: hn.normal }
					this.options.pedantic
						? ((e.block = Nn.pedantic), (e.inline = hn.pedantic))
						: this.options.gfm && ((e.block = Nn.gfm), (e.inline = this.options.breaks ? hn.breaks : hn.gfm)),
						(this.tokenizer.rules = e)
				}
				static get rules() {
					return { block: Nn, inline: hn }
				}
				static lex(n, e) {
					return new Sf(e).lex(n)
				}
				static lexInline(n, e) {
					return new Sf(e).inlineTokens(n)
				}
				lex(n) {
					let e
					for (n = n.replace(/\r\n|\r/g, "\n"), this.blockTokens(n, this.tokens); (e = this.inlineQueue.shift()); )
						this.inlineTokens(e.src, e.tokens)
					return this.tokens
				}
				blockTokens(n, e = []) {
					let i, r, o, s
					for (
						n = this.options.pedantic
							? n.replace(/\t/g, "    ").replace(/^ +$/gm, "")
							: n.replace(/^( *)(\t+)/gm, (a, c, l) => c + "    ".repeat(l.length));
						n;

					)
						if (
							!(
								this.options.extensions &&
								this.options.extensions.block &&
								this.options.extensions.block.some(
									a => !!(i = a.call({ lexer: this }, n, e)) && ((n = n.substring(i.raw.length)), e.push(i), !0)
								)
							)
						) {
							if ((i = this.tokenizer.space(n))) {
								;(n = n.substring(i.raw.length)),
									1 === i.raw.length && e.length > 0 ? (e[e.length - 1].raw += "\n") : e.push(i)
								continue
							}
							if ((i = this.tokenizer.code(n))) {
								;(n = n.substring(i.raw.length)),
									(r = e[e.length - 1]),
									!r || ("paragraph" !== r.type && "text" !== r.type)
										? e.push(i)
										: ((r.raw += "\n" + i.raw),
										  (r.text += "\n" + i.text),
										  (this.inlineQueue[this.inlineQueue.length - 1].src = r.text))
								continue
							}
							if ((i = this.tokenizer.fences(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.heading(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.hr(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.blockquote(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.list(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.html(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.def(n))) {
								;(n = n.substring(i.raw.length)),
									(r = e[e.length - 1]),
									!r || ("paragraph" !== r.type && "text" !== r.type)
										? this.tokens.links[i.tag] || (this.tokens.links[i.tag] = { href: i.href, title: i.title })
										: ((r.raw += "\n" + i.raw),
										  (r.text += "\n" + i.raw),
										  (this.inlineQueue[this.inlineQueue.length - 1].src = r.text))
								continue
							}
							if ((i = this.tokenizer.table(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.lheading(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if (((o = n), this.options.extensions && this.options.extensions.startBlock)) {
								let a = 1 / 0
								const c = n.slice(1)
								let l
								this.options.extensions.startBlock.forEach(function (d) {
									;(l = d.call({ lexer: this }, c)), "number" == typeof l && l >= 0 && (a = Math.min(a, l))
								}),
									a < 1 / 0 && a >= 0 && (o = n.substring(0, a + 1))
							}
							if (this.state.top && (i = this.tokenizer.paragraph(o))) {
								;(r = e[e.length - 1]),
									s && "paragraph" === r.type
										? ((r.raw += "\n" + i.raw),
										  (r.text += "\n" + i.text),
										  this.inlineQueue.pop(),
										  (this.inlineQueue[this.inlineQueue.length - 1].src = r.text))
										: e.push(i),
									(s = o.length !== n.length),
									(n = n.substring(i.raw.length))
								continue
							}
							if ((i = this.tokenizer.text(n))) {
								;(n = n.substring(i.raw.length)),
									(r = e[e.length - 1]),
									r && "text" === r.type
										? ((r.raw += "\n" + i.raw),
										  (r.text += "\n" + i.text),
										  this.inlineQueue.pop(),
										  (this.inlineQueue[this.inlineQueue.length - 1].src = r.text))
										: e.push(i)
								continue
							}
							if (n) {
								const a = "Infinite loop on byte: " + n.charCodeAt(0)
								if (this.options.silent) {
									console.error(a)
									break
								}
								throw new Error(a)
							}
						}
					return (this.state.top = !0), e
				}
				inline(n, e = []) {
					return this.inlineQueue.push({ src: n, tokens: e }), e
				}
				inlineTokens(n, e = []) {
					let i,
						r,
						o,
						a,
						c,
						l,
						s = n
					if (this.tokens.links) {
						const d = Object.keys(this.tokens.links)
						if (d.length > 0)
							for (; null != (a = this.tokenizer.rules.inline.reflinkSearch.exec(s)); )
								d.includes(a[0].slice(a[0].lastIndexOf("[") + 1, -1)) &&
									(s =
										s.slice(0, a.index) +
										"[" +
										gee("a", a[0].length - 2) +
										"]" +
										s.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
					}
					for (; null != (a = this.tokenizer.rules.inline.blockSkip.exec(s)); )
						s =
							s.slice(0, a.index) +
							"[" +
							gee("a", a[0].length - 2) +
							"]" +
							s.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)
					for (; null != (a = this.tokenizer.rules.inline.escapedEmSt.exec(s)); )
						(s = s.slice(0, a.index + a[0].length - 2) + "++" + s.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex)),
							this.tokenizer.rules.inline.escapedEmSt.lastIndex--
					for (; n; )
						if (
							(c || (l = ""),
							(c = !1),
							!(
								this.options.extensions &&
								this.options.extensions.inline &&
								this.options.extensions.inline.some(
									d => !!(i = d.call({ lexer: this }, n, e)) && ((n = n.substring(i.raw.length)), e.push(i), !0)
								)
							))
						) {
							if ((i = this.tokenizer.escape(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.tag(n))) {
								;(n = n.substring(i.raw.length)),
									(r = e[e.length - 1]),
									r && "text" === i.type && "text" === r.type ? ((r.raw += i.raw), (r.text += i.text)) : e.push(i)
								continue
							}
							if ((i = this.tokenizer.link(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.reflink(n, this.tokens.links))) {
								;(n = n.substring(i.raw.length)),
									(r = e[e.length - 1]),
									r && "text" === i.type && "text" === r.type ? ((r.raw += i.raw), (r.text += i.text)) : e.push(i)
								continue
							}
							if ((i = this.tokenizer.emStrong(n, s, l))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.codespan(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.br(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.del(n))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if ((i = this.tokenizer.autolink(n, _ee))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if (!this.state.inLink && (i = this.tokenizer.url(n, _ee))) {
								;(n = n.substring(i.raw.length)), e.push(i)
								continue
							}
							if (((o = n), this.options.extensions && this.options.extensions.startInline)) {
								let d = 1 / 0
								const u = n.slice(1)
								let h
								this.options.extensions.startInline.forEach(function (f) {
									;(h = f.call({ lexer: this }, u)), "number" == typeof h && h >= 0 && (d = Math.min(d, h))
								}),
									d < 1 / 0 && d >= 0 && (o = n.substring(0, d + 1))
							}
							if ((i = this.tokenizer.inlineText(o, YQe))) {
								;(n = n.substring(i.raw.length)),
									"_" !== i.raw.slice(-1) && (l = i.raw.slice(-1)),
									(c = !0),
									(r = e[e.length - 1]),
									r && "text" === r.type ? ((r.raw += i.raw), (r.text += i.text)) : e.push(i)
								continue
							}
							if (n) {
								const d = "Infinite loop on byte: " + n.charCodeAt(0)
								if (this.options.silent) {
									console.error(d)
									break
								}
								throw new Error(d)
							}
						}
					return e
				}
			}
			class j3 {
				constructor(n) {
					this.options = n || Vp
				}
				code(n, e, i) {
					const r = (e || "").match(/\S*/)[0]
					if (this.options.highlight) {
						const o = this.options.highlight(n, r)
						null != o && o !== n && ((i = !0), (n = o))
					}
					return (
						(n = n.replace(/\n$/, "") + "\n"),
						r
							? '<pre><code class="' + this.options.langPrefix + Ks(r) + '">' + (i ? n : Ks(n, !0)) + "</code></pre>\n"
							: "<pre><code>" + (i ? n : Ks(n, !0)) + "</code></pre>\n"
					)
				}
				blockquote(n) {
					return `<blockquote>\n${n}</blockquote>\n`
				}
				html(n) {
					return n
				}
				heading(n, e, i, r) {
					return this.options.headerIds
						? `<h${e} id="${this.options.headerPrefix + r.slug(i)}">${n}</h${e}>\n`
						: `<h${e}>${n}</h${e}>\n`
				}
				hr() {
					return this.options.xhtml ? "<hr/>\n" : "<hr>\n"
				}
				list(n, e, i) {
					const r = e ? "ol" : "ul"
					return "<" + r + (e && 1 !== i ? ' start="' + i + '"' : "") + ">\n" + n + "</" + r + ">\n"
				}
				listitem(n) {
					return `<li>${n}</li>\n`
				}
				checkbox(n) {
					return "<input " + (n ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> "
				}
				paragraph(n) {
					return `<p>${n}</p>\n`
				}
				table(n, e) {
					return e && (e = `<tbody>${e}</tbody>`), "<table>\n<thead>\n" + n + "</thead>\n" + e + "</table>\n"
				}
				tablerow(n) {
					return `<tr>\n${n}</tr>\n`
				}
				tablecell(n, e) {
					const i = e.header ? "th" : "td"
					return (e.align ? `<${i} align="${e.align}">` : `<${i}>`) + n + `</${i}>\n`
				}
				strong(n) {
					return `<strong>${n}</strong>`
				}
				em(n) {
					return `<em>${n}</em>`
				}
				codespan(n) {
					return `<code>${n}</code>`
				}
				br() {
					return this.options.xhtml ? "<br/>" : "<br>"
				}
				del(n) {
					return `<del>${n}</del>`
				}
				link(n, e, i) {
					if (null === (n = pee(this.options.sanitize, this.options.baseUrl, n))) return i
					let r = '<a href="' + n + '"'
					return e && (r += ' title="' + e + '"'), (r += ">" + i + "</a>"), r
				}
				image(n, e, i) {
					if (null === (n = pee(this.options.sanitize, this.options.baseUrl, n))) return i
					let r = `<img src="${n}" alt="${i}"`
					return e && (r += ` title="${e}"`), (r += this.options.xhtml ? "/>" : ">"), r
				}
				text(n) {
					return n
				}
			}
			class vee {
				strong(n) {
					return n
				}
				em(n) {
					return n
				}
				codespan(n) {
					return n
				}
				del(n) {
					return n
				}
				html(n) {
					return n
				}
				text(n) {
					return n
				}
				link(n, e, i) {
					return "" + i
				}
				image(n, e, i) {
					return "" + i
				}
				br() {
					return ""
				}
			}
			class yee {
				constructor() {
					this.seen = {}
				}
				serialize(n) {
					return n
						.toLowerCase()
						.trim()
						.replace(/<[!\/a-z].*?>/gi, "")
						.replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "")
						.replace(/\s/g, "-")
				}
				getNextSafeSlug(n, e) {
					let i = n,
						r = 0
					if (this.seen.hasOwnProperty(i)) {
						r = this.seen[n]
						do {
							r++, (i = n + "-" + r)
						} while (this.seen.hasOwnProperty(i))
					}
					return e || ((this.seen[n] = r), (this.seen[i] = 0)), i
				}
				slug(n, e = {}) {
					const i = this.serialize(n)
					return this.getNextSafeSlug(i, e.dryrun)
				}
			}
			class kf {
				constructor(n) {
					;(this.options = n || Vp),
						(this.options.renderer = this.options.renderer || new j3()),
						(this.renderer = this.options.renderer),
						(this.renderer.options = this.options),
						(this.textRenderer = new vee()),
						(this.slugger = new yee())
				}
				static parse(n, e) {
					return new kf(e).parse(n)
				}
				static parseInline(n, e) {
					return new kf(e).parseInline(n)
				}
				parse(n, e = !0) {
					let r,
						o,
						s,
						a,
						c,
						l,
						d,
						u,
						h,
						f,
						_,
						y,
						C,
						x,
						w,
						S,
						M,
						O,
						N,
						i = ""
					const j = n.length
					for (r = 0; r < j; r++)
						if (
							((f = n[r]),
							this.options.extensions &&
								this.options.extensions.renderers &&
								this.options.extensions.renderers[f.type] &&
								((N = this.options.extensions.renderers[f.type].call({ parser: this }, f)),
								!1 !== N ||
									![
										"space",
										"hr",
										"heading",
										"code",
										"table",
										"blockquote",
										"list",
										"html",
										"paragraph",
										"text"
									].includes(f.type)))
						)
							i += N || ""
						else
							switch (f.type) {
								case "space":
									continue
								case "hr":
									i += this.renderer.hr()
									continue
								case "heading":
									i += this.renderer.heading(
										this.parseInline(f.tokens),
										f.depth,
										mee(this.parseInline(f.tokens, this.textRenderer)),
										this.slugger
									)
									continue
								case "code":
									i += this.renderer.code(f.text, f.lang, f.escaped)
									continue
								case "table":
									for (u = "", d = "", a = f.header.length, o = 0; o < a; o++)
										d += this.renderer.tablecell(this.parseInline(f.header[o].tokens), {
											header: !0,
											align: f.align[o]
										})
									for (u += this.renderer.tablerow(d), h = "", a = f.rows.length, o = 0; o < a; o++) {
										for (l = f.rows[o], d = "", c = l.length, s = 0; s < c; s++)
											d += this.renderer.tablecell(this.parseInline(l[s].tokens), { header: !1, align: f.align[s] })
										h += this.renderer.tablerow(d)
									}
									i += this.renderer.table(u, h)
									continue
								case "blockquote":
									;(h = this.parse(f.tokens)), (i += this.renderer.blockquote(h))
									continue
								case "list":
									for (_ = f.ordered, y = f.start, C = f.loose, a = f.items.length, h = "", o = 0; o < a; o++)
										(w = f.items[o]),
											(S = w.checked),
											(M = w.task),
											(x = ""),
											w.task &&
												((O = this.renderer.checkbox(S)),
												C
													? w.tokens.length > 0 && "paragraph" === w.tokens[0].type
														? ((w.tokens[0].text = O + " " + w.tokens[0].text),
														  w.tokens[0].tokens &&
																w.tokens[0].tokens.length > 0 &&
																"text" === w.tokens[0].tokens[0].type &&
																(w.tokens[0].tokens[0].text = O + " " + w.tokens[0].tokens[0].text))
														: w.tokens.unshift({ type: "text", text: O })
													: (x += O)),
											(x += this.parse(w.tokens, C)),
											(h += this.renderer.listitem(x, M, S))
									i += this.renderer.list(h, _, y)
									continue
								case "html":
									i += this.renderer.html(f.text)
									continue
								case "paragraph":
									i += this.renderer.paragraph(this.parseInline(f.tokens))
									continue
								case "text":
									for (h = f.tokens ? this.parseInline(f.tokens) : f.text; r + 1 < j && "text" === n[r + 1].type; )
										(f = n[++r]), (h += "\n" + (f.tokens ? this.parseInline(f.tokens) : f.text))
									i += e ? this.renderer.paragraph(h) : h
									continue
								default: {
									const le = 'Token with "' + f.type + '" type was not found.'
									if (this.options.silent) return void console.error(le)
									throw new Error(le)
								}
							}
					return i
				}
				parseInline(n, e) {
					e = e || this.renderer
					let r,
						o,
						s,
						i = ""
					const a = n.length
					for (r = 0; r < a; r++)
						if (
							((o = n[r]),
							this.options.extensions &&
								this.options.extensions.renderers &&
								this.options.extensions.renderers[o.type] &&
								((s = this.options.extensions.renderers[o.type].call({ parser: this }, o)),
								!1 !== s ||
									!["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(o.type)))
						)
							i += s || ""
						else
							switch (o.type) {
								case "escape":
								case "text":
									i += e.text(o.text)
									break
								case "html":
									i += e.html(o.text)
									break
								case "link":
									i += e.link(o.href, o.title, this.parseInline(o.tokens, e))
									break
								case "image":
									i += e.image(o.href, o.title, o.text)
									break
								case "strong":
									i += e.strong(this.parseInline(o.tokens, e))
									break
								case "em":
									i += e.em(this.parseInline(o.tokens, e))
									break
								case "codespan":
									i += e.codespan(o.text)
									break
								case "br":
									i += e.br()
									break
								case "del":
									i += e.del(this.parseInline(o.tokens, e))
									break
								default: {
									const c = 'Token with "' + o.type + '" type was not found.'
									if (this.options.silent) return void console.error(c)
									throw new Error(c)
								}
							}
					return i
				}
			}
			class K3 {
				constructor(n) {
					this.options = n || Vp
				}
				static passThroughHooks = new Set(["preprocess", "postprocess"])
				preprocess(n) {
					return n
				}
				postprocess(n) {
					return n
				}
			}
			function wee(t, n) {
				return (e, i, r) => {
					"function" == typeof i && ((r = i), (i = null))
					const o = { ...i },
						s = (function qQe(t, n, e) {
							return i => {
								if (((i.message += "\nPlease report this to https://github.com/markedjs/marked."), t)) {
									const r = "<p>An error occurred:</p><pre>" + Ks(i.message + "", !0) + "</pre>"
									return n ? Promise.resolve(r) : e ? void e(null, r) : r
								}
								if (n) return Promise.reject(i)
								if (!e) throw i
								e(i)
							}
						})((i = { ...zn.defaults, ...o }).silent, i.async, r)
					if (typeof e > "u" || null === e) return s(new Error("marked(): input parameter is undefined or null"))
					if ("string" != typeof e)
						return s(
							new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected")
						)
					if (
						((function KQe(t) {
							t &&
								t.sanitize &&
								!t.silent &&
								console.warn(
									"marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options"
								)
						})(i),
						i.hooks && (i.hooks.options = i),
						r)
					) {
						const a = i.highlight
						let c
						try {
							i.hooks && (e = i.hooks.preprocess(e)), (c = t(e, i))
						} catch (u) {
							return s(u)
						}
						const l = function (u) {
							let h
							if (!u)
								try {
									i.walkTokens && zn.walkTokens(c, i.walkTokens), (h = n(c, i)), i.hooks && (h = i.hooks.postprocess(h))
								} catch (f) {
									u = f
								}
							return (i.highlight = a), u ? s(u) : r(null, h)
						}
						if (!a || a.length < 3 || (delete i.highlight, !c.length)) return l()
						let d = 0
						return (
							zn.walkTokens(c, function (u) {
								"code" === u.type &&
									(d++,
									setTimeout(() => {
										a(u.text, u.lang, function (h, f) {
											if (h) return l(h)
											null != f && f !== u.text && ((u.text = f), (u.escaped = !0)), d--, 0 === d && l()
										})
									}, 0))
							}),
							void (0 === d && l())
						)
					}
					if (i.async)
						return Promise.resolve(i.hooks ? i.hooks.preprocess(e) : e)
							.then(a => t(a, i))
							.then(a => (i.walkTokens ? Promise.all(zn.walkTokens(a, i.walkTokens)).then(() => a) : a))
							.then(a => n(a, i))
							.then(a => (i.hooks ? i.hooks.postprocess(a) : a))
							.catch(s)
					try {
						i.hooks && (e = i.hooks.preprocess(e))
						const a = t(e, i)
						i.walkTokens && zn.walkTokens(a, i.walkTokens)
						let c = n(a, i)
						return i.hooks && (c = i.hooks.postprocess(c)), c
					} catch (a) {
						return s(a)
					}
				}
			}
			function zn(t, n, e) {
				return wee(Sf.lex, kf.parse)(t, n, e)
			}
			function ZQe(t, n) {
				if ((1 & t && (F(0, "div")(1, "h2"), ge(2), L(), fe(3, "ul", 7), L()), 2 & t)) {
					const e = n.$implicit
					T(2), cr(e.key), T(1), U("innerHTML", e.value, $F)
				}
			}
			;(zn.options = zn.setOptions =
				function (t) {
					return (
						(function RQe(t) {
							Vp = t
						})((zn.defaults = { ...zn.defaults, ...t })),
						zn
					)
				}),
				(zn.getDefaults = function dee() {
					return {
						async: !1,
						baseUrl: null,
						breaks: !1,
						extensions: null,
						gfm: !0,
						headerIds: !0,
						headerPrefix: "",
						highlight: null,
						hooks: null,
						langPrefix: "language-",
						mangle: !0,
						pedantic: !1,
						renderer: null,
						sanitize: !1,
						sanitizer: null,
						silent: !1,
						smartypants: !1,
						tokenizer: null,
						walkTokens: null,
						xhtml: !1
					}
				}),
				(zn.defaults = Vp),
				(zn.use = function (...t) {
					const n = zn.defaults.extensions || { renderers: {}, childTokens: {} }
					t.forEach(e => {
						const i = { ...e }
						if (
							((i.async = zn.defaults.async || i.async || !1),
							e.extensions &&
								(e.extensions.forEach(r => {
									if (!r.name) throw new Error("extension name required")
									if (r.renderer) {
										const o = n.renderers[r.name]
										n.renderers[r.name] = o
											? function (...s) {
													let a = r.renderer.apply(this, s)
													return !1 === a && (a = o.apply(this, s)), a
											  }
											: r.renderer
									}
									if (r.tokenizer) {
										if (!r.level || ("block" !== r.level && "inline" !== r.level))
											throw new Error("extension level must be 'block' or 'inline'")
										n[r.level] ? n[r.level].unshift(r.tokenizer) : (n[r.level] = [r.tokenizer]),
											r.start &&
												("block" === r.level
													? n.startBlock
														? n.startBlock.push(r.start)
														: (n.startBlock = [r.start])
													: "inline" === r.level &&
													  (n.startInline ? n.startInline.push(r.start) : (n.startInline = [r.start])))
									}
									r.childTokens && (n.childTokens[r.name] = r.childTokens)
								}),
								(i.extensions = n)),
							e.renderer)
						) {
							const r = zn.defaults.renderer || new j3()
							for (const o in e.renderer) {
								const s = r[o]
								r[o] = (...a) => {
									let c = e.renderer[o].apply(r, a)
									return !1 === c && (c = s.apply(r, a)), c
								}
							}
							i.renderer = r
						}
						if (e.tokenizer) {
							const r = zn.defaults.tokenizer || new W3()
							for (const o in e.tokenizer) {
								const s = r[o]
								r[o] = (...a) => {
									let c = e.tokenizer[o].apply(r, a)
									return !1 === c && (c = s.apply(r, a)), c
								}
							}
							i.tokenizer = r
						}
						if (e.hooks) {
							const r = zn.defaults.hooks || new K3()
							for (const o in e.hooks) {
								const s = r[o]
								r[o] = K3.passThroughHooks.has(o)
									? a => {
											if (zn.defaults.async) return Promise.resolve(e.hooks[o].call(r, a)).then(l => s.call(r, l))
											const c = e.hooks[o].call(r, a)
											return s.call(r, c)
									  }
									: (...a) => {
											let c = e.hooks[o].apply(r, a)
											return !1 === c && (c = s.apply(r, a)), c
									  }
							}
							i.hooks = r
						}
						if (e.walkTokens) {
							const r = zn.defaults.walkTokens
							i.walkTokens = function (o) {
								let s = []
								return s.push(e.walkTokens.call(this, o)), r && (s = s.concat(r.call(this, o))), s
							}
						}
						zn.setOptions(i)
					})
				}),
				(zn.walkTokens = function (t, n) {
					let e = []
					for (const i of t)
						switch (((e = e.concat(n.call(zn, i))), i.type)) {
							case "table":
								for (const r of i.header) e = e.concat(zn.walkTokens(r.tokens, n))
								for (const r of i.rows) for (const o of r) e = e.concat(zn.walkTokens(o.tokens, n))
								break
							case "list":
								e = e.concat(zn.walkTokens(i.items, n))
								break
							default:
								zn.defaults.extensions && zn.defaults.extensions.childTokens && zn.defaults.extensions.childTokens[i.type]
									? zn.defaults.extensions.childTokens[i.type].forEach(function (r) {
											e = e.concat(zn.walkTokens(i[r], n))
									  })
									: i.tokens && (e = e.concat(zn.walkTokens(i.tokens, n)))
						}
					return e
				}),
				(zn.parseInline = wee(Sf.lexInline, kf.parseInline)),
				(zn.Parser = kf),
				(zn.parser = kf.parse),
				(zn.Renderer = j3),
				(zn.TextRenderer = vee),
				(zn.Lexer = Sf),
				(zn.lexer = Sf.lex),
				(zn.Tokenizer = W3),
				(zn.Slugger = yee),
				(zn.Hooks = K3),
				(zn.parse = zn)
			let JQe = (() => {
				class t {
					constructor(e) {
						;(this.data = e), (this.changes = this.getChangelogChanges())
					}
					getChangelogChanges() {
						let i = zn
							.parse(
								'# Change Log - Visualization\r\n\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/)\r\nand this project adheres to [Semantic Versioning](http://semver.org/)\r\n\r\n## [unreleased] (Added \u{1f680} | Changed | Removed \u{1f5d1} | Fixed \u{1f41e} | Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb})\r\n\r\n## [1.124.2] - 2024-04-04\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add search bar for custom configs [#3529](https://github.com/MaibornWolff/codecharta/pull/3529)\r\n-   Automatically reverse the metric direction for those where higher values indicate better codequality, such as `branch_coverage` [#3518](https://github.com/MaibornWolff/codecharta/pull/3518)\r\n-   Display summary metrics for root node as default [#3525](https://github.com/MaibornWolff/codecharta/pull/3525)\r\n-   Remove whitespace on screenshots [#3527](https://github.com/MaibornWolff/codecharta/pull/3527)\r\n\r\n## [1.124.1] - 2024-03-18\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix metrics being reset on excluding / flattening buildings [#3524](https://github.com/MaibornWolff/codecharta/pull/3524)\r\n-   Take direction of attributes into account when creating the list with highest metrics [#3526](https://github.com/MaibornWolff/codecharta/pull/3526)\r\n\r\n## [1.124.0] - 2024-03-18\r\n\r\n### Added \u{1f680}\r\n\r\n-   Display diagram of color distribution [#3511](https://github.com/MaibornWolff/codecharta/pull/3511)\r\n    </br>\r\n    <img width="300" alt="color-metric-diagram" src="https://github.com/MaibornWolff/codecharta/assets/149768491/0b0e4e6f-e0c2-49b1-b9e8-2d69002338f0">\r\n    </br>\r\n-   Persist uploaded files and applied configuration accross page-reloads [#3486](https://github.com/MaibornWolff/codecharta/pull/3486)\r\n-   Height, color, edge and area metric can be selected via query parameters [#3513](https://github.com/MaibornWolff/codecharta/pull/3513)\r\n-   Capturing a screenshot of the map also captures the legend [#3520](https://github.com/MaibornWolff/codecharta/pull/3520)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Bump node version from 16 to 18 [#3452](https://github.com/MaibornWolff/codecharta/pull/3452)\r\n\r\n## [1.123.0] - 2024-02-26\r\n\r\n### Changed\r\n\r\n-   CodeCharta Analysis and Visualization now have separate changelogs and releases [#3499](https://github.com/MaibornWolff/codecharta/pull/3499)\r\n\r\n### Added \u{1f680}\r\n\r\n-   Highlight building on-click of file in explorer [#3488](https://github.com/MaibornWolff/codecharta/pull/3488)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix buildings inability to be completely red in delta mode [#3439](https://github.com/MaibornWolff/codecharta/pull/3439)\r\n-   Fix edge preview in visualization [#3439](https://github.com/MaibornWolff/codecharta/pull/3439)\r\n-   Fix edges start/end intersecting with building in delta mode [#3439](https://github.com/MaibornWolff/codecharta/pull/3439)\r\n-   Fix style issues in the node/file explorer of visualization [#3439](https://github.com/MaibornWolff/codecharta/pull/3439)\r\n\r\n## [1.122.0] - 2024-01-16\r\n\r\n### Added \u{1f680}\r\n\r\n-   File explorer can be pinned while analyzing the code-map [#3459](https://github.com/MaibornWolff/codecharta/pull/3459)\r\n-   Validate input file during interactive parser configuration [#3460](https://github.com/MaibornWolff/codecharta/pull/3460)\r\n-   Add functionality to screenshot legend [#3471](https://github.com/MaibornWolff/codecharta/pull/3471)\r\n\r\n### Changed\r\n\r\n-   Multiple values for options need to be separated by comma [#3434](https://github.com/MaibornWolff/codecharta/pull/3434)\r\n-   Changed the short-form of the `--no-issues` flag in the SourceCodeParser from `-i` to `-ni` [#3434](https://github.com/MaibornWolff/codecharta/pull/3434)\r\n-   Clarify sonar user token question [#3445](https://github.com/MaibornWolff/codecharta/pull/3445)\r\n-   Changed the `--user` flag to `--user-token` in SonarImporter [#3445](https://github.com/MaibornWolff/codecharta/pull/3445)\r\n-   Changed the interactive dialog of `modify` to prompt user for single action to perform [#3448](https://github.com/MaibornWolff/codecharta/pull/3448)\r\n-   Selected buildings now keep their label until they are unselected [#3465](https://github.com/MaibornWolff/codecharta/pull/3465)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix saving the number of top-labels in custom configs [#3461](https://github.com/MaibornWolff/codecharta/pull/3461)\r\n-   Fix parsers crashing after printing output to stdout [#3442](https://github.com/MaibornWolff/codecharta/pull/3442)\r\n-   Fix removal of nodes with identical names in `modify` [#3446](https://github.com/MaibornWolff/codecharta/pull/3446)\r\n-   Fix the highlighting of very high risk metrics to highlight only matching files [#3454](https://github.com/MaibornWolff/codecharta/pull/3454)\r\n\r\n## [1.121.1] - 2023-12-08\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix github-pages not showing documentation [#3436](https://github.com/MaibornWolff/codecharta/pull/3436)\r\n\r\n## [1.121.0] - 2023-12-07\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add logging of absolute file paths of output files [#3414](https://github.com/MaibornWolff/codecharta/pull/3414)\r\n\r\n### Changed\r\n\r\n-   Changed short form of parameter `--file-extensions` of RawTextParser from `-f` to `-fe` [#3405](https://github.com/MaibornWolff/codecharta/pull/3405)\r\n-   Update readme and gh-pages for RawTextParser [#3405](https://github.com/MaibornWolff/codecharta/pull/3405)\r\n-   Changed the `--format` flag for csv-output in SourceCodeParser from `table` to `csv` [#3414](https://github.com/MaibornWolff/codecharta/pull/3414)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix RawTextParser producing incorrect output when no (or multiple) file extensions were specified in interactive mode [#3405](https://github.com/MaibornWolff/codecharta/pull/3405)\r\n-   Fix handling of empty inputs for the `--metrics`, `--exclude`, `--file-extensions` flags in the RawTextParser [#3415](https://github.com/MaibornWolff/codecharta/pull/3415)\r\n-   Fix RawTextParser incorrectly setting max indentation level to a predefined value [#3419](https://github.com/MaibornWolff/codecharta/pull/3419)\r\n-   Fix the csv-exporter so that it exports multiple projects instead of just one when multiple projects are specified [#3414](https://github.com/MaibornWolff/codecharta/pull/3414)\r\n-   Fix file extensions of output files for merged projects [#3421](https://github.com/MaibornWolff/codecharta/pull/3421)\r\n-   Fix the ability for users to accidentally pass invalid metrics to the RawTextParser without it crashing [#3424](https://github.com/MaibornWolff/codecharta/pull/3424)\r\n-   Fix deselected buildings with green/red roof in delta mode do not reset their color roof [#3426](https://github.com/MaibornWolff/codecharta/pull/3426)\r\n-   Fix parser hang issue in interactive mode caused by unintentional "enter" input after the last question [#3422](https://github.com/MaibornWolff/codecharta/pull/3422)\r\n\r\n### Chore \u200d\u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Upgraded to angular 16 [#3408](https://github.com/MaibornWolff/codecharta/pull/3408)\r\n\r\n## [1.120.1] - 2023-11-17\r\n\r\n### Removed \u{1f5d1}\r\n\r\n-   Deprecated download button removed (functionality has been replaced by custom views) [#3398](https://github.com/MaibornWolff/codecharta/pull/3398)\r\n-   Remove the \'new\' badges from the \'Custom Views\' and \'Suspicious Metrics\' features as these features are no longer new [#3393](https://github.com/MaibornWolff/codecharta/pull/3399)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix an issue with web demo on Safari showing a white screen and not loading [#3396](https://github.com/MaibornWolff/codecharta/pull/3396)\r\n-   Fix the ability for users to skip the value for tab-width when configuring the rawtextparser and estimate its value [#3404](https://github.com/MaibornWolff/codecharta/pull/3404)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Add documentation for the installation requirements for metric-gardener [#3395](https://github.com/MaibornWolff/codecharta/pull/3395)\r\n-   Add hints to README (visualization and package) about MacOS arm64 standalone execution [#3395](https://github.com/MaibornWolff/codecharta/pull/3395)\r\n\r\n## [1.120.0] - 2023-11-02\r\n\r\n### Added \u{1f680}\r\n\r\n-   Only ask to merge results after parser suggestion execution when more than one parser was executed [#3384](https://github.com/MaibornWolff/codecharta/pull/3384)\r\n-   Add the description of each parser to the list of suggested parsers [#3387](https://github.com/MaibornWolff/codecharta/pull/3387)\r\n\r\n### Changed\r\n\r\n-   Adjust console output of metric gardener importer to no longer include one line for each processed node [#3386](https://github.com/MaibornWolff/codecharta/pull/3390)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix command not found issue for --version and --help in the analysis [#3377](https://github.com/MaibornWolff/codecharta/pull/3377)\r\n-   Fix metric gardener importer getting stuck for large inputs [#3382](https://github.com/MaibornWolff/codecharta/pull/3382)\r\n-   Update docs for ccsh to remove outdated parameters and unify the pages structure [#3333](https://github.com/MaibornWolff/codecharta/pull/3388)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Raise minimum required Java Version from 8 to 11 [#3359](https://github.com/MaibornWolff/codecharta/pull/3359)\r\n-   Swap nw.js to electron for standalone execution [#3373](https://github.com/MaibornWolff/codecharta/pull/3373)\r\n\r\n## [1.119.1] - 2023-08-03\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix ccsh execution under windows via cmd-terminal [#3354](https://github.com/MaibornWolff/codecharta/pull/3354)\r\n\r\n## [1.119.0] - 2023-07-13\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add message outputting which parser is being configured during parser suggestions [#3335](https://github.com/MaibornWolff/codecharta/pull/3335)\r\n-   Add basic validity checking for all input resources (files/folders, url for SonarImporter) [#3325](https://github.com/MaibornWolff/codecharta/pull/3325)\r\n-   Automatically start specific interactive parser when calling parser without args [#3332](https://github.com/MaibornWolff/codecharta/pull/3332)\r\n\r\n## [1.118.0] - 2023-06-15\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add metric tooltips that display attribute descriptors and provide hyperlinks in the sidebar to the metric\'s documentation [#3273](https://github.com/MaibornWolff/codecharta/pull/3273) </br>\r\n    <img src="https://user-images.githubusercontent.com/65733509/241383211-d9e8e54b-6b06-45bb-8b99-81cc8e0a4596.png" width="450px"/> <img src="https://github.com/MaibornWolff/codecharta/assets/65733509/0ade9ad4-e60b-4911-aadc-d8142167b21a" width="300px"/>\r\n-   Expand and restructure documentation regarding Docker usage [#3312](https://github.com/MaibornWolff/codecharta/pull/3312)\r\n-   Add current working directories as hint or default value to interactive parser and parser suggestions when asking for input [#3319](https://github.com/MaibornWolff/codecharta/pull/3319)\r\n-   Add helpful status messages when calculating parser suggestions [#3329](https://github.com/MaibornWolff/codecharta/pull/3329)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Speed up parser suggestions significantly [#3329](https://github.com/MaibornWolff/codecharta/pull/3329)\r\n-   Fix color range reset not triggering on color metric change [#3311](https://github.com/MaibornWolff/codecharta/pull/3311)\r\n\r\n## [1.117.0] - 2023-05-19\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add support for parser suggestions to SVN-, MetricGardener-, RawText- and SourceCodeParser [#3287](https://github.com/MaibornWolff/codecharta/pull/3287)\r\n-   Add semi automatic merging feature after executing multiple parsers [#3287](https://github.com/MaibornWolff/codecharta/pull/3287)\r\n-   Expand developer documentation to include common problems and solutions for them [#3289](https://github.com/MaibornWolff/codecharta/pull/3289)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix entrypoint for analysis docker image [#3259](https://github.com/MaibornWolff/codecharta/pull/3259)\r\n-   Show again delta of a building which have nothing in common in red or green [#3271](https://github.com/MaibornWolff/codecharta/pull/3271)\r\n-   Always show description of suspicious metrics [#3285](https://github.com/MaibornWolff/codecharta/pull/3285)\r\n-   Show suspicious metrics and risk profile documentation pages in navigation bar [#3290](https://github.com/MaibornWolff/codecharta/pull/3290)\r\n-   Merge filter will now abort execution when an invalid file is specified as input [#3305](https://github.com/MaibornWolff/codecharta/pull/3305)\r\n-   Fix formatting issues in docs turning `--` to `\u2013` [#3301](https://github.com/MaibornWolff/codecharta/pull/3301)\r\n\r\n### Changed\r\n\r\n-   Adjusted documentation for parser suggestions [#3287](https://github.com/MaibornWolff/codecharta/pull/3287)\r\n-   Make the size of the CodeCharta logo more suitable for any screen size and remove MaibornWolff logo [#3302](https://github.com/MaibornWolff/codecharta/pull/3302)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Replace custom Redux adapter through real NgRx [#3271](https://github.com/MaibornWolff/codecharta/pull/3271)\r\n\r\n## [1.116.0] - 2023-04-28\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add automatic parser suggestions to recommend usable parsers for a codebase (supports GitLogParser and SonarImporter) when running `ccsh` command [#3275](https://github.com/MaibornWolff/codecharta/pull/3275) </br>\r\n    ![image](https://user-images.githubusercontent.com/129938897/234309117-c9edd4e7-7c53-4ba7-b849-ec9c3f8f3215.png)\r\n-   Add documentation subsections for interactive shell and parser suggestions\r\n\r\n### Changed\r\n\r\n-   Changed default behavior when launching ccsh without arguments to parser suggestions [#3275](https://github.com/MaibornWolff/codecharta/pull/3275)\r\n-   Old interactive parser selection now reachable by passing `-i` or `--interactive` as arguments [#3275](https://github.com/MaibornWolff/codecharta/pull/3275)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix suspicious metrics and risk profile docs not loading [#3272](https://github.com/MaibornWolff/codecharta/pull/3272)\r\n\r\n## [1.115.1] - 2023-04-06\r\n\r\n### Removed \u{1f5d1}\r\n\r\n-   Support for Custom Views created before CodeCharta version 1.110.0 or older is no longer be maintained [#3265](https://github.com/MaibornWolff/codecharta/pull/3265)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix the disappearance of the suspicious metrics labels [#3263](https://github.com/MaibornWolff/codecharta/pull/3263)\r\n-   Fix UI components that look different since version 1.115.0 [#3260](https://github.com/MaibornWolff/codecharta/pull/3260)\r\n-   Show latest release notes in changelog dialog [#3264](https://github.com/MaibornWolff/codecharta/pull/3264)\r\n\r\n## [1.115.0] - 2023-03-30\r\n\r\n### Added \u{1f680}\r\n\r\n-   Display the CodeCharta logo next to the MaibornWolff logo [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n-   Tooltip for primary and secondary metrics that displays AttributeDescriptor information in the sidebar [#3239](https://github.com/MaibornWolff/codecharta/pull/3239) </br>\r\n    ![image](https://user-images.githubusercontent.com/65733509/227218468-b7d1e1ae-b847-40ab-8513-f3762b8787bb.png)\r\n-   Supports adding note to a custom view, provides a preview and an edit option for notes from the selection menu [#3234](https://github.com/MaibornWolff/codecharta/pull/3234) </br>\r\n    ![image](https://user-images.githubusercontent.com/72517530/226942610-9e08d39c-324d-4de3-81d0-4e5da4e589aa.png)\r\n    ![image](https://user-images.githubusercontent.com/72517530/226943152-1bb339bb-c39f-4bf6-a32d-ee8476249f98.png)\r\n\r\n### Changed\r\n\r\n-   The Suspicious metrics and Risk profile Feature is now also available outside the Experimental Feature Mode [#2963](https://github.com/MaibornWolff/codecharta/pull/2963) </br>\r\n    ![image](https://user-images.githubusercontent.com/47224279/222686442-05d4b83c-04d7-4275-b1eb-4339e8906130.jpg)\r\n-   Made the background color a bit lighter [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n-   Saturate the distribution bar colors [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n-   Improve the layout of all metric menus [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n-   Improve the layout of the global configuration dialog [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n-   Improve the layout of the metric chooser panel [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n-   Change the primary color to match the color of the CodeCharta logo [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n-   Improve the docs for suspicious metrics and risk profile feature [#3238](https://github.com/MaibornWolff/codecharta/pull/3238)\r\n-   Improve Custom Views Dialog [#3238](https://github.com/MaibornWolff/codecharta/pull/3248)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Unselecting a folder in Presentation Mode leads to console error [#3215](https://github.com/MaibornWolff/codecharta/pull/3215)\r\n-   Fix Shrunken FileExplorer\'s file list on small displays [#3235](https://github.com/MaibornWolff/codecharta/pull/3235)\r\n-   Fix various margin problems in the UI [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n-   Fix bumpy animations when moving/turning the map, hover buildings (showing labels and edges) [#3244](https://github.com/MaibornWolff/codecharta/pull/3244)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Upgrade all material UI components to MDC (not using the UI legacy components any more) [#3226](https://github.com/MaibornWolff/codecharta/pull/3226)\r\n\r\n## [1.114.0] - 2023-01-13\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add an option to hide floor labels under the Area Metric Options. This recalculates the map. [#3175](https://github.com/MaibornWolff/codecharta/pull/3175)\r\n\r\n### Removed \u{1f5d1}\r\n\r\n-   Camera settings for custom views generated with version 1.101.1 and earlier are now ignored. [#3196](https://github.com/MaibornWolff/codecharta/pull/3196)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Reposition legend panel button again, when attribute sidebar is open [#3183](https://github.com/MaibornWolff/codecharta/pull/3183)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Add attribute descriptors (metric descriptions) to TokeiImporter and SVNlogParser [#3176](https://github.com/MaibornWolff/codecharta/pull/3176)\r\n\r\n## [1.113.0] - 2022-12-15\r\n\r\n### Changed\r\n\r\n-   The Custom Views Feature is now also available outside the Experimental Feature Mode [#3079](https://github.com/MaibornWolff/codecharta/pull/3076) </br>\r\n    ![image](https://user-images.githubusercontent.com/72517530/204557970-0ba31f3b-5209-4707-a2d0-55cc45509f8a.png)\r\n-   Please note that the functionality of downloading cc.json maps will no longer be supported from April 2023. Instead, use the Custom View feature to create and share configurations for different views of your map. [#3079](https://github.com/MaibornWolff/codecharta/pull/3076)\r\n-   Change tooltips in the legend to show the metric description [#3162](https://github.com/MaibornWolff/codecharta/pull/3162) <br/>\r\n    ![image](https://user-images.githubusercontent.com/27358421/205251507-100b1e1a-d86e-44f3-89cf-f32bf295aabd.png)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Improve metric titles by loading them from cc.json [#3162](https://github.com/MaibornWolff/codecharta/pull/3162)\r\n-   Add attribute descriptors to SoureCodeParser [#3166](https://github.com/MaibornWolff/codecharta/pull/3166)\r\n\r\n## [1.112.1] - 2022-12-01\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Reverted PR [#3077](https://github.com/MaibornWolff/codecharta/pull/3077) that introduced a rendering bug, where buildings sizes were not proportional to their area value [#3159](https://github.com/MaibornWolff/codecharta/pull/3159)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Add attribute descriptors to SonarImporter [#3149](https://github.com/MaibornWolff/codecharta/pull/3149)\r\n-   Add title field to attribute descriptors [#3158](https://github.com/MaibornWolff/codecharta/pull/3158)\r\n\r\n## [1.112.0] - 2022-11-25\r\n\r\n### Added \u{1f680}\r\n\r\n-   New calculation algorithm for treeMap that accounts for paddings and floor labels [#3077](https://github.com/MaibornWolff/codecharta/pull/3077)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix ribbon-bar shadow moving down when search is expanded [#3138](https://github.com/MaibornWolff/codecharta/pull/3138)\r\n-   Fix loading errors of maps containing no programming-language-info [#3144](https://github.com/MaibornWolff/codecharta/pull/3144)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Documentation for new treeMap calculation algorithm [#3077](https://github.com/MaibornWolff/codecharta/pull/3077)\r\n-   Add attribute descriptors (metric descriptions) to some filters and importers [#3091](https://github.com/MaibornWolff/codecharta/pull/3091)\r\n\r\n## [1.111.0] - 2022-11-17\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add description to every Custom View [#3119](https://github.com/MaibornWolff/codecharta/pull/3119) </br>\r\n    ![image](https://user-images.githubusercontent.com/72517530/201381274-a9a913d5-8f9d-4da6-9f26-6476e194ce3b.png)\r\n-   Highlight files and folders with no area metric or an area metric value of zero in the search panel [#3126](https://github.com/MaibornWolff/codecharta/pull/3126)\r\n\r\n### Changed\r\n\r\n-   Be aware, that all Custom Views generated with version 1.110.0 or older will be unusable by April 2023 [#3119](https://github.com/MaibornWolff/codecharta/pull/3119)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix Node Context-Menu in Map Tree View opening multiple times [#3135](https://github.com/MaibornWolff/codecharta/pull/3135)\r\n-   Fix crashing on focusing or hovering un-rendered buildings [#3123](https://github.com/MaibornWolff/codecharta/pull/3123)\r\n-   Fix showing changelog entries in the dialog when a new version is available [#3123](https://github.com/MaibornWolff/codecharta/pull/3129)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Update supported latest browsers [#3125](https://github.com/MaibornWolff/codecharta/pull/3125)\r\n-   Split e2e and unit test configs [#3128](https://github.com/MaibornWolff/codecharta/pull/3128)\r\n\r\n## [1.110.0] - 2022-11-04\r\n\r\n### Changed\r\n\r\n-   Custom Views are now applicable even if maps or mode are different. Missing maps or map selection mode is displayed in the tooltip [#3090](https://github.com/MaibornWolff/codecharta/pull/3090)\r\n-   Be aware, that all Custom Views generated with version 1.109.1 or older will be unusable by April 2023 [#3105](https://github.com/MaibornWolff/codecharta/pull/3105)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix broken link to Custom View documentation [#3101](https://github.com/MaibornWolff/codecharta/pull/3101)\r\n-   Don\'t re-center map after every state change like changing area metric [#3109](https://github.com/MaibornWolff/codecharta/pull/3109)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Adjust Custom View API and maintain old Custom Views until April 2023 [#3105](https://github.com/MaibornWolff/codecharta/pull/3105)\r\n-   Migrate codeMap.render.service, codeMap.label.service, codeMap.mouseEvent.service, codeMap.arrow.service, codeCharta.service, sharpnessMode.service, isLoadingFile.service, scaling.service and experimentalFeaturesEnabled.service to Angular [#3094](https://github.com/MaibornWolff/codecharta/pull/3094)\r\n-   Extract tree map size into a const as this is never changed [3098](https://github.com/MaibornWolff/codecharta/pull/3098)\r\n-   Migrate markedPackages.service, edges.service, blacklist.service, files.service and injector.service [3106](https://github.com/MaibornWolff/codecharta/pull/3106)\r\n-   Refactor out `LoadInitialFileService` and fix with it loose Promise in tests [#3110](https://github.com/MaibornWolff/codecharta/pull/3110)\r\n-   Migrate codeCharta.component, storeService.service and remove AngularJS dual boot from bootstrapping [#3114](https://github.com/MaibornWolff/codecharta/pull/3114)\r\n-   Remove obsolete AngularJS dependencies [#3115](https://github.com/MaibornWolff/codecharta/pull/3115)\r\n\r\n## [1.109.1] - 2022-10-12\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix broken links on new GitHub Page \'Docker Containers\' [#3089](https://github.com/MaibornWolff/codecharta/pull/3089)\r\n\r\n## [1.109.0] - 2022-10-12\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add description and documentation to Custom View modal [#3085](https://github.com/MaibornWolff/codecharta/pull/3085)\r\n-   Add a new button that links the height metric to the color metric so that the colour metric is automatically set to\r\n    the selected height metric [#3058](https://github.com/MaibornWolff/codecharta/pull/3058) <br/>\r\n    ![image](https://user-images.githubusercontent.com/72517530/193291144-fdc73a15-2087-47e2-845b-05c666aec71d.png) <br/>\r\n    ![image](https://user-images.githubusercontent.com/72517530/194300920-60ce9fcd-0dd5-46ef-a90b-01d9a29205e6.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix interactive GitLogParser using wrong dialogue with repo-scan subcommand [#3073](https://github.com/MaibornWolff/codecharta/pull/3073)\r\n-   Fix CodeCharta Analysis container exiting when detached [#3062](https://github.com/MaibornWolff/codecharta/pull/3062)\r\n-   Fix CodeCharta Analysis container not coming with the sonar-scanner pre-installed [#3062](https://github.com/MaibornWolff/codecharta/pull/3062)\r\n-   Rerender immediately after marking a folder with a color [#3067](https://github.com/MaibornWolff/codecharta/pull/3067)\r\n-   Clicking the \'reset height metric settings\' button resets the number of top labels to the dynamic default value [#3066](https://github.com/MaibornWolff/codecharta/pull/3066)\r\n-   Unfocus nodes when changing selected files, which prevents the app from crashing [#3072](https://github.com/MaibornWolff/codecharta/pull/3072)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Update Docker Publish Action in Release Pipeline [#3060](https://github.com/MaibornWolff/codecharta/pull/3060)\r\n-   Write documentation for docker containers [#3063](https://github.com/MaibornWolff/codecharta/pull/3063)\r\n-   Migrate isAttributeSideBarVisible.service, threeScene.service, threeCamera.service and threeStats.service to Angular [#3068](https://github.com/MaibornWolff/codecharta/pull/3068)\r\n-   Migrate dialog.service to Angular [#3072](https://github.com/MaibornWolff/codecharta/pull/3072)\r\n-   Add documentation for new treeMap algorithm [#3077](https://github.com/MaibornWolff/codecharta/pull/3077)\r\n-   Migrate dialog.service to Angular [#3070](https://github.com/MaibornWolff/codecharta/pull/3070)\r\n-   Migrate FocusedNodePathService, LayoutAlgorithmService, ThreeOrbitControlsService and ThreeViewerService to Angular [#3072](https://github.com/MaibornWolff/codecharta/pull/3072)\r\n-   Migrate updateAttributeTypes.service to Angular [#3082](https://github.com/MaibornWolff/codecharta/pull/3082)\r\n\r\n## [1.108.1] - 2022-09-29\r\n\r\n## Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Update formatting in Docker Release Pipeline [#3059](https://github.com/MaibornWolff/codecharta/pull/3059)\r\n\r\n## [1.108.0] - 2022-09-28\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add new Analysis docker container, together with a docker-compose file that contains analysis, visualization and a\r\n    SonarQube instance [#3057](https://github.com/MaibornWolff/codecharta/pull/3057)\r\n\r\n### Removed \u{1f5d1}\r\n\r\n-   remove outdated Crococosmo, Understand and Jasome Importer from Analysis including its documentation [#3053](https://github.com/MaibornWolff/codecharta/pull/3053)\r\n\r\n## [1.107.0] - 2022-09-27\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add subcommand to GitLogParser to run necessary git commands automatically [#3041](https://github.com/MaibornWolff/codecharta/pull/3041)\r\n\r\n### Changed\r\n\r\n-   Change default behaviour of GitLogParser to use new subcommands [#3041](https://github.com/MaibornWolff/codecharta/pull/3041)\r\n-   Set default value for displaying labels 1 per 100 buildings with a maximum of 10 labels [#3046](https://github.com/MaibornWolff/codecharta/pull/3046)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Uncheck the box when \'reset invert height\' icon is clicked [#3048](https://github.com/MaibornWolff/codecharta/pull/3048)\r\n-   Update ReadMe and GitHub pages for MetricGardener [#3045](https://github.com/MaibornWolff/codecharta/pull/3045)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate codeMap.component to Angular with minor internal improvements [#3049](https://github.com/MaibornWolff/codecharta/pull/3049)\r\n-   Remove threeUpdateCycle.service [#3050](https://github.com/MaibornWolff/codecharta/pull/3050)\r\n-   Migrate metricData.service, edgeMetric.service, nodeMetricData.service and edgeMetricData.service to Angular [#3051](https://github.com/MaibornWolff/codecharta/pull/3051)\r\n-   Migrate threeRenderer.service to Angular [#3052](https://github.com/MaibornWolff/codecharta/pull/3052)\r\n\r\n## [1.106.1] - 2022-09-20\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   CC-JSON Files not loaded on Safari browser [#3042](https://github.com/MaibornWolff/codecharta/pull/3042)\r\n-   Show loading spinners while loading a file [#2980](https://github.com/MaibornWolff/codecharta/pull/2980)\r\n-   Prevent clicking on not opened metric options in ribbon bar [#3029](https://github.com/MaibornWolff/codecharta/pull/3029)\r\n-   Set cursor to pointer on color settings panel of delta mode [#3029](https://github.com/MaibornWolff/codecharta/pull/3029)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Throttle rendering and migrate codeMap.preRender.service to Angular [#2980](https://github.com/MaibornWolff/codecharta/pull/2980)\r\n\r\n## [1.106.0] - 2022-09-13\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add option to CSVImporter to specify the path column name [#3026](https://github.com/MaibornWolff/codecharta/pull/3026)\r\n\r\n### Changed\r\n\r\n-   Stop asking the user to compress a file when printing to stdOut [#3024](https://github.com/MaibornWolff/codecharta/pull/3024)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix anongit script using the wrong whitespace, causing gitlogparser to fail [#3030](https://github.com/MaibornWolff/codecharta/pull/3030)\r\n-   Reshow suspicious metrics badge when calculated data has changed [#2997](https://github.com/MaibornWolff/codecharta/pull/2997)\r\n\r\n## [1.105.0] - 2022-09-06\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add an option to run MetricGardener before its parser if requested [#3015](https://github.com/MaibornWolff/codecharta/pull/3015)\r\n-   Add missing documentation for MetricGardener importer [#3016](https://github.com/MaibornWolff/codecharta/pull/3016)\r\n\r\n### Changed\r\n\r\n-   Increase the size of the close button to simplify closing the attribute sidebar [#3014](https://github.com/MaibornWolff/codecharta/pull/3014)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix console error when clicking switch button in delta mode [#3023](https://github.com/MaibornWolff/codecharta/pull/3023)\r\n-   Fix broken images to new document pages about how using SonarQube [#3012](https://github.com/MaibornWolff/codecharta/pull/3012)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate tool bar component to Angular [#3020](https://github.com/MaibornWolff/codecharta/pull/3020)\r\n-   Remove obsolete AngularJS IsPresentationModeService and ShowOnlyBuildingsWithEdgesService [#3005](https://github.com/MaibornWolff/codecharta/pull/3005)\r\n\r\n## [1.104.1] - 2022-08-31\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix broken links to new document pages about how using SonarQube [#3009](https://github.com/MaibornWolff/codecharta/pull/3009)\r\n\r\n## [1.104.0] - 2022-08-31\r\n\r\n### Added \u{1f680}\r\n\r\n-   Copy-to-Clipboard-Button to paste the top 10 files with highest metric values [#2942](https://github.com/MaibornWolff/codecharta/pull/2942), [#2996](https://github.com/MaibornWolff/codecharta/pull/2995) <br/>\r\n    ![image](https://user-images.githubusercontent.com/46388280/184089603-ecfa8e31-8241-42a2-9954-2de554347381.png) </br>\r\n    ![image](https://user-images.githubusercontent.com/46388280/184089577-5cd2eec0-5293-4083-b629-0e3c5621047c.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Correct file types now get appended to the name of the output file when using the interactive ccsh [#2914](https://github.com/MaibornWolff/codecharta/pull/2914)\r\n-   Fix exit code handling and update integrationTest\'s golden_test.sh to cover all modules [#2988](https://github.com/MaibornWolff/codecharta/pull/2988)\r\n-   Fix missing color pickers within edge metric options [#2993](https://github.com/MaibornWolff/codecharta/pull/2993)\r\n-   Fix labels being displayed at an incorrect height and lines being disconnected from labels [#2991](https://github.com/MaibornWolff/codecharta/pull/2991)\r\n-   Provides a list of metrics where no calculation could be performed in relation to a suspicion [#2996](https://github.com/MaibornWolff/codecharta/pull/2996) </br>\r\n    ![missing_values_suspicious_metrics](https://user-images.githubusercontent.com/31436472/187439165-77eda080-ceba-4bab-b077-4f6a2d6162b5.png)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate view cube component and its service to Angular [#2998](https://github.com/MaibornWolff/codecharta/pull/2998)\r\n\r\n## [1.104.0] - 2022-08-29\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate presentation mode button to Angular [#2938](https://github.com/MaibornWolff/codecharta/pull/2938)\r\n\r\n## [1.103.6] - 2022-08-17\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix bug in CompressionStreamHandler\'s input stream validation, that caused endless blocking reads from System.In [#2987](https://github.com/MaibornWolff/codecharta/pull/2987)\r\n\r\n## [1.103.5] - 2022-08-12\r\n\r\n### Changed\r\n\r\n-   Update visualization readme file [#2932](https://github.com/MaibornWolff/codecharta/pull/2932)\r\n-   Update the documentation for the usage of SonarQube [#2965](https://github.com/MaibornWolff/codecharta/pull/2965)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Add permission to upload-assets action [#2979](https://github.com/MaibornWolff/codecharta/pull/2979), [#2982](https://github.com/MaibornWolff/codecharta/pull/2982)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate download button to Angular [#2973](https://github.com/MaibornWolff/codecharta/pull/2973)\r\n\r\n## [1.103.3] - 2022-08-10\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Update Ubuntu images package list as part of the wine action [#2976](https://github.com/MaibornWolff/codecharta/pull/2976)\r\n\r\n## [1.103.2] - 2022-08-10\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Highlight buildings on hover of file extension bar [#2969](https://github.com/MaibornWolff/codecharta/pull/2969)\r\n-   Fix of the npm visualization installation under MacOS by version bumping nwjs [#2974](https://github.com/MaibornWolff/codecharta/pull/2974)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate file extension bar to Angular [#2968](https://github.com/MaibornWolff/codecharta/pull/2968)\r\n\r\n## [1.103.1] - 2022-08-09\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Change release action script in order to show changelog in release notes [#2970](https://github.com/MaibornWolff/codecharta/pull/2970)\r\n\r\n## [1.103.0] - 2022-08-09\r\n\r\n### Changed\r\n\r\n-   Update links to demo website [#2961](https://github.com/MaibornWolff/codecharta/pull/2961)\r\n\r\n### Added \u{1f680}\r\n\r\n-   Show tooltip with explanation for some metrics [#2957](https://github.com/MaibornWolff/codecharta/pull/2957)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix installation instructions for Apple Silicon [#2956](https://github.com/MaibornWolff/codecharta/pull/2956)\r\n-   Fix release tag [#2954](https://github.com/MaibornWolff/codecharta/pull/2954)\r\n-   Prevent dark map on unhover [#2959](https://github.com/MaibornWolff/codecharta/pull/2959)\r\n-   Zoom in/out time [#2959](https://github.com/MaibornWolff/codecharta/pull/2959)\r\n-   Fix webpack build package being corrupt if zipped under linux by changing the compression path [#2934](https://github.com/MaibornWolff/codecharta/pull/2934)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Load metric templates lazily and migrate them to Angular [#2960](https://github.com/MaibornWolff/codecharta/pull/2960)\r\n\r\n## [1.102] - 2022-08-04\r\n\r\n### Changed\r\n\r\n-   Changed storing format for camera position within custom views and scenarios. Loading of created custom views or scenarios in old format will stop working in 2023 [2880](https://github.com/MaibornWolff/codecharta/pull/2880)\r\n-   Add error messages for the user to "Add Scenario Dialog" [#2928](https://github.com/MaibornWolff/codecharta/pull/2928)\r\n\r\n### Added \u{1f680}\r\n\r\n-   Switch reference and comparison file by button click in delta mode [#2933](https://github.com/MaibornWolff/codecharta/pull/2933)\r\n    ![image](https://user-images.githubusercontent.com/72517530/182630368-2d2b177d-8b4b-4850-8486-8d9afc7153c5.png)\r\n-   Add display of changed files in delta mode (changed := metric values changed or list of applied metrics\r\n    changed) [#2890](https://github.com/MaibornWolff/codecharta/pull/2890)\r\n    ![image](https://user-images.githubusercontent.com/72517530/182631857-6192dea1-7a01-4684-90a6-d5da8615434a.png)\r\n-   Load compressed files (cc.json.gz) via URL parameter [#2917](https://github.com/MaibornWolff/codecharta/pull/2917)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix SonarImporter requesting no metrics from SonarQube when the list of metrics was left empty [#2913](https://github.com/MaibornWolff/codecharta/pull/2913)\r\n-   Exclude edge metrics from custom scenarios, when there are no edge metrics available. Before it was impossible to apply those custom configs [#2928](https://github.com/MaibornWolff/codecharta/pull/2928)\r\n-   Fix of NoSuchMethodException due to a call of method `readNBytes()` that is not available in Java 9 with replacement call `read()` [#2930](https://github.com/MaibornWolff/codecharta/pull/2930)\r\n-   Keep selected metrics when excluding buildings [#2935](https://github.com/MaibornWolff/codecharta/pull/2935)\r\n-   Update UI correctly when toggling between standard and delta mode [#2937](https://github.com/MaibornWolff/codecharta/pull/2937)\r\n\r\n## [1.101.1] - 2022-07-27\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Modify build script for GitHub pages in order to provide zipped maps.\r\n\r\n## [1.101.0] - 2022-07-26\r\n\r\n### Added \u{1f680}\r\n\r\n-   Transform a metric gardener json file into a code charta json file, that can be correctly visualized [#2675](https://github.com/MaibornWolff/codecharta/pull/2875)\r\n\r\n### Changed\r\n\r\n-   Restore previous selected files when switching back from delta to standard mode [#2891](https://github.com/MaibornWolff/codecharta/pull/2891)\r\n-   Add more metrics that can be preselected when opening a cc.json file [#2907](https://github.com/MaibornWolff/codecharta/pull/2907) [#2908](https://github.com/MaibornWolff/codecharta/pull/2908)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Let file selection always show what is actual rendered within the map [#2891](https://github.com/MaibornWolff/codecharta/pull/2891)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Improve performance by slightly delaying node-name popups and removing unused functionality [#2897](https://github.com/MaibornWolff/codecharta/pull/2897)\r\n\r\n## [1.100.0] - 2022-07-12\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add a description for the statements metric [#2883](https://github.com/MaibornWolff/codecharta/pull/2883)\r\n\r\n### Changed\r\n\r\n-   Select matching metric combination based on available metrics [#2862](https://github.com/MaibornWolff/codecharta/pull/2862)\r\n-   Unify UI of buttons in toolbar [#2857](https://github.com/MaibornWolff/codecharta/pull/2857)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix resetting of color range within color settings panel [#2877](https://github.com/MaibornWolff/codecharta/pull/2877)\r\n-   Fix resetting of colors in delta mode within color settings panel [#2873](https://github.com/MaibornWolff/codecharta/pull/2873)\r\n-   Restore global settings on page load again [#2878](https://github.com/MaibornWolff/codecharta/pull/2878)\r\n-   Fix \'undefinded\' being displayed as a metric description when no description was available [#2883](https://github.com/MaibornWolff/codecharta/pull/2883)\r\n-   Fix windows standalone builds [#2881](https://github.com/MaibornWolff/codecharta/pull/2881)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate color settings panel to Angular [#2873](https://github.com/MaibornWolff/codecharta/pull/2873)\r\n\r\n## [1.99.1] - 2022-06-22\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix packaging of standalone app for macOS and Windows [#2847](https://github.com/MaibornWolff/codecharta/pull/2847)\r\n-   Fix dialogparser test of sourcecode parser[#2860](https://github.com/MaibornWolff/codecharta/pull/2860)\r\n\r\n## [1.99.0] - 2022-06-21\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add interactive dialog support for the remaining parsers [#2833](https://github.com/MaibornWolff/codecharta/pull/2833) [#2836](https://github.com/MaibornWolff/codecharta/pull/2836) [#2842](https://github.com/MaibornWolff/codecharta/pull/2842) [#2843](https://github.com/MaibornWolff/codecharta/pull/2843) [#2846](https://github.com/MaibornWolff/codecharta/pull/2846)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix analysis bug where importers would get stuck before file output [#2854](https://github.com/MaibornWolff/codecharta/pull/2854)\r\n-   Use correct icon for height metric chooser again [#2851](https://github.com/MaibornWolff/codecharta/pull/2851)\r\n-   Close height metric option instead of making it only invisible on close [#2853](https://github.com/MaibornWolff/codecharta/pull/2853)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate changelog dialog to Angular [#2849](https://github.com/MaibornWolff/codecharta/pull/2849)\r\n-   Migrate node path panel to Angular [#2855](https://github.com/MaibornWolff/codecharta/pull/2855)\r\n\r\n## [1.98.0] - 2022-06-14\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add missing documentation for ccsh filters and csv exporter [#2831](https://github.com/MaibornWolff/codecharta/pull/2831)\r\n-   Add support for compressed files to all analysis filters and to `check` validation [#2820](https://github.com/MaibornWolff/codecharta/pull/2820)\r\n\r\n### Changed\r\n\r\n-   Update Readme file [#2837](https://github.com/MaibornWolff/codecharta/pull/2837)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Default selected metrics on file changes when default scenario is not applicable [#2828](https://github.com/MaibornWolff/codecharta/pull/2828)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Remove old references to single mode states and actions [#2574](https://github.com/MaibornWolff/codecharta/pull/2841)\r\n-   Rename multiple mode references to standard [#2574](https://github.com/MaibornWolff/codecharta/pull/2848)\r\n\r\n## [1.97.0] - 2022-05-31\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add interactive dialog support for the parsers [#2737](https://github.com/MaibornWolff/codecharta/pull/2737) [#2822](https://github.com/MaibornWolff/codecharta/pull/2822) <br>\r\n    ![m](https://user-images.githubusercontent.com/48621967/161549546-1463914e-c223-4912-acb1-db4e357e76c5.png)\r\n\r\n### Changed\r\n\r\n-   Hide color metric range-slider in color metric options of ribbon bar in delta mode instead of disabling it [#2797](https://github.com/MaibornWolff/codecharta/pull/2797)\r\n-   Display max value of selected distribution metric in file extension bar [#2824](https://github.com/MaibornWolff/codecharta/pull/2824)\r\n-   Display max value of selected metric in all metric chooser of ribbon bar [#2825](https://github.com/MaibornWolff/codecharta/pull/2825)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Handle invalid input of range-slider correctly [#2797](https://github.com/MaibornWolff/codecharta/pull/2797)\r\n-   Use real color range min value instead of 0 and take color range min value into account for calculating initial first third of positive color [#2797](https://github.com/MaibornWolff/codecharta/pull/2797)\r\n-   Fix range-slider in case of min value equal to max value [#2797](https://github.com/MaibornWolff/codecharta/pull/2797)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Track not only changes to color metric options by slider but also by related input field [#2797](https://github.com/MaibornWolff/codecharta/pull/2797)\r\n-   Migrate center-map-button-component to Angular [#2809](https://github.com/MaibornWolff/codecharta/pull/2809)\r\n-   Migrate the following components to Angular: globalSettingsButton.component, dialog.globalSettings.component, layoutSelection.component, sharpnessModeSelector.component, maxTreeMapFiles.component, maxTreeMapFiles.service, hideFlatBuildings.service, resetCameraIfNewFileIsLoaded.service [#2815](https://github.com/MaibornWolff/codecharta/pull/2815)\r\n-   Migrate area-settings-panel-component to Angular [#2821](https://github.com/MaibornWolff/codecharta/pull/2821)\r\n\r\n## [1.96.0] - 2022-05-17\r\n\r\n### Changed\r\n\r\n-   Remove all mentions of regular `.cc` `.json` `.gz` file extensions from file panel and sidebar [#2793](https://github.com/MaibornWolff/codecharta/pull/2793)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Update slider of area metric options correctly on changes of related input field [#2787](https://github.com/MaibornWolff/codecharta/pull/2787)\r\n-   Limit length of labels in legend panel [#2804](https://github.com/MaibornWolff/codecharta/pull/2804)\r\n-   Prevent invalid input for margin in area metric options to be submitted [#2799](https://github.com/MaibornWolff/codecharta/pull/2799)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Introduce custom angular material theme [#2784](https://github.com/MaibornWolff/codecharta/pull/2784)\r\n-   Migrate height-settings-panel-component [#2790](https://github.com/MaibornWolff/codecharta/pull/2790)\r\n-   Fully migrate custom-config-component [#2760](https://github.com/MaibornWolff/codecharta/pull/2760)\r\n\r\n## [1.95.2] - 2022-04-19\r\n\r\n### Changed\r\n\r\n-   Restrict upload in custom views menu to custom views. Custom views uploaded in the custom views menu are now allowed to have an arbitrary file suffix [#2773](https://github.com/MaibornWolff/codecharta/pull/2773)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate reset-settings-button-component to Angular [#2774](https://github.com/MaibornWolff/codecharta/pull/2774)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Set files loaded via URL to multiple mode by default when delta mode is not selected [#2769](https://github.com/MaibornWolff/codecharta/pull/2769)\r\n\r\n## [1.95.1] - 2022-04-01\r\n\r\n### Changed\r\n\r\n-   Display project name as file name (if not empty or blank) for loaded files via URL [#2767](https://github.com/MaibornWolff/codecharta/pull/2767)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fixes floor labels being drawn next to the map if margin was changed after map height is unequal to 1 [#2763](https://github.com/MaibornWolff/codecharta/pull/2763)\r\n-   Fixes floor labels being stuck inside folder geometry when scaling [#2766](https://github.com/MaibornWolff/codecharta/pull/2766)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate metric-hovered-value-component to Angular [#2752](https://github.com/MaibornWolff/codecharta/pull/2752)\r\n\r\n## [1.95.0] - 2022-03-28\r\n\r\n### Added \u{1f680}\r\n\r\n-   Focused gradient option for color metric. Only applies a gradient between the two set borders. [#2750](https://github.com/MaibornWolff/codecharta/pull/2750)\r\n\r\n### Changed\r\n\r\n-   Mark SCMLogParserV2 as stable and deprecate SCMLogParser for Git [2725](https://github.com/MaibornWolff/codecharta/pull/2725)\r\n    -   Rename SCMLogParserV2 to GitLogParser\r\n    -   Rename SCMLogParser to SVNLogParser and remove git parsing\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Set initially correct attribute type of primary edge metric in attribute sidebar [#2731](https://github.com/MaibornWolff/codecharta/issues/2731)\r\n-   Fix switching secondary metrics to median aggregation in attribute sidebar [#2630](https://github.com/MaibornWolff/codecharta/issues/2630)\r\n\r\n## [1.94.0] - 2022-03-21\r\n\r\n### Changed\r\n\r\n-   Improve sonarimport help message [#2717](https://github.com/MaibornWolff/codecharta/pull/2717)\r\n-   Remove blacklist entry on click of name as well [#2712](https://github.com/MaibornWolff/codecharta/pull/2712)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate add `custom config button` in ribbonbar to Angular [#2736](https://github.com/MaibornWolff/codecharta/pull/2736)\r\n\r\n## [1.93.0] - 2022-03-14\r\n\r\n### Added \u{1f680}\r\n\r\n-   Show amount of added and removed files in attribute sidebar when delta mode is enabled and a folder is selected [#2701](https://github.com/MaibornWolff/codecharta/pull/2701/files) <br>\r\n    ![xs](https://user-images.githubusercontent.com/72517530/157468180-4e2d052b-63b8-4040-bb22-b633a24d3b8a.png)\r\n\r\n### Changed\r\n\r\n-   Suspicious metrics and risk profile are calculated for all selected maps [#2721](https://github.com/MaibornWolff/codecharta/pull/2721)\r\n-   Close search panel and ribbon bar dropdowns on every outside click [#2692](https://github.com/MaibornWolff/codecharta/issues/2692)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix GameObjects importer edge cases [#2705](https://github.com/MaibornWolff/codecharta/pull/2705)\r\n\r\n## [1.92.1] - 2022-03-07\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix removing maps with long file names [#2696](https://github.com/MaibornWolff/codecharta/pull/2697)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate search-bar-component to Angular [#2686](https://github.com/MaibornWolff/codecharta/pull/2686)\r\n\r\n## [1.92.0] - 2022-03-01\r\n\r\n### Changed\r\n\r\n-   Design and add a new CodeChara Logo [#2682](https://github.com/MaibornWolff/codecharta/pull/2682) <br>\r\n    ![xs](https://user-images.githubusercontent.com/48621967/155682925-ecc9fe5d-77de-4927-9c6a-b1059ae9eead.png)\r\n-   Risk profile is now calculated for every occurring programming languages in selected file(s)[#2679](https://github.com/MaibornWolff/codecharta/pull/2679)\r\n\r\n## [1.91.1] - 2022-02-25\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix loading of files without edge metric never finished [#2680](https://github.com/MaibornWolff/codecharta/issues/2680)\r\n\r\n## [1.91.0] - 2022-02-21\r\n\r\n### Changed\r\n\r\n-   Refactor edge metric panel [#2670](https://github.com/MaibornWolff/codecharta/pull/2670)\r\n    -   Remove edge metric option \'none\'\r\n    -   By default, the first edge metric is enabled when map has edge metrics\r\n    -   Disable edge metric panel when loaded map has no edge metrics\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Improve loading times by reducing the size of JavaScript files [#2667](https://github.com/MaibornWolff/codecharta/pull/2667)\r\n-   Fix loading of files without edge metric never finished [#2680](https://github.com/MaibornWolff/codecharta/issues/2680)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate loading gifs to Angular and remove now unused `isLoadingMap.service` [#2668](https://github.com/MaibornWolff/codecharta/pull/2668)\r\n\r\n## [1.90.0] - 2022-02-15\r\n\r\n### Added \u{1f680}\r\n\r\n-   Parse and import GameObjects file structure into cc.json on upload [#2646](https://github.com/MaibornWolff/codecharta/pull/2646)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix flaky string comparison possibly due to puppeteer update [#2659](https://github.com/MaibornWolff/codecharta/pull/2659)\r\n-   Fix show garbage bin next to the loaded maps [#2647](https://github.com/MaibornWolff/codecharta/pull/2647)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Run standalone version of CodeCharta in Node.js web target (and disable [#1314](https://github.com/MaibornWolff/codecharta/issues/1314)), so that local storage is available [#2637](https://github.com/MaibornWolff/codecharta/pull/2637)\r\n\r\n## [1.89.0] - 2022-02-07\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add area metric option to invert the amount of area, which is used for the nodes [#2626](https://github.com/MaibornWolff/codecharta/pull/2626)\r\n-   Add button to clear search field [#2638](https://github.com/MaibornWolff/codecharta/pull/2638) <br>\r\n    ![xs](https://user-images.githubusercontent.com/48218172/151999974-3b8a7cca-52b2-4757-b3c0-e3b2e36ad237.png)\r\n\r\n### Changed\r\n\r\n-   New buttons for selecting attribute types [#2631](https://github.com/MaibornWolff/codecharta/pull/2631)\r\n    ![xs](https://user-images.githubusercontent.com/72517530/151762455-07e47bf5-18aa-4721-a60a-6dfee057e1e5.png)\r\n-   Migrate context menu with slightly new layout touch to Angular. Migrated version prevents rendering outside of view [#1661](https://github.com/MaibornWolff/codecharta/issues/1661)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Remove delay of keeping a building highlight permanently [#2641](https://github.com/MaibornWolff/codecharta/issues/2641)\r\n\r\n## [1.88.0] - 2022-01-24\r\n\r\n### Changed\r\n\r\n-   Rename custom configs to custom view [#2625](https://github.com/MaibornWolff/codecharta/pull/2625)\r\n-   Combine single and multiple mode into standard mode [#2578](https://github.com/MaibornWolff/codecharta/pull/2578)\r\n    ![xs](https://user-images.githubusercontent.com/72517530/150765617-2d66eb78-2c26-45c5-b63b-f84994ed88ab.png)\r\n-   Improve file validation handling and provide more descriptive import messages [#2604](https://github.com/MaibornWolff/codecharta/pull/2604)\r\n    ![xs](https://user-images.githubusercontent.com/48621967/150532207-f3b482ed-3a14-43c0-b1a3-80ac4c25d5e0.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix Image not shown in what is new dialog [#2610](https://github.com/MaibornWolff/codecharta/pull/2610)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n    - Unfocus focused node only when map starts to load and not also when map has finished loading. This shouldn\'t change any behavior for the user [#2614](https://github.com/MaibornWolff/codecharta/pull/2614)\r\n\r\n## [1.87.1] - 2022-01-17\r\n\r\n### Changed\r\n\r\n-   User-friendly renaming for display quality options [#2601](https://github.com/MaibornWolff/codecharta/pull/2601)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix color of selected building in delta mode [#2603](https://github.com/MaibornWolff/codecharta/pull/2603)\r\n-   Fix link to news page when clicking \'Know more\' button changelog dialog [#2602](https://github.com/MaibornWolff/codecharta/pull/2602)\r\n-   Fix Image not shown in what is new dialog [#2610](https://github.com/MaibornWolff/codecharta/pull/2610)\r\n\r\n## [1.87.0] - 2022-01-11\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate `unfocus-button-component` to Angular.\r\n\r\n### Changed\r\n\r\n-   Remove suspicious metrics from custom map configurations [#2564](https://github.com/MaibornWolff/codecharta/pull/2564).\r\n-   Add \'show/hide non-applicable CustomConfigs\' button to Custom Configs menu [#2591](https://github.com/MaibornWolff/codecharta/pull/2591).\r\n\r\n## [1.86.0] - 2021-12-20\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add 3D export feature for 3D printing [#2561](https://github.com/MaibornWolff/codecharta/pull/2561). <br>\r\n    ![xs](https://user-images.githubusercontent.com/48621967/146173663-e0ea177e-6ed8-4ddb-bd11-410415541e9f.png)\r\n    ![l](https://user-images.githubusercontent.com/48621967/146174397-42a6e475-ed2f-47c0-ba9c-4f8304d53399.png)\r\n\r\n### Changed\r\n\r\n-   Replace all color pickers in the context of ongoing Angular migration [#2560](https://github.com/MaibornWolff/codecharta/pull/2560).\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix showing names of custom configs properly [#2557](https://github.com/MaibornWolff/codecharta/pull/2557).\r\n-   Fix minor memory leak in context menu for code map buildings [#2565](https://github.com/MaibornWolff/codecharta/issues/2565).\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Migrate legend panel to Angular [#2560](https://github.com/MaibornWolff/codecharta/pull/2560).\r\n\r\n## [1.85.0] - 2021-12-13\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix delta values of secondary metrics not shown in delta mode within attribute side bar [#2539](https://github.com/MaibornWolff/codecharta/issues/2539).\r\n-   Use icon tag instead of font awesome icon [#2537](https://github.com/MaibornWolff/codecharta/pull/2537).\r\n-   Rename text for placeholder of metric chooser [#2547](https://github.com/MaibornWolff/codecharta/pull/2547)\r\n-   Fix attribute type selector of primary edge metric not shown [#2528](https://github.com/MaibornWolff/codecharta/issues/2528).\r\n-   Identical files and files with identical file names but different hashes can be loaded [#2548](https://github.com/MaibornWolff/codecharta/pull/2548)\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Remove `secondaryMetrics` from store and remove `secondaryMetrics.service` as the data can be derived from selected node [#2527](https://github.com/MaibornWolff/codecharta/pull/2527).\r\n-   Migrate `attribute-side-bar-component` to Angular [#2527](https://github.com/MaibornWolff/codecharta/pull/2527).\r\n-   Switch from Webpack 4 Loaders to Asset Module to load icons properly with css-loader 6.x [#2542](https://github.com/MaibornWolff/codecharta/pull/2542).\r\n\r\n### Removed \u{1f5d1}\r\n\r\n-   Remove notification dialog when deleting a custom config [#2553](https://github.com/MaibornWolff/codecharta/pull/2553)\r\n\r\n## [1.84.1] - 2021-11-29\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix compressed files not being loaded ([#2524](https://github.com/MaibornWolff/codecharta/pull/2525))\r\n\r\n## [1.84.0] - 2021-11-22\r\n\r\n### Changed\r\n\r\n-   Improved the UI and usability of the Suspicious Metrics Feature ([#2376](https://github.com/MaibornWolff/codecharta/pull/2494)) <br>\r\n    -   The Metrics and the Analysis are now split in two menus <br>\r\n        ![xs](https://user-images.githubusercontent.com/48621967/141795078-bb856f53-1bc3-4c09-8be5-d031899835ae.png)\r\n    -   The Suspicious Metrics are now sorted with the Very High Risk on top <br>\r\n        ![m](https://user-images.githubusercontent.com/48621967/141793011-1bfc0e19-bd3a-4bd2-af70-c3dd472821b6.png)\r\n    -   The bar in the analysis shows the percentages <br>\r\n        ![m](https://user-images.githubusercontent.com/48621967/141791111-564778fa-b767-4ee4-b024-6856f1a79b4b.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix showing labels when weighted gradient on yellow buildings in color metric options are enabled ([#2511](https://github.com/MaibornWolff/codecharta/pull/2511))\r\n-   Fix rounding of the sum of percentages in risk profile ([#2393](https://github.com/MaibornWolff/codecharta/pull/2516))\r\n-   Fix legend panel not having a background ([#2422](https://github.com/MaibornWolff/codecharta/pull/2510))\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Remove `nodeSearch.service.ts` and `searchedNodePaths` from store as they can be derived from `searchPattern` ([#2495](https://github.com/MaibornWolff/codecharta/pull/2495)).\r\n-   Refactor where metric data are calculated ([#2514](https://github.com/MaibornWolff/codecharta/pull/2514)).\r\n-   Migrate `attribute-type-selector-component` to Angular ([#2519](https://github.com/MaibornWolff/codecharta/pull/2519)).\r\n\r\n## [1.83.1] - 2021-11-10\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix loading files from URL in Web Demo ([#2494](https://github.com/MaibornWolff/codecharta/pull/2494))\r\n\r\n## [1.83.0] - 2021-11-09\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix unwanted calculations of suspicious metrics when experimental features are disabled ([#2471](https://github.com/MaibornWolff/codecharta/pull/2471))\r\n-   Fix UI issues in the configuration panel ([#2322](https://github.com/maibornwolff/codecharta/issues/2322))\r\n-   Fix tooltip of sorting order button in map tree view showing wrong sorting order ([#2473](https://github.com/maibornwolff/codecharta/issues/2473))\r\n\r\n### Changed\r\n\r\n-   Calculate MD5 checksum when generating .cc.json files ([#2411](https://github.com/MaibornWolff/codecharta/pull/2450))\r\n\r\n## [1.82.0] - 2021-10-18\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix what\'s new section including the last opened version ([#2447](https://github.com/MaibornWolff/codecharta/pull/2453))\r\n-   Fix unfocus button text not showing correctly ([#2439](https://github.com/MaibornWolff/codecharta/pull/2439))\r\n\r\n### Changed\r\n\r\n-   Folders in the Folder structure view of the top left come now always before any files, regardless of the sort order.\r\n\r\n## [1.81.0] - 2021-10-11\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix color picker not being usable ([#2439](https://github.com/MaibornWolff/codecharta/pull/2439))\r\n-   Fix Changelog inconsistencies ([#2425](https://github.com/MaibornWolff/codecharta/pull/2425)) <br>\r\n    ![xl](https://user-images.githubusercontent.com/48621967/135866024-ee06119a-1a62-4912-90df-ac3aa9216608.PNG)\r\n-   Fix memory and performance issues related to drawing labels on floors/folders ([#2348](https://github.com/MaibornWolff/codecharta/issues/2348)).\r\n-   Hides legend block if label description is not available and adds new metric descriptions ([#2377](https://github.com/maibornwolff/codecharta/issues/2377)).\r\n\r\n## [1.80.0] - 2021-10-04\r\n\r\n### Added \u{1f680}\r\n\r\n-   Adds feature to display building colors as a gradients ([#2327](https://github.com/MaibornWolff/codecharta/issues/2327)).\r\n    -   "Weighted Gradient" only mixes colors in a small interval around the preset values.\r\n    -   "True Gradient" mixes colors from the 0 to the highest value, the two preset color range values determine the balance.\r\n    -   "Absolute" represents the old behaviour without gradients. <br>\r\n        ![l](https://user-images.githubusercontent.com/42114276/134924267-245c65c9-2893-43a8-9a0a-17e3182bf15a.JPG)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix broken file/node search #2389\r\n-   Fix changelog inconsistencies ([#2425](https://github.com/MaibornWolff/codecharta/pull/2425))\r\n\r\n## [1.79.0] - 2021-09-20\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add metric descriptions to the frontend and show a translation next to the entry ([#2330](https://github.com/MaibornWolff/codecharta/issues/2330)) <br>\r\n    <img src="https://user-images.githubusercontent.com/31436472/133093437-eaa0efdc-9d8c-49a8-ab21-5c959e232a49.png" width="250px"/>\r\n-   An option has been added to the global settings to enable copying screenshots to clipboard instead of saving them in a file ([#2326](https://github.com/MaibornWolff/codecharta/issues/2326)) <br>\r\n    ![xl](https://user-images.githubusercontent.com/57844849/131342771-a3c637e3-8241-49aa-8d51-71e3a8d38aef.png)\r\n-   Add changelog guidelines ([#2358](https://github.com/MaibornWolff/codecharta/pull/2358))\r\n-   A changelog dialog with the latest additions to CodeCharta appears on version update ([#1315](https://github.com/MaibornWolff/codecharta/pull/2342)) <br>\r\n    ![xl](https://user-images.githubusercontent.com/48621967/131360878-a8e1ef40-7f73-4de7-8b3f-4c8dc21448da.PNG)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Fix broken method call in screenshot feature.\r\n-   Improve changelog entries.\r\n\r\n### Changed\r\n\r\n-   Changing the background color and remove "outgoing" and "incoming" edges from the legend, if not applicable ([#2330](https://github.com/MaibornWolff/codecharta/issues/2330))\r\n-   Improve the user experience for the AI Feature "Suspicious Metrics and Risk Profiles" and enable it for any programming language ([#2362](https://github.com/MaibornWolff/codecharta/pull/2362)) <br>\r\n    ![m](https://user-images.githubusercontent.com/26900540/133250867-adf4583d-9d0e-4f81-b8a7-1407b93d9f40.png)\r\n\r\n## [1.78.0] - 2021-09-06\r\n\r\n### Added \u{1f680}\r\n\r\n-   A changelog dialog with the latest additions to CodeCharta appears on version update ([#1315](https://github.com/MaibornWolff/codecharta/issues/1315))\r\n-   Add documentation for SCMLogParserV2 ([#1349](https://github.com/maibornwolff/codecharta/issues/1349))\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Empty temporary label during hovering ([#2328](https://github.com/maibornwolff/codecharta/issues/2328))\r\n-   Show the screenshot hotkey in the screenshot title ([#2323](https://github.com/maibornwolff/codecharta/issues/2323))\r\n-   Improved rendering performance ([#2345](https://github.com/MaibornWolff/codecharta/pull/2345))\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Update GH-Pages and visualization dependencies ([#2356](https://github.com/maibornwolff/codecharta/issues/2356))\r\n\r\n## [1.77.0] - 2021-07-30\r\n\r\n### Added \u{1f680}\r\n\r\n-   The "Color Metric Options" panel and "Legend" panel display the maximum value of the selected metric instead of infinite. ([#1520](https://github.com/maibornwolff/codecharta/issues/1520))\r\n-   Mark color-section as unimportant in delta mode ([#769](https://github.com/maibornwolff/codecharta/issues/769))\r\n\r\n### Changed\r\n\r\n-   Small ui improvements added. ([#1881](https://github.com/MaibornWolff/codecharta/issues/1881))\r\n-   Numbers/Percentages always show in the distribution bar([#1540](https://github.com/MaibornWolff/codecharta/issues/1540))\r\n    -   Toggle between percentage and absolute numbers by clicking anywhere on the (expanded) distribution bar.\r\n    -   The old expanded distribution bar is now accessible through a button.\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   It is no longer possible to exclude all files on the map ([#901](https://github.com/MaibornWolff/codecharta/issues/901))\r\n\r\n## [1.76.0] - 2021-07-13\r\n\r\n### Added \u{1f680}\r\n\r\n-   Custom metric scenarios which include the \'Color-Metric\' (rloc) will now also save any changes made to the color scheme.\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Performance improvements when loading new files. ([#1312](https://github.com/maibornwolff/codecharta/issues/1312))\r\n\r\n## [1.75.0] - 2021-07-05\r\n\r\n### Added \u{1f680}\r\n\r\n-   Imported files are now compressed by default. Use the -nc parameter to uncompress the files. ([#1702](https://github.com/maibornwolff/codecharta/issues/1702))\r\n-   Export the current view as a png image by using "Ctrl+Alt+S" or clicking the corresponding button ([#674](https://github.com/MaibornWolff/codecharta/issues/674))\r\n-   Show only labels of buildings according to a chosen color ([#1347](https://github.com/MaibornWolff/codecharta/issues/1347))\r\n-   New buttons to reset the color hex values and color metric thresholds separately ([#1613](https://github.com/MaibornWolff/codecharta/issues/1613)) <br>\r\n    ![l](https://user-images.githubusercontent.com/50167165/121889295-5b071780-cd19-11eb-87ef-aba0ab0c6c09.png)\r\n\r\n### Changed\r\n\r\n-   Metric aggregations now work as intended and are available from the sidebar when selecting folders ([#1953](https://github.com/MaibornWolff/codecharta/issues/1953))\r\n-   Opening new files does no longer remove old ones.\r\n    -   Already loaded files can be individually removed.\r\n    -   The \'Multiple\' view will select the latest files. <br>\r\n        ![l](https://user-images.githubusercontent.com/50167165/123071234-c6856f00-d414-11eb-8326-e25f614e75d7.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   It is now possible to rotate the map by rotating the view cube ([#353](https://github.com/MaibornWolff/codecharta/issues/353))\r\n\r\n## [1.74.0] - 2021-05-31\r\n\r\n### Added \u{1f680}\r\n\r\n-   SonarImport: SonarQube 8.8 support. Older versions are still supported.\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Only show labels for building included in the search\r\n-   Color slider not initialized correctly ([#1592](https://github.com/MaibornWolff/codecharta/issues/1592))\r\n\r\n## [1.73.0] - 2021-05-10\r\n\r\n### Added \u{1f680}\r\n\r\n-   Improve descriptions ([#1879](https://github.com/MaibornWolff/codecharta/issues/1879))\r\n    <br></br>\r\n    ![m](https://user-images.githubusercontent.com/57844849/115393175-b2897b00-a1e1-11eb-8601-d2128f3469a3.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Excluding in delta mode is broken ([#1578](https://github.com/MaibornWolff/codecharta/issues/1578))\r\n    (Inclusion and exclusion of files using wildcard searches in the flatten and exclude operations)\r\n-   Fix labels and lines missing a connection in some cases([#1716](https://github.com/MaibornWolff/codecharta/issues/1716))\r\n-   Ribbons resizing when expanding ([#1952](https://github.com/MaibornWolff/codecharta/issues/1952))\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Fix breaking changes with newest three-js version([#1877](https://github.com/MaibornWolff/codecharta/issues/1877))\r\n\r\n## [1.72.0] - 2021-04-22\r\n\r\n### Added \u{1f680}\r\n\r\n-   Hints for Global Settings ([#1715](https://github.com/MaibornWolff/codecharta/issues/1715))\r\n-   Indicate total nodes and excluded / flattened nodes in file explorer ([#1880](https://github.com/MaibornWolff/codecharta/issues/1880))\r\n-   Add path to node context menu ([#1667](https://github.com/MaibornWolff/codecharta/issues/1667))\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Made the header semi responsive ([#1037](https://github.com/MaibornWolff/codecharta/issues/1037))\r\n\r\n## [1.71.2] - 2021-03-16\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   DevOps pipeline changes\r\n-   Fixed web visualization in github\r\n\r\n## [1.71.1] - 2021-03-16\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   DevOps pipeline changes\r\n\r\n## [1.71.0] - 2021-03-16\r\n\r\n### Changed\r\n\r\n-   Disable unready AI function\r\n-   Fix linter errors\r\n-   Fix editorconfig\r\n\r\n## [1.70.2] - 2021-03-12\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   DevOps pipeline changes\r\n-   Project naming for Docker deployment\r\n\r\n## [1.70.1] - 2021-03-12\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   DevOps pipeline changes\r\n\r\n## [1.70.0] - 2021-03-09\r\n\r\n### Changed\r\n\r\n-   Render on demand ([#1728](https://github.com/MaibornWolff/codecharta/issues/1728))\r\n\r\n### Fixed\r\n\r\n-   Memory leaks\r\n\r\n## [1.69.0] - 2021-02-23\r\n\r\n### Added \u{1f680}\r\n\r\n-   Added WebGL FXAA antialias & PixelRatio Options in order to achieve better resolution on high dpi displays(https://github.com/MaibornWolff/codecharta/pull/1551).</br></br>\r\n    ![option dialog](https://user-images.githubusercontent.com/74670211/106582136-f4404900-6543-11eb-8f5b-5e1ec47457c7.png)\r\n    There are 4 available modes:\r\n    -   **standard mode**: the pixel density is only applied to the small cube with standard browser aliasing\r\n    -   **pixel ratio without aliasing**: no antialiasing is used\r\n    -   **pixel ration with FXAA**: Nvidia FXAA antialiasing shader is used as an alisaing technique. this has better perfromance the standard browser aliasing aliasing\r\n    -   **pixel ration with MSAA**: this is the best aliasing quality, slower then FXAA.\r\n-   Added GPU Stats (only in dev mode)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Unfocus now respects the focus depth ([#1099](https://github.com/MaibornWolff/codecharta/issues/1099))\r\n-   Track anonymous usage data also for older CodeCharta API versions and fix some minor bugs.\r\n\r\n## [1.68.0] - 2021-02-08\r\n\r\n### Added \u{1f680}\r\n\r\n-   A new experimental feature has been added to track anonymous metadata of a currently loaded map.\r\n    -   Neither the map name nor file names will be tracked but anonymous metric values and statistics like (average, min, max).\r\n    -   The tracked data will not be sent to a server yet. Instead, it can be downloaded as a json file in the Global Settings for now.\r\n    -   It is planned to send the anonymous data to a server in the future, so that we can collect tracking data automatically.\r\n    -   ![example of new feature](https://user-images.githubusercontent.com/26900540/106896300-ac5f2480-66f1-11eb-8096-246d1733c0ee.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Errors occurred in delta mode if names of root folders were different\r\n-   Switching maps in delta mode now shows the differences between the maps ([#1606](https://github.com/maibornwolff/codecharta/issues/1606))\r\n-   Label over hovered building not shown for height Metric value of zero ([#1623](https://github.com/MaibornWolff/codecharta/issues/1623))\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   CodeChartaStorage class has been introduced to dynamically store values either on disk (standalone version) or in the localStorage (web version). This is the first step to solve [#684](https://github.com/MaibornWolff/codecharta/issues/684).\r\n\r\n## [1.67.0] - 2021-01-26\r\n\r\n### Added \u{1f680}\r\n\r\n-   Allow opening files from local drive by double clicking on the buildings or clicking on their names ([#1314](https://github.com/MaibornWolff/codecharta/issues/1314))\r\n    -   Only available in the standalone version!\r\n    -   files are opened in associated third-party applications\r\n    -   web-links are opened in a browser window\r\n-   Allow customized color in the node context menu ([#1556](https://github.com/MaibornWolff/codecharta/issues/1556)).\r\n\r\n    [!example of new feature #1556](https://user-images.githubusercontent.com/3596742/104302048-a007f300-54c8-11eb-86c1-287483884783.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   fixed wrong max tree map visibility ([#1624](https://github.com/MaibornWolff/codecharta/issues/1624))\r\n-   fixed incorrect label placement on delta maps that share no common nodes ([#1686](https://github.com/MaibornWolff/codecharta/issues/1686))\r\n\r\n## [1.66.0] - 2021-01-18\r\n\r\n### Added \u{1f680}\r\n\r\n-   Allow color of buildings to be customizable in the ribbon bar and in the legend. Colors of edges are now customizable as well ([#1533](https://github.com/MaibornWolff/codecharta/issues/1533))<br/><br/>\r\n    ![example of new feature](https://user-images.githubusercontent.com/3596742/103547861-3c1c7380-4ea5-11eb-8df2-541caf65b9df.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Global settings not reverting to default ones ([#1632](https://github.com/MaibornWolff/codecharta/issues/1632))\r\n-   Maximum treemap files shown in squarified node ([#1624](https://github.com/MaibornWolff/codecharta/issues/1624))\r\n-   Wrong folder names and colors in legend when using the highlight folder feature ([#1555](https://github.com/MaibornWolff/codecharta/issues/1555))\r\n-   Temporary labels are placed at the wrong height for scaled buildings ([#1618](https://github.com/MaibornWolff/codecharta/issues/1618))\r\n-   Visible labels will disappear or placed lower for scaled buildings ([#1619](https://github.com/MaibornWolff/codecharta/issues/1619))\r\n-   Unnecessary break line for secondary metrics ([#1093](https://github.com/MaibornWolff/codecharta/issues/1093))\r\n\r\n## [1.65.0] - 2020-12-23\r\n\r\n### Added \u{1f680}\r\n\r\n-   Highlight label while hovering over building, draw a temporary label for hovered buildings that have none ([#1529](https://github.com/MaibornWolff/codecharta/issues/1529))\r\n-   Integrated streetlayout ([#904](https://github.com/MaibornWolff/codecharta/issues/904))\r\n    ![cc_street_ccv](https://user-images.githubusercontent.com/63230711/78872405-87eed900-7a49-11ea-984a-c0ef738779b9.png)\r\n    In street layout file nodes are displayed as buildings and directories are displayed as streets. A street layout has the advantage of a more apparent directory structure and stable positioning of nodes after metric changes.\r\n    two different Street layout are integrated : - StreetLayout : as described above. - TMStreet : a combination of street layout and squarified layout.\r\n\r\n### Changed\r\n\r\n-   The button to see excluded buildings is now merged into the flattened button. Excluded and flattened buildings can now be seen by opening the building with the eye slash icon ([#1543](https://github.com/MaibornWolff/codecharta/issues/1543))\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Height scaling not applied to buildings ([#1595](https://github.com/MaibornWolff/codecharta/issues/1595)))\r\n-   Fixed multiple label positioning/scaling bugs\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   e2e flaky test ([#1322](https://github.com/MaibornWolff/codecharta/issues/1322))\r\n\r\n## [1.64.0] - 2020-12-15\r\n\r\n### Added \u{1f680}\r\n\r\n-   Download and upload Custom Configurations is now possible ([#1472](https://github.com/MaibornWolff/codecharta/issues/1472))\r\n\r\n    -   Open the Custom Configs menu in the toolbar on top of the map\r\n    -   Next to the `plus` Button you can see two new buttons: Upload and download.\r\n        -   Download: If you already have added Custom Configs you can download them by clicking the download button.\r\n            -   Custom Configs which are applicable for the currently selected map(s) will be downloaded as `.cc.config.json` files.\r\n        -   Upload: Click the upload button and specify your Custom Config file (`<file-name>.cc.config.json`)\r\n            -   Already existing Custom Configs will be skipped.\r\n            -   Different Custom Configs with same names will be renamed.\r\n            -   Another way to upload your Custom Configs is to upload a `.cc.json` file together with one or multiple `.cc.config.json` files using the default `Load .cc.json map` button in the upper left corner.\r\n    -   The Configs are stored to the local storage of your browser.\r\n        -   If a limit of `768KB` is exceeded you will see a warning when trying to add a new Custom Config.\r\n        -   You can click the displayed "download and purge" button to download/backup at least 6 months old Configs and then purge them from the local storage to make space for new ones.\r\n        -   If we cannot purge any Configs, you might have to do that by your own by deleting specific Configs manually.\r\n\r\n### Changed\r\n\r\n-   Increase possible margin size ([#1490](https://github.com/MaibornWolff/codecharta/pull/1490))\r\n    -   change displayed margin value from % to pixel\r\n    -   change dynamic margin value to a default margin value that should fit the map\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Re-enabled color selection for folders and on hover ([#1544](https://github.com/MaibornWolff/codecharta/pull/1544))\r\n-   Labels do not take delta height into account ([#1523](https://github.com/MaibornWolff/codecharta/issues/1523))\r\n-   The calculation of the map resolution scale factor was wrong ([#1491](https://github.com/MaibornWolff/codecharta/issues/1491))\r\n    -   The factor is used to decrease the map resolution especially for big maps to avoid performance issues.\r\n    -   Now only the selected maps will be considered for the calculation. Unselected maps will be skipped.\r\n\r\n## [1.63.0] - 2020-11-30\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add the folder name onto the floor on the first 3 layers to get a better overview of the map ([#1491](https://github.com/MaibornWolff/codecharta/issues/1491))\r\n-   UX Improvements related to labels allowing for user interaction #1404\r\n    -   Labels can be hovered, hovering their corresponding node\r\n    -   Selecting a label will select the corresponding node\r\n    -   Hovering a label will remove its transparency and move towards the user:\r\n        -   If other labels obstruct the hovered label it will move to the front\r\n    -   Increased the transparency of other labels; this makes it easier to distinguish the hovered label\r\n    -   Increase the amount of labels to 250.\r\n-   Show file count of folders in Attribute-Side-Bar ([#1255](https://github.com/MaibornWolff/codecharta/issues/1255)):\r\n    ![img showing file count of folder](https://user-images.githubusercontent.com/3596742/100371884-be915800-3008-11eb-89f5-ed57c62680cc.png)\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Buildings are flattened when delta is active #824.\r\n-   Selected Building now stays highlighted when map is rotated #1498\r\n\r\n## [1.62.0] - 2020-11-12\r\n\r\n### Added \u{1f680}\r\n\r\n-   A new option in the Global Settings allows to enable/disable experimental features #1318\r\n    -   Click on the settings button in the upper right corner to open the Global Settings dialog.\r\n    -   Activate/Deactivate the new option "Enable Experimental Features"\r\n    -   The features will be shown/hidden accordingly\r\n-   "CustomViews", the first experimental feature has been added #1318\r\n\r\n    -   It must be enabled by activating the new option in the Global Settings dialog as mentioned before.\r\n    -   You can save your current map configurations to replay/restore them later.\r\n    -   A saved CustomView can only be applied for it\'s original map.\r\n    -   This will enable you to be more efficient in analizing projects by switching between different CustomViews.\r\n\r\n-   NodeContextMenu now contains option to keep buildings highlighted #1323\r\n\r\n-   Fixed Folder algorithm supports nested (parent-child) Fixed Folders #1431\r\n    1. Define children of a Fixed Folder also as Fixed Folders by adding the `fixedPosition` attribute manually in `.cc.json`.\r\n    1. All children of a parent Fixed Folder must be fixed.\r\n    1. Read the how-to guide for further information: https://maibornwolff.github.io/codecharta/how-to/fixate_folders_with_a_custom_cc_json/\r\n\r\n### Changed\r\n\r\n-   Improved search\r\n\r\n    1. Not providing any star in the search bar from now on expects the input to\r\n       be a wildcard search. Thus, files are going to match paths that have\r\n       leading or following characters. E.g., `oo` is going to match\r\n       `/root/foobar`.\r\n    1. To use the explicit former search mode, wrap the search entry in quotes as\r\n       in: `"oo"`. This would only match filenames that are exactly `oo`.\r\n    1. The search field accepts multiple search entries at once, separated by\r\n       commata. `foo,bar` is going to search for both `*foo*` and `*bar*` and\r\n       marks all matched files accordingly.\r\n    1. It is possible to invert the search with a leading exclamation mark as in\r\n       `!foobar`. That will match any file that does not match `*foobar*`. It is\r\n       only possible to invert the complete input, not individual search entries.\r\n    1. Whitespace handling changed to ignore leading whitespace.\r\n\r\n-   Distribution metric #1188\r\n\r\n    1. set rloc to default distribution metric, showing language percentages for real lines of code, if available. Else set to unary to show language distribution over files\r\n\r\n-   Improved file sorting in the file overview of the search bar\r\n    -   Numbers are sorted naturally\r\n    -   Characters are compared with their base character (e.g., `a` is now next to `\xe1`).\r\n-   Label metric not shown by default anymore\r\n\r\n## [1.61.0] - 2020-10-30\r\n\r\n### Changed\r\n\r\n-   Disable highlighting buildings during map movement #1432\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   File tree/flattened/excluded overlay visualization is buggy #1269\r\n-   EdgePreview on Map broken when selecting zero #1276\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Schedules and merge retries of dependabot dependency updates changed\r\n\r\n## [1.60.2] - 2020-10-24\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Mouse cursor flickering #1170\r\n-   Fix flipping map when clicking any option in the toolbar #1410\r\n-   Fix edge metric not working correctly\r\n\r\n## [1.60.1] - 2020-10-20\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Issue with first start without an internet connection not working#1266\r\n-   Issue with ribbon bar sizes for opened cards #1035\r\n\r\n## [1.60.0] - 2020-10-16\r\n\r\n### Added \u{1f680}\r\n\r\n-   Parsing feedback with progressbar and probable ETA for parsers and SonarImporter #847\r\n-   Mark node names and make the names clickable for nodes that have a link to them #1313\r\n-   Indicate the metric name next to a shown value in a new line on labels #1035\r\n-   Checkboxes to display metric names and values and to display node names on labels #1035\r\n-   Mark node names and make the names clickable for nodes that have a link to them #1313\r\n\r\n### Changed\r\n\r\n-   Label design #1035\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   First start without an internet connection of standalone not working #1266\r\n-   Comparing a map in delta mode shows the correct differences\r\n-   This mainly applies to maps compared with itself while it also fixes some other minor miscalculations\r\n-   File extensions detection is improved\r\n-   Zooming in and out the map will now close the node context menu #1324\r\n    -   Improved and simplified event handling in NodeContextMenu component\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Improved performance of multiple operations (e.g., delta mode).\r\n\r\n## [1.59.0] - 2020-10-09\r\n\r\n### Added \u{1f680}\r\n\r\n-   New EXPERIMENTAL SCMLogParser version\r\n-   Improved performance around 300% when parsing CodeCharta\r\n-   Improved memory usage\r\n-   Fixed issue with old parser creating incorrect nodes in CodeCharta #871\r\n-   ATTENTION: the parser is experimental, therefore some potential issues might remain, e.g. potentially an unhandled edge case when parsing node\r\n-   To use the new parser a reversed git log is needed, as well as a git file list, refer to `ccsh scmlogparserv2 -h` for additional information\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Color-Metric slider is set and activated in the map accordingly to the released sliderbutton #1319\r\n-   Deselcting a building will instantly dehighlight the buildings which were connected through edges #890\r\n\r\n## [1.58.1] - 2020-10-02\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Showing wrong edges when hovering a building after selecting one #1137\r\n\r\n## [1.58.0] - 2020-10-02\r\n\r\n### Added \u{1f680}\r\n\r\n-   Add active color metric to the top of the legend panel #1278\r\n-   SourceCodeParser: Java 14 Support #1277\r\n\r\n## [1.57.4] - 2020-09-25\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Metric-Settings-Panels closed when clicking an option inside the panel #1258\r\n-   Improve loading and rendering maps performance\r\n\r\n## [1.57.3] - 2020-09-18\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Improve overall performance for loading and rendering maps\r\n-   Improve error messages when a file can\'t be loaded with the URL parameters\r\n\r\n## [1.57.2] - 2020-09-11\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   New API version 1.2 not set correctly in analysis\r\n\r\n## [1.57.1] - 2020-09-11\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Validation of unique filenames not checking for the complete path and instead throwing an error on duplicate filename\r\n\r\n## [1.57.0] - 2020-09-11\r\n\r\n### Added \u{1f680}\r\n\r\n-   `fixedPosition` as a new property in the `cc.json` that allows to fixate folders in the map\r\n\r\n### Changed\r\n\r\n-   `cc.json` version updated to `1.2`\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Compressed `cc.jsons (.gz) not marked as accepted when selecting a file in the file chooser\r\n\r\n### Docs \u{1f50e}\r\n\r\n-   [How-To: Fixate Folders in the `cc.json`](https://maibornwolff.github.io//codecharta/how-to/fixate_folders_with_a_custom_cc_json/)\r\n-   CC-Json-API changes\r\n\r\n## [1.56.0] - 2020-09-04\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Improve performance when switching to multiple or delta mode when edges are available\r\n-   Scenario with EdgeMetric is only appliable when EdgeMetric is existing for the Map #1201\r\n-   Starting standalone version results in infinite loading loop #1202\r\n-   Expanded metric selection will close when clicking anywhere outside of that selection #1036\r\n\r\n## [1.55.0] - 2020-08-28\r\n\r\n### Added \u{1f680}\r\n\r\n-   Cursor indicator for different mouse actions #1042\r\n\r\n### Changed\r\n\r\n-   Edge-Metrics sorted by name now instead of number of incoming and outgoing edges\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Number of incoming and outgoing edges not visible when hovering over a node #1095\r\n-   Highlighting buildings in multiple mode now works #956\r\n\r\n## [1.54.0] - 2020-08-21\r\n\r\n### Added \u{1f680}\r\n\r\n-   Opening NodeContextMenu in the tree-view marks the node until it is closed #1068\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Missing Sonarcloud metrics in demo\r\n\r\n### Docs \u{1f50e}\r\n\r\n-   Added note how to fix missing `sh` command issue when running integration tests on Windows\r\n\r\n## [1.53.0] - 2020-08-14\r\n\r\n### Changed\r\n\r\n-   NodeContextMenu will show up when releasing the right-mouse-button now #1027\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   NodeContextMenu showing up after moving the mouse while holding right-mouse-button #1027\r\n\r\n## [1.52.0] - 2020-08-07\r\n\r\n### Added \u{1f680}\r\n\r\n-   Support for Tokei 12 new JSON schema #1103\r\n\r\n### Changed\r\n\r\n-   Rename master branch to main for a more inclusive naming #1117\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   After loading an invalid file the filechooser pops up again, so that the user can choose a valid file #1021\r\n-   Quality gates on sonarcloud.io are red #879\r\n\r\n### Docs \u{1f50e}\r\n\r\n-   Moved developer guides to our [gh-pages](https://maibornwolff.github.io/codecharta/) #986\r\n\r\n## [1.51.0] - 2020-07-24\r\n\r\n### Added \u{1f680}\r\n\r\n-   File chooser now accept ".json" files only to avoid accidentally loading incorrect files #1094\r\n-   Lots of tooltips #1030\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Blacklisting a building would sometimes not update the map #1098\r\n-   Changes made after opening the filechooser and closing it won\'t be applied #875\r\n-   Edge metric list not always updated correctly when loading a new file #1106\r\n\r\n## [1.50.0] - 2020-07-10\r\n\r\n### Added \u{1f680}\r\n\r\n-   Line between scenario indicator and remove button #1069\r\n\r\n### Changed\r\n\r\n-   Reduced transition time when opening or collapsing parts of the ribbon bar #1043\r\n-   Search Panel will open now when clicking in the search field and collapse when clicking somewhere else #1071\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Opening the same file again will now reload the file and reset the application #1032\r\n-   Improve render performance by persisting color conversions #1034\r\n-   Sorting in tree-view not being applied #1040\r\n\r\n## [1.49.1] - 2020-07-03\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Improved performance significantly when switching between single, multiple and delta\r\n-   Color-Range-Slider sometimes misbehaved when loading a new map or excluding buildings #926\r\n\r\n## [1.49.0] - 2020-06-19\r\n\r\n### Added \u{1f680}\r\n\r\n-   Custom scenarios can be created and saved through the scenario menu #675\r\n-   Importer and parser documentation can now be found on the github Website #954\r\n-   Output of sourcemonitor can now be compressed with the compression flag\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   [Security] Bump angular from 1.7.9 to 1.8.0 in /visualization #995\r\n\r\n## [1.48.0] - 2020-06-12\r\n\r\n### Added \u{1f680}\r\n\r\n-   Support of compressed cc.json files. Files can be compressed in the analysis #848\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Improved performance of several importers #846\r\n\r\n## [1.47.1] - 2020-05-08\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Attribute-Side-Bar being invisible\r\n\r\n## [1.47.0] - 2020-05-02\r\n\r\n### Added \u{1f680}\r\n\r\n-   When hovering over a folder, all buildings inside it will be highlighted as well #694\r\n\r\n### Changed\r\n\r\n-   Rename the button Show-Complete-Map button to Unfocus #642\r\n-   Move the Unfocus button (visible when right-clicking a focused node) to the node-context-menu #948\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Generating a delta map with merged empty folders in between is now working correctly #730\r\n-   Reduced time when opening a new file #932\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   [Security] Bump jquery from 3.4.0 to 3.5.0 in /visualization #944\r\n\r\n## [1.46.1] - 2020-04-24\r\n\r\n### Added \u{1f680}\r\n\r\n-   Error dialogs in case of validation or api version issues #610\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Improved overall rendering performance of larger maps by roughly 40% #836\r\n\r\n## [1.45.5] - 2020-04-17\r\n\r\n### Added \u{1f680}\r\n\r\n-   Median symbol for aggregated relative metrics #365\r\n-   AttributeTypes for tokeiImporter and SCMLogParser #365\r\n-   Ellipsis button in TreeView list when hovering a node to access context menu #780\r\n-   Show gray eye-icon next to the ellipsis-button to indicate a flattened node #780\r\n-   Attribute Type selector in the metric dropdowns for edges and nodes\r\n\r\n### Changed\r\n\r\n-   Metrics with AttributeType relative are now aggregated using the median #365\r\n-   Showing absolute number of files instead of relative number when hovering list item in TreeView #780\r\n-   Clicking a hovered list item inside the TreeView opens folders #780\r\n-   Color node name in gray when flattened #780\r\n\r\n### Removed \u{1f5d1}\r\n\r\n-   Eye-icon in TreeView list to flatten a node #780\r\n-   Option to focus a node when clicking the node name inside the TreeView #780\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Consistency of AttributeTypes representation #365\r\n-   Wrong file description for tokeiimporter\r\n-   Improved search performance #837\r\n\r\n## [1.44.0] - 2020-03-27\r\n\r\n### Added \u{1f680}\r\n\r\n-   Dialog to select between different sorting options #388\r\n-   Button to reverse the current selected sorting #388\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Show file selection in toolBar after excluding or hiding a node instead of an empty toolBar #896\r\n\r\n## [1.43.0] - 2020-03-20\r\n\r\n### Changed\r\n\r\n-   Selectable metrics will only contain metrics from the visible maps\r\n-   Closing the attribute-side-bar by clicking somewhere in the map will now be triggered on mouse up instead of mouse down\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Search-panel opening for a short duration when importing a new file\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Fix vulnerability with nokogiri <1.10.8\r\n\r\n## [1.42.3] - 2020-03-13\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Loading Gif not displayed when preparing to render a new map #857\r\n-   Selecting zero files in Multiple mode will not trigger the 3D CodeMap creation\r\n-   Metrics in the dropdown menu now show the correct max value for the visible maps #876\r\n\r\n## [1.42.2] - 2020-02-14\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Replaced non standard `[[` in sh scripts #849\r\n-   Improved performance for loading a new file #836\r\n-   Marked Packages are loaded from files #798\r\n\r\n## [1.42.1] - 2020-02-07\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   GC Overhead Limit (OutOfMemory Exception) during analysis of large SCMLogs fixed #845\r\n\r\n## [1.42.0] - 2020-01-31\r\n\r\n### Added \u{1f680}\r\n\r\n-   Support for camel and kebab-case for ccsh arguments #772\r\n-   RawTextParser for analysis #660\r\n-   IndentationLevel as metric for RawTextParser #660\r\n-   Show additional Pairing Rate of Selected Building, simultaneously to the currently hovered Buildings #736\r\n\r\n### Changed\r\n\r\n-   Options of the ccsh are now consistently in kebab-case #772\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Path prefix handling in tokeiimporter #841\r\n\r\n## [1.41.8] - 2020-01-17\r\n\r\n### Removed \u{1f5d1}\r\n\r\n-   Project name parameters in the ccsh #773\r\n\r\n## [1.41.6] - 2020-01-10\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Deployment\r\n\r\n## [1.41.1] - 2020-01-10\r\n\r\n### Fixed \u{1f41e}\r\n\r\n-   Performance of loading maps with edges improved #823\r\n-   Calculation of other Group for fileExtensionBar #768\r\n-   Remove focus of UI elements when they are not visible anymore\r\n\r\n## [1.41.0] - 2019-12-06\r\n\r\n### Added \u{1f680}\r\n\r\n-   Show the relative number of files a folder includes compared to the project in the TreeView #380\r\n-   Show the number of files a folder includes in the TreeView when hovering #380\r\n-   When the File Extension Bar is hovered, all buildings corresponding to that extension are highlighted #545\r\n-   Toggle between percentage and absolute values when clicking the file extension details section #545\r\n-   Sum hovered delta values for folders #781\r\n\r\n## [1.40.0] - 2019-11-22\r\n\r\n### Changed\r\n\r\n-   Replaced Blacklist Hide with Flatten option #691\r\n-   Flattened buildings are not hidden by default #691\r\n\r\n### Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}\r\n\r\n-   Bump @types/three from 0.89.12 to 0.103.2 in /visualization #453\r\n-   Bump angularjs-slider from 6.5.1 to 7.0.0 in /visualization #454\r\n-   Bump webpack from 3.12.0 to 4.41.2 in /visualization #436\r\n-   [Security] Bump angular from 1.7.7 to 1.7.9 in /visualization #800\r\n\r\n## [1.39.0] - 2019-11-15\r\n\r\n### Added\r\n\r\n-   Progress indicator for SonarImporter #544\r\n\r\n### Changed\r\n\r\n-   New style for hovered metric values #696\r\n-   Redesigned slider labels in ribbonBar sections #696\r\n-   Shortened ribbonBar sections #696\r\n\r\n### Fixed\r\n\r\n-   Missing pictures and broken links in docs #785\r\n-   SCMLogParser is now more resilient to unusual SVN commit messages #763\r\n\r\n## [1.38.1] - 2019-11-13\r\n\r\n### Added\r\n\r\n-   New github-pages https://maibornwolff.github.io/codecharta/\r\n\r\n### Fixed\r\n\r\n-   Sum symbol for hovered metric values only shows for folders #775\r\n\r\n## [1.38.0] - 2019-11-08\r\n\r\n### Added\r\n\r\n-   Temporal coupling edges generated by SCMLogParser #622\r\n\r\n### Changed\r\n\r\n-   Downloaded files are no longer formatted #679\r\n-   Added highly and median coupled files metrics to non-churn metric list of SCMLogParser #622\r\n-   Moved nodePathPanel to toolBar and updated style #607\r\n\r\n### Fixed\r\n\r\n-   Removed attributes from downloaded files that should not be there #679\r\n\r\n## [1.37.0] - 2019-10-25\r\n\r\n### Added\r\n\r\n-   Sidebar with information regarding the selected building #527\r\n-   Sidebar closes when selected buildings is excluded #748\r\n\r\n### Changed\r\n\r\n-   Animation to show or hide the legend panel #527\r\n\r\n### Removed\r\n\r\n-   Expandable detail panel in lower left corner #527\r\n-   Removed option to maximize/minimize detail panel #527\r\n\r\n### Fixed\r\n\r\n-   Autofocus and label size for focused nodes #747\r\n-   Selected buildings stays selected when settings are changed #748\r\n-   IllegalStateException when scanning single file in SourceCodeParser #573\r\n-   SourceCodeParser places files in the project root correctly into the hierarchy #574\r\n\r\n## [1.36.0] - 2019-10-18\r\n\r\n### Changed\r\n\r\n-   Open and close the ribbonBar sections independently with an updated animation\r\n\r\n### Fixed\r\n\r\n-   Camera is now resetted correctly, when unfocusing #634\r\n-   Inputs of Color Range Slider now waits a second before it commits its values #676\r\n-   Fixed root folder name in TreeView after new map after loading new map #649\r\n-   Increased size of ribbonBar for big screens #644\r\n-   File-Extension-Bar will not display excluded nodes anymore #725\r\n-   Sanitize input for shelljs #600\r\n\r\n### Chore\r\n\r\n-   Bump jacoco from 0.8.1 to 0.8.4 in /analysis\r\n\r\n## [1.35.0] - 2019-10-04\r\n\r\n### Added\r\n\r\n-   Checkbox in global Settings for disabling camera reset, when new map is loaded #685\r\n-   Pipe support for SourceCodeParser #716\r\n-   Pipe support for SCMLogParser #717\r\n-   Pipe support for SonarImporter #715\r\n\r\n### Fixed\r\n\r\n-   Exclude and Hide options are disabled for empty and already existing search patterns #654\r\n\r\n## [1.34.0] - 2019-09-20\r\n\r\n### Added\r\n\r\n-   Tokei Importer #538\r\n-   Prominent Notice that we use Sonar-jar #713\r\n\r\n### Chore\r\n\r\n-   Bump kotlin-reflect from 1.3.41 to 1.3.50 in /analysis\r\n-   Bump json from 20180813 to 20190722 in /analysis\r\n-   Bump rxjava from 2.2.9 to 2.2.12 in /analysis\r\n-   Bump assertj-core from 3.12.2 to 3.13.2 in /analysis\r\n-   Bump sonar-java-plugin from 5.12.1.17771 to 5.14.0.18788 in /analysis\r\n\r\n## [1.33.0] - 2019-09-10\r\n\r\n### Added\r\n\r\n-   Edge Previews (Palm-Tree-Effect) #529\r\n-   Dropdown to select Edge Metric, including Edge Counter #529\r\n-   Edge Metric settings for Edge Height, Number of Previews & show only building with Edges #529\r\n\r\n### Changed\r\n\r\n-   Edge Visualization to better distinguish between incoming and outgoing edges #529\r\n-   Distribution metric is by default the same as area metric #689\r\n-   MapTreeView below searchBar opens the first level by default #690\r\n-   Focus metric search when opening metricChooser #693\r\n\r\n### Removed\r\n\r\n-   Edge Options in Context menu #529\r\n\r\n### Fixed\r\n\r\n-   SourceCodeParser now skips custom metrics for files, if the syntax tree cannot be created\r\n-   Nodes with color metric equals 0 are colored correct again #677\r\n\r\n### Chore\r\n\r\n-   [Security] Bump mixin-deep from 1.3.1 to 1.3.2 in /visualization\r\n\r\n## [1.32.0] - 2019-08-09\r\n\r\n### Added\r\n\r\n-   Search for metrics and an indicator for the highest value in dropdown #575\r\n-   Button to enable PresentationMode that uses Flashlight-Hovering #576\r\n-   Clarifying information which file is which in the file bar when in delta mode #615\r\n\r\n### Changed\r\n\r\n-   Replaced Scenario dropdown with button on the left of the metric sections #628\r\n\r\n## [1.31.0] - 2019-08-02\r\n\r\n### Added\r\n\r\n-   New Metric in SourceCodeParser: Maximum-Nesting-Level #659\r\n\r\n### Fixed\r\n\r\n-   Label hight adjustment now matches scaling of map #594\r\n-   SCMLogParser now guesses the input file encoding #614\r\n\r\n## [1.30.0] - 2019-07-26\r\n\r\n### Added\r\n\r\n-   New Search Bar #526\r\n-   Number of Renames Metric to SCMLogParser #621\r\n-   Age In Weeks Metric for SCMLogParser #620\r\n\r\n### Changed\r\n\r\n-   ToolBar now shows partially cut-off controls if the window is too small #582\r\n-   Position of the legendPanel was moved to the bottom-right corner #633\r\n-   RibbonBar only opens the three metric section\r\n-   Moved Scenario-select to the right in order to use less space\r\n-   Moved loading-gif from ribbonBar to toolBar\r\n\r\n### Removed\r\n\r\n-   RibbonBar toggle button\r\n\r\n### Fixed\r\n\r\n-   FileExtensionBar height to not show a bottom-margin in Chrome\r\n-   PointerEvents not being propagated when RibbonBar was extended\r\n-   Reduced memory usage of SCMLogParser to avoid OutOfMemory Exception #631\r\n\r\n### Chore\r\n\r\n-   [Security] Bump lodash.mergewith from 4.6.1 to 4.6.2 in /visualization\r\n-   [Security] Bump lodash from 4.17.11 to 4.17.13 in /visualization\r\n-   [Security] Bump fstream from 1.0.11 to 1.0.12 in /visualization\r\n\r\n## [1.29.0] - 2019-07-12\r\n\r\n### Changed\r\n\r\n-   Moved Button to reset the map to the center next to the view-cube #606\r\n-   Moved FileExtensionBar #527\r\n\r\n### Removed\r\n\r\n-   Burger Menu / SideNav #526\r\n\r\n### Fixed\r\n\r\n-   Colors in File-Extension-Bar will be displayed in MS Edge and Standlone now #584\r\n\r\n## [1.28.0] - 2019-06-28\r\n\r\n### Added\r\n\r\n-   Releasing will now remind the developer to manually add the release notes #533\r\n-   StructureModifier to remove and move nodes and set root of projects #547 / #181\r\n\r\n### Changed\r\n\r\n-   More informative log messages regarding the success of project merging #547\r\n\r\n### Removed\r\n\r\n-   Release Notes are not generated and added automatically to a release #533\r\n\r\n### Fixed\r\n\r\n-   Margin will now be set correctly depending on whether dynamicMargin is enabled or not #602\r\n\r\n## [1.27.0] - 2019-06-25\r\n\r\n### Added\r\n\r\n-   Automatically generates release notes from changelog and appends it to release #533\r\n-   Adds global settings-menu with settings from options panel and weblinks #528\r\n\r\n### Changed\r\n\r\n-   Moved File Settings from Ribbon Bar to new File Setting Bar #525\r\n-   Rename sample file codemap-nodes #587\r\n-   Hide checkbox to select white-positive-buildings in delta state #345\r\n\r\n### Removed\r\n\r\n-   Removes Options panel from sidebar #528\r\n-   Removes Weblinks panel from sidebar #528\r\n-   Removed URL-parameter info from sidebar #525\r\n\r\n### Fixed\r\n\r\n-   Unary Metric will no longer be auto-selected when a new map is loaded #579\r\n\r\n## [1.26.0] - 2019-06-14\r\n\r\n### Added\r\n\r\n-   FileExtensionBar to show file-distribution of chosen metric #495\r\n-   sum icon is now displayed on the left of the metric value #364\r\n-   Added Pop-up dialog before downloading file to set filename and see what data will be stored #523\r\n\r\n### Fixed\r\n\r\n-   Fix set default ColorRange when resetting color section #560\r\n\r\n## [1.25.1] - 2019-05-30\r\n\r\n### Added\r\n\r\n-   SVN log parser keeps track of renaming of files for metric calculation #542\r\n\r\n### Fixed\r\n\r\n-   Entries with renaming information in SVN logs are attributed to correct file #542\r\n-   Unary metric will no longer be removed from the MetricChooser-Dropdown when a folder was excluded or hidden #548\r\n-   Changing margin and then file or mode will no longer freeze the application #524\r\n\r\n### Chore\r\n\r\n-   [Security] Bump tar from 2.2.1 to 2.2.2 in /visualization\r\n\r\n## [1.25.0] - 2019-05-17\r\n\r\n### Added\r\n\r\n-   Added SonarJava to Source code parser #343\r\n-   Added exclude and defaultExclude options to SourceCodeParser #508\r\n-   Show loading-gif in ribbonBar when rerendering map\r\n\r\n### Changed\r\n\r\n-   Using Sonar Plugins for Source code parser, giving the Sonar Metrics #343\r\n-   Use debounced settings update instead of throttled\r\n-   Filename of downloaded file now contains time #484\r\n\r\n### Fixed\r\n\r\n-   Fixed issue with too long line in ccsh.bat #506\r\n-   Prevent downloaded files from having multiple Timestamps #484\r\n-   Do not show loadingGif when cancelling the fileChooser #498\r\n-   Excluding a building now updates the maximum value of colorRange #355\r\n\r\n### Chore\r\n\r\n-   Bump angular-material from 1.1.9 to 1.1.14 in /visualization\r\n-   [Security] Bump jquery from 3.3.1 to 3.4.0 in /visualization\r\n\r\n## [1.24.0] - 2019-04-23\r\n\r\n### Removed\r\n\r\n-   Settings as URL parameters #470\r\n\r\n### Fixed\r\n\r\n-   Fixed issue with trailing slash in URL parameter of SonarImporter #356\r\n\r\n### Chore\r\n\r\n-   Bump d3 from 4.13.0 to 5.9.2 in /visualization\r\n-   Bump sinon from 4.5.0 to 7.3.1 in /visualization\r\n\r\n## [1.23.0] - 2019-03-22\r\n\r\n### Added\r\n\r\n-   Project Name can be specified for merge filter #394\r\n\r\n### Changed\r\n\r\n-   Throw a MergeException if project names do not match in MergeFilter #394\r\n\r\n### Fixed\r\n\r\n-   Excluded buildings are no longer used for aggregated metric calculation #352\r\n\r\n### Chore\r\n\r\n-   Bump browser-sync-webpack-plugin from 1.2.0 to 2.2.2 in /visualization\r\n-   Bump @types/node from 8.10.19 to 11.11.3 in /visualization\r\n-   Bump html-webpack-plugin from 2.30.1 to 3.2.0 in /visualization\r\n-   Bump load-grunt-tasks from 3.5.2 to 4.0.0 in /visualization #444\r\n-   Bump ajv from 5.5.2 to 6.10.0 in /visualization #447\r\n-   Bump resolve-url-loader from 2.3.0 to 3.0.1 in /visualization #448\r\n\r\n## [1.22.0] - 2019-03-15\r\n\r\n### Added\r\n\r\n-   Added buttons to select all/none/inversion of revisions/maps in multiple mode #391\r\n-   Merge filter can merge all files of folders #392\r\n\r\n### Fixed\r\n\r\n-   Fixed bug that code map was not re-loaded when changing from multiple to single revision mode #396\r\n-   Fixed missing apiVersion in aggregated map #398\r\n-   Input Fields of color sliders adjust width according to content #409\r\n\r\n### Chore\r\n\r\n-   Bump nouislider from 11.1.0 to 13.1.1 in /visualization\r\n-   Bump typescript from 2.7.2 to 3.3.3333 in /visualization\r\n-   Bump @types/d3 from 4.13.0 to 5.7.1 in /visualization\r\n\r\n## [1.21.2] - 2019-02-26\r\n\r\n### Added\r\n\r\n-   When entering Multiple Mode, all Maps/revisions are preselected\r\n\r\n### Fixed\r\n\r\n-   Fixing non-existent metric aggregation on root-level when using multiple Files\r\n\r\n## [1.21.1] - 2019-02-22\r\n\r\n### Added\r\n\r\n-   Hovering a node in the map also hovers it in the tree view #351\r\n\r\n### Fixed\r\n\r\n-   Fixing sync between treeview hovering and map hovering #351\r\n-   Folders can no longer be colored in the CodeMap or TreeView #359\r\n\r\n## [1.21.0] - 2019-02-16\r\n\r\n### Added\r\n\r\n-   Color searched node names green in TreeView #225\r\n-   Add option buttons (three dots) in TreeViewSearch to `Hide` or `Exclude` matching nodes #298\r\n-   Show blacklist entry counter in blacklistPanel header #298\r\n-   Option checkbox \'Hide Flattened Buildings\' #225\r\n-   Hide/Flatten non-searched buildings #225\r\n-   Hide/Flatten all buildings, if searchPattern can\'t find any matching nodes #225\r\n-   Show maxValue of each metric in metricChooser select list #204\r\n-   Colored color-slider inside the RibbonBar #318\r\n-   Option to color positive buildings white #311\r\n-   Clicking the ribbonBar section-titles toggles the ribbonBar #324\r\n-   View-Cube displayed in top right corner #274\r\n-   Adding prettier formatter\r\n-   Adapt colorRange when changing colorMetric #330\r\n\r\n### Changed\r\n\r\n-   Update TreeView filter with search field #225\r\n-   Use \'gitignore\' style matching in TreeViewSearch #225\r\n-   Reorder `Focus`, `Hide` and `Exclude` buttons in nodeContextMenu #298\r\n-   Reorder sidebarPanels (BlacklistPanel beneath TreeViewSearchPanel) #298\r\n-   Use `fa-ban`-icon as symbols for blacklistPanel (instead of `fa-list`) #298\r\n-   Use `fa-ban`-icon as symbols for blacklistType `Exclude` (instead of `fa-times`) #298\r\n-   Label size keeps readable for large maps or a high distance between camera and map #237\r\n-   updated dependencies to fix vulnerabilities\r\n-   Scenarios only update settings which exist in Scenario and not all #224\r\n-   MergeFilter to merge unique blacklist entries #275\r\n-   MergeFilter to only merge unique attributeType entries #275\r\n\r\n### Removed\r\n\r\n-   Remove invertHeight checkbox in delta-view #306\r\n-   Remove option to add blacklist entries from inside the blacklistPanel #298\r\n-   Remove statistic functions in Experimental panel #308\r\n\r\n### Fixed\r\n\r\n-   CodeMap does not move anymore when navigating in text-fields #307\r\n-   Merge blacklist in multipleFile view and convert paths #275\r\n-   Show logo in NW.js standalone application #233\r\n\r\n## [1.20.1] - 2018-12-19\r\n\r\nFixed release issues.\r\n\r\n## [1.20.0] - 2018-12-19\r\n\r\n### Added\r\n\r\n-   button to unfocus node\r\n-   NodeContextMenu: Option to only hide dependent edges\r\n-   plop support\r\n\r\n### Changed\r\n\r\n-   Renaming \'isolate node\' to \'focus node\'\r\n-   Focusing a node does not remove the blacklist items of type Hide\r\n\r\n### Removed\r\n\r\n-   NodeContextMenu: Option to \'show all\' nodes, which used to unhide all nodes\r\n\r\n### Fixed\r\n\r\n-   Reshow hidden nodes from Treeview or Blacklist\r\n\r\n## [1.19.0] - 2018-11-02\r\n\r\n### Added\r\n\r\n-   Deleted files in delta view use their previous area value in order to be visible #254\r\n\r\n### Fixed\r\n\r\n-   Buildings in the delta view are not colored correctly #253\r\n-   Reset Button in RibbonBar to reset \'Invert Colors\' #255\r\n-   Remove lag of \'Invert Color\' checkboxes, when selecting single/delta mode #255\r\n\r\n## [1.18.1] - 2018-10-31\r\n\r\nFixed release issues\r\n\r\n## [1.18.0] - 2018-10-29\r\n\r\n### Added\r\n\r\n-   Integration with Jasome through JasomeImporter #245\r\n-   URL parameter \'mode\' with the values Single, Multiple or Delta\r\n-   Blacklist to persist excluded or hidden nodes #205\r\n-   Option to exclude nodes in nodeContextMenu #205\r\n-   BlacklistPanel in SettingsSidebar to manage blacklist #205\r\n-   Save-Button to download current CodeMap #205\r\n-   Publishing visualization on Docker Hub #252\r\n\r\n### Changed\r\n\r\n-   No longer fat jar of every subcomponent of analysis, baked into ccsh\r\n-   Changed simple syserr write to logger call for analysis #243\r\n\r\n### Removed\r\n\r\n-   URL parameter \'delta\' does not exist anymore\r\n\r\n### Fixed\r\n\r\n-   Show delta of CodeMap when URL parameter mode=delta is set\r\n\r\n## [1.17.0] - 2018-09-28\r\n\r\n### Changed\r\n\r\n-   Invert delta colors moved from color to heigh metric column in ribbon bar #220\r\n-   Delta value now as kindOfMap shown #220\r\n-   Aggreate maps as multiple rename #220\r\n\r\n### Fixed\r\n\r\n-   Single/delta buttons now correctly activated when delta in ulr shown #220\r\n\r\n## [1.17.0] - 2018-09-21\r\n\r\n### Added\r\n\r\n-   CodeMaatImport for temporal coupling dependencies #172\r\n-   EdgeFilter to aggregate edge-attributes as node-attributes #222\r\n-   Option to show and hide dependent edges from node-context-menu #218\r\n\r\n### Changed\r\n\r\n-   MergeFilter merges edges #172\r\n\r\n## [1.16.2] - 2018-09-10\r\n\r\n### Fixed\r\n\r\n-   missing event in firefox #232\r\n\r\n## [1.16.1] - 2018-08-31\r\n\r\n### Added\r\n\r\n-   gitlab + dotnet manual\r\n\r\n## [1.16.0] - 2018-08-31\r\n\r\n### Added\r\n\r\n-   add the option to add multiple files via url parameter (e.g. ?file=a&file=b...)\r\n\r\n## [1.15.1] - 2018-08-13\r\n\r\nFixed release issues\r\n\r\n## [1.15.0] - 2018-08-13\r\n\r\n### Added\r\n\r\n-   e2e tests are running in CI Environment (headless)\r\n-   pupeteer as e2e test framework\r\n-   Show names of marked packages in legend\r\n-   Added a source code importer that can analyse rloc,mcc for java source code\r\n-   keep settings when the user changes a file\r\n-   Added option to set white background\r\n\r\n### Removed\r\n\r\n-   cypress\r\n\r\n## [1.14.2] - 2018-07-16\r\n\r\n### Changed\r\n\r\n-   Changed folder detail metrics from mean to sum\r\n\r\n## [1.14.1] - 2018-07-13\r\n\r\nFixed release issues\r\n\r\n## [1.14.0] - 2018-07-13\r\n\r\n### Added\r\n\r\n-   Added UnderstandImporter to Analysis\r\n-   Packages can be highlighted in different colors #152\r\n-   Adding a context menu with highlighting colors and convenience methods for the tree view and 3D view #155\r\n-   Folders and files to highlight can be described in the cc.json #165\r\n-   Dynamic/automatic margin computing de/activated by tick\r\n\r\n### Changed\r\n\r\n-   Details panel: using the sum of the childrens metrics instead of the mean value\r\n\r\n### Fixed\r\n\r\n-   Display buttons do not trigger map changes #185\r\n-   Flickering surfaces when zooming out\r\n\r\n## [1.13.0] - 2018-06-08\r\n\r\n### Added\r\n\r\n-   Layout switcher #141\r\n-   Added CrococosmoImporter to Analysis\r\n-   Added type, dirs, name to CSVExporter\r\n-   Invert height of building checkbox\r\n-   Aggregate multiple maps in visualization #110\r\n-   Auto Focus selected map part\r\n-   Timmer added to applySettings in SettingsService\r\n\r\n### Changed\r\n\r\n-   Crococosmo xml files will now generate a cc.json file for each version\r\n-   Suppressing ARIA warnings\r\n-   Simplified gradle structure of analysis part\r\n-   Deltas added in the metric quick access panel #138\r\n-   Ticks and ResetValue Buttons call to onSettingsChange to avoid applySettings timer\r\n-   compacting empty middle packages #150\r\n-   Detail panel minimized by default\r\n\r\n### Fixed\r\n\r\n-   filter by regex shows parent nodes #116\r\n-   typo in scss file\r\n\r\n## [1.12.0] - 2018-04-27\r\n\r\n### Added\r\n\r\n-   horizontal quick access metric chooser\r\n-   Link behind filepath in detailPanel #84\r\n-   Double click event-handler on Buildings #84\r\n-   Detail Panel can be minimized and maximized\r\n-   Settings option to minimize Detail Panel\r\n-   cypress as an e2e test runner\r\n\r\n### Removed\r\n\r\n-   metric details from legend\r\n-   metric chooser from settings panel\r\n\r\n## [1.11.2] - 2018-04-13\r\n\r\n### Fixed\r\n\r\n-   a sonar importer bug which prevented the importer to fetch the last page #122\r\n\r\n## [1.11.1] - 2018-04-11\r\n\r\nFixed release issues\r\n\r\n## [1.11.0] - 2018-04-11\r\n\r\n### Added\r\n\r\n-   SASS support\r\n-   simple regex filter\r\n-   Reset Button\r\n-   Dialog Service replaces console log calls and window.alert calls\r\n-   linking tree view and map hover\r\n-   auto fit scene button\r\n-   anugularJS material\r\n-   Scenarios are now filtered by compatibility for the given map\r\n-   Link in visualization #84\r\n\r\n### Removed\r\n\r\n-   materialize-css\r\n-   grunt\r\n\r\n### Fixed\r\n\r\n-   less flickering and artifacts\r\n\r\n## [1.10.0] - 2018-03-22\r\n\r\n### Changed\r\n\r\n-   Clean up UI #86\r\n-   Updated analysis dependencies\r\n\r\n### Fixed\r\n\r\n-   Delta View shows Deltas of itself as non-trivial if nodes have same name #89: Compare deltas by path not name\r\n-   Delta calculation performance boost #91\r\n-   Problems when intermediate nodes missed metrics #92\r\n-   removed unnecessary calculations\r\n-   removed bug in SonarImporter that slowed up performance and missed out multiple metrics\r\n-   minor bugs\r\n\r\n## [1.9.3] - 2018-02-23\r\n\r\n### Changed\r\n\r\n-   sorting treeview by folders and names\r\n\r\n## [1.9.2] - 2018-02-20\r\n\r\n### Added\r\n\r\n-   added preliminary CSVExporter for visualisation data\r\n\r\n### Changed\r\n\r\n-   padding rendering\r\n-   minimal building height is 1 to prevent clipping issues\r\n-   fallback values for visualization when no metric is available (area = 1, height = 1, color = grey). Data in data structure will not be changed.\r\n\r\n## [1.9.1] - 2018-02-20\r\n\r\n### Fixed\r\n\r\n-   detail panel bug fix\r\n\r\n## [1.9.0] - 2018-02-20\r\n\r\n### Changed\r\n\r\n-   moved to unscoped npm packages\r\n\r\n## [1.8.2] - 2018-02-20\r\n\r\n### Changed\r\n\r\n-   detail panel background is white now. better visibility\r\n\r\n## [1.8.1] - 2018-02-20\r\n\r\n### Changed\r\n\r\n-   revision chooser moved to settings panel and uses now understandable dropdowns instead of links. Part of the #82 proposals\r\n\r\n## [1.8.0] - 2018-02-20\r\n\r\n### Added\r\n\r\n-   Experimental dependency support\r\n-   loading indicator\r\n-   file path to detail panel\r\n-   collapsible tree view and visibility/isolation per node toggles\r\n\r\n### Changed\r\n\r\n-   added a ray-aabb intersection test before precise testing. Less time is spent in intersection methods.\r\n\r\n### Fixed\r\n\r\n-   fixed a minor bug\r\n-   canvas mouse event listener are now limited to the canvas dom element. UI events will not trigger the canvas listeners anymore\r\n-   canvas mouse events distinguish now between click and drag. Dragging does not reset selection anymore\r\n-   slider input #64\r\n-   rz slider initialization bug\r\n-   increasing test coverage\r\n-   deltas where calculated on map loading even though, they were disabled\r\n\r\n## [1.7.2] - 2018-02-02\r\n\r\n### Fixed\r\n\r\n-   url to homepage\r\n-   analysis package\r\n\r\n## [1.7.1] - 2018-02-02\r\n\r\nFixed release issues\r\n\r\n## [1.7.0] - 2018-02-02\r\n\r\n### Changed\r\n\r\n-   npm pachage scoped to @maibornwolff\r\n-   Defined further scenarios via json file\r\n-   Added description for metrics and scenarios\r\n-   using fixed point values in detail panel (ui) to truncate infinite or long decimals\r\n-   folders now use the mean attributes of their buildings(leaves)\r\n\r\n### Fixed\r\n\r\n-   Bugfix: detail panel should be cleared before setting new details else old values may survive\r\n\r\n## [1.6.7] - 2018-02-01\r\n\r\nFixed release issues\r\n\r\n## [1.6.6] - 2018-02-01\r\n\r\n### Added\r\n\r\n-   added anonymous git log generator anongit\r\n-   browser demo shows codecharta-visualization sonar analysis\r\n\r\n### Changed\r\n\r\n-   rewrote command line interface\r\n-   linking ccsh to bin/ccsh will be deleted later\r\n\r\n### Fixed\r\n\r\n-   No underscore for scenarios in tooltips #71\r\n\r\n## [1.6.5] - 2018-01-30\r\n\r\nFixed release issues\r\n\r\n## [1.6.4] - 2018-01-30\r\n\r\n### Fixed\r\n\r\n-   fixed broken SonarImporter due to jdk9 migration\r\n\r\n## [1.6.3] - 2018-01-26\r\n\r\n### Added\r\n\r\n-   added npm publish for analysis\r\n-   simple release script for automatic changelog updates, commits, tags, version bumps\r\n\r\n## [1.6.2] - 2018-01-25\r\n\r\n### Added\r\n\r\n-   added support for git log --raw and git log --numstat --raw\r\n-   added support for git log --numstat and codechurn\r\n-   added support for renames in SCMLogParser for git log --name-status\r\n-   added support for renames in SCMLogParser for git log --numstat, git log --raw and git log --numstat --raw\r\n-   added new SCM experimental metrics range_of_weeks_with_commits and successive_weeks_of_commits\r\n-   the file origin of a node is displayed in the details now\r\n-   sonarqube analysis on CI build\r\n-   npm publish support in visualization\r\n\r\n### Changed\r\n\r\n-   Deltas are no longer experimental\r\n-   two selected delta maps now merge their nodes correctly. The map where\r\n    a node was missing get\'s a copy of this node with metrics=0.\r\n    File additions/deletions are therefore only visible when areaMetric is\r\n    unary and deltas are activated.\r\n\r\n### Fixed\r\n\r\n-   delta display bug for heights\r\n-   going back from delta view now correctly removes deltas from node data\r\n-   Delta shown although not in delta mode #60\r\n-   Allow inversion of delta colors #57\r\n-   npm binary error\r\n\r\n## [1.5.2] - 2018-01-04\r\n\r\n### Changed\r\n\r\n-   scaling slider now has steps of 0.1. This allows the user to select precise values like 2.0\r\n-   updated jdk to jdk9\r\n\r\n### Fixed\r\n\r\n-   Opening the same file a second time does not work #53\r\n-   added missing require declaration\r\n-   added glsl loader in testing environment\r\n-   Native Application support is bugged while building in Travis CI #48\r\n\r\n## [1.5.1] - 2017-11-14\r\n\r\n### Added\r\n\r\n-   command line parameter to toggle "authors" attribute in SCMLogParser\r\n\r\n### Fixed\r\n\r\n-   when passing a file through the "file" parameter in the URL, the map now renders correctly\r\n\r\n## [1.5.0] - 2017-10-24\r\n\r\n### Added\r\n\r\n-   experimental delta functionality\r\n-   loading multiple maps\r\n-   experimental margin slider\r\n\r\n### Changed\r\n\r\n-   faster rendering\r\n\r\n### Removed\r\n\r\n-   nwjs packages and native apps due to a bug\r\n\r\n### Fixed\r\n\r\n-   using color metric instead of height metric for color range slider ceil\r\n\r\n## [1.4.0] - 2017-09-14\r\n\r\n### Added\r\n\r\n-   Typescript support\r\n-   Browsersync\r\n-   added advanced merging strategy "leaf" in MergeFilter\r\n-   advanced merging with restructuring\r\n\r\n### Changed\r\n\r\n-   Browserify replaced with Webpack\r\n-   Better debugging\r\n-   Karma instead of Mocha\r\n\r\n## [1.3.2] - 2017-08-18\r\n\r\n### Added\r\n\r\n-   add slider controls for color thresholds #19\r\n-   Added additional structuring in SonarImporter for multi-module projects\r\n-   button to generate current url parameters\r\n-   camera position is now a setting (e.g. in scenarios or url parameters)\r\n-   margin slider: make it easier to find out to which package/folder a class belongs #20\r\n\r\n### Changed\r\n\r\n-   better url parameter resolution (nested parameters are handled correctly)\r\n-   changed hover color. Allows better distinction between hover and select\r\n\r\n### Removed\r\n\r\n-   obsolete helper grid\r\n\r\n### Fixed\r\n\r\n-   changing display or color settings resets scaling #18\r\n-   scenario description #32\r\n-   Scaling should not scale the labels #35\r\n\r\n## [1.3.1] - 2017-07-05\r\n\r\n### Fixed\r\n\r\n-   Prevented override of URL-parameters by default scenario\r\n\r\n## [1.3.0] - 2017-07-05\r\n\r\n### Added\r\n\r\n-   Adding simple merge functionality for multiple json files\r\n-   Added CSVImporter\r\n-   Added Translation for SonarQube metrics\r\n-   Added descriptions for metrics\r\n\r\n### Changed\r\n\r\n-   Changed uppercase metrics, e.g. RLOC, to lowercase metrics\r\n\r\n### Fixed\r\n\r\n-   Simple cc.json does not display anything #17\r\n\r\n## [1.2.0] - 2017-06-19\r\n\r\n### Added\r\n\r\n-   Adding Labels and UI\r\n-   Support for links to source page of SonarQube in sonarimporter\r\n-   Added SCMLogParser\r\n\r\n### Fixed\r\n\r\n-   GitHub Issue: legend is wrong #21\r\n\r\n## [1.1.5] - 2017-05-31\r\n\r\n### Fixed\r\n\r\n-   Wrong version numbers in analysis part\r\n\r\n## [1.1.4] - 2017-05-26\r\n\r\n### Added\r\n\r\n-   Scenarios and default scenario\r\n-   Translation API for Metrics\r\n-   Metric tooltips in dropdown\r\n\r\n### Fixed\r\n\r\n-   GitHub Issue: Sonarimporter crashes with null pointer exception when there is a component without path. #13\r\n\r\n## [1.1.3] - 2017-05-01\r\n\r\n### Added\r\n\r\n-   Support for SonarQube Measures-API\r\n-   Error logging for sonarqube errors\r\n\r\n### Changed\r\n\r\n-   Standard Sonar metric is now complexity,ncloc,functions,duplicated_lines,classes,blocker_violations,generated_lines,bugs,commented_out_code_lines,lines,violations,comment_lines,duplicated_blocks\r\n\r\n## [1.1.2] - 2017-04-28\r\n\r\n### Added\r\n\r\n-   Translation API for Metrics\r\n\r\n## [1.1.1] - 2017-04-07\r\n\r\n### Fixed\r\n\r\n-   GitHub Issue: Flickering surfaces #3\r\n-   GitHub Issue: Unable to install due to readlink error on macOS #4\r\n\r\n## [1.1.0] - 2017-03-27\r\n\r\n### Added\r\n\r\n-   SourceMonitorImporter for importing projects from SourceMonitor.\r\n\r\n## [1.0.0] - 2017-03-17\r\n\r\n### Added\r\n\r\n-   SonarImporter for importing projects from SonarQube.\r\n-   ValidationTool for validating an existing json file.\r\n',
								{ headerIds: !1 }
							)
							.split("\n")
						const r = this.findVersionLine(i, this.data.currentVersion),
							o = this.findVersionLine(i, this.data.previousVersion)
						i = i.slice(r, o + 1)
						const s = [
								"Added \u{1f680}",
								"Fixed \u{1f41e}",
								"Changed",
								"Removed \u{1f5d1}",
								"Chore \u{1f468}\u200d\u{1f4bb} \u{1f469}\u200d\u{1f4bb}"
							],
							a = {}
						for (const c of s) {
							const l = new RegExp(`<h3>${c}</h3>`),
								d = this.getAllIndexes(i, l),
								u = []
							for (const h of d) {
								const f = h + 2,
									_ = this.findEndChangesLine(i, h)
								for (const y of i.slice(f, _)) u.push(`${y}<br>`)
							}
							u.length > 0 && (a[c] = u.join("\n"))
						}
						return a
					}
					getAllIndexes(e, i) {
						return e.reduce((r, o, s) => (i.test(o) && r.push(s), r), [])
					}
					findVersionLine(e, i) {
						const r = new RegExp(`\\[${i}]`)
						return e.findIndex(o => r.test(o))
					}
					findEndChangesLine(e, i) {
						return i + e.slice(i + 1).findIndex(r => /<h3>/.test(r) || /<h2>/.test(r))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Bv))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["ng-component"]],
							decls: 15,
							vars: 6,
							consts: [
								["color", "primary"],
								["mat-dialog-content", ""],
								[1, "content"],
								[4, "ngFor", "ngForOf"],
								["mat-dialog-actions", ""],
								[
									"href",
									"https://maibornwolff.github.io/codecharta/news/",
									"target",
									"_blank",
									"rel",
									"noopener noreferrer"
								],
								["mat-button", "", "cdkFocusInitial", "", 3, "mat-dialog-close"],
								[3, "innerHTML"]
							],
							template: function (i, r) {
								1 & i &&
									(F(0, "mat-toolbar", 0),
									ge(1, "Changelog"),
									L(),
									F(2, "div", 1)(3, "h1"),
									ge(4, "What is new in CodeCharta?"),
									L(),
									F(5, "h2"),
									ge(6),
									L(),
									F(7, "div", 2),
									Ee(8, ZQe, 4, 2, "div", 3),
									Me(9, "keyvalue"),
									L()(),
									F(10, "div", 4)(11, "a", 5),
									ge(12, "Know more"),
									L(),
									F(13, "button", 6),
									ge(14, "CLOSE"),
									L()()),
									2 & i &&
										(T(6),
										JA("", r.data.previousVersion, " \u2192 ", r.data.currentVersion, ""),
										T(2),
										U("ngForOf", De(9, 4, r.changes)),
										T(5),
										U("mat-dialog-close", !0))
							},
							dependencies: [_o, Qs, md, Hm, Vm, Mb, wC],
							styles: [
								'.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;inset:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator{position:relative}.mat-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border:var(--mat-focus-indicator-border-width, 3px) var(--mat-focus-indicator-border-style, solid) var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-focus-indicator-display: block}.mat-mdc-focus-indicator{position:relative}.mat-mdc-focus-indicator:before{inset:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-mdc-focus-indicator-display, none);border:var(--mat-mdc-focus-indicator-border-width, 3px) var(--mat-mdc-focus-indicator-border-style, solid) var(--mat-mdc-focus-indicator-border-color, transparent);border-radius:var(--mat-mdc-focus-indicator-border-radius, 4px)}.mat-mdc-focus-indicator:focus:before{content:""}.cdk-high-contrast-active{--mat-mdc-focus-indicator-display: block}:root .mat-mdc-checkbox.mat-accent{--mdc-checkbox-selected-checkmark-color: #fff !important}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-content]{padding:8px 24px 0;margin-top:10px;color:#000}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-content] img[alt$=xs]{height:32px}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-content] img[alt$=s]{height:64px}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-content] img[alt$=m]{height:256px}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-content] img[alt$=l]{height:350px}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-content] img[alt$=xl]{height:512px}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-actions]{justify-content:flex-end}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-actions] a{color:#1b9cfc}.cc-changelog-dialog .mat-mdc-dialog-container [mat-dialog-actions] button{margin:0 8px}\n'
							],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function xee(t) {
				const n = t.split(".")
				return { major: Number.parseInt(n[0]) || 0, minor: Number.parseInt(n[1]) || 0, patch: Number.parseInt(n[2]) || 0 }
			}
			let Cee = (() => {
				class t {
					constructor(e) {
						;(this.dialog = e), (this.version = Iv.i8)
					}
					synchronizeLocalCodeChartaVersion() {
						const e = localStorage.getItem("codeChartaVersion")
						null !== e
							? (function eze(t, n) {
									const e = xee(t),
										i = xee(n)
									return e.major === i.major && e.minor === i.minor && e.patch === i.patch
										? 0
										: e.major > i.major
										? 1
										: e.major < i.major
										? -1
										: e.minor > i.minor
										? 1
										: e.minor < i.minor
										? -1
										: e.patch > i.patch
										? 1
										: e.patch < i.patch
										? -1
										: void 0
							  })(e, this.version) < 0 &&
							  (this.dialog.open(JQe, {
									panelClass: "cc-changelog-dialog",
									data: { previousVersion: e, currentVersion: this.version }
							  }),
							  localStorage.setItem("codeChartaVersion", this.version))
							: localStorage.setItem("codeChartaVersion", this.version)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(re(la))
						}
					}
					static {
						this.ɵprov = mt({ token: t, factory: t.ɵfac })
					}
				}
				return t
			})()
			const X3 = Mt(cc, t => t.focusedNodePath)
			const Eee = [
				W0,
				Au,
				iE,
				rE,
				rv,
				iv,
				Z0,
				Y0,
				q0,
				X0,
				tv,
				j0,
				pk,
				Lm,
				J0,
				ev,
				nv,
				sv,
				Oh,
				sd,
				lv,
				Nh,
				sE,
				aE,
				cv,
				cE,
				bu,
				gu,
				hl,
				ov,
				hE,
				dv,
				fE,
				K0,
				Sp
			]
			let Mee = (() => {
					class t {
						constructor(e, i, r, o, s) {
							;(this.store = e),
								(this.actions$ = i),
								(this.uploadFilesService = r),
								(this.threeRendererService = o),
								(this.codeMapRenderService = s),
								(this.actionsRequiringRender$ = this.actions$.pipe(dl(...Eee))),
								(this.renderCodeMap$ = yo(
									() =>
										xu([this.store.select(Vc), this.actionsRequiringRender$]).pipe(
											xi(([a]) => !!a.unifiedMapNode),
											(function nze(t, n = dg, e) {
												const i = ID(t, n)
												return (function tze(t, n) {
													return Wt((e, i) => {
														const { leading: r = !0, trailing: o = !1 } = n ?? {}
														let s = !1,
															a = null,
															c = null,
															l = !1
														const d = () => {
																c?.unsubscribe(), (c = null), o && (f(), l && i.complete())
															},
															u = () => {
																;(c = null), l && i.complete()
															},
															h = _ => (c = _e(t(_)).subscribe(we(i, d, u))),
															f = () => {
																if (s) {
																	s = !1
																	const _ = a
																	;(a = null), i.next(_), !l && h(_)
																}
															}
														e.subscribe(
															we(
																i,
																_ => {
																	;(s = !0), (a = _), (!c || c.closed) && (r ? f() : h(_))
																},
																() => {
																	;(l = !0), (!(o && s && c) || c.closed) && i.complete()
																}
															)
														)
													})
												})(() => i, e)
											})(16.666666666666668, dg, { leading: !1, trailing: !0 }),
											eo(([a]) => {
												this.codeMapRenderService.render(a.unifiedMapNode),
													this.codeMapRenderService.scaleMap(),
													this.threeRendererService.render()
											}),
											Rl()
										),
									{ dispatch: !1 }
								)),
								(this.removeLoadingIndicatorAfterRender$ = yo(
									() =>
										this.renderCodeMap$.pipe(
											xi(() => !this.uploadFilesService.isUploading),
											eo(() => {
												this.store.dispatch(Dm({ value: !1 })), this.store.dispatch(fg({ value: !1 }))
											})
										),
									{ dispatch: !1 }
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(pu), re(SZ), re(Ri), re(OY))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				rze = (() => {
					class t {
						constructor(e, i, r) {
							;(this.store = e),
								(this.renderCodeMapEffect = i),
								(this.threeOrbitControlsService = r),
								(this.autoFitTo$ = yo(
									() =>
										xu([this.store.select(ld), this.store.select(X3), this.store.select(jZ)]).pipe(
											Mv(1),
											mu(this.store.select(WZ)),
											xi(([, o]) => o),
											ya(() => this.renderCodeMapEffect.renderCodeMap$.pipe(Do(1))),
											eo(() => {
												this.threeOrbitControlsService.autoFitTo()
											})
										),
									{ dispatch: !1 }
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(Mee), re(El))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				oze = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.linkHeightAndColorMetric$ = yo(() =>
									xu([this.store.select(Aw), this.store.select(FN)]).pipe(
										xi(([, i]) => i),
										Ke(([i]) => hl({ value: i }))
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				sze = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				aze = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				cze = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				lze = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, KJ] })
						}
					}
					return t
				})(),
				dze = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi, sze, aze, cze, lze] })
						}
					}
					return t
				})()
			const Y3 = Mt(iee, _b, (t, n) => (t ? n.get(t.nodeId) : null))
			function uze(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "button", 2),
						Le("click", function () {
							return rn(e), on(Te().flattenNode())
						}),
						fe(1, "img", 3),
						ge(2, " FLATTEN\n"),
						L()
				}
			}
			function hze(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "button", 4),
						Le("click", function () {
							return rn(e), on(Te().unFlattenNode())
						}),
						fe(1, "img", 3),
						ge(2, " SHOW\n"),
						L()
				}
			}
			let fze = (() => {
				class t {
					constructor(e) {
						this.store = e
					}
					flattenNode() {
						this.store.dispatch(nD({ item: { path: this.codeMapNode.path, type: "flatten", nodeType: this.codeMapNode.type } }))
					}
					unFlattenNode() {
						this.store.dispatch(uE({ item: { path: this.codeMapNode.path, type: "flatten", nodeType: this.codeMapNode.type } }))
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-flatten-buttons"]],
							inputs: { codeMapNode: "codeMapNode" },
							decls: 2,
							vars: 2,
							consts: [
								[
									"mat-button",
									"",
									"title",
									"Flatten node and children-nodes, but keep an empty space",
									3,
									"click",
									4,
									"ngIf"
								],
								["mat-button", "", "title", "Show node and children-nodes", 3, "click", 4, "ngIf"],
								["mat-button", "", "title", "Flatten node and children-nodes, but keep an empty space", 3, "click"],
								["alt", "flattenIcon", "src", "codeCharta/assets/flatten.png", 1, "png-icon"],
								["mat-button", "", "title", "Show node and children-nodes", 3, "click"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, uze, 3, 0, "button", 0), Ee(1, hze, 3, 0, "button", 1)),
									2 & i &&
										(U("ngIf", !(null != r.codeMapNode && r.codeMapNode.isFlattened)),
										T(1),
										U("ngIf", null == r.codeMapNode ? null : r.codeMapNode.isFlattened))
							},
							dependencies: [En, Qs],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const mze = Mt(X3, t => t[0])
			let pze = (() => {
				class t {
					transform(e, i) {
						if (!e || !i) return { isNodeFocused: !1, isParentFocused: !1 }
						const r = e === i.path
						return { isNodeFocused: r, isParentFocused: !r && i.path.startsWith(e) }
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)()
						}
					}
					static {
						this.ɵpipe = Zi({ name: "isNodeFocused", type: t, pure: !0 })
					}
				}
				return t
			})()
			function Aze(t, n) {
				if (1 & t) {
					const e = ri()
					Cr(0),
						F(1, "button", 1),
						Le("click", function () {
							return rn(e), on(Te(2).handleFocusNodeClicked())
						}),
						fe(2, "i", 2),
						ge(3, " FOCUS "),
						L(),
						Er()
				}
			}
			function gze(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "button", 5),
						Le("click", function () {
							return rn(e), on(Te(3).handleUnfocusAllNodesClicked())
						}),
						fe(1, "i", 2),
						ge(2, " UNFOCUS ALL "),
						L()
				}
			}
			function bze(t, n) {
				if (1 & t) {
					const e = ri()
					Cr(0),
						F(1, "button", 3),
						Le("click", function () {
							return rn(e), on(Te(2).handleUnfocusNodeClicked())
						}),
						fe(2, "i", 2),
						ge(3),
						L(),
						Ee(4, gze, 3, 0, "button", 4),
						Me(5, "async"),
						Er()
				}
				if (2 & t) {
					const e = Te().$implicit,
						i = Te()
					T(3),
						Vt(" ", e.isParentFocused ? "UNFOCUS PARENT" : "UNFOCUS", " "),
						T(1),
						U("ngIf", De(5, 2, i.hasPreviousFocusedNodePath$))
				}
			}
			function _ze(t, n) {
				if ((1 & t && (Cr(0), Ee(1, Aze, 4, 0, "ng-container", 0), Ee(2, bze, 6, 4, "ng-container", 0), Er()), 2 & t)) {
					const e = n.$implicit
					T(1), U("ngIf", !e.isNodeFocused), T(1), U("ngIf", e.isNodeFocused || e.isParentFocused)
				}
			}
			let vze = (() => {
				class t {
					constructor(e) {
						;(this.store = e),
							(this.currentFocusedNodePath$ = this.store.select(mze)),
							(this.hasPreviousFocusedNodePath$ = this.store.select(X3).pipe(Ke(i => i.length > 1)))
					}
					handleFocusNodeClicked() {
						this.store.dispatch(aE({ value: this.codeMapNode.path }))
					}
					handleUnfocusNodeClicked() {
						this.store.dispatch(cE())
					}
					handleUnfocusAllNodesClicked() {
						this.store.dispatch(cv())
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Ct))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-focus-buttons"]],
							inputs: { codeMapNode: "codeMapNode" },
							decls: 3,
							vars: 6,
							consts: [
								[4, "ngIf"],
								[
									"mat-button",
									"",
									"id",
									"focus-button",
									"title",
									"Only show selected nodes with children-nodes",
									3,
									"click"
								],
								[1, "fa", "fa-bullseye"],
								[
									"mat-button",
									"",
									"aria-label",
									"Remove Focus from node",
									"title",
									"Show previous focused node",
									3,
									"click"
								],
								[
									"mat-button",
									"",
									"aria-label",
									"Remove Focus from all nodes",
									"title",
									"Show complete map",
									3,
									"click",
									4,
									"ngIf"
								],
								["mat-button", "", "aria-label", "Remove Focus from all nodes", "title", "Show complete map", 3, "click"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, _ze, 3, 2, "ng-container", 0), Me(1, "isNodeFocused"), Me(2, "async")),
									2 & i && U("ngIf", lo(1, 1, De(2, 4, r.currentFocusedNodePath$), r.codeMapNode))
							},
							dependencies: [En, Qs, Bn, pze],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			function yze(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "button", 2),
						Le("click", function () {
							return rn(e), on(Te().addNodeToConstantHighlight())
						}),
						fe(1, "i", 3),
						ge(2, " KEEP HIGHLIGHT\n"),
						L()
				}
			}
			function wze(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "button", 4),
						Le("click", function () {
							return rn(e), on(Te().removeNodeFromConstantHighlight())
						}),
						fe(1, "i", 3),
						ge(2, " REMOVE HIGHLIGHT\n"),
						L()
				}
			}
			let xze = (() => {
				class t {
					constructor(e, i) {
						;(this.threeSceneService = e), (this.idToBuilding = i)
					}
					ngOnChanges(e) {
						e.codeMapNode && (this.isHighlighted = this.calculateIsHighlighted())
					}
					addNodeToConstantHighlight() {
						this.threeSceneService.addNodeAndChildrenToConstantHighlight(this.codeMapNode)
					}
					removeNodeFromConstantHighlight() {
						this.threeSceneService.removeNodeAndChildrenFromConstantHighlight(this.codeMapNode)
					}
					calculateIsHighlighted() {
						if (!this.codeMapNode) return !1
						const e = this.idToBuilding.get(this.codeMapNode.id)
						return !!e && this.threeSceneService.getConstantHighlight().has(e.id)
					}
					static {
						this.ɵfac = function (i) {
							return new (i || t)(P(Qc), P(lw))
						}
					}
					static {
						this.ɵcmp = Ye({
							type: t,
							selectors: [["cc-highlight-buttons"]],
							inputs: { codeMapNode: "codeMapNode" },
							features: [Ar],
							decls: 2,
							vars: 2,
							consts: [
								["mat-button", "", "title", "Highlight node constantly", 3, "click", 4, "ngIf"],
								["mat-button", "", "title", "Remove constant highlight", 3, "click", 4, "ngIf"],
								["mat-button", "", "title", "Highlight node constantly", 3, "click"],
								[1, "fa", "fa-cubes"],
								["mat-button", "", "title", "Remove constant highlight", 3, "click"]
							],
							template: function (i, r) {
								1 & i && (Ee(0, yze, 3, 0, "button", 0), Ee(1, wze, 3, 0, "button", 1)),
									2 & i && (U("ngIf", !r.isHighlighted), T(1), U("ngIf", r.isHighlighted))
							},
							dependencies: [En, Qs],
							encapsulation: 2
						})
					}
				}
				return t
			})()
			const Cze = Mt(vb, t => t.markingColors),
				Eze = Mt(Y3, Cze, xX, (t, n, e) => {
					if (null === t) return n.map(r => ({ color: r, isMarked: !1 }))
					const i = tq(e, t.path)
					return n.map(r => ({ color: r, isMarked: -1 !== i && r === e[i].color }))
				})
			function Mze(t, n) {
				1 & t && fe(0, "i", 7)
			}
			function Sze(t, n) {
				if (1 & t) {
					const e = ri()
					Cr(0),
						F(1, "button", 5),
						Le("click", function () {
							const o = rn(e).$implicit,
								s = Te().ngIf,
								a = Te()
							return on(o.isMarked ? a.unmarkFolder(s.path) : a.markFolder(s.path, o.color))
						}),
						Ee(2, Mze, 1, 0, "i", 6),
						L(),
						Er()
				}
				if (2 & t) {
					const e = n.$implicit
					T(1), bi("background-color", e.color), T(1), U("ngIf", e.isMarked)
				}
			}
			function kze(t, n) {
				if (1 & t) {
					const e = ri()
					F(0, "div", 2),
						Ee(1, Sze, 3, 3, "ng-container", 3),
						Me(2, "async"),
						F(3, "cc-color-picker", 4),
						Le("onColorChange", function (r) {
							const s = rn(e).ngIf
							return on(Te().markFolder(s.path, r))
						}),
						L()()
				}
				if (2 & t) {
					const e = Te(),
						i = br(3)
					T(1), U("ngForOf", De(2, 3, e.markFolderItems$)), T(2), U("hexColor", "#ff0000")("triggerTemplate", i)
				}
			}
			function Tze(t, n) {
				1 & t && fe(0, "div", 8)
			}
			let Fze = (() => {
					class t {
						constructor(e) {
							;(this.store = e), (this.markFolderItems$ = this.store.select(Eze)), (this.codeMapNode$ = this.store.select(Y3))
						}
						markFolder(e, i) {
							this.store.dispatch(dv({ packages: [{ path: e, color: i }] }))
						}
						unmarkFolder(e) {
							this.store.dispatch(fE({ path: e }))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-mark-folder-row"]],
								decls: 4,
								vars: 3,
								consts: [
									["class", "row", 4, "ngIf"],
									["colorPickerTriggerTemplate", ""],
									[1, "row"],
									[4, "ngFor", "ngForOf"],
									[3, "hexColor", "triggerTemplate", "onColorChange"],
									["title", "Colorize folder", 1, "colorButton", 3, "click"],
									["class", "fa fa-times", 4, "ngIf"],
									[1, "fa", "fa-times"],
									[1, "cc-color-picker-trigger", "fa", "fa-paint-brush"]
								],
								template: function (i, r) {
									1 & i && (Ee(0, kze, 4, 5, "div", 0), Me(1, "async"), Ee(2, Tze, 1, 0, "ng-template", null, 1, oa)),
										2 & i && U("ngIf", De(1, 1, r.codeMapNode$))
								},
								dependencies: [_o, En, HX, Bn],
								styles: [
									"cc-mark-folder-row .row{display:flex}cc-mark-folder-row :hover{cursor:pointer}cc-mark-folder-row .colorButton{width:32px;height:32px}cc-mark-folder-row .colorButton i{font-size:25px;display:block;color:red;text-shadow:-1px 0 white,0 1px white,1px 0 white,0 -1px white}cc-mark-folder-row cc-color-picker{width:32px;height:32px}cc-mark-folder-row cc-color-picker .cc-color-picker-trigger{font-size:25px;margin-top:8px}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				Bze = (() => {
					class t {
						constructor(e) {
							this.store = e
						}
						excludeNode() {
							this.store.dispatch(
								iD({ items: [{ path: this.codeMapNode.path, type: "exclude", nodeType: this.codeMapNode.type }] })
							)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["cc-exclude-button"]],
								inputs: { codeMapNode: "codeMapNode" },
								decls: 3,
								vars: 0,
								consts: [
									[
										"mat-button",
										"",
										"id",
										"exclude-button",
										"title",
										"Exclude node and children-nodes and reorder the CodeMap",
										3,
										"click"
									],
									[1, "fa", "fa-ban"]
								],
								template: function (i, r) {
									1 & i &&
										(F(0, "button", 0),
										Le("click", function () {
											return r.excludeNode()
										}),
										fe(1, "i", 1),
										ge(2, " EXCLUDE\n"),
										L())
								},
								dependencies: [Qs],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				Ize = (() => {
					class t {
						transform(e) {
							return `${0 === e.lastIndexOf("/") ? "" : "..."}${e.slice(e.lastIndexOf("/"))}`
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵpipe = Zi({ name: "lastPartOfNodePath", type: t, pure: !0 })
						}
					}
					return t
				})()
			function Dze(t, n) {
				1 & t && (F(0, "div"), fe(1, "cc-mark-folder-row")(2, "mat-divider"), L())
			}
			function Lze(t, n) {
				if (
					(1 & t &&
						(F(0, "mat-card", 1),
						Ee(1, Dze, 3, 0, "div", 2),
						F(2, "div", 3)(3, "button", 4),
						ge(4),
						Me(5, "lastPartOfNodePath"),
						L(),
						fe(6, "cc-focus-buttons", 5)(7, "cc-flatten-buttons", 5)(8, "cc-highlight-buttons", 5)(9, "cc-exclude-button", 5),
						L()()),
					2 & t)
				) {
					const e = n.$implicit
					T(1),
						U("ngIf", (null == e || null == e.children ? null : e.children.length) > 0),
						T(2),
						Fa("title", e.path),
						T(1),
						Vt(" ", De(5, 7, e.path), " "),
						T(2),
						U("codeMapNode", e),
						T(1),
						U("codeMapNode", e),
						T(1),
						U("codeMapNode", e),
						T(1),
						U("codeMapNode", e)
				}
			}
			let Rze = (() => {
					class t {
						constructor(e) {
							this.store = e
						}
						ngOnInit() {
							this.codeMapNode$ = this.store.select(Y3)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(P(Ct))
							}
						}
						static {
							this.ɵcmp = Ye({
								type: t,
								selectors: [["ng-component"]],
								decls: 2,
								vars: 3,
								consts: [
									["appearance", "outlined", "id", "codemap-context-menu", 4, "ngIf"],
									["appearance", "outlined", "id", "codemap-context-menu"],
									[4, "ngIf"],
									[1, "button-group"],
									["mat-button", "", "disabled", "true", 3, "title"],
									[3, "codeMapNode"]
								],
								template: function (i, r) {
									1 & i && (Ee(0, Lze, 10, 9, "mat-card", 0), Me(1, "async")),
										2 & i && U("ngIf", De(1, 1, r.codeMapNode$))
								},
								dependencies: [En, Qs, SO, rk, fze, vze, xze, Fze, Bze, Bn, Ize],
								styles: [
									"#codemap-context-menu{padding:12px}#codemap-context-menu .button-group{display:flex;flex-direction:column;gap:6px;width:100%}#codemap-context-menu .png-icon{width:17px;height:17px;margin:5px auto auto;padding:0;display:inline-block;background-repeat:no-repeat no-repeat;pointer-events:none}#codemap-context-menu [mat-button]{width:100%;text-align:left;margin:0;justify-content:left;line-height:30px;min-height:30px}#codemap-context-menu [mat-button] i{min-width:15px}\n"
								],
								encapsulation: 2
							})
						}
					}
					return t
				})(),
				Pze = (() => {
					class t {
						constructor(e, i) {
							;(this.overlay = e),
								(this.store = i),
								(this.overlayReference = null),
								(this.close = () => {
									document.removeEventListener("click", this.onLeftClickHideNodeContextMenu, !0),
										document.removeEventListener("mousedown", this.onRightClickHideNodeContextMenu, !0),
										document.getElementById("codeMap").removeEventListener("wheel", this.close, !0),
										this.store.dispatch(xb(null)),
										this.overlayReference && this.resetOverlay()
								}),
								(this.onLeftClickHideNodeContextMenu = r => {
									this.isEventFromColorPicker(r) || this.close()
								}),
								(this.onRightClickHideNodeContextMenu = r => {
									2 === r.button && this.close()
								})
						}
						open(e, i) {
							this.overlayReference && this.resetOverlay()
							const r = this.overlay
								.position()
								.flexibleConnectedTo({ x: e, y: i })
								.withPositions([{ originX: "end", originY: "bottom", overlayX: "start", overlayY: "top" }])
							;(this.overlayReference = this.overlay.create({
								positionStrategy: r,
								scrollStrategy: this.overlay.scrollStrategies.close()
							})),
								this.overlayReference.attach(new vv(Rze)),
								this.overlayReference.overlayElement.addEventListener("contextmenu", o => {
									o.preventDefault()
								}),
								document.addEventListener("click", this.onLeftClickHideNodeContextMenu, !1),
								document.addEventListener("mousedown", this.onRightClickHideNodeContextMenu, !0),
								document.getElementById("codeMap").addEventListener("wheel", this.close, !0)
						}
						resetOverlay() {
							this.overlayReference.dispose(), (this.overlayReference = null)
						}
						isEventFromColorPicker(e) {
							return e.composedPath().some(r => "CC-COLOR-PICKER" === r?.nodeName || "COLOR-CHROME" === r?.nodeName)
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(ec), re(Ct))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac, providedIn: "root" })
						}
					}
					return t
				})(),
				Oze = (() => {
					class t {
						constructor(e, i) {
							;(this.actions$ = e),
								(this.nodeContextMenu = i),
								(this.openNodeContextMenu$ = yo(
									() =>
										this.actions$.pipe(
											dl(xb),
											eo(r => {
												r.value &&
													this.nodeContextMenu.open(
														r.value.xPositionOfRightClickEvent,
														r.value.yPositionOfRightClickEvent
													)
											})
										),
									{ dispatch: !1 }
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(pu), re(Pze))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				Nze = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.resetSelectedEdgeMetricWhenItDoesntExistAnymore$ = yo(() =>
									this.store.select(Fs).pipe(
										mu(this.store.select(zu)),
										xi(([i, r]) => !i.edgeMetricData.some(o => o.name === r)),
										Ke(([i]) => i.edgeMetricData[0]?.name),
										Ys(),
										Ke(i => Oh({ value: i }))
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})()
			const Vze = [
				[hE, dv, fE, rD, G6, $6, JI, eD, ZI, tD, nD, dE, uE],
				[
					W0,
					rv,
					iv,
					KY,
					$O,
					qY,
					dN,
					Au,
					iE,
					rE,
					oE,
					ov,
					XI,
					tE,
					Z0,
					q0,
					Y0,
					X0,
					tv,
					j0,
					pk,
					Lm,
					nE,
					eE,
					JC,
					J0,
					ev,
					nv,
					YI,
					qI,
					K0
				],
				[sv, lE, Oh, sd, lv, Nh, pv, sE, cv, aE, cE, bu, av, hl, gu],
				[...EE]
			].flat()
			let Qze = (() => {
					class t {
						constructor(e, i) {
							var r = this
							;(this.actions$ = e),
								(this.state = i),
								(this.saveCcState$ = yo(
									() =>
										this.actions$.pipe(
											xi(o => o.type !== wb.type),
											dl(...Vze),
											ug(500),
											eo(
												_r(function* () {
													const o = r.state.getValue()
													yield (function ame(t) {
														return mD.apply(this, arguments)
													})(o)
												})
											)
										),
									{ dispatch: !1 }
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(pu), re(Sr))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				zze = (() => {
					class t {
						constructor(e) {
							;(this.actions$ = e),
								(this.setIsLoadingFile$ = yo(() =>
									this.actions$.pipe(
										dl(...EE),
										Ke(() => Dm({ value: !0 }))
									)
								)),
								(this.setIsLoadingMap$ = yo(() =>
									this.actions$.pipe(
										dl(...Eee),
										Ke(() => fg({ value: !0 }))
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(pu))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				Gze = (() => {
					class t {
						constructor(e) {
							;(this.store = e), (this.unfocusNodes$ = yo(() => this.store.select(ld).pipe(Ke(() => cv()))))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				$ze = (() => {
					class t {
						constructor(e) {
							;(this.store = e),
								(this.resetIsEdgeMetricVisible$ = yo(() =>
									this.store.select(zu).pipe(
										mu(this.store.select(s3)),
										xi(([, i]) => !i),
										Ke(() => tE())
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})()
			function Wze(t, n) {
				const e = new Map()
				if (1 === t.length) return t[0].settings.fileSettings.edges
				for (const i of t)
					if (i.settings.fileSettings.edges)
						for (const r of i.settings.fileSettings.edges) {
							const o = {
									fromNodeName: n ? cw(i.fileMeta.fileName, r.fromNodeName) : r.fromNodeName,
									toNodeName: n ? cw(i.fileMeta.fileName, r.toNodeName) : r.toNodeName,
									attributes: dd(r.attributes),
									visible: r.visible
								},
								s = e.get(`${o.fromNodeName}|${o.toNodeName}`)
							if (void 0 !== s) for (const a of Object.keys(o.attributes)) s.attributes[a] = o.attributes[a]
							else e.set(`${o.fromNodeName}|${o.toNodeName}`, o)
						}
				return [...e.values()]
			}
			function jze(t, n) {
				if (1 === t.length) return t[0].settings.fileSettings.markedPackages
				const e = new Map()
				for (const i of t)
					if (i.settings.fileSettings.markedPackages)
						for (const r of i.settings.fileSettings.markedPackages) {
							const o = { path: n ? GK(i.fileMeta.fileName, r.path) : r.path, color: r.color }
							e.set(`${o.path}|${o.color}`, o)
						}
				return [...e.values()]
			}
			function Kze(t, n) {
				const e = new Map()
				if (1 === t.length) return t[0].settings.fileSettings.blacklist
				for (const i of t)
					if (i.settings.fileSettings.blacklist)
						for (const r of i.settings.fileSettings.blacklist) {
							const o = { path: n ? GK(i.fileMeta.fileName, r.path) : r.path, type: r.type }
							e.set(`${o.path}|${o.type}`, o)
						}
				return [...e.values()]
			}
			function Xze(t) {
				const n = {},
					e = {}
				for (const i of t) {
					for (const r of Object.keys(i.nodes)) n[r] || (n[r] = i.nodes[r])
					for (const r of Object.keys(i.edges)) e[r] || (e[r] = i.edges[r])
				}
				return { nodes: n, edges: e }
			}
			function Yze(t) {
				const n = {}
				for (const e of t) for (const i of Object.keys(e)) n[i] || (n[i] = e[i])
				return n
			}
			let qze = (() => {
					class t {
						constructor(e, i) {
							;(this.actions$ = e),
								(this.state = i),
								(this.updateFileSettings$ = yo(() =>
									this.actions$.pipe(
										dl(...EE),
										Ke(() => {
											const r = this.state.getValue(),
												o = (function fme(t) {
													return yD(t).map(n => n.file)
												})(r.files),
												s = rG(r.files),
												a = ld(r).map(({ file: l }) => l.settings.fileSettings.attributeTypes),
												c = ld(r).map(({ file: l }) => l.settings.fileSettings.attributeDescriptors)
											return Sp({
												value: {
													fileSettings: {
														edges: Wze(o, s),
														markedPackages: jze(o, s),
														blacklist: Kze(o, s),
														attributeTypes: Xze(a),
														attributeDescriptors: Yze(c)
													}
												}
											})
										})
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(pu), re(Sr))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				Zze = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e),
								(this.state = i),
								(this.updateMapColors$ = yo(() =>
									this.store.select(Af).pipe(
										Ke(r => {
											const o = this.state.getValue()
											if (1 === o.fileSettings.attributeDescriptors[r]?.direction) {
												const a = JSON.parse(ul(o.appSettings.mapColors)),
													c = a.negative
												return (a.negative = a.positive), (a.positive = c), Au({ value: a })
											}
											return Au({ value: Vu })
										})
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(Sr))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				Jze = (() => {
					class t {
						constructor(e, i) {
							;(this.store = e),
								(this.state = i),
								(this.updateVisibleTopLabels$ = yo(() =>
									this.store.select(ld).pipe(
										VZ(),
										mu(this.store.select(VO)),
										Ke(([[r, o], s]) => {
											const c = ul(r) === ul(o) ? this.state.getValue().appSettings.amountOfTopLabels : jY(s)
											return Lm({ value: c })
										})
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(Ct), re(Sr))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				e8e = (() => {
					class t {
						constructor(e, i) {
							;(this.actions$ = e),
								(this.store = i),
								(this.resetColorRange$ = yo(() =>
									this.actions$.pipe(
										dl(...EE),
										ya(() => this.store.select(gf).pipe(Mv(1), Do(1))),
										Ke(r => sd({ value: BN(r) }))
									)
								)),
								(this.resetColorRangeOnColorMetricChange$ = yo(() =>
									this.actions$.pipe(
										dl(hl),
										ya(() => this.store.select(gf).pipe(Do(1))),
										Ke(r => sd({ value: BN(r) }))
									)
								))
						}
						static {
							this.ɵfac = function (i) {
								return new (i || t)(re(pu), re(Ct))
							}
						}
						static {
							this.ɵprov = mt({ token: t, factory: t.ɵfac })
						}
					}
					return t
				})(),
				t8e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t })
						}
						static {
							this.ɵinj = rt({ imports: [Ot, Qi] })
						}
					}
					return t
				})(),
				n8e = (() => {
					class t {
						static {
							this.ɵfac = function (i) {
								return new (i || t)()
							}
						}
						static {
							this.ɵmod = at({ type: t, bootstrap: [AUe] })
						}
						static {
							this.ɵinj = rt({
								providers: [
									Cee,
									{ provide: YV, useFactory: e => () => e.synchronizeLocalCodeChartaVersion(), deps: [Cee], multi: !0 }
								],
								imports: [
									bz,
									Wde,
									wfe.forRoot(kIe, { metaReducers: [TIe] }),
									Gfe.forRoot([Gze, JJ, Oze, G5e, e8e, v3e, $ze, Mee, rze, Jze, oze, Nze, qze, zze, Qze, npe, Zze]),
									Qi,
									od,
									N0,
									t8e,
									DQe,
									dze
								]
							})
						}
					}
					return t
				})()
			typeof window < "u" && !window.__TEST_ENVIRONMENT__ && mde().bootstrapModule(n8e)
		},
		3233: (ct, ft, A) => {
			"use strict"
			var X = A(2786),
				q = A(2266),
				m = A(2040),
				de = A(1382),
				Q = A(4236),
				D = A(9604),
				$ = A(5051),
				R = A(3439),
				V = A(6518)
			;(ct.exports = Y),
				(Y.prototype.validate = function pe(we, gt) {
					var Ke
					if ("string" == typeof we) {
						if (!(Ke = this.getSchema(we))) throw new Error('no schema with key or ref "' + we + '"')
					} else {
						var fn = this._addSchema(we)
						Ke = fn.validate || this._compile(fn)
					}
					var St = Ke(gt)
					return !0 !== Ke.$async && (this.errors = Ke.errors), St
				}),
				(Y.prototype.compile = function Ne(we, gt) {
					var Ke = this._addSchema(we, void 0, gt)
					return Ke.validate || this._compile(Ke)
				}),
				(Y.prototype.addSchema = function ye(we, gt, Ke, fn) {
					if (Array.isArray(we)) {
						for (var St = 0; St < we.length; St++) this.addSchema(we[St], void 0, Ke, fn)
						return this
					}
					var Dt = this._getId(we)
					if (void 0 !== Dt && "string" != typeof Dt) throw new Error("schema id must be string")
					return vt(this, (gt = q.normalizeId(gt || Dt))), (this._schemas[gt] = this._addSchema(we, Ke, fn, !0)), this
				}),
				(Y.prototype.addMetaSchema = function Qe(we, gt, Ke) {
					return this.addSchema(we, gt, Ke, !0), this
				}),
				(Y.prototype.validateSchema = function Je(we, gt) {
					var Ke = we.$schema
					if (void 0 !== Ke && "string" != typeof Ke) throw new Error("$schema must be a string")
					if (
						!(Ke =
							Ke ||
							this._opts.defaultMeta ||
							(function Ce(we) {
								var gt = we._opts.meta
								return (
									(we._opts.defaultMeta = "object" == typeof gt ? we._getId(gt) || gt : we.getSchema(I) ? I : void 0),
									we._opts.defaultMeta
								)
							})(this))
					)
						return this.logger.warn("meta-schema not available"), (this.errors = null), !0
					var fn = this.validate(Ke, we)
					if (!fn && gt) {
						var St = "schema is invalid: " + this.errorsText()
						if ("log" != this._opts.validateSchema) throw new Error(St)
						this.logger.error(St)
					}
					return fn
				}),
				(Y.prototype.getSchema = function We(we) {
					var gt = Ue(this, we)
					switch (typeof gt) {
						case "object":
							return gt.validate || this._compile(gt)
						case "string":
							return this.getSchema(gt)
						case "undefined":
							return (function it(we, gt) {
								var Ke = q.schema.call(we, { schema: {} }, gt)
								if (Ke) {
									var fn = Ke.schema,
										St = Ke.root,
										Dt = Ke.baseId,
										gn = X.call(we, fn, St, void 0, Dt)
									return (
										(we._fragments[gt] = new de({
											ref: gt,
											fragment: !0,
											schema: fn,
											root: St,
											baseId: Dt,
											validate: gn
										})),
										gn
									)
								}
							})(this, we)
					}
				}),
				(Y.prototype.removeSchema = function st(we) {
					if (we instanceof RegExp) return et(this, this._schemas, we), et(this, this._refs, we), this
					switch (typeof we) {
						case "undefined":
							return et(this, this._schemas), et(this, this._refs), this._cache.clear(), this
						case "string":
							var gt = Ue(this, we)
							return gt && this._cache.del(gt.cacheKey), delete this._schemas[we], delete this._refs[we], this
						case "object":
							var Ke = this._opts.serialize,
								fn = Ke ? Ke(we) : we
							this._cache.del(fn)
							var St = this._getId(we)
							St && ((St = q.normalizeId(St)), delete this._schemas[St], delete this._refs[St])
					}
					return this
				}),
				(Y.prototype.addFormat = function Ge(we, gt) {
					return "string" == typeof gt && (gt = new RegExp(gt)), (this._formats[we] = gt), this
				}),
				(Y.prototype.errorsText = function qe(we, gt) {
					if (!(we = we || this.errors)) return "No errors"
					for (
						var Ke = void 0 === (gt = gt || {}).separator ? ", " : gt.separator,
							fn = void 0 === gt.dataVar ? "data" : gt.dataVar,
							St = "",
							Dt = 0;
						Dt < we.length;
						Dt++
					) {
						var gn = we[Dt]
						gn && (St += fn + gn.dataPath + " " + gn.message + Ke)
					}
					return St.slice(0, -Ke.length)
				}),
				(Y.prototype._addSchema = function ke(we, gt, Ke, fn) {
					if ("object" != typeof we && "boolean" != typeof we) throw new Error("schema should be object or boolean")
					var St = this._opts.serialize,
						Dt = St ? St(we) : we,
						gn = this._cache.get(Dt)
					if (gn) return gn
					fn = fn || !1 !== this._opts.addUsedSchema
					var ci = q.normalizeId(this._getId(we))
					ci && fn && vt(this, ci)
					var nr,
						Ci = !1 !== this._opts.validateSchema && !gt
					Ci && !(nr = ci && ci == q.normalizeId(we.$schema)) && this.validateSchema(we, !0)
					var hr = q.ids.call(this, we),
						Qn = new de({ id: ci, schema: we, localRefs: hr, cacheKey: Dt, meta: Ke })
					return "#" != ci[0] && fn && (this._refs[ci] = Qn), this._cache.put(Dt, Qn), Ci && nr && this.validateSchema(we, !0), Qn
				}),
				(Y.prototype._compile = function he(we, gt) {
					if (we.compiling)
						return (
							(we.validate = St),
							(St.schema = we.schema),
							(St.errors = null),
							(St.root = gt || St),
							!0 === we.schema.$async && (St.$async = !0),
							St
						)
					var Ke, fn
					;(we.compiling = !0), we.meta && ((Ke = this._opts), (this._opts = this._metaOpts))
					try {
						fn = X.call(this, we.schema, gt, we.localRefs)
					} catch (Dt) {
						throw (delete we.validate, Dt)
					} finally {
						;(we.compiling = !1), we.meta && (this._opts = Ke)
					}
					return (we.validate = fn), (we.refs = fn.refs), (we.refVal = fn.refVal), (we.root = fn.root), fn
					function St() {
						var Dt = we.validate,
							gn = Dt.apply(this, arguments)
						return (St.errors = Dt.errors), gn
					}
				}),
				(Y.prototype.compileAsync = A(2918))
			var B = A(246)
			;(Y.prototype.addKeyword = B.add),
				(Y.prototype.getKeyword = B.get),
				(Y.prototype.removeKeyword = B.remove),
				(Y.prototype.validateKeyword = B.validate)
			var H = A(9021)
			;(Y.ValidationError = H.Validation), (Y.MissingRefError = H.MissingRef), (Y.$dataMetaSchema = R)
			var I = "http://json-schema.org/draft-07/schema",
				G = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"],
				J = ["/properties"]
			function Y(we) {
				if (!(this instanceof Y)) return new Y(we)
				;(we = this._opts = V.copy(we) || {}),
					(function yi(we) {
						var gt = we._opts.logger
						if (!1 === gt) we.logger = { log: Wt, warn: Wt, error: Wt }
						else {
							if ((void 0 === gt && (gt = console), !("object" == typeof gt && gt.log && gt.warn && gt.error)))
								throw new Error("logger must implement log, warn and error methods")
							we.logger = gt
						}
					})(this),
					(this._schemas = {}),
					(this._refs = {}),
					(this._fragments = {}),
					(this._formats = D(we.format)),
					(this._cache = we.cache || new m()),
					(this._loadingSchemas = {}),
					(this._compilations = []),
					(this.RULES = $()),
					(this._getId = (function Ve(we) {
						switch (we.schemaId) {
							case "auto":
								return ze
							case "id":
								return je
							default:
								return Re
						}
					})(we)),
					(we.loopRequired = we.loopRequired || 1 / 0),
					"property" == we.errorDataPath && (we._errorDataPathProperty = !0),
					void 0 === we.serialize && (we.serialize = Q),
					(this._metaOpts = (function hi(we) {
						for (var gt = V.copy(we._opts), Ke = 0; Ke < G.length; Ke++) delete gt[G[Ke]]
						return gt
					})(this)),
					we.formats &&
						(function yn(we) {
							for (var gt in we._opts.formats) we.addFormat(gt, we._opts.formats[gt])
						})(this),
					we.keywords &&
						(function ai(we) {
							for (var gt in we._opts.keywords) we.addKeyword(gt, we._opts.keywords[gt])
						})(this),
					(function wt(we) {
						var gt
						if ((we._opts.$data && ((gt = A(894)), we.addMetaSchema(gt, gt.$id, !0)), !1 !== we._opts.meta)) {
							var Ke = A(6680)
							we._opts.$data && (Ke = R(Ke, J)), we.addMetaSchema(Ke, I, !0), (we._refs["http://json-schema.org/schema"] = I)
						}
					})(this),
					"object" == typeof we.meta && this.addMetaSchema(we.meta),
					we.nullable && this.addKeyword("nullable", { metaSchema: { type: "boolean" } }),
					(function Jt(we) {
						var gt = we._opts.schemas
						if (gt)
							if (Array.isArray(gt)) we.addSchema(gt)
							else for (var Ke in gt) we.addSchema(gt[Ke], Ke)
					})(this)
			}
			function Ue(we, gt) {
				return (gt = q.normalizeId(gt)), we._schemas[gt] || we._refs[gt] || we._fragments[gt]
			}
			function et(we, gt, Ke) {
				for (var fn in gt) {
					var St = gt[fn]
					!St.meta && (!Ke || Ke.test(fn)) && (we._cache.del(St.cacheKey), delete gt[fn])
				}
			}
			function je(we) {
				return we.$id && this.logger.warn("schema $id ignored", we.$id), we.id
			}
			function Re(we) {
				return we.id && this.logger.warn("schema id ignored", we.id), we.$id
			}
			function ze(we) {
				if (we.$id && we.id && we.$id != we.id) throw new Error("schema $id is different from id")
				return we.$id || we.id
			}
			function vt(we, gt) {
				if (we._schemas[gt] || we._refs[gt]) throw new Error('schema with key or id "' + gt + '" already exists')
			}
			function Wt() {}
		},
		2040: ct => {
			"use strict"
			var ft = (ct.exports = function () {
				this._cache = {}
			})
			;(ft.prototype.put = function (X, q) {
				this._cache[X] = q
			}),
				(ft.prototype.get = function (X) {
					return this._cache[X]
				}),
				(ft.prototype.del = function (X) {
					delete this._cache[X]
				}),
				(ft.prototype.clear = function () {
					this._cache = {}
				})
		},
		2918: (ct, ft, A) => {
			"use strict"
			var X = A(9021).MissingRef
			ct.exports = function q(m, de, Q) {
				var D = this
				if ("function" != typeof this._opts.loadSchema) throw new Error("options.loadSchema should be a function")
				"function" == typeof de && ((Q = de), (de = void 0))
				var $ = R(m).then(function () {
					var B = D._addSchema(m, void 0, de)
					return B.validate || V(B)
				})
				return (
					Q &&
						$.then(function (B) {
							Q(null, B)
						}, Q),
					$
				)
				function R(B) {
					var H = B.$schema
					return H && !D.getSchema(H) ? q.call(D, { $ref: H }, !0) : Promise.resolve()
				}
				function V(B) {
					try {
						return D._compile(B)
					} catch (I) {
						if (I instanceof X)
							return (function H(I) {
								var G = I.missingSchema
								if (pe(G)) throw new Error("Schema " + G + " is loaded but " + I.missingRef + " cannot be resolved")
								var J = D._loadingSchemas[G]
								return (
									J || (J = D._loadingSchemas[G] = D._opts.loadSchema(G)).then(Y, Y),
									J.then(function (Ne) {
										if (!pe(G))
											return R(Ne).then(function () {
												pe(G) || D.addSchema(Ne, G, void 0, de)
											})
									}).then(function () {
										return V(B)
									})
								)
								function Y() {
									delete D._loadingSchemas[G]
								}
								function pe(Ne) {
									return D._refs[Ne] || D._schemas[Ne]
								}
							})(I)
						throw I
					}
				}
			}
		},
		9021: (ct, ft, A) => {
			"use strict"
			var X = A(2266)
			function m(Q, D, $) {
				;(this.message = $ || m.message(Q, D)),
					(this.missingRef = X.url(Q, D)),
					(this.missingSchema = X.normalizeId(X.fullPath(this.missingRef)))
			}
			function de(Q) {
				return (Q.prototype = Object.create(Error.prototype)), (Q.prototype.constructor = Q), Q
			}
			;(ct.exports = {
				Validation: de(function q(Q) {
					;(this.message = "validation failed"), (this.errors = Q), (this.ajv = this.validation = !0)
				}),
				MissingRef: de(m)
			}),
				(m.message = function (Q, D) {
					return "can't resolve reference " + D + " from id " + Q
				})
		},
		9604: (ct, ft, A) => {
			"use strict"
			var X = A(6518),
				q = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
				m = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
				de = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,
				Q = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
				D =
					/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
				R =
					/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
				V =
					/^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,
				B = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
				H = /^(?:\/(?:[^~/]|~0|~1)*)*$/,
				I = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
				G = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/
			function J(Ue) {
				return X.copy(J[(Ue = "full" == Ue ? "full" : "fast")])
			}
			function pe(Ue) {
				var st = Ue.match(q)
				if (!st) return !1
				var ke = +st[2],
					he = +st[3]
				return (
					ke >= 1 &&
					ke <= 12 &&
					he >= 1 &&
					he <=
						(2 == ke &&
						(function Y(Ue) {
							return Ue % 4 == 0 && (Ue % 100 != 0 || Ue % 400 == 0)
						})(+st[1])
							? 29
							: m[ke])
				)
			}
			function Ne(Ue, st) {
				var et = Ue.match(de)
				if (!et) return !1
				var ke = et[1],
					he = et[2],
					Ve = et[3]
				return ((ke <= 23 && he <= 59 && Ve <= 59) || (23 == ke && 59 == he && 60 == Ve)) && (!st || et[5])
			}
			;(ct.exports = J),
				(J.fast = {
					date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
					time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
					"date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
					uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
					"uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
					"uri-template": R,
					url: V,
					email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
					hostname: Q,
					ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
					ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
					regex: it,
					uuid: B,
					"json-pointer": H,
					"json-pointer-uri-fragment": I,
					"relative-json-pointer": G
				}),
				(J.full = {
					date: pe,
					time: Ne,
					"date-time": function Qe(Ue) {
						var st = Ue.split(ye)
						return 2 == st.length && pe(st[0]) && Ne(st[1], !0)
					},
					uri: function Ce(Ue) {
						return Je.test(Ue) && D.test(Ue)
					},
					"uri-reference":
						/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
					"uri-template": R,
					url: V,
					email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
					hostname: Q,
					ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
					ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
					regex: it,
					uuid: B,
					"json-pointer": H,
					"json-pointer-uri-fragment": I,
					"relative-json-pointer": G
				})
			var ye = /t|\s/i,
				Je = /\/|:/,
				We = /[^\\]\\Z/
			function it(Ue) {
				if (We.test(Ue)) return !1
				try {
					return new RegExp(Ue), !0
				} catch {
					return !1
				}
			}
		},
		2786: (ct, ft, A) => {
			"use strict"
			var X = A(2266),
				q = A(6518),
				m = A(9021),
				de = A(4236),
				Q = A(751),
				D = q.ucs2length,
				$ = A(9818),
				R = m.Validation
			function B(ye, Qe, Je) {
				var Ce = I.call(this, ye, Qe, Je)
				return Ce >= 0
					? { index: Ce, compiling: !0 }
					: ((this._compilations[(Ce = this._compilations.length)] = { schema: ye, root: Qe, baseId: Je }),
					  { index: Ce, compiling: !1 })
			}
			function H(ye, Qe, Je) {
				var Ce = I.call(this, ye, Qe, Je)
				Ce >= 0 && this._compilations.splice(Ce, 1)
			}
			function I(ye, Qe, Je) {
				for (var Ce = 0; Ce < this._compilations.length; Ce++) {
					var We = this._compilations[Ce]
					if (We.schema == ye && We.root == Qe && We.baseId == Je) return Ce
				}
				return -1
			}
			function G(ye, Qe) {
				return "var pattern" + ye + " = new RegExp(" + q.toQuotedString(Qe[ye]) + ");"
			}
			function J(ye) {
				return "var default" + ye + " = defaults[" + ye + "];"
			}
			function Y(ye, Qe) {
				return void 0 === Qe[ye] ? "" : "var refVal" + ye + " = refVal[" + ye + "];"
			}
			function pe(ye) {
				return "var customRule" + ye + " = customRules[" + ye + "];"
			}
			function Ne(ye, Qe) {
				if (!ye.length) return ""
				for (var Je = "", Ce = 0; Ce < ye.length; Ce++) Je += Qe(Ce, ye)
				return Je
			}
			ct.exports = function V(ye, Qe, Je, Ce) {
				var We = this,
					it = this._opts,
					Ue = [void 0],
					st = {},
					et = [],
					ke = {},
					he = [],
					Ve = {},
					je = [],
					Re = B.call(this, ye, (Qe = Qe || { schema: ye, refVal: Ue, refs: st }), Ce),
					ze = this._compilations[Re.index]
				if (Re.compiling)
					return (ze.callValidate = function yn() {
						var St = ze.validate,
							Dt = St.apply(this, arguments)
						return (yn.errors = St.errors), Dt
					})
				var qe = this._formats,
					Ge = this.RULES
				try {
					var wt = ai(ye, Qe, Je, Ce)
					ze.validate = wt
					var Jt = ze.callValidate
					return (
						Jt &&
							((Jt.schema = wt.schema),
							(Jt.errors = null),
							(Jt.refs = wt.refs),
							(Jt.refVal = wt.refVal),
							(Jt.root = wt.root),
							(Jt.$async = wt.$async),
							it.sourceCode && (Jt.source = wt.source)),
						wt
					)
				} finally {
					H.call(this, ye, Qe, Ce)
				}
				function ai(St, Dt, gn, ci) {
					var Ci = !Dt || (Dt && Dt.schema == St)
					if (Dt.schema != Qe.schema) return V.call(We, St, Dt, gn, ci)
					var Qn,
						nr = !0 === St.$async,
						hr = Q({
							isTop: !0,
							schema: St,
							isRoot: Ci,
							baseId: ci,
							root: Dt,
							schemaPath: "",
							errSchemaPath: "#",
							errorPath: '""',
							MissingRefError: m.MissingRef,
							RULES: Ge,
							validate: Q,
							util: q,
							resolve: X,
							resolveRef: vt,
							usePattern: gt,
							useDefault: Ke,
							useCustomRule: fn,
							opts: it,
							formats: qe,
							logger: We.logger,
							self: We
						})
					;(hr = Ne(Ue, Y) + Ne(et, G) + Ne(he, J) + Ne(je, pe) + hr), it.processCode && (hr = it.processCode(hr, St))
					try {
						;(Qn = new Function(
							"self",
							"RULES",
							"formats",
							"root",
							"refVal",
							"defaults",
							"customRules",
							"equal",
							"ucs2length",
							"ValidationError",
							hr
						)(We, Ge, qe, Qe, Ue, he, je, $, D, R)),
							(Ue[0] = Qn)
					} catch (Br) {
						throw (We.logger.error("Error compiling schema, function code:", hr), Br)
					}
					return (
						(Qn.schema = St),
						(Qn.errors = null),
						(Qn.refs = st),
						(Qn.refVal = Ue),
						(Qn.root = Ci ? Qn : Dt),
						nr && (Qn.$async = !0),
						!0 === it.sourceCode && (Qn.source = { code: hr, patterns: et, defaults: he }),
						Qn
					)
				}
				function vt(St, Dt, gn) {
					Dt = X.url(St, Dt)
					var Ci,
						nr,
						ci = st[Dt]
					if (void 0 !== ci) return we((Ci = Ue[ci]), (nr = "refVal[" + ci + "]"))
					if (!gn && Qe.refs) {
						var hr = Qe.refs[Dt]
						if (void 0 !== hr) return we((Ci = Qe.refVal[hr]), (nr = hi(Dt, Ci)))
					}
					nr = hi(Dt)
					var Qn = X.call(We, ai, Qe, Dt)
					if (void 0 === Qn) {
						var io = Je && Je[Dt]
						io && (Qn = X.inlineRef(io, it.inlineRefs) ? io : V.call(We, io, Qe, Je, St))
					}
					if (void 0 !== Qn)
						return (
							(function Wt(St, Dt) {
								Ue[st[St]] = Dt
							})(Dt, Qn),
							we(Qn, nr)
						)
					!(function yi(St) {
						delete st[St]
					})(Dt)
				}
				function hi(St, Dt) {
					var gn = Ue.length
					return (Ue[gn] = Dt), (st[St] = gn), "refVal" + gn
				}
				function we(St, Dt) {
					return "object" == typeof St || "boolean" == typeof St
						? { code: Dt, schema: St, inline: !0 }
						: { code: Dt, $async: St && !!St.$async }
				}
				function gt(St) {
					var Dt = ke[St]
					return void 0 === Dt && ((Dt = ke[St] = et.length), (et[Dt] = St)), "pattern" + Dt
				}
				function Ke(St) {
					switch (typeof St) {
						case "boolean":
						case "number":
							return "" + St
						case "string":
							return q.toQuotedString(St)
						case "object":
							if (null === St) return "null"
							var Dt = de(St),
								gn = Ve[Dt]
							return void 0 === gn && ((gn = Ve[Dt] = he.length), (he[gn] = St)), "default" + gn
					}
				}
				function fn(St, Dt, gn, ci) {
					if (!1 !== We._opts.validateSchema) {
						var Ci = St.definition.dependencies
						if (
							Ci &&
							!Ci.every(function (Vr) {
								return Object.prototype.hasOwnProperty.call(gn, Vr)
							})
						)
							throw new Error("parent schema must have all required keywords: " + Ci.join(","))
						var nr = St.definition.validateSchema
						if (nr && !nr(Dt)) {
							var Qn = "keyword schema is invalid: " + We.errorsText(nr.errors)
							if ("log" != We._opts.validateSchema) throw new Error(Qn)
							We.logger.error(Qn)
						}
					}
					var Ze,
						io = St.definition.compile,
						Br = St.definition.inline,
						Pi = St.definition.macro
					if (io) Ze = io.call(We, Dt, gn, ci)
					else if (Pi) (Ze = Pi.call(We, Dt, gn, ci)), !1 !== it.validateSchema && We.validateSchema(Ze, !0)
					else if (Br) Ze = Br.call(We, ci, St.keyword, Dt, gn)
					else if (!(Ze = St.definition.validate)) return
					if (void 0 === Ze) throw new Error('custom keyword "' + St.keyword + '"failed to compile')
					var li = je.length
					return (je[li] = Ze), { code: "customRule" + li, validate: Ze }
				}
			}
		},
		2266: (ct, ft, A) => {
			"use strict"
			var X = A(6064),
				q = A(9818),
				m = A(6518),
				de = A(1382),
				Q = A(7037)
			function D(Ce, We, it) {
				var Ue = this._refs[it]
				if ("string" == typeof Ue) {
					if (!this._refs[Ue]) return D.call(this, Ce, We, Ue)
					Ue = this._refs[Ue]
				}
				if ((Ue = Ue || this._schemas[it]) instanceof de)
					return I(Ue.schema, this._opts.inlineRefs) ? Ue.schema : Ue.validate || this._compile(Ue)
				var et,
					ke,
					he,
					st = $.call(this, We, it)
				return (
					st && ((et = st.schema), (We = st.root), (he = st.baseId)),
					et instanceof de
						? (ke = et.validate || Ce.call(this, et.schema, We, void 0, he))
						: void 0 !== et && (ke = I(et, this._opts.inlineRefs) ? et : Ce.call(this, et, We, void 0, he)),
					ke
				)
			}
			function $(Ce, We) {
				var it = X.parse(We),
					Ue = pe(it),
					st = Y(this._getId(Ce.schema))
				if (0 === Object.keys(Ce.schema).length || Ue !== st) {
					var et = ye(Ue),
						ke = this._refs[et]
					if ("string" == typeof ke) return R.call(this, Ce, ke, it)
					if (ke instanceof de) ke.validate || this._compile(ke), (Ce = ke)
					else {
						if (!((ke = this._schemas[et]) instanceof de)) return
						if ((ke.validate || this._compile(ke), et == ye(We))) return { schema: ke, root: Ce, baseId: st }
						Ce = ke
					}
					if (!Ce.schema) return
					st = Y(this._getId(Ce.schema))
				}
				return B.call(this, it, st, Ce.schema, Ce)
			}
			function R(Ce, We, it) {
				var Ue = $.call(this, Ce, We)
				if (Ue) {
					var st = Ue.schema,
						et = Ue.baseId
					Ce = Ue.root
					var ke = this._getId(st)
					return ke && (et = Qe(et, ke)), B.call(this, it, et, st, Ce)
				}
			}
			;(ct.exports = D),
				(D.normalizeId = ye),
				(D.fullPath = Y),
				(D.url = Qe),
				(D.ids = function Je(Ce) {
					var We = ye(this._getId(Ce)),
						it = { "": We },
						Ue = { "": Y(We, !1) },
						st = {},
						et = this
					return (
						Q(Ce, { allKeys: !0 }, function (ke, he, Ve, je, Re, ze, qe) {
							if ("" !== he) {
								var Ge = et._getId(ke),
									wt = it[je],
									Jt = Ue[je] + "/" + Re
								if (
									(void 0 !== qe && (Jt += "/" + ("number" == typeof qe ? qe : m.escapeFragment(qe))),
									"string" == typeof Ge)
								) {
									Ge = wt = ye(wt ? X.resolve(wt, Ge) : Ge)
									var yn = et._refs[Ge]
									if (("string" == typeof yn && (yn = et._refs[yn]), yn && yn.schema)) {
										if (!q(ke, yn.schema)) throw new Error('id "' + Ge + '" resolves to more than one schema')
									} else if (Ge != ye(Jt))
										if ("#" == Ge[0]) {
											if (st[Ge] && !q(ke, st[Ge]))
												throw new Error('id "' + Ge + '" resolves to more than one schema')
											st[Ge] = ke
										} else et._refs[Ge] = Jt
								}
								;(it[he] = wt), (Ue[he] = Jt)
							}
						}),
						st
					)
				}),
				(D.inlineRef = I),
				(D.schema = $)
			var V = m.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"])
			function B(Ce, We, it, Ue) {
				if (((Ce.fragment = Ce.fragment || ""), "/" == Ce.fragment.slice(0, 1))) {
					for (var st = Ce.fragment.split("/"), et = 1; et < st.length; et++) {
						var ke = st[et]
						if (ke) {
							if (void 0 === (it = it[(ke = m.unescapeFragment(ke))])) break
							var he
							if (!V[ke] && ((he = this._getId(it)) && (We = Qe(We, he)), it.$ref)) {
								var Ve = Qe(We, it.$ref),
									je = $.call(this, Ue, Ve)
								je && ((it = je.schema), (Ue = je.root), (We = je.baseId))
							}
						}
					}
					if (void 0 !== it && it !== Ue.schema) return { schema: it, root: Ue, baseId: We }
				}
			}
			var H = m.toHash([
				"type",
				"format",
				"pattern",
				"maxLength",
				"minLength",
				"maxProperties",
				"minProperties",
				"maxItems",
				"minItems",
				"maximum",
				"minimum",
				"uniqueItems",
				"multipleOf",
				"required",
				"enum"
			])
			function I(Ce, We) {
				return !1 !== We && (void 0 === We || !0 === We ? G(Ce) : We ? J(Ce) <= We : void 0)
			}
			function G(Ce) {
				var We
				if (Array.isArray(Ce)) {
					for (var it = 0; it < Ce.length; it++) if ("object" == typeof (We = Ce[it]) && !G(We)) return !1
				} else for (var Ue in Ce) if ("$ref" == Ue || ("object" == typeof (We = Ce[Ue]) && !G(We))) return !1
				return !0
			}
			function J(Ce) {
				var it,
					We = 0
				if (Array.isArray(Ce)) {
					for (var Ue = 0; Ue < Ce.length; Ue++)
						if (("object" == typeof (it = Ce[Ue]) && (We += J(it)), We == 1 / 0)) return 1 / 0
				} else
					for (var st in Ce) {
						if ("$ref" == st) return 1 / 0
						if (H[st]) We++
						else if (("object" == typeof (it = Ce[st]) && (We += J(it) + 1), We == 1 / 0)) return 1 / 0
					}
				return We
			}
			function Y(Ce, We) {
				return !1 !== We && (Ce = ye(Ce)), pe(X.parse(Ce))
			}
			function pe(Ce) {
				return X.serialize(Ce).split("#")[0] + "#"
			}
			var Ne = /#\/?$/
			function ye(Ce) {
				return Ce ? Ce.replace(Ne, "") : ""
			}
			function Qe(Ce, We) {
				return (We = ye(We)), X.resolve(Ce, We)
			}
		},
		5051: (ct, ft, A) => {
			"use strict"
			var X = A(5986),
				q = A(6518).toHash
			ct.exports = function () {
				var de = [
						{
							type: "number",
							rules: [{ maximum: ["exclusiveMaximum"] }, { minimum: ["exclusiveMinimum"] }, "multipleOf", "format"]
						},
						{ type: "string", rules: ["maxLength", "minLength", "pattern", "format"] },
						{ type: "array", rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"] },
						{
							type: "object",
							rules: [
								"maxProperties",
								"minProperties",
								"required",
								"dependencies",
								"propertyNames",
								{ properties: ["additionalProperties", "patternProperties"] }
							]
						},
						{ rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
					],
					Q = ["type", "$comment"]
				return (
					(de.all = q(Q)),
					(de.types = q(["number", "integer", "string", "array", "object", "boolean", "null"])),
					de.forEach(function (R) {
						;(R.rules = R.rules.map(function (V) {
							var B
							if ("object" == typeof V) {
								var H = Object.keys(V)[0]
								;(B = V[H]),
									(V = H),
									B.forEach(function (G) {
										Q.push(G), (de.all[G] = !0)
									})
							}
							return Q.push(V), (de.all[V] = { keyword: V, code: X[V], implements: B })
						})),
							(de.all.$comment = { keyword: "$comment", code: X.$comment }),
							R.type && (de.types[R.type] = R)
					}),
					(de.keywords = q(
						Q.concat([
							"$schema",
							"$id",
							"id",
							"$data",
							"$async",
							"title",
							"description",
							"default",
							"definitions",
							"examples",
							"readOnly",
							"writeOnly",
							"contentMediaType",
							"contentEncoding",
							"additionalItems",
							"then",
							"else"
						])
					)),
					(de.custom = {}),
					de
				)
			}
		},
		1382: (ct, ft, A) => {
			"use strict"
			var X = A(6518)
			ct.exports = function q(m) {
				X.copy(m, this)
			}
		},
		3059: ct => {
			"use strict"
			ct.exports = function (A) {
				for (var de, X = 0, q = A.length, m = 0; m < q; )
					X++, (de = A.charCodeAt(m++)) >= 55296 && de <= 56319 && m < q && 56320 == (64512 & (de = A.charCodeAt(m))) && m++
				return X
			}
		},
		6518: (ct, ft, A) => {
			"use strict"
			function q(ke, he, Ve, je) {
				var Re = je ? " !== " : " === ",
					ze = je ? " || " : " && ",
					qe = je ? "!" : "",
					Ge = je ? "" : "!"
				switch (ke) {
					case "null":
						return he + Re + "null"
					case "array":
						return qe + "Array.isArray(" + he + ")"
					case "object":
						return "(" + qe + he + ze + "typeof " + he + Re + '"object"' + ze + Ge + "Array.isArray(" + he + "))"
					case "integer":
						return (
							"(typeof " +
							he +
							Re +
							'"number"' +
							ze +
							Ge +
							"(" +
							he +
							" % 1)" +
							ze +
							he +
							Re +
							he +
							(Ve ? ze + qe + "isFinite(" + he + ")" : "") +
							")"
						)
					case "number":
						return "(typeof " + he + Re + '"' + ke + '"' + (Ve ? ze + qe + "isFinite(" + he + ")" : "") + ")"
					default:
						return "typeof " + he + Re + '"' + ke + '"'
				}
			}
			ct.exports = {
				copy: function X(ke, he) {
					for (var Ve in ((he = he || {}), ke)) he[Ve] = ke[Ve]
					return he
				},
				checkDataType: q,
				checkDataTypes: function m(ke, he, Ve) {
					if (1 === ke.length) return q(ke[0], he, Ve, !0)
					var je = "",
						Re = D(ke)
					for (var ze in (Re.array &&
						Re.object &&
						((je = Re.null ? "(" : "(!" + he + " || "),
						(je += "typeof " + he + ' !== "object")'),
						delete Re.null,
						delete Re.array,
						delete Re.object),
					Re.number && delete Re.integer,
					Re))
						je += (je ? " && " : "") + q(ze, he, Ve, !0)
					return je
				},
				coerceToTypes: function Q(ke, he) {
					if (Array.isArray(he)) {
						for (var Ve = [], je = 0; je < he.length; je++) {
							var Re = he[je]
							;(de[Re] || ("array" === ke && "array" === Re)) && (Ve[Ve.length] = Re)
						}
						if (Ve.length) return Ve
					} else {
						if (de[he]) return [he]
						if ("array" === ke && "array" === he) return ["array"]
					}
				},
				toHash: D,
				getProperty: V,
				escapeQuotes: B,
				equal: A(9818),
				ucs2length: A(3059),
				varOccurences: function H(ke, he) {
					var Ve = ke.match(new RegExp((he += "[^0-9]"), "g"))
					return Ve ? Ve.length : 0
				},
				varReplace: function I(ke, he, Ve) {
					return (he += "([^0-9])"), (Ve = Ve.replace(/\$/g, "$$$$")), ke.replace(new RegExp(he, "g"), Ve + "$1")
				},
				schemaHasRules: function G(ke, he) {
					if ("boolean" == typeof ke) return !ke
					for (var Ve in ke) if (he[Ve]) return !0
				},
				schemaHasRulesExcept: function J(ke, he, Ve) {
					if ("boolean" == typeof ke) return !ke && "not" != Ve
					for (var je in ke) if (je != Ve && he[je]) return !0
				},
				schemaUnknownRules: function Y(ke, he) {
					if ("boolean" != typeof ke) for (var Ve in ke) if (!he[Ve]) return Ve
				},
				toQuotedString: pe,
				getPathExpr: function Ne(ke, he, Ve, je) {
					return We(
						ke,
						Ve
							? "'/' + " + he + (je ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')")
							: je
							? "'[' + " + he + " + ']'"
							: "'[\\'' + " + he + " + '\\']'"
					)
				},
				getPath: function ye(ke, he, Ve) {
					return We(ke, pe(Ve ? "/" + st(he) : V(he)))
				},
				getData: function Ce(ke, he, Ve) {
					var je, Re, ze, qe
					if ("" === ke) return "rootData"
					if ("/" == ke[0]) {
						if (!Qe.test(ke)) throw new Error("Invalid JSON-pointer: " + ke)
						;(Re = ke), (ze = "rootData")
					} else {
						if (!(qe = ke.match(Je))) throw new Error("Invalid JSON-pointer: " + ke)
						if (((je = +qe[1]), "#" == (Re = qe[2]))) {
							if (je >= he) throw new Error("Cannot access property/index " + je + " levels up, current level is " + he)
							return Ve[he - je]
						}
						if (je > he) throw new Error("Cannot access data " + je + " levels up, current level is " + he)
						if (((ze = "data" + (he - je || "")), !Re)) return ze
					}
					for (var Ge = ze, wt = Re.split("/"), Jt = 0; Jt < wt.length; Jt++) {
						var yn = wt[Jt]
						yn && (Ge += " && " + (ze += V(et(yn))))
					}
					return Ge
				},
				unescapeFragment: function it(ke) {
					return et(decodeURIComponent(ke))
				},
				unescapeJsonPointer: et,
				escapeFragment: function Ue(ke) {
					return encodeURIComponent(st(ke))
				},
				escapeJsonPointer: st
			}
			var de = D(["string", "number", "integer", "boolean", "null"])
			function D(ke) {
				for (var he = {}, Ve = 0; Ve < ke.length; Ve++) he[ke[Ve]] = !0
				return he
			}
			var $ = /^[a-z$_][a-z$_0-9]*$/i,
				R = /'|\\/g
			function V(ke) {
				return "number" == typeof ke ? "[" + ke + "]" : $.test(ke) ? "." + ke : "['" + B(ke) + "']"
			}
			function B(ke) {
				return ke.replace(R, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t")
			}
			function pe(ke) {
				return "'" + B(ke) + "'"
			}
			var Qe = /^\/(?:[^~]|~0|~1)*$/,
				Je = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/
			function We(ke, he) {
				return '""' == ke ? he : (ke + " + " + he).replace(/([^\\])' \+ '/g, "$1")
			}
			function st(ke) {
				return ke.replace(/~/g, "~0").replace(/\//g, "~1")
			}
			function et(ke) {
				return ke.replace(/~1/g, "/").replace(/~0/g, "~")
			}
		},
		3439: ct => {
			"use strict"
			var ft = [
				"multipleOf",
				"maximum",
				"exclusiveMaximum",
				"minimum",
				"exclusiveMinimum",
				"maxLength",
				"minLength",
				"pattern",
				"additionalItems",
				"maxItems",
				"minItems",
				"uniqueItems",
				"maxProperties",
				"minProperties",
				"required",
				"additionalProperties",
				"enum",
				"format",
				"const"
			]
			ct.exports = function (A, X) {
				for (var q = 0; q < X.length; q++) {
					A = JSON.parse(JSON.stringify(A))
					var Q,
						m = X[q].split("/"),
						de = A
					for (Q = 1; Q < m.length; Q++) de = de[m[Q]]
					for (Q = 0; Q < ft.length; Q++) {
						var D = ft[Q],
							$ = de[D]
						$ &&
							(de[D] = {
								anyOf: [$, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }]
							})
					}
				}
				return A
			}
		},
		4686: (ct, ft, A) => {
			"use strict"
			var X = A(6680)
			ct.exports = {
				$id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
				definitions: { simpleTypes: X.definitions.simpleTypes },
				type: "object",
				dependencies: {
					schema: ["validate"],
					$data: ["validate"],
					statements: ["inline"],
					valid: { not: { required: ["macro"] } }
				},
				properties: {
					type: X.properties.type,
					schema: { type: "boolean" },
					statements: { type: "boolean" },
					dependencies: { type: "array", items: { type: "string" } },
					metaSchema: { type: "object" },
					modifying: { type: "boolean" },
					valid: { type: "boolean" },
					$data: { type: "boolean" },
					async: { type: "boolean" },
					errors: { anyOf: [{ type: "boolean" }, { const: "full" }] }
				}
			}
		},
		5112: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var I,
					m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = A.opts.$data && D && D.$data
				H ? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (I = "schema" + de)) : (I = D)
				var G = "maximum" == X,
					J = G ? "exclusiveMaximum" : "exclusiveMinimum",
					Y = A.schema[J],
					pe = A.opts.$data && Y && Y.$data,
					Ne = G ? "<" : ">",
					ye = G ? ">" : "<",
					Qe = void 0
				if (!H && "number" != typeof D && void 0 !== D) throw new Error(X + " must be number")
				if (!pe && void 0 !== Y && "number" != typeof Y && "boolean" != typeof Y) throw new Error(J + " must be number or boolean")
				if (pe) {
					var et,
						Je = A.util.getData(Y.$data, Q, A.dataPathArr),
						Ce = "exclusive" + de,
						We = "exclType" + de,
						it = "exclIsNumber" + de,
						st = "' + " + (Ue = "op" + de) + " + '"
					;(m += " var schemaExcl" + de + " = " + Je + "; "),
						(Qe = J),
						(et = et || []).push(
							(m +=
								" var " +
								Ce +
								"; var " +
								We +
								" = typeof " +
								(Je = "schemaExcl" + de) +
								"; if (" +
								We +
								" != 'boolean' && " +
								We +
								" != 'undefined' && " +
								We +
								" != 'number') { ")
						),
						(m = ""),
						!1 !== A.createErrors
							? ((m +=
									" { keyword: '" +
									(Qe || "_exclusiveLimit") +
									"' , dataPath: (dataPath || '') + " +
									A.errorPath +
									" , schemaPath: " +
									A.util.toQuotedString(R) +
									" , params: {} "),
							  !1 !== A.opts.messages && (m += " , message: '" + J + " should be boolean' "),
							  A.opts.verbose &&
									(m +=
										" , schema: validate.schema" +
										$ +
										" , parentSchema: validate.schema" +
										A.schemaPath +
										" , data: " +
										B +
										" "),
							  (m += " } "))
							: (m += " {} ")
					var ke = m
					;(m = et.pop()),
						(m +=
							!A.compositeRule && V
								? A.async
									? " throw new ValidationError([" + ke + "]); "
									: " validate.errors = [" + ke + "]; return false; "
								: " var err = " + ke + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
						(m += " } else if ( "),
						H && (m += " (" + I + " !== undefined && typeof " + I + " != 'number') || "),
						(m +=
							" " +
							We +
							" == 'number' ? ( (" +
							Ce +
							" = " +
							I +
							" === undefined || " +
							Je +
							" " +
							Ne +
							"= " +
							I +
							") ? " +
							B +
							" " +
							ye +
							"= " +
							Je +
							" : " +
							B +
							" " +
							ye +
							" " +
							I +
							" ) : ( (" +
							Ce +
							" = " +
							Je +
							" === true) ? " +
							B +
							" " +
							ye +
							"= " +
							I +
							" : " +
							B +
							" " +
							ye +
							" " +
							I +
							" ) || " +
							B +
							" !== " +
							B +
							") { var op" +
							de +
							" = " +
							Ce +
							" ? '" +
							Ne +
							"' : '" +
							Ne +
							"='; "),
						void 0 === D && ((Qe = J), (R = A.errSchemaPath + "/" + J), (I = Je), (H = pe))
				} else if (((st = Ne), (it = "number" == typeof Y) && H)) {
					var Ue = "'" + st + "'"
					;(m += " if ( "),
						H && (m += " (" + I + " !== undefined && typeof " + I + " != 'number') || "),
						(m +=
							" ( " +
							I +
							" === undefined || " +
							Y +
							" " +
							Ne +
							"= " +
							I +
							" ? " +
							B +
							" " +
							ye +
							"= " +
							Y +
							" : " +
							B +
							" " +
							ye +
							" " +
							I +
							" ) || " +
							B +
							" !== " +
							B +
							") { ")
				} else
					it && void 0 === D
						? ((Ce = !0), (Qe = J), (R = A.errSchemaPath + "/" + J), (I = Y), (ye += "="))
						: (it && (I = Math[G ? "min" : "max"](Y, D)),
						  Y === (!it || I)
								? ((Ce = !0), (Qe = J), (R = A.errSchemaPath + "/" + J), (ye += "="))
								: ((Ce = !1), (st += "="))),
						(Ue = "'" + st + "'"),
						(m += " if ( "),
						H && (m += " (" + I + " !== undefined && typeof " + I + " != 'number') || "),
						(m += " " + B + " " + ye + " " + I + " || " + B + " !== " + B + ") { ")
				return (
					(Qe = Qe || X),
					(et = et || []).push(m),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: '" +
								(Qe || "_limit") +
								"' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { comparison: " +
								Ue +
								", limit: " +
								I +
								", exclusive: " +
								Ce +
								" } "),
						  !1 !== A.opts.messages && ((m += " , message: 'should be " + st + " "), (m += H ? "' + " + I : I + "'")),
						  A.opts.verbose &&
								((m += " , schema:  "),
								(m += H ? "validate.schema" + $ : "" + D),
								(m += "         , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " ")),
						  (m += " } "))
						: (m += " {} "),
					(ke = m),
					(m = et.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + ke + "]); "
								: " validate.errors = [" + ke + "]; return false; "
							: " var err = " + ke + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += " } "),
					V && (m += " else { "),
					m
				)
			}
		},
		3195: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var I,
					m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = A.opts.$data && D && D.$data
				if (
					(H
						? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (I = "schema" + de))
						: (I = D),
					!H && "number" != typeof D)
				)
					throw new Error(X + " must be number")
				;(m += "if ( "), H && (m += " (" + I + " !== undefined && typeof " + I + " != 'number') || ")
				var J = X,
					Y = Y || []
				Y.push((m += " " + B + ".length " + ("maxItems" == X ? ">" : "<") + " " + I + ") { ")),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: '" +
								(J || "_limitItems") +
								"' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { limit: " +
								I +
								" } "),
						  !1 !== A.opts.messages &&
								((m += " , message: 'should NOT have "),
								(m += "maxItems" == X ? "more" : "fewer"),
								(m += " than "),
								(m += H ? "' + " + I + " + '" : "" + D),
								(m += " items' ")),
						  A.opts.verbose &&
								((m += " , schema:  "),
								(m += H ? "validate.schema" + $ : "" + D),
								(m += "         , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " ")),
						  (m += " } "))
						: (m += " {} ")
				var pe = m
				return (
					(m = Y.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + pe + "]); "
								: " validate.errors = [" + pe + "]; return false; "
							: " var err = " + pe + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += "} "),
					V && (m += " else { "),
					m
				)
			}
		},
		1504: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var I,
					m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = A.opts.$data && D && D.$data
				if (
					(H
						? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (I = "schema" + de))
						: (I = D),
					!H && "number" != typeof D)
				)
					throw new Error(X + " must be number")
				;(m += "if ( "),
					H && (m += " (" + I + " !== undefined && typeof " + I + " != 'number') || "),
					(m += !1 === A.opts.unicode ? " " + B + ".length " : " ucs2length(" + B + ") ")
				var J = X,
					Y = Y || []
				Y.push((m += " " + ("maxLength" == X ? ">" : "<") + " " + I + ") { ")),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: '" +
								(J || "_limitLength") +
								"' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { limit: " +
								I +
								" } "),
						  !1 !== A.opts.messages &&
								((m += " , message: 'should NOT be "),
								(m += "maxLength" == X ? "longer" : "shorter"),
								(m += " than "),
								(m += H ? "' + " + I + " + '" : "" + D),
								(m += " characters' ")),
						  A.opts.verbose &&
								((m += " , schema:  "),
								(m += H ? "validate.schema" + $ : "" + D),
								(m += "         , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " ")),
						  (m += " } "))
						: (m += " {} ")
				var pe = m
				return (
					(m = Y.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + pe + "]); "
								: " validate.errors = [" + pe + "]; return false; "
							: " var err = " + pe + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += "} "),
					V && (m += " else { "),
					m
				)
			}
		},
		2724: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var I,
					m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = A.opts.$data && D && D.$data
				if (
					(H
						? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (I = "schema" + de))
						: (I = D),
					!H && "number" != typeof D)
				)
					throw new Error(X + " must be number")
				;(m += "if ( "), H && (m += " (" + I + " !== undefined && typeof " + I + " != 'number') || ")
				var J = X,
					Y = Y || []
				Y.push((m += " Object.keys(" + B + ").length " + ("maxProperties" == X ? ">" : "<") + " " + I + ") { ")),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: '" +
								(J || "_limitProperties") +
								"' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { limit: " +
								I +
								" } "),
						  !1 !== A.opts.messages &&
								((m += " , message: 'should NOT have "),
								(m += "maxProperties" == X ? "more" : "fewer"),
								(m += " than "),
								(m += H ? "' + " + I + " + '" : "" + D),
								(m += " properties' ")),
						  A.opts.verbose &&
								((m += " , schema:  "),
								(m += H ? "validate.schema" + $ : "" + D),
								(m += "         , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " ")),
						  (m += " } "))
						: (m += " {} ")
				var pe = m
				return (
					(m = Y.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + pe + "]); "
								: " validate.errors = [" + pe + "]; return false; "
							: " var err = " + pe + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += "} "),
					V && (m += " else { "),
					m
				)
			}
		},
		4842: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.schema[X],
					Q = A.schemaPath + A.util.getProperty(X),
					D = A.errSchemaPath + "/" + X,
					$ = !A.opts.allErrors,
					R = A.util.copy(A),
					V = ""
				R.level++
				var B = "valid" + R.level,
					H = R.baseId,
					I = !0,
					G = de
				if (G)
					for (var J, Y = -1, pe = G.length - 1; Y < pe; )
						(J = G[(Y += 1)]),
							(A.opts.strictKeywords
								? ("object" == typeof J && Object.keys(J).length > 0) || !1 === J
								: A.util.schemaHasRules(J, A.RULES.all)) &&
								((I = !1),
								(R.schema = J),
								(R.schemaPath = Q + "[" + Y + "]"),
								(R.errSchemaPath = D + "/" + Y),
								(m += "  " + A.validate(R) + " "),
								(R.baseId = H),
								$ && ((m += " if (" + B + ") { "), (V += "}")))
				return $ && (m += I ? " if (true) { " : " " + V.slice(0, -1) + " "), m
			}
		},
		7825: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = "errs__" + de,
					G = A.util.copy(A),
					J = ""
				G.level++
				var Y = "valid" + G.level
				if (
					D.every(function (it) {
						return A.opts.strictKeywords
							? ("object" == typeof it && Object.keys(it).length > 0) || !1 === it
							: A.util.schemaHasRules(it, A.RULES.all)
					})
				) {
					var Ne = G.baseId
					m += " var " + I + " = errors; var " + H + " = false;  "
					var ye = A.compositeRule
					A.compositeRule = G.compositeRule = !0
					var Qe = D
					if (Qe)
						for (var Je, Ce = -1, We = Qe.length - 1; Ce < We; )
							(Je = Qe[(Ce += 1)]),
								(G.schema = Je),
								(G.schemaPath = $ + "[" + Ce + "]"),
								(G.errSchemaPath = R + "/" + Ce),
								(m += "  " + A.validate(G) + " "),
								(G.baseId = Ne),
								(m += " " + H + " = " + H + " || " + Y + "; if (!" + H + ") { "),
								(J += "}")
					;(A.compositeRule = G.compositeRule = ye),
						(m += " " + J + " if (!" + H + ") {   var err =   "),
						!1 !== A.createErrors
							? ((m +=
									" { keyword: 'anyOf' , dataPath: (dataPath || '') + " +
									A.errorPath +
									" , schemaPath: " +
									A.util.toQuotedString(R) +
									" , params: {} "),
							  !1 !== A.opts.messages && (m += " , message: 'should match some schema in anyOf' "),
							  A.opts.verbose &&
									(m +=
										" , schema: validate.schema" +
										$ +
										" , parentSchema: validate.schema" +
										A.schemaPath +
										" , data: " +
										B +
										" "),
							  (m += " } "))
							: (m += " {} "),
						(m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
						!A.compositeRule &&
							V &&
							(m += A.async ? " throw new ValidationError(vErrors); " : " validate.errors = vErrors; return false; "),
						(m +=
							" } else {  errors = " +
							I +
							"; if (vErrors !== null) { if (" +
							I +
							") vErrors.length = " +
							I +
							"; else vErrors = null; } "),
						A.opts.allErrors && (m += " } ")
				} else V && (m += " if (true) { ")
				return m
			}
		},
		3235: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					Q = A.errSchemaPath + "/" + X,
					$ = A.util.toQuotedString(A.schema[X])
				return (
					!0 === A.opts.$comment
						? (m += " console.log(" + $ + ");")
						: "function" == typeof A.opts.$comment &&
						  (m += " self._opts.$comment(" + $ + ", " + A.util.toQuotedString(Q) + ", validate.root.schema);"),
					m
				)
			}
		},
		3295: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = A.opts.$data && D && D.$data
				I && (m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "),
					I || (m += " var schema" + de + " = validate.schema" + $ + ";")
				var J = J || []
				J.push((m += "var " + H + " = equal(" + B + ", schema" + de + "); if (!" + H + ") {   ")),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: 'const' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { allowedValue: schema" +
								de +
								" } "),
						  !1 !== A.opts.messages && (m += " , message: 'should be equal to constant' "),
						  A.opts.verbose &&
								(m +=
									" , schema: validate.schema" +
									$ +
									" , parentSchema: validate.schema" +
									A.schemaPath +
									" , data: " +
									B +
									" "),
						  (m += " } "))
						: (m += " {} ")
				var Y = m
				return (
					(m = J.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + Y + "]); "
								: " validate.errors = [" + Y + "]; return false; "
							: " var err = " + Y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += " }"),
					V && (m += " else { "),
					m
				)
			}
		},
		1710: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = "errs__" + de,
					G = A.util.copy(A)
				G.level++
				var Y = "valid" + G.level,
					pe = "i" + de,
					Ne = (G.dataLevel = A.dataLevel + 1),
					ye = "data" + Ne,
					Qe = A.baseId,
					Je = A.opts.strictKeywords
						? ("object" == typeof D && Object.keys(D).length > 0) || !1 === D
						: A.util.schemaHasRules(D, A.RULES.all)
				if (((m += "var " + I + " = errors;var " + H + ";"), Je)) {
					var Ce = A.compositeRule
					;(A.compositeRule = G.compositeRule = !0),
						(G.schema = D),
						(G.schemaPath = $),
						(G.errSchemaPath = R),
						(m += " var " + Y + " = false; for (var " + pe + " = 0; " + pe + " < " + B + ".length; " + pe + "++) { "),
						(G.errorPath = A.util.getPathExpr(A.errorPath, pe, A.opts.jsonPointers, !0))
					var We = B + "[" + pe + "]"
					G.dataPathArr[Ne] = pe
					var it = A.validate(G)
					;(G.baseId = Qe),
						A.util.varOccurences(it, ye) < 2
							? (m += " " + A.util.varReplace(it, ye, We) + " ")
							: (m += " var " + ye + " = " + We + "; " + it + " "),
						(m += " if (" + Y + ") break; }  "),
						(A.compositeRule = G.compositeRule = Ce),
						(m += "  if (!" + Y + ") {")
				} else m += " if (" + B + ".length == 0) {"
				var Ue = Ue || []
				Ue.push(m),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: 'contains' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: {} "),
						  !1 !== A.opts.messages && (m += " , message: 'should contain a valid item' "),
						  A.opts.verbose &&
								(m +=
									" , schema: validate.schema" +
									$ +
									" , parentSchema: validate.schema" +
									A.schemaPath +
									" , data: " +
									B +
									" "),
						  (m += " } "))
						: (m += " {} ")
				var st = m
				return (
					(m = Ue.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + st + "]); "
								: " validate.errors = [" + st + "]; return false; "
							: " var err = " + st + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += " } else { "),
					Je &&
						(m +=
							"  errors = " +
							I +
							"; if (vErrors !== null) { if (" +
							I +
							") vErrors.length = " +
							I +
							"; else vErrors = null; } "),
					A.opts.allErrors && (m += " } "),
					m
				)
			}
		},
		6791: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var B,
					Y,
					m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					H = "data" + (Q || ""),
					I = "valid" + de,
					G = "errs__" + de,
					J = A.opts.$data && D && D.$data
				J ? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (Y = "schema" + de)) : (Y = D)
				var Je,
					Ce,
					We,
					it,
					Ue,
					pe = this,
					Ne = "definition" + de,
					ye = pe.definition,
					Qe = ""
				if (J && ye.$data) {
					var st = ye.validateSchema
					m +=
						" var " +
						Ne +
						" = RULES.custom['" +
						X +
						"'].definition; var " +
						(Ue = "keywordValidate" + de) +
						" = " +
						Ne +
						".validate;"
				} else {
					if (!(it = A.useCustomRule(pe, D, A.schema, A))) return
					;(Y = "validate.schema" + $), (Ue = it.code), (Je = ye.compile), (Ce = ye.inline), (We = ye.macro)
				}
				var et = Ue + ".errors",
					ke = "i" + de,
					he = "ruleErr" + de,
					Ve = ye.async
				if (Ve && !A.async) throw new Error("async keyword in sync schema")
				if (
					(Ce || We || (m += et + " = null;"),
					(m += "var " + G + " = errors;var " + I + ";"),
					J &&
						ye.$data &&
						((Qe += "}"),
						(m += " if (" + Y + " === undefined) { " + I + " = true; } else { "),
						st && ((Qe += "}"), (m += " " + I + " = " + Ne + ".validateSchema(" + Y + "); if (" + I + ") { "))),
					Ce)
				)
					m += ye.statements ? " " + it.validate + " " : " " + I + " = " + it.validate + "; "
				else if (We) {
					var je = A.util.copy(A)
					;(Qe = ""), je.level++
					var Re = "valid" + je.level
					;(je.schema = it.validate), (je.schemaPath = "")
					var ze = A.compositeRule
					A.compositeRule = je.compositeRule = !0
					var qe = A.validate(je).replace(/validate\.schema/g, Ue)
					;(A.compositeRule = je.compositeRule = ze), (m += " " + qe)
				} else {
					;(Ge = Ge || []).push(m),
						(m = ""),
						(m += "  " + Ue + ".call( "),
						(m += A.opts.passContext ? "this" : "self"),
						(m += Je || !1 === ye.schema ? " , " + H + " " : " , " + Y + " , " + H + " , validate.schema" + A.schemaPath + " "),
						(m += " , (dataPath || '')"),
						'""' != A.errorPath && (m += " + " + A.errorPath)
					var wt = Q ? "data" + (Q - 1 || "") : "parentData",
						Jt = Q ? A.dataPathArr[Q] : "parentDataProperty",
						yn = (m += " , " + wt + " , " + Jt + " , rootData )  ")
					;(m = Ge.pop()),
						!1 === ye.errors
							? ((m += " " + I + " = "), Ve && (m += "await "), (m += yn + "; "))
							: (m += Ve
									? " var " +
									  (et = "customErrors" + de) +
									  " = null; try { " +
									  I +
									  " = await " +
									  yn +
									  "; } catch (e) { " +
									  I +
									  " = false; if (e instanceof ValidationError) " +
									  et +
									  " = e.errors; else throw e; } "
									: " " + et + " = null; " + I + " = " + yn + "; ")
				}
				if ((ye.modifying && (m += " if (" + wt + ") " + H + " = " + wt + "[" + Jt + "];"), (m += "" + Qe), ye.valid))
					V && (m += " if (true) { ")
				else {
					var Ge
					;(m += " if ( "),
						void 0 === ye.valid ? ((m += " !"), (m += We ? "" + Re : "" + I)) : (m += " " + !ye.valid + " "),
						(B = pe.keyword),
						(Ge = Ge || []).push((m += ") { ")),
						(Ge = Ge || []).push((m = "")),
						(m = ""),
						!1 !== A.createErrors
							? ((m +=
									" { keyword: '" +
									(B || "custom") +
									"' , dataPath: (dataPath || '') + " +
									A.errorPath +
									" , schemaPath: " +
									A.util.toQuotedString(R) +
									" , params: { keyword: '" +
									pe.keyword +
									"' } "),
							  !1 !== A.opts.messages && (m += " , message: 'should pass \"" + pe.keyword + "\" keyword validation' "),
							  A.opts.verbose &&
									(m +=
										" , schema: validate.schema" +
										$ +
										" , parentSchema: validate.schema" +
										A.schemaPath +
										" , data: " +
										H +
										" "),
							  (m += " } "))
							: (m += " {} ")
					var ai = m
					m = Ge.pop()
					var vt = (m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + ai + "]); "
								: " validate.errors = [" + ai + "]; return false; "
							: " var err = " + ai + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ")
					;(m = Ge.pop()),
						Ce
							? ye.errors
								? "full" != ye.errors &&
								  ((m +=
										"  for (var " +
										ke +
										"=" +
										G +
										"; " +
										ke +
										"<errors; " +
										ke +
										"++) { var " +
										he +
										" = vErrors[" +
										ke +
										"]; if (" +
										he +
										".dataPath === undefined) " +
										he +
										".dataPath = (dataPath || '') + " +
										A.errorPath +
										"; if (" +
										he +
										".schemaPath === undefined) { " +
										he +
										'.schemaPath = "' +
										R +
										'"; } '),
								  A.opts.verbose && (m += " " + he + ".schema = " + Y + "; " + he + ".data = " + H + "; "),
								  (m += " } "))
								: !1 === ye.errors
								? (m += " " + vt + " ")
								: ((m +=
										" if (" +
										G +
										" == errors) { " +
										vt +
										" } else {  for (var " +
										ke +
										"=" +
										G +
										"; " +
										ke +
										"<errors; " +
										ke +
										"++) { var " +
										he +
										" = vErrors[" +
										ke +
										"]; if (" +
										he +
										".dataPath === undefined) " +
										he +
										".dataPath = (dataPath || '') + " +
										A.errorPath +
										"; if (" +
										he +
										".schemaPath === undefined) { " +
										he +
										'.schemaPath = "' +
										R +
										'"; } '),
								  A.opts.verbose && (m += " " + he + ".schema = " + Y + "; " + he + ".data = " + H + "; "),
								  (m += " } } "))
							: We
							? ((m += "   var err =   "),
							  !1 !== A.createErrors
									? ((m +=
											" { keyword: '" +
											(B || "custom") +
											"' , dataPath: (dataPath || '') + " +
											A.errorPath +
											" , schemaPath: " +
											A.util.toQuotedString(R) +
											" , params: { keyword: '" +
											pe.keyword +
											"' } "),
									  !1 !== A.opts.messages &&
											(m += " , message: 'should pass \"" + pe.keyword + "\" keyword validation' "),
									  A.opts.verbose &&
											(m +=
												" , schema: validate.schema" +
												$ +
												" , parentSchema: validate.schema" +
												A.schemaPath +
												" , data: " +
												H +
												" "),
									  (m += " } "))
									: (m += " {} "),
							  (m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
							  !A.compositeRule &&
									V &&
									(m += A.async ? " throw new ValidationError(vErrors); " : " validate.errors = vErrors; return false; "))
							: !1 === ye.errors
							? (m += " " + vt + " ")
							: ((m +=
									" if (Array.isArray(" +
									et +
									")) { if (vErrors === null) vErrors = " +
									et +
									"; else vErrors = vErrors.concat(" +
									et +
									"); errors = vErrors.length;  for (var " +
									ke +
									"=" +
									G +
									"; " +
									ke +
									"<errors; " +
									ke +
									"++) { var " +
									he +
									" = vErrors[" +
									ke +
									"]; if (" +
									he +
									".dataPath === undefined) " +
									he +
									".dataPath = (dataPath || '') + " +
									A.errorPath +
									";  " +
									he +
									'.schemaPath = "' +
									R +
									'";  '),
							  A.opts.verbose && (m += " " + he + ".schema = " + Y + "; " + he + ".data = " + H + "; "),
							  (m += " } } else { " + vt + " } ")),
						(m += " } "),
						V && (m += " else { ")
				}
				return m
			}
		},
		4992: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "errs__" + de,
					I = A.util.copy(A),
					G = ""
				I.level++
				var J = "valid" + I.level,
					Y = {},
					pe = {},
					Ne = A.opts.ownProperties
				for (Ce in D)
					if ("__proto__" != Ce) {
						var ye = D[Ce],
							Qe = Array.isArray(ye) ? pe : Y
						Qe[Ce] = ye
					}
				m += "var " + H + " = errors;"
				var Je = A.errorPath
				for (var Ce in ((m += "var missing" + de + ";"), pe))
					if ((Qe = pe[Ce]).length) {
						if (
							((m += " if ( " + B + A.util.getProperty(Ce) + " !== undefined "),
							Ne && (m += " && Object.prototype.hasOwnProperty.call(" + B + ", '" + A.util.escapeQuotes(Ce) + "') "),
							V)
						) {
							m += " && ( "
							var We = Qe
							if (We)
								for (var Ue = -1, st = We.length - 1; Ue < st; )
									(it = We[(Ue += 1)]),
										Ue && (m += " || "),
										(m += " ( ( " + (ke = B + (et = A.util.getProperty(it))) + " === undefined "),
										Ne &&
											(m +=
												" || ! Object.prototype.hasOwnProperty.call(" +
												B +
												", '" +
												A.util.escapeQuotes(it) +
												"') "),
										(m += ") && (missing" + de + " = " + A.util.toQuotedString(A.opts.jsonPointers ? it : et) + ") ) ")
							m += ")) {  "
							var he = "missing" + de,
								Ve = "' + " + he + " + '"
							A.opts._errorDataPathProperty &&
								(A.errorPath = A.opts.jsonPointers ? A.util.getPathExpr(Je, he, !0) : Je + " + " + he)
							var je = je || []
							je.push(m),
								(m = ""),
								!1 !== A.createErrors
									? ((m +=
											" { keyword: 'dependencies' , dataPath: (dataPath || '') + " +
											A.errorPath +
											" , schemaPath: " +
											A.util.toQuotedString(R) +
											" , params: { property: '" +
											A.util.escapeQuotes(Ce) +
											"', missingProperty: '" +
											Ve +
											"', depsCount: " +
											Qe.length +
											", deps: '" +
											A.util.escapeQuotes(1 == Qe.length ? Qe[0] : Qe.join(", ")) +
											"' } "),
									  !1 !== A.opts.messages &&
											((m += " , message: 'should have "),
											(m +=
												1 == Qe.length
													? "property " + A.util.escapeQuotes(Qe[0])
													: "properties " + A.util.escapeQuotes(Qe.join(", "))),
											(m += " when property " + A.util.escapeQuotes(Ce) + " is present' ")),
									  A.opts.verbose &&
											(m +=
												" , schema: validate.schema" +
												$ +
												" , parentSchema: validate.schema" +
												A.schemaPath +
												" , data: " +
												B +
												" "),
									  (m += " } "))
									: (m += " {} ")
							var Re = m
							;(m = je.pop()),
								(m +=
									!A.compositeRule && V
										? A.async
											? " throw new ValidationError([" + Re + "]); "
											: " validate.errors = [" + Re + "]; return false; "
										: " var err = " +
										  Re +
										  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ")
						} else {
							m += " ) { "
							var ze = Qe
							if (ze)
								for (var it, qe = -1, Ge = ze.length - 1; qe < Ge; ) {
									it = ze[(qe += 1)]
									var et = A.util.getProperty(it),
										ke = ((Ve = A.util.escapeQuotes(it)), B + et)
									A.opts._errorDataPathProperty && (A.errorPath = A.util.getPath(Je, it, A.opts.jsonPointers)),
										(m += " if ( " + ke + " === undefined "),
										Ne &&
											(m +=
												" || ! Object.prototype.hasOwnProperty.call(" +
												B +
												", '" +
												A.util.escapeQuotes(it) +
												"') "),
										(m += ") {  var err =   "),
										!1 !== A.createErrors
											? ((m +=
													" { keyword: 'dependencies' , dataPath: (dataPath || '') + " +
													A.errorPath +
													" , schemaPath: " +
													A.util.toQuotedString(R) +
													" , params: { property: '" +
													A.util.escapeQuotes(Ce) +
													"', missingProperty: '" +
													Ve +
													"', depsCount: " +
													Qe.length +
													", deps: '" +
													A.util.escapeQuotes(1 == Qe.length ? Qe[0] : Qe.join(", ")) +
													"' } "),
											  !1 !== A.opts.messages &&
													((m += " , message: 'should have "),
													(m +=
														1 == Qe.length
															? "property " + A.util.escapeQuotes(Qe[0])
															: "properties " + A.util.escapeQuotes(Qe.join(", "))),
													(m += " when property " + A.util.escapeQuotes(Ce) + " is present' ")),
											  A.opts.verbose &&
													(m +=
														" , schema: validate.schema" +
														$ +
														" , parentSchema: validate.schema" +
														A.schemaPath +
														" , data: " +
														B +
														" "),
											  (m += " } "))
											: (m += " {} "),
										(m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ")
								}
						}
						;(m += " }   "), V && ((G += "}"), (m += " else { "))
					}
				A.errorPath = Je
				var wt = I.baseId
				for (var Ce in Y)
					(ye = Y[Ce]),
						(A.opts.strictKeywords
							? ("object" == typeof ye && Object.keys(ye).length > 0) || !1 === ye
							: A.util.schemaHasRules(ye, A.RULES.all)) &&
							((m += " " + J + " = true; if ( " + B + A.util.getProperty(Ce) + " !== undefined "),
							Ne && (m += " && Object.prototype.hasOwnProperty.call(" + B + ", '" + A.util.escapeQuotes(Ce) + "') "),
							(m += ") { "),
							(I.schema = ye),
							(I.schemaPath = $ + A.util.getProperty(Ce)),
							(I.errSchemaPath = R + "/" + A.util.escapeFragment(Ce)),
							(m += "  " + A.validate(I) + " "),
							(I.baseId = wt),
							(m += " }  "),
							V && ((m += " if (" + J + ") { "), (G += "}")))
				return V && (m += "   " + G + " if (" + H + " == errors) {"), m
			}
		},
		3387: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = A.opts.$data && D && D.$data
				I && (m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; ")
				var J = "i" + de,
					Y = "schema" + de
				I || (m += " var " + Y + " = validate.schema" + $ + ";"),
					(m += "var " + H + ";"),
					I &&
						(m +=
							" if (schema" +
							de +
							" === undefined) " +
							H +
							" = true; else if (!Array.isArray(schema" +
							de +
							")) " +
							H +
							" = false; else {"),
					(m +=
						H +
						" = false;for (var " +
						J +
						"=0; " +
						J +
						"<" +
						Y +
						".length; " +
						J +
						"++) if (equal(" +
						B +
						", " +
						Y +
						"[" +
						J +
						"])) { " +
						H +
						" = true; break; }"),
					I && (m += "  }  ")
				var pe = pe || []
				pe.push((m += " if (!" + H + ") {   ")),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: 'enum' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { allowedValues: schema" +
								de +
								" } "),
						  !1 !== A.opts.messages && (m += " , message: 'should be equal to one of the allowed values' "),
						  A.opts.verbose &&
								(m +=
									" , schema: validate.schema" +
									$ +
									" , parentSchema: validate.schema" +
									A.schemaPath +
									" , data: " +
									B +
									" "),
						  (m += " } "))
						: (m += " {} ")
				var Ne = m
				return (
					(m = pe.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + Ne + "]); "
								: " validate.errors = [" + Ne + "]; return false; "
							: " var err = " + Ne + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += " }"),
					V && (m += " else { "),
					m
				)
			}
		},
		5192: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || "")
				if (!1 === A.opts.format) return V && (m += " if (true) { "), m
				var I,
					H = A.opts.$data && D && D.$data
				H ? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (I = "schema" + de)) : (I = D)
				var G = A.opts.unknownFormats,
					J = Array.isArray(G)
				if (H)
					(m +=
						" var " +
						(Y = "format" + de) +
						" = formats[" +
						I +
						"]; var " +
						(pe = "isObject" + de) +
						" = typeof " +
						Y +
						" == 'object' && !(" +
						Y +
						" instanceof RegExp) && " +
						Y +
						".validate; var " +
						(Ne = "formatType" + de) +
						" = " +
						pe +
						" && " +
						Y +
						".type || 'string'; if (" +
						pe +
						") { "),
						A.async && (m += " var async" + de + " = " + Y + ".async; "),
						(m += " " + Y + " = " + Y + ".validate; } if (  "),
						H && (m += " (" + I + " !== undefined && typeof " + I + " != 'string') || "),
						(m += " ("),
						"ignore" != G &&
							((m += " (" + I + " && !" + Y + " "),
							J && (m += " && self._opts.unknownFormats.indexOf(" + I + ") == -1 "),
							(m += ") || ")),
						(m += " (" + Y + " && " + Ne + " == '" + q + "' && !(typeof " + Y + " == 'function' ? "),
						(m += A.async
							? " (async" + de + " ? await " + Y + "(" + B + ") : " + Y + "(" + B + ")) "
							: " " + Y + "(" + B + ") "),
						(m += " : " + Y + ".test(" + B + "))))) {")
				else {
					var Y
					if (!(Y = A.formats[D])) {
						if ("ignore" == G)
							return (
								A.logger.warn('unknown format "' + D + '" ignored in schema at path "' + A.errSchemaPath + '"'),
								V && (m += " if (true) { "),
								m
							)
						if (J && G.indexOf(D) >= 0) return V && (m += " if (true) { "), m
						throw new Error('unknown format "' + D + '" is used in schema at path "' + A.errSchemaPath + '"')
					}
					var pe,
						Ne = ((pe = "object" == typeof Y && !(Y instanceof RegExp) && Y.validate) && Y.type) || "string"
					if (pe) {
						var ye = !0 === Y.async
						Y = Y.validate
					}
					if (Ne != q) return V && (m += " if (true) { "), m
					if (ye) {
						if (!A.async) throw new Error("async format in sync schema")
						m += " if (!(await " + (Qe = "formats" + A.util.getProperty(D) + ".validate") + "(" + B + "))) { "
					} else {
						m += " if (! "
						var Qe = "formats" + A.util.getProperty(D)
						pe && (Qe += ".validate"),
							(m += "function" == typeof Y ? " " + Qe + "(" + B + ") " : " " + Qe + ".test(" + B + ") "),
							(m += ") { ")
					}
				}
				var Je = Je || []
				Je.push(m),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: 'format' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { format:  "),
						  (m += H ? "" + I : "" + A.util.toQuotedString(D)),
						  (m += "  } "),
						  !1 !== A.opts.messages &&
								((m += " , message: 'should match format \""),
								(m += H ? "' + " + I + " + '" : "" + A.util.escapeQuotes(D)),
								(m += "\"' ")),
						  A.opts.verbose &&
								((m += " , schema:  "),
								(m += H ? "validate.schema" + $ : "" + A.util.toQuotedString(D)),
								(m += "         , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " ")),
						  (m += " } "))
						: (m += " {} ")
				var Ce = m
				return (
					(m = Je.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + Ce + "]); "
								: " validate.errors = [" + Ce + "]; return false; "
							: " var err = " + Ce + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += " } "),
					V && (m += " else { "),
					m
				)
			}
		},
		5341: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = "errs__" + de,
					G = A.util.copy(A)
				G.level++
				var J = "valid" + G.level,
					Y = A.schema.then,
					pe = A.schema.else,
					Ne =
						void 0 !== Y &&
						(A.opts.strictKeywords
							? ("object" == typeof Y && Object.keys(Y).length > 0) || !1 === Y
							: A.util.schemaHasRules(Y, A.RULES.all)),
					ye =
						void 0 !== pe &&
						(A.opts.strictKeywords
							? ("object" == typeof pe && Object.keys(pe).length > 0) || !1 === pe
							: A.util.schemaHasRules(pe, A.RULES.all)),
					Qe = G.baseId
				if (Ne || ye) {
					var Je
					;(G.createErrors = !1),
						(G.schema = D),
						(G.schemaPath = $),
						(G.errSchemaPath = R),
						(m += " var " + I + " = errors; var " + H + " = true;  ")
					var Ce = A.compositeRule
					;(A.compositeRule = G.compositeRule = !0),
						(m += "  " + A.validate(G) + " "),
						(G.baseId = Qe),
						(G.createErrors = !0),
						(m +=
							"  errors = " +
							I +
							"; if (vErrors !== null) { if (" +
							I +
							") vErrors.length = " +
							I +
							"; else vErrors = null; }  "),
						(A.compositeRule = G.compositeRule = Ce),
						Ne
							? ((m += " if (" + J + ") {  "),
							  (G.schema = A.schema.then),
							  (G.schemaPath = A.schemaPath + ".then"),
							  (G.errSchemaPath = A.errSchemaPath + "/then"),
							  (m += "  " + A.validate(G) + " "),
							  (G.baseId = Qe),
							  (m += " " + H + " = " + J + "; "),
							  Ne && ye ? (m += " var " + (Je = "ifClause" + de) + " = 'then'; ") : (Je = "'then'"),
							  (m += " } "),
							  ye && (m += " else { "))
							: (m += " if (!" + J + ") { "),
						ye &&
							((G.schema = A.schema.else),
							(G.schemaPath = A.schemaPath + ".else"),
							(G.errSchemaPath = A.errSchemaPath + "/else"),
							(m += "  " + A.validate(G) + " "),
							(G.baseId = Qe),
							(m += " " + H + " = " + J + "; "),
							Ne && ye ? (m += " var " + (Je = "ifClause" + de) + " = 'else'; ") : (Je = "'else'"),
							(m += " } ")),
						(m += " if (!" + H + ") {   var err =   "),
						!1 !== A.createErrors
							? ((m +=
									" { keyword: 'if' , dataPath: (dataPath || '') + " +
									A.errorPath +
									" , schemaPath: " +
									A.util.toQuotedString(R) +
									" , params: { failingKeyword: " +
									Je +
									" } "),
							  !1 !== A.opts.messages && (m += " , message: 'should match \"' + " + Je + " + '\" schema' "),
							  A.opts.verbose &&
									(m +=
										" , schema: validate.schema" +
										$ +
										" , parentSchema: validate.schema" +
										A.schemaPath +
										" , data: " +
										B +
										" "),
							  (m += " } "))
							: (m += " {} "),
						(m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
						!A.compositeRule &&
							V &&
							(m += A.async ? " throw new ValidationError(vErrors); " : " validate.errors = vErrors; return false; "),
						(m += " }   "),
						V && (m += " else { ")
				} else V && (m += " if (true) { ")
				return m
			}
		},
		5986: (ct, ft, A) => {
			"use strict"
			ct.exports = {
				$ref: A(9255),
				allOf: A(4842),
				anyOf: A(7825),
				$comment: A(3235),
				const: A(3295),
				contains: A(1710),
				dependencies: A(4992),
				enum: A(3387),
				format: A(5192),
				if: A(5341),
				items: A(2989),
				maximum: A(5112),
				minimum: A(5112),
				maxItems: A(3195),
				minItems: A(3195),
				maxLength: A(1504),
				minLength: A(1504),
				maxProperties: A(2724),
				minProperties: A(2724),
				multipleOf: A(7285),
				not: A(4999),
				oneOf: A(9002),
				pattern: A(8386),
				properties: A(1719),
				propertyNames: A(555),
				required: A(8244),
				uniqueItems: A(8306),
				validate: A(751)
			}
		},
		2989: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = "errs__" + de,
					G = A.util.copy(A),
					J = ""
				G.level++
				var Y = "valid" + G.level,
					pe = "i" + de,
					Ne = (G.dataLevel = A.dataLevel + 1),
					ye = "data" + Ne,
					Qe = A.baseId
				if (((m += "var " + I + " = errors;var " + H + ";"), Array.isArray(D))) {
					var Je = A.schema.additionalItems
					if (!1 === Je) {
						m += " " + H + " = " + B + ".length <= " + D.length + "; "
						var Ce = R
						R = A.errSchemaPath + "/additionalItems"
						var We = We || []
						We.push((m += "  if (!" + H + ") {   ")),
							(m = ""),
							!1 !== A.createErrors
								? ((m +=
										" { keyword: 'additionalItems' , dataPath: (dataPath || '') + " +
										A.errorPath +
										" , schemaPath: " +
										A.util.toQuotedString(R) +
										" , params: { limit: " +
										D.length +
										" } "),
								  !1 !== A.opts.messages && (m += " , message: 'should NOT have more than " + D.length + " items' "),
								  A.opts.verbose &&
										(m += " , schema: false , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " "),
								  (m += " } "))
								: (m += " {} ")
						var it = m
						;(m = We.pop()),
							(m +=
								!A.compositeRule && V
									? A.async
										? " throw new ValidationError([" + it + "]); "
										: " validate.errors = [" + it + "]; return false; "
									: " var err = " + it + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
							(m += " } "),
							(R = Ce),
							V && ((J += "}"), (m += " else { "))
					}
					var Ue = D
					if (Ue)
						for (var st, et = -1, ke = Ue.length - 1; et < ke; )
							if (
								((st = Ue[(et += 1)]),
								A.opts.strictKeywords
									? ("object" == typeof st && Object.keys(st).length > 0) || !1 === st
									: A.util.schemaHasRules(st, A.RULES.all))
							) {
								m += " " + Y + " = true; if (" + B + ".length > " + et + ") { "
								var he = B + "[" + et + "]"
								;(G.schema = st),
									(G.schemaPath = $ + "[" + et + "]"),
									(G.errSchemaPath = R + "/" + et),
									(G.errorPath = A.util.getPathExpr(A.errorPath, et, A.opts.jsonPointers, !0)),
									(G.dataPathArr[Ne] = et)
								var Ve = A.validate(G)
								;(G.baseId = Qe),
									A.util.varOccurences(Ve, ye) < 2
										? (m += " " + A.util.varReplace(Ve, ye, he) + " ")
										: (m += " var " + ye + " = " + he + "; " + Ve + " "),
									(m += " }  "),
									V && ((m += " if (" + Y + ") { "), (J += "}"))
							}
					"object" == typeof Je &&
						(A.opts.strictKeywords
							? ("object" == typeof Je && Object.keys(Je).length > 0) || !1 === Je
							: A.util.schemaHasRules(Je, A.RULES.all)) &&
						((G.schema = Je),
						(G.schemaPath = A.schemaPath + ".additionalItems"),
						(G.errSchemaPath = A.errSchemaPath + "/additionalItems"),
						(m +=
							" " +
							Y +
							" = true; if (" +
							B +
							".length > " +
							D.length +
							") {  for (var " +
							pe +
							" = " +
							D.length +
							"; " +
							pe +
							" < " +
							B +
							".length; " +
							pe +
							"++) { "),
						(G.errorPath = A.util.getPathExpr(A.errorPath, pe, A.opts.jsonPointers, !0)),
						(he = B + "[" + pe + "]"),
						(G.dataPathArr[Ne] = pe),
						(Ve = A.validate(G)),
						(G.baseId = Qe),
						A.util.varOccurences(Ve, ye) < 2
							? (m += " " + A.util.varReplace(Ve, ye, he) + " ")
							: (m += " var " + ye + " = " + he + "; " + Ve + " "),
						V && (m += " if (!" + Y + ") break; "),
						(m += " } }  "),
						V && ((m += " if (" + Y + ") { "), (J += "}")))
				} else
					(A.opts.strictKeywords
						? ("object" == typeof D && Object.keys(D).length > 0) || !1 === D
						: A.util.schemaHasRules(D, A.RULES.all)) &&
						((G.schema = D),
						(G.schemaPath = $),
						(G.errSchemaPath = R),
						(m += "  for (var " + pe + " = 0; " + pe + " < " + B + ".length; " + pe + "++) { "),
						(G.errorPath = A.util.getPathExpr(A.errorPath, pe, A.opts.jsonPointers, !0)),
						(he = B + "[" + pe + "]"),
						(G.dataPathArr[Ne] = pe),
						(Ve = A.validate(G)),
						(G.baseId = Qe),
						A.util.varOccurences(Ve, ye) < 2
							? (m += " " + A.util.varReplace(Ve, ye, he) + " ")
							: (m += " var " + ye + " = " + he + "; " + Ve + " "),
						V && (m += " if (!" + Y + ") break; "),
						(m += " }"))
				return V && (m += " " + J + " if (" + I + " == errors) {"), m
			}
		},
		7285: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var I,
					m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = A.opts.$data && D && D.$data
				if (
					(H
						? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (I = "schema" + de))
						: (I = D),
					!H && "number" != typeof D)
				)
					throw new Error(X + " must be number")
				;(m += "var division" + de + ";if ("),
					H && (m += " " + I + " !== undefined && ( typeof " + I + " != 'number' || "),
					(m += " (division" + de + " = " + B + " / " + I + ", "),
					(m += A.opts.multipleOfPrecision
						? " Math.abs(Math.round(division" + de + ") - division" + de + ") > 1e-" + A.opts.multipleOfPrecision + " "
						: " division" + de + " !== parseInt(division" + de + ") "),
					(m += " ) "),
					H && (m += "  )  ")
				var G = G || []
				G.push((m += " ) {   ")),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: 'multipleOf' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { multipleOf: " +
								I +
								" } "),
						  !1 !== A.opts.messages && ((m += " , message: 'should be multiple of "), (m += H ? "' + " + I : I + "'")),
						  A.opts.verbose &&
								((m += " , schema:  "),
								(m += H ? "validate.schema" + $ : "" + D),
								(m += "         , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " ")),
						  (m += " } "))
						: (m += " {} ")
				var J = m
				return (
					(m = G.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + J + "]); "
								: " validate.errors = [" + J + "]; return false; "
							: " var err = " + J + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += "} "),
					V && (m += " else { "),
					m
				)
			}
		},
		4999: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "errs__" + de,
					I = A.util.copy(A)
				I.level++
				var G = "valid" + I.level
				if (
					A.opts.strictKeywords
						? ("object" == typeof D && Object.keys(D).length > 0) || !1 === D
						: A.util.schemaHasRules(D, A.RULES.all)
				) {
					;(I.schema = D), (I.schemaPath = $), (I.errSchemaPath = R), (m += " var " + H + " = errors;  ")
					var Y,
						J = A.compositeRule
					;(A.compositeRule = I.compositeRule = !0),
						(I.createErrors = !1),
						I.opts.allErrors && ((Y = I.opts.allErrors), (I.opts.allErrors = !1)),
						(m += " " + A.validate(I) + " "),
						(I.createErrors = !0),
						Y && (I.opts.allErrors = Y),
						(A.compositeRule = I.compositeRule = J)
					var pe = pe || []
					pe.push((m += " if (" + G + ") {   ")),
						(m = ""),
						!1 !== A.createErrors
							? ((m +=
									" { keyword: 'not' , dataPath: (dataPath || '') + " +
									A.errorPath +
									" , schemaPath: " +
									A.util.toQuotedString(R) +
									" , params: {} "),
							  !1 !== A.opts.messages && (m += " , message: 'should NOT be valid' "),
							  A.opts.verbose &&
									(m +=
										" , schema: validate.schema" +
										$ +
										" , parentSchema: validate.schema" +
										A.schemaPath +
										" , data: " +
										B +
										" "),
							  (m += " } "))
							: (m += " {} ")
					var Ne = m
					;(m = pe.pop()),
						(m +=
							!A.compositeRule && V
								? A.async
									? " throw new ValidationError([" + Ne + "]); "
									: " validate.errors = [" + Ne + "]; return false; "
								: " var err = " + Ne + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
						(m +=
							" } else {  errors = " +
							H +
							"; if (vErrors !== null) { if (" +
							H +
							") vErrors.length = " +
							H +
							"; else vErrors = null; } "),
						A.opts.allErrors && (m += " } ")
				} else
					(m += "  var err =   "),
						!1 !== A.createErrors
							? ((m +=
									" { keyword: 'not' , dataPath: (dataPath || '') + " +
									A.errorPath +
									" , schemaPath: " +
									A.util.toQuotedString(R) +
									" , params: {} "),
							  !1 !== A.opts.messages && (m += " , message: 'should NOT be valid' "),
							  A.opts.verbose &&
									(m +=
										" , schema: validate.schema" +
										$ +
										" , parentSchema: validate.schema" +
										A.schemaPath +
										" , data: " +
										B +
										" "),
							  (m += " } "))
							: (m += " {} "),
						(m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
						V && (m += " if (false) { ")
				return m
			}
		},
		9002: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = "errs__" + de,
					G = A.util.copy(A),
					J = ""
				G.level++
				var Y = "valid" + G.level,
					pe = G.baseId,
					Ne = "prevValid" + de,
					ye = "passingSchemas" + de
				m += "var " + I + " = errors , " + Ne + " = false , " + H + " = false , " + ye + " = null; "
				var Qe = A.compositeRule
				A.compositeRule = G.compositeRule = !0
				var Je = D
				if (Je)
					for (var Ce, We = -1, it = Je.length - 1; We < it; )
						(Ce = Je[(We += 1)]),
							(
								A.opts.strictKeywords
									? ("object" == typeof Ce && Object.keys(Ce).length > 0) || !1 === Ce
									: A.util.schemaHasRules(Ce, A.RULES.all)
							)
								? ((G.schema = Ce),
								  (G.schemaPath = $ + "[" + We + "]"),
								  (G.errSchemaPath = R + "/" + We),
								  (m += "  " + A.validate(G) + " "),
								  (G.baseId = pe))
								: (m += " var " + Y + " = true; "),
							We &&
								((m +=
									" if (" + Y + " && " + Ne + ") { " + H + " = false; " + ye + " = [" + ye + ", " + We + "]; } else { "),
								(J += "}")),
							(m += " if (" + Y + ") { " + H + " = " + Ne + " = true; " + ye + " = " + We + "; }")
				return (
					(A.compositeRule = G.compositeRule = Qe),
					(m += J + "if (!" + H + ") {   var err =   "),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: 'oneOf' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { passingSchemas: " +
								ye +
								" } "),
						  !1 !== A.opts.messages && (m += " , message: 'should match exactly one schema in oneOf' "),
						  A.opts.verbose &&
								(m +=
									" , schema: validate.schema" +
									$ +
									" , parentSchema: validate.schema" +
									A.schemaPath +
									" , data: " +
									B +
									" "),
						  (m += " } "))
						: (m += " {} "),
					(m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					!A.compositeRule &&
						V &&
						(m += A.async ? " throw new ValidationError(vErrors); " : " validate.errors = vErrors; return false; "),
					(m +=
						"} else {  errors = " +
						I +
						"; if (vErrors !== null) { if (" +
						I +
						") vErrors.length = " +
						I +
						"; else vErrors = null; }"),
					A.opts.allErrors && (m += " } "),
					m
				)
			}
		},
		8386: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var I,
					m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = A.opts.$data && D && D.$data
				H ? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (I = "schema" + de)) : (I = D)
				var G = H ? "(new RegExp(" + I + "))" : A.usePattern(D)
				;(m += "if ( "), H && (m += " (" + I + " !== undefined && typeof " + I + " != 'string') || ")
				var J = J || []
				J.push((m += " !" + G + ".test(" + B + ") ) {   ")),
					(m = ""),
					!1 !== A.createErrors
						? ((m +=
								" { keyword: 'pattern' , dataPath: (dataPath || '') + " +
								A.errorPath +
								" , schemaPath: " +
								A.util.toQuotedString(R) +
								" , params: { pattern:  "),
						  (m += H ? "" + I : "" + A.util.toQuotedString(D)),
						  (m += "  } "),
						  !1 !== A.opts.messages &&
								((m += " , message: 'should match pattern \""),
								(m += H ? "' + " + I + " + '" : "" + A.util.escapeQuotes(D)),
								(m += "\"' ")),
						  A.opts.verbose &&
								((m += " , schema:  "),
								(m += H ? "validate.schema" + $ : "" + A.util.toQuotedString(D)),
								(m += "         , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " ")),
						  (m += " } "))
						: (m += " {} ")
				var Y = m
				return (
					(m = J.pop()),
					(m +=
						!A.compositeRule && V
							? A.async
								? " throw new ValidationError([" + Y + "]); "
								: " validate.errors = [" + Y + "]; return false; "
							: " var err = " + Y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
					(m += "} "),
					V && (m += " else { "),
					m
				)
			}
		},
		1719: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "errs__" + de,
					I = A.util.copy(A),
					G = ""
				I.level++
				var J = "valid" + I.level,
					Y = "key" + de,
					pe = "idx" + de,
					Ne = (I.dataLevel = A.dataLevel + 1),
					ye = "data" + Ne,
					Qe = "dataProperties" + de,
					Je = Object.keys(D || {}).filter(qe),
					Ce = A.schema.patternProperties || {},
					We = Object.keys(Ce).filter(qe),
					it = A.schema.additionalProperties,
					Ue = Je.length || We.length,
					st = !1 === it,
					et = "object" == typeof it && Object.keys(it).length,
					ke = A.opts.removeAdditional,
					he = st || et || ke,
					Ve = A.opts.ownProperties,
					je = A.baseId,
					Re = A.schema.required
				if (Re && (!A.opts.$data || !Re.$data) && Re.length < A.opts.loopRequired) var ze = A.util.toHash(Re)
				function qe(rs) {
					return "__proto__" !== rs
				}
				if (((m += "var " + H + " = errors;var " + J + " = true;"), Ve && (m += " var " + Qe + " = undefined;"), he)) {
					if (
						((m += Ve
							? " " +
							  Qe +
							  " = " +
							  Qe +
							  " || Object.keys(" +
							  B +
							  "); for (var " +
							  pe +
							  "=0; " +
							  pe +
							  "<" +
							  Qe +
							  ".length; " +
							  pe +
							  "++) { var " +
							  Y +
							  " = " +
							  Qe +
							  "[" +
							  pe +
							  "]; "
							: " for (var " + Y + " in " + B + ") { "),
						Ue)
					) {
						if (((m += " var isAdditional" + de + " = !(false "), Je.length))
							if (Je.length > 8) m += " || validate.schema" + $ + ".hasOwnProperty(" + Y + ") "
							else {
								var Ge = Je
								if (Ge)
									for (var Jt = -1, yn = Ge.length - 1; Jt < yn; )
										(wt = Ge[(Jt += 1)]), (m += " || " + Y + " == " + A.util.toQuotedString(wt) + " ")
							}
						if (We.length) {
							var ai = We
							if (ai)
								for (var hi = -1, yi = ai.length - 1; hi < yi; )
									(vt = ai[(hi += 1)]), (m += " || " + A.usePattern(vt) + ".test(" + Y + ") ")
						}
						m += " ); if (isAdditional" + de + ") { "
					}
					if ("all" == ke) m += " delete " + B + "[" + Y + "]; "
					else {
						var Wt = A.errorPath,
							we = "' + " + Y + " + '"
						if ((A.opts._errorDataPathProperty && (A.errorPath = A.util.getPathExpr(A.errorPath, Y, A.opts.jsonPointers)), st))
							if (ke) m += " delete " + B + "[" + Y + "]; "
							else {
								var gt = R
								;(R = A.errSchemaPath + "/additionalProperties"),
									(Ke = Ke || []).push((m += " " + J + " = false; ")),
									(m = ""),
									!1 !== A.createErrors
										? ((m +=
												" { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " +
												A.errorPath +
												" , schemaPath: " +
												A.util.toQuotedString(R) +
												" , params: { additionalProperty: '" +
												we +
												"' } "),
										  !1 !== A.opts.messages &&
												((m += " , message: '"),
												(m += A.opts._errorDataPathProperty
													? "is an invalid additional property"
													: "should NOT have additional properties"),
												(m += "' ")),
										  A.opts.verbose &&
												(m +=
													" , schema: false , parentSchema: validate.schema" +
													A.schemaPath +
													" , data: " +
													B +
													" "),
										  (m += " } "))
										: (m += " {} ")
								var fn = m
								;(m = Ke.pop()),
									(m +=
										!A.compositeRule && V
											? A.async
												? " throw new ValidationError([" + fn + "]); "
												: " validate.errors = [" + fn + "]; return false; "
											: " var err = " +
											  fn +
											  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
									(R = gt),
									V && (m += " break; ")
							}
						else if (et)
							if ("failing" == ke) {
								m += " var " + H + " = errors;  "
								var St = A.compositeRule
								;(A.compositeRule = I.compositeRule = !0),
									(I.schema = it),
									(I.schemaPath = A.schemaPath + ".additionalProperties"),
									(I.errSchemaPath = A.errSchemaPath + "/additionalProperties"),
									(I.errorPath = A.opts._errorDataPathProperty
										? A.errorPath
										: A.util.getPathExpr(A.errorPath, Y, A.opts.jsonPointers))
								var Dt = B + "[" + Y + "]"
								I.dataPathArr[Ne] = Y
								var gn = A.validate(I)
								;(I.baseId = je),
									A.util.varOccurences(gn, ye) < 2
										? (m += " " + A.util.varReplace(gn, ye, Dt) + " ")
										: (m += " var " + ye + " = " + Dt + "; " + gn + " "),
									(m +=
										" if (!" +
										J +
										") { errors = " +
										H +
										"; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " +
										B +
										"[" +
										Y +
										"]; }  "),
									(A.compositeRule = I.compositeRule = St)
							} else
								(I.schema = it),
									(I.schemaPath = A.schemaPath + ".additionalProperties"),
									(I.errSchemaPath = A.errSchemaPath + "/additionalProperties"),
									(I.errorPath = A.opts._errorDataPathProperty
										? A.errorPath
										: A.util.getPathExpr(A.errorPath, Y, A.opts.jsonPointers)),
									(Dt = B + "[" + Y + "]"),
									(I.dataPathArr[Ne] = Y),
									(gn = A.validate(I)),
									(I.baseId = je),
									A.util.varOccurences(gn, ye) < 2
										? (m += " " + A.util.varReplace(gn, ye, Dt) + " ")
										: (m += " var " + ye + " = " + Dt + "; " + gn + " "),
									V && (m += " if (!" + J + ") break; ")
						A.errorPath = Wt
					}
					Ue && (m += " } "), (m += " }  "), V && ((m += " if (" + J + ") { "), (G += "}"))
				}
				var ci = A.opts.useDefaults && !A.compositeRule
				if (Je.length) {
					var Ci = Je
					if (Ci)
						for (var wt, nr = -1, hr = Ci.length - 1; nr < hr; ) {
							var Qn = D[(wt = Ci[(nr += 1)])]
							if (
								A.opts.strictKeywords
									? ("object" == typeof Qn && Object.keys(Qn).length > 0) || !1 === Qn
									: A.util.schemaHasRules(Qn, A.RULES.all)
							) {
								var io = A.util.getProperty(wt),
									Br = ((Dt = B + io), ci && void 0 !== Qn.default)
								if (
									((I.schema = Qn),
									(I.schemaPath = $ + io),
									(I.errSchemaPath = R + "/" + A.util.escapeFragment(wt)),
									(I.errorPath = A.util.getPath(A.errorPath, wt, A.opts.jsonPointers)),
									(I.dataPathArr[Ne] = A.util.toQuotedString(wt)),
									(gn = A.validate(I)),
									(I.baseId = je),
									A.util.varOccurences(gn, ye) < 2)
								) {
									gn = A.util.varReplace(gn, ye, Dt)
									var Pi = Dt
								} else (Pi = ye), (m += " var " + ye + " = " + Dt + "; ")
								if (Br) m += " " + gn + " "
								else {
									if (ze && ze[wt]) {
										;(m += " if ( " + Pi + " === undefined "),
											Ve &&
												(m +=
													" || ! Object.prototype.hasOwnProperty.call(" +
													B +
													", '" +
													A.util.escapeQuotes(wt) +
													"') "),
											(m += ") { " + J + " = false; "),
											(Wt = A.errorPath),
											(gt = R)
										var Ke,
											Ze = A.util.escapeQuotes(wt)
										A.opts._errorDataPathProperty && (A.errorPath = A.util.getPath(Wt, wt, A.opts.jsonPointers)),
											(R = A.errSchemaPath + "/required"),
											(Ke = Ke || []).push(m),
											(m = ""),
											!1 !== A.createErrors
												? ((m +=
														" { keyword: 'required' , dataPath: (dataPath || '') + " +
														A.errorPath +
														" , schemaPath: " +
														A.util.toQuotedString(R) +
														" , params: { missingProperty: '" +
														Ze +
														"' } "),
												  !1 !== A.opts.messages &&
														((m += " , message: '"),
														(m += A.opts._errorDataPathProperty
															? "is a required property"
															: "should have required property \\'" + Ze + "\\'"),
														(m += "' ")),
												  A.opts.verbose &&
														(m +=
															" , schema: validate.schema" +
															$ +
															" , parentSchema: validate.schema" +
															A.schemaPath +
															" , data: " +
															B +
															" "),
												  (m += " } "))
												: (m += " {} "),
											(fn = m),
											(m = Ke.pop()),
											(m +=
												!A.compositeRule && V
													? A.async
														? " throw new ValidationError([" + fn + "]); "
														: " validate.errors = [" + fn + "]; return false; "
													: " var err = " +
													  fn +
													  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
											(R = gt),
											(A.errorPath = Wt),
											(m += " } else { ")
									} else
										V
											? ((m += " if ( " + Pi + " === undefined "),
											  Ve &&
													(m +=
														" || ! Object.prototype.hasOwnProperty.call(" +
														B +
														", '" +
														A.util.escapeQuotes(wt) +
														"') "),
											  (m += ") { " + J + " = true; } else { "))
											: ((m += " if (" + Pi + " !== undefined "),
											  Ve &&
													(m +=
														" &&   Object.prototype.hasOwnProperty.call(" +
														B +
														", '" +
														A.util.escapeQuotes(wt) +
														"') "),
											  (m += " ) { "))
									m += " " + gn + " } "
								}
							}
							V && ((m += " if (" + J + ") { "), (G += "}"))
						}
				}
				if (We.length) {
					var li = We
					if (li)
						for (var vt, Vr = -1, Yr = li.length - 1; Vr < Yr; )
							(Qn = Ce[(vt = li[(Vr += 1)])]),
								(A.opts.strictKeywords
									? ("object" == typeof Qn && Object.keys(Qn).length > 0) || !1 === Qn
									: A.util.schemaHasRules(Qn, A.RULES.all)) &&
									((I.schema = Qn),
									(I.schemaPath = A.schemaPath + ".patternProperties" + A.util.getProperty(vt)),
									(I.errSchemaPath = A.errSchemaPath + "/patternProperties/" + A.util.escapeFragment(vt)),
									(m += Ve
										? " " +
										  Qe +
										  " = " +
										  Qe +
										  " || Object.keys(" +
										  B +
										  "); for (var " +
										  pe +
										  "=0; " +
										  pe +
										  "<" +
										  Qe +
										  ".length; " +
										  pe +
										  "++) { var " +
										  Y +
										  " = " +
										  Qe +
										  "[" +
										  pe +
										  "]; "
										: " for (var " + Y + " in " + B + ") { "),
									(m += " if (" + A.usePattern(vt) + ".test(" + Y + ")) { "),
									(I.errorPath = A.util.getPathExpr(A.errorPath, Y, A.opts.jsonPointers)),
									(Dt = B + "[" + Y + "]"),
									(I.dataPathArr[Ne] = Y),
									(gn = A.validate(I)),
									(I.baseId = je),
									A.util.varOccurences(gn, ye) < 2
										? (m += " " + A.util.varReplace(gn, ye, Dt) + " ")
										: (m += " var " + ye + " = " + Dt + "; " + gn + " "),
									V && (m += " if (!" + J + ") break; "),
									(m += " } "),
									V && (m += " else " + J + " = true; "),
									(m += " }  "),
									V && ((m += " if (" + J + ") { "), (G += "}")))
				}
				return V && (m += " " + G + " if (" + H + " == errors) {"), m
			}
		},
		555: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "errs__" + de,
					I = A.util.copy(A)
				I.level++
				var J = "valid" + I.level
				if (
					((m += "var " + H + " = errors;"),
					A.opts.strictKeywords
						? ("object" == typeof D && Object.keys(D).length > 0) || !1 === D
						: A.util.schemaHasRules(D, A.RULES.all))
				) {
					;(I.schema = D), (I.schemaPath = $), (I.errSchemaPath = R)
					var Y = "key" + de,
						pe = "idx" + de,
						Ne = "i" + de,
						ye = "' + " + Y + " + '",
						Je = "data" + (I.dataLevel = A.dataLevel + 1),
						Ce = "dataProperties" + de,
						We = A.opts.ownProperties,
						it = A.baseId
					We && (m += " var " + Ce + " = undefined; "),
						(m += We
							? " " +
							  Ce +
							  " = " +
							  Ce +
							  " || Object.keys(" +
							  B +
							  "); for (var " +
							  pe +
							  "=0; " +
							  pe +
							  "<" +
							  Ce +
							  ".length; " +
							  pe +
							  "++) { var " +
							  Y +
							  " = " +
							  Ce +
							  "[" +
							  pe +
							  "]; "
							: " for (var " + Y + " in " + B + ") { "),
						(m += " var startErrs" + de + " = errors; ")
					var Ue = Y,
						st = A.compositeRule
					A.compositeRule = I.compositeRule = !0
					var et = A.validate(I)
					;(I.baseId = it),
						A.util.varOccurences(et, Je) < 2
							? (m += " " + A.util.varReplace(et, Je, Ue) + " ")
							: (m += " var " + Je + " = " + Ue + "; " + et + " "),
						(A.compositeRule = I.compositeRule = st),
						(m +=
							" if (!" +
							J +
							") { for (var " +
							Ne +
							"=startErrs" +
							de +
							"; " +
							Ne +
							"<errors; " +
							Ne +
							"++) { vErrors[" +
							Ne +
							"].propertyName = " +
							Y +
							"; }   var err =   "),
						!1 !== A.createErrors
							? ((m +=
									" { keyword: 'propertyNames' , dataPath: (dataPath || '') + " +
									A.errorPath +
									" , schemaPath: " +
									A.util.toQuotedString(R) +
									" , params: { propertyName: '" +
									ye +
									"' } "),
							  !1 !== A.opts.messages && (m += " , message: 'property name \\'" + ye + "\\' is invalid' "),
							  A.opts.verbose &&
									(m +=
										" , schema: validate.schema" +
										$ +
										" , parentSchema: validate.schema" +
										A.schemaPath +
										" , data: " +
										B +
										" "),
							  (m += " } "))
							: (m += " {} "),
						(m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
						!A.compositeRule &&
							V &&
							(m += A.async ? " throw new ValidationError(vErrors); " : " validate.errors = vErrors; return false; "),
						V && (m += " break; "),
						(m += " } }")
				}
				return V && (m += "  if (" + H + " == errors) {"), m
			}
		},
		9255: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var H,
					I,
					m = " ",
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.errSchemaPath + "/" + X,
					R = !A.opts.allErrors,
					V = "data" + (Q || ""),
					B = "valid" + A.level
				if ("#" == D || "#/" == D)
					A.isRoot ? ((H = A.async), (I = "validate")) : ((H = !0 === A.root.schema.$async), (I = "root.refVal[0]"))
				else {
					var G = A.resolveRef(A.baseId, D, A.isRoot)
					if (void 0 === G) {
						var J = A.MissingRefError.message(A.baseId, D)
						if ("fail" == A.opts.missingRefs) {
							A.logger.error(J),
								(Y = Y || []).push(m),
								(m = ""),
								!1 !== A.createErrors
									? ((m +=
											" { keyword: '$ref' , dataPath: (dataPath || '') + " +
											A.errorPath +
											" , schemaPath: " +
											A.util.toQuotedString($) +
											" , params: { ref: '" +
											A.util.escapeQuotes(D) +
											"' } "),
									  !1 !== A.opts.messages &&
											(m += " , message: 'can\\'t resolve reference " + A.util.escapeQuotes(D) + "' "),
									  A.opts.verbose &&
											(m +=
												" , schema: " +
												A.util.toQuotedString(D) +
												" , parentSchema: validate.schema" +
												A.schemaPath +
												" , data: " +
												V +
												" "),
									  (m += " } "))
									: (m += " {} ")
							var pe = m
							;(m = Y.pop()),
								(m +=
									!A.compositeRule && R
										? A.async
											? " throw new ValidationError([" + pe + "]); "
											: " validate.errors = [" + pe + "]; return false; "
										: " var err = " +
										  pe +
										  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
								R && (m += " if (false) { ")
						} else {
							if ("ignore" != A.opts.missingRefs) throw new A.MissingRefError(A.baseId, D, J)
							A.logger.warn(J), R && (m += " if (true) { ")
						}
					} else if (G.inline) {
						var Ne = A.util.copy(A)
						Ne.level++
						var ye = "valid" + Ne.level
						;(Ne.schema = G.schema),
							(Ne.schemaPath = ""),
							(Ne.errSchemaPath = D),
							(m += " " + A.validate(Ne).replace(/validate\.schema/g, G.code) + " "),
							R && (m += " if (" + ye + ") { ")
					} else (H = !0 === G.$async || (A.async && !1 !== G.$async)), (I = G.code)
				}
				if (I) {
					var Y
					;(Y = Y || []).push(m),
						(m = ""),
						(m += A.opts.passContext ? " " + I + ".call(this, " : " " + I + "( "),
						(m += " " + V + ", (dataPath || '')"),
						'""' != A.errorPath && (m += " + " + A.errorPath)
					var We = (m +=
						" , " +
						(Q ? "data" + (Q - 1 || "") : "parentData") +
						" , " +
						(Q ? A.dataPathArr[Q] : "parentDataProperty") +
						", rootData)  ")
					if (((m = Y.pop()), H)) {
						if (!A.async) throw new Error("async schema referenced by sync schema")
						R && (m += " var " + B + "; "),
							(m += " try { await " + We + "; "),
							R && (m += " " + B + " = true; "),
							(m +=
								" } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; "),
							R && (m += " " + B + " = false; "),
							(m += " } "),
							R && (m += " if (" + B + ") { ")
					} else
						(m +=
							" if (!" +
							We +
							") { if (vErrors === null) vErrors = " +
							I +
							".errors; else vErrors = vErrors.concat(" +
							I +
							".errors); errors = vErrors.length; } "),
							R && (m += " else { ")
				}
				return m
			}
		},
		8244: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = A.opts.$data && D && D.$data
				I && (m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; ")
				var J = "schema" + de
				if (!I)
					if (D.length < A.opts.loopRequired && A.schema.properties && Object.keys(A.schema.properties).length) {
						var Y = [],
							pe = D
						if (pe)
							for (var Ne, ye = -1, Qe = pe.length - 1; ye < Qe; ) {
								Ne = pe[(ye += 1)]
								var Je = A.schema.properties[Ne]
								;(Je &&
									(A.opts.strictKeywords
										? ("object" == typeof Je && Object.keys(Je).length > 0) || !1 === Je
										: A.util.schemaHasRules(Je, A.RULES.all))) ||
									(Y[Y.length] = Ne)
							}
					} else Y = D
				if (I || Y.length) {
					var Ce = A.errorPath,
						We = I || Y.length >= A.opts.loopRequired,
						it = A.opts.ownProperties
					if (V)
						if (((m += " var missing" + de + "; "), We)) {
							I || (m += " var " + J + " = validate.schema" + $ + "; ")
							var et = "' + " + (st = "schema" + de + "[" + (Ue = "i" + de) + "]") + " + '"
							A.opts._errorDataPathProperty && (A.errorPath = A.util.getPathExpr(Ce, st, A.opts.jsonPointers)),
								(m += " var " + H + " = true; "),
								I &&
									(m +=
										" if (schema" +
										de +
										" === undefined) " +
										H +
										" = true; else if (!Array.isArray(schema" +
										de +
										")) " +
										H +
										" = false; else {"),
								(m +=
									" for (var " +
									Ue +
									" = 0; " +
									Ue +
									" < " +
									J +
									".length; " +
									Ue +
									"++) { " +
									H +
									" = " +
									B +
									"[" +
									J +
									"[" +
									Ue +
									"]] !== undefined "),
								it && (m += " &&   Object.prototype.hasOwnProperty.call(" + B + ", " + J + "[" + Ue + "]) "),
								(m += "; if (!" + H + ") break; } "),
								I && (m += "  }  "),
								(ke = ke || []).push((m += "  if (!" + H + ") {   ")),
								(m = ""),
								!1 !== A.createErrors
									? ((m +=
											" { keyword: 'required' , dataPath: (dataPath || '') + " +
											A.errorPath +
											" , schemaPath: " +
											A.util.toQuotedString(R) +
											" , params: { missingProperty: '" +
											et +
											"' } "),
									  !1 !== A.opts.messages &&
											((m += " , message: '"),
											(m += A.opts._errorDataPathProperty
												? "is a required property"
												: "should have required property \\'" + et + "\\'"),
											(m += "' ")),
									  A.opts.verbose &&
											(m +=
												" , schema: validate.schema" +
												$ +
												" , parentSchema: validate.schema" +
												A.schemaPath +
												" , data: " +
												B +
												" "),
									  (m += " } "))
									: (m += " {} ")
							var he = m
							;(m = ke.pop()),
								(m +=
									!A.compositeRule && V
										? A.async
											? " throw new ValidationError([" + he + "]); "
											: " validate.errors = [" + he + "]; return false; "
										: " var err = " +
										  he +
										  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
								(m += " } else { ")
						} else {
							m += " if ( "
							var ke,
								Ve = Y
							if (Ve)
								for (var Ue = -1, Re = Ve.length - 1; Ue < Re; )
									(je = Ve[(Ue += 1)]),
										Ue && (m += " || "),
										(m += " ( ( " + (qe = B + (ze = A.util.getProperty(je))) + " === undefined "),
										it &&
											(m +=
												" || ! Object.prototype.hasOwnProperty.call(" +
												B +
												", '" +
												A.util.escapeQuotes(je) +
												"') "),
										(m += ") && (missing" + de + " = " + A.util.toQuotedString(A.opts.jsonPointers ? je : ze) + ") ) ")
							;(m += ") {  "),
								(et = "' + " + (st = "missing" + de) + " + '"),
								A.opts._errorDataPathProperty &&
									(A.errorPath = A.opts.jsonPointers ? A.util.getPathExpr(Ce, st, !0) : Ce + " + " + st),
								(ke = ke || []).push(m),
								(m = ""),
								!1 !== A.createErrors
									? ((m +=
											" { keyword: 'required' , dataPath: (dataPath || '') + " +
											A.errorPath +
											" , schemaPath: " +
											A.util.toQuotedString(R) +
											" , params: { missingProperty: '" +
											et +
											"' } "),
									  !1 !== A.opts.messages &&
											((m += " , message: '"),
											(m += A.opts._errorDataPathProperty
												? "is a required property"
												: "should have required property \\'" + et + "\\'"),
											(m += "' ")),
									  A.opts.verbose &&
											(m +=
												" , schema: validate.schema" +
												$ +
												" , parentSchema: validate.schema" +
												A.schemaPath +
												" , data: " +
												B +
												" "),
									  (m += " } "))
									: (m += " {} "),
								(he = m),
								(m = ke.pop()),
								(m +=
									!A.compositeRule && V
										? A.async
											? " throw new ValidationError([" + he + "]); "
											: " validate.errors = [" + he + "]; return false; "
										: " var err = " +
										  he +
										  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
								(m += " } else { ")
						}
					else if (We) {
						var st
						I || (m += " var " + J + " = validate.schema" + $ + "; "),
							(et = "' + " + (st = "schema" + de + "[" + (Ue = "i" + de) + "]") + " + '"),
							A.opts._errorDataPathProperty && (A.errorPath = A.util.getPathExpr(Ce, st, A.opts.jsonPointers)),
							I &&
								((m += " if (" + J + " && !Array.isArray(" + J + ")) {  var err =   "),
								!1 !== A.createErrors
									? ((m +=
											" { keyword: 'required' , dataPath: (dataPath || '') + " +
											A.errorPath +
											" , schemaPath: " +
											A.util.toQuotedString(R) +
											" , params: { missingProperty: '" +
											et +
											"' } "),
									  !1 !== A.opts.messages &&
											((m += " , message: '"),
											(m += A.opts._errorDataPathProperty
												? "is a required property"
												: "should have required property \\'" + et + "\\'"),
											(m += "' ")),
									  A.opts.verbose &&
											(m +=
												" , schema: validate.schema" +
												$ +
												" , parentSchema: validate.schema" +
												A.schemaPath +
												" , data: " +
												B +
												" "),
									  (m += " } "))
									: (m += " {} "),
								(m +=
									";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" +
									J +
									" !== undefined) { ")),
							(m +=
								" for (var " +
								Ue +
								" = 0; " +
								Ue +
								" < " +
								J +
								".length; " +
								Ue +
								"++) { if (" +
								B +
								"[" +
								J +
								"[" +
								Ue +
								"]] === undefined "),
							it && (m += " || ! Object.prototype.hasOwnProperty.call(" + B + ", " + J + "[" + Ue + "]) "),
							(m += ") {  var err =   "),
							!1 !== A.createErrors
								? ((m +=
										" { keyword: 'required' , dataPath: (dataPath || '') + " +
										A.errorPath +
										" , schemaPath: " +
										A.util.toQuotedString(R) +
										" , params: { missingProperty: '" +
										et +
										"' } "),
								  !1 !== A.opts.messages &&
										((m += " , message: '"),
										(m += A.opts._errorDataPathProperty
											? "is a required property"
											: "should have required property \\'" + et + "\\'"),
										(m += "' ")),
								  A.opts.verbose &&
										(m +=
											" , schema: validate.schema" +
											$ +
											" , parentSchema: validate.schema" +
											A.schemaPath +
											" , data: " +
											B +
											" "),
								  (m += " } "))
								: (m += " {} "),
							(m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } "),
							I && (m += "  }  ")
					} else {
						var Ge = Y
						if (Ge)
							for (var je, wt = -1, Jt = Ge.length - 1; wt < Jt; ) {
								je = Ge[(wt += 1)]
								var ze = A.util.getProperty(je),
									qe = ((et = A.util.escapeQuotes(je)), B + ze)
								A.opts._errorDataPathProperty && (A.errorPath = A.util.getPath(Ce, je, A.opts.jsonPointers)),
									(m += " if ( " + qe + " === undefined "),
									it &&
										(m += " || ! Object.prototype.hasOwnProperty.call(" + B + ", '" + A.util.escapeQuotes(je) + "') "),
									(m += ") {  var err =   "),
									!1 !== A.createErrors
										? ((m +=
												" { keyword: 'required' , dataPath: (dataPath || '') + " +
												A.errorPath +
												" , schemaPath: " +
												A.util.toQuotedString(R) +
												" , params: { missingProperty: '" +
												et +
												"' } "),
										  !1 !== A.opts.messages &&
												((m += " , message: '"),
												(m += A.opts._errorDataPathProperty
													? "is a required property"
													: "should have required property \\'" + et + "\\'"),
												(m += "' ")),
										  A.opts.verbose &&
												(m +=
													" , schema: validate.schema" +
													$ +
													" , parentSchema: validate.schema" +
													A.schemaPath +
													" , data: " +
													B +
													" "),
										  (m += " } "))
										: (m += " {} "),
									(m += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ")
							}
					}
					A.errorPath = Ce
				} else V && (m += " if (true) {")
				return m
			}
		},
		8306: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var G,
					m = " ",
					de = A.level,
					Q = A.dataLevel,
					D = A.schema[X],
					$ = A.schemaPath + A.util.getProperty(X),
					R = A.errSchemaPath + "/" + X,
					V = !A.opts.allErrors,
					B = "data" + (Q || ""),
					H = "valid" + de,
					I = A.opts.$data && D && D.$data
				if (
					(I
						? ((m += " var schema" + de + " = " + A.util.getData(D.$data, Q, A.dataPathArr) + "; "), (G = "schema" + de))
						: (G = D),
					(D || I) && !1 !== A.opts.uniqueItems)
				) {
					I &&
						(m +=
							" var " +
							H +
							"; if (" +
							G +
							" === false || " +
							G +
							" === undefined) " +
							H +
							" = true; else if (typeof " +
							G +
							" != 'boolean') " +
							H +
							" = false; else { "),
						(m += " var i = " + B + ".length , " + H + " = true , j; if (i > 1) { ")
					var J = A.schema.items && A.schema.items.type,
						Y = Array.isArray(J)
					!J || "object" == J || "array" == J || (Y && (J.indexOf("object") >= 0 || J.indexOf("array") >= 0))
						? (m +=
								" outer: for (;i--;) { for (j = i; j--;) { if (equal(" +
								B +
								"[i], " +
								B +
								"[j])) { " +
								H +
								" = false; break outer; } } } ")
						: ((m += " var itemIndices = {}, item; for (;i--;) { var item = " + B + "[i]; "),
						  (m += " if (" + A.util["checkDataType" + (Y ? "s" : "")](J, "item", A.opts.strictNumbers, !0) + ") continue; "),
						  Y && (m += " if (typeof item == 'string') item = '\"' + item; "),
						  (m +=
								" if (typeof itemIndices[item] == 'number') { " +
								H +
								" = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ")),
						(m += " } "),
						I && (m += "  }  ")
					var Ne = Ne || []
					Ne.push((m += " if (!" + H + ") {   ")),
						(m = ""),
						!1 !== A.createErrors
							? ((m +=
									" { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " +
									A.errorPath +
									" , schemaPath: " +
									A.util.toQuotedString(R) +
									" , params: { i: i, j: j } "),
							  !1 !== A.opts.messages &&
									(m +=
										" , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "),
							  A.opts.verbose &&
									((m += " , schema:  "),
									(m += I ? "validate.schema" + $ : "" + D),
									(m += "         , parentSchema: validate.schema" + A.schemaPath + " , data: " + B + " ")),
							  (m += " } "))
							: (m += " {} ")
					var ye = m
					;(m = Ne.pop()),
						(m +=
							!A.compositeRule && V
								? A.async
									? " throw new ValidationError([" + ye + "]); "
									: " validate.errors = [" + ye + "]; return false; "
								: " var err = " + ye + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
						(m += " } "),
						V && (m += " else { ")
				} else V && (m += " if (true) { ")
				return m
			}
		},
		751: ct => {
			"use strict"
			ct.exports = function (A, X, q) {
				var m = "",
					de = !0 === A.schema.$async,
					Q = A.util.schemaHasRulesExcept(A.schema, A.RULES.all, "$ref"),
					D = A.self._getId(A.schema)
				if (A.opts.strictKeywords) {
					var $ = A.util.schemaUnknownRules(A.schema, A.RULES.keywords)
					if ($) {
						var R = "unknown keyword: " + $
						if ("log" !== A.opts.strictKeywords) throw new Error(R)
						A.logger.warn(R)
					}
				}
				if (
					(A.isTop &&
						((m += " var validate = "),
						de && ((A.async = !0), (m += "async ")),
						(m += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; "),
						D && (A.opts.sourceCode || A.opts.processCode) && (m += " /*# sourceURL=" + D + " */ ")),
					"boolean" == typeof A.schema || (!Q && !A.schema.$ref))
				) {
					var V = A.level,
						B = A.dataLevel,
						H = A.schema[(X = "false schema")],
						I = A.schemaPath + A.util.getProperty(X),
						G = A.errSchemaPath + "/" + X,
						Je = !A.opts.allErrors,
						J = "data" + (B || ""),
						Qe = "valid" + V
					if (!1 === A.schema) {
						A.isTop ? (Je = !0) : (m += " var " + Qe + " = false; "),
							(Y = Y || []).push(m),
							(m = ""),
							!1 !== A.createErrors
								? ((m +=
										" { keyword: 'false schema' , dataPath: (dataPath || '') + " +
										A.errorPath +
										" , schemaPath: " +
										A.util.toQuotedString(G) +
										" , params: {} "),
								  !1 !== A.opts.messages && (m += " , message: 'boolean schema is false' "),
								  A.opts.verbose &&
										(m += " , schema: false , parentSchema: validate.schema" + A.schemaPath + " , data: " + J + " "),
								  (m += " } "))
								: (m += " {} ")
						var pe = m
						;(m = Y.pop()),
							(m +=
								!A.compositeRule && Je
									? A.async
										? " throw new ValidationError([" + pe + "]); "
										: " validate.errors = [" + pe + "]; return false; "
									: " var err = " + pe + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ")
					} else m += A.isTop ? (de ? " return data; " : " validate.errors = null; return true; ") : " var " + Qe + " = true; "
					return A.isTop && (m += " }; return validate; "), m
				}
				if (A.isTop) {
					var Ne = A.isTop
					if (
						((V = A.level = 0),
						(B = A.dataLevel = 0),
						(J = "data"),
						(A.rootId = A.resolve.fullPath(A.self._getId(A.root.schema))),
						(A.baseId = A.baseId || A.rootId),
						delete A.isTop,
						(A.dataPathArr = [""]),
						void 0 !== A.schema.default && A.opts.useDefaults && A.opts.strictDefaults)
					) {
						var ye = "default is ignored in the schema root"
						if ("log" !== A.opts.strictDefaults) throw new Error(ye)
						A.logger.warn(ye)
					}
					;(m += " var vErrors = null; "), (m += " var errors = 0;     "), (m += " if (rootData === undefined) rootData = data; ")
				} else {
					if (
						((V = A.level),
						(J = "data" + ((B = A.dataLevel) || "")),
						D && (A.baseId = A.resolve.url(A.baseId, D)),
						de && !A.async)
					)
						throw new Error("async schema in sync schema")
					m += " var errs_" + V + " = errors;"
				}
				;(Qe = "valid" + V), (Je = !A.opts.allErrors)
				var Ce = "",
					We = "",
					Ue = A.schema.type,
					st = Array.isArray(Ue)
				if (
					(Ue &&
						A.opts.nullable &&
						!0 === A.schema.nullable &&
						(st ? -1 == Ue.indexOf("null") && (Ue = Ue.concat("null")) : "null" != Ue && ((Ue = [Ue, "null"]), (st = !0))),
					st && 1 == Ue.length && ((Ue = Ue[0]), (st = !1)),
					A.schema.$ref && Q)
				) {
					if ("fail" == A.opts.extendRefs)
						throw new Error(
							'$ref: validation keywords used in schema at path "' + A.errSchemaPath + '" (see option extendRefs)'
						)
					!0 !== A.opts.extendRefs &&
						((Q = !1), A.logger.warn('$ref: keywords ignored in schema at path "' + A.errSchemaPath + '"'))
				}
				if ((A.schema.$comment && A.opts.$comment && (m += " " + A.RULES.all.$comment.code(A, "$comment")), Ue)) {
					if (A.opts.coerceTypes) var et = A.util.coerceToTypes(A.opts.coerceTypes, Ue)
					var ke = A.RULES.types[Ue]
					if (et || st || !0 === ke || (ke && !Qn(ke))) {
						if (
							((I = A.schemaPath + ".type"),
							(G = A.errSchemaPath + "/type"),
							(I = A.schemaPath + ".type"),
							(G = A.errSchemaPath + "/type"),
							(m += " if (" + A.util[st ? "checkDataTypes" : "checkDataType"](Ue, J, A.opts.strictNumbers, !0) + ") { "),
							et)
						) {
							var Ve = "dataType" + V,
								je = "coerced" + V
							;(m += " var " + Ve + " = typeof " + J + "; var " + je + " = undefined; "),
								"array" == A.opts.coerceTypes &&
									(m +=
										" if (" +
										Ve +
										" == 'object' && Array.isArray(" +
										J +
										") && " +
										J +
										".length == 1) { " +
										J +
										" = " +
										J +
										"[0]; " +
										Ve +
										" = typeof " +
										J +
										"; if (" +
										A.util.checkDataType(A.schema.type, J, A.opts.strictNumbers) +
										") " +
										je +
										" = " +
										J +
										"; } "),
								(m += " if (" + je + " !== undefined) ; ")
							var Re = et
							if (Re)
								for (var ze, qe = -1, Ge = Re.length - 1; qe < Ge; )
									"string" == (ze = Re[(qe += 1)])
										? (m +=
												" else if (" +
												Ve +
												" == 'number' || " +
												Ve +
												" == 'boolean') " +
												je +
												" = '' + " +
												J +
												"; else if (" +
												J +
												" === null) " +
												je +
												" = ''; ")
										: "number" == ze || "integer" == ze
										? ((m +=
												" else if (" +
												Ve +
												" == 'boolean' || " +
												J +
												" === null || (" +
												Ve +
												" == 'string' && " +
												J +
												" && " +
												J +
												" == +" +
												J +
												" "),
										  "integer" == ze && (m += " && !(" + J + " % 1)"),
										  (m += ")) " + je + " = +" + J + "; "))
										: "boolean" == ze
										? (m +=
												" else if (" +
												J +
												" === 'false' || " +
												J +
												" === 0 || " +
												J +
												" === null) " +
												je +
												" = false; else if (" +
												J +
												" === 'true' || " +
												J +
												" === 1) " +
												je +
												" = true; ")
										: "null" == ze
										? (m += " else if (" + J + " === '' || " + J + " === 0 || " + J + " === false) " + je + " = null; ")
										: "array" == A.opts.coerceTypes &&
										  "array" == ze &&
										  (m +=
												" else if (" +
												Ve +
												" == 'string' || " +
												Ve +
												" == 'number' || " +
												Ve +
												" == 'boolean' || " +
												J +
												" == null) " +
												je +
												" = [" +
												J +
												"]; ")
							;(Y = Y || []).push((m += " else {   ")),
								(m = ""),
								!1 !== A.createErrors
									? ((m +=
											" { keyword: 'type' , dataPath: (dataPath || '') + " +
											A.errorPath +
											" , schemaPath: " +
											A.util.toQuotedString(G) +
											" , params: { type: '"),
									  (m += st ? "" + Ue.join(",") : "" + Ue),
									  (m += "' } "),
									  !1 !== A.opts.messages &&
											((m += " , message: 'should be "), (m += st ? "" + Ue.join(",") : "" + Ue), (m += "' ")),
									  A.opts.verbose &&
											(m +=
												" , schema: validate.schema" +
												I +
												" , parentSchema: validate.schema" +
												A.schemaPath +
												" , data: " +
												J +
												" "),
									  (m += " } "))
									: (m += " {} "),
								(pe = m),
								(m = Y.pop()),
								(m +=
									!A.compositeRule && Je
										? A.async
											? " throw new ValidationError([" + pe + "]); "
											: " validate.errors = [" + pe + "]; return false; "
										: " var err = " +
										  pe +
										  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
								(m += " } if (" + je + " !== undefined) {  ")
							var wt = B ? "data" + (B - 1 || "") : "parentData"
							;(m += " " + J + " = " + je + "; "),
								B || (m += "if (" + wt + " !== undefined)"),
								(m += " " + wt + "[" + (B ? A.dataPathArr[B] : "parentDataProperty") + "] = " + je + "; } ")
						} else
							(Y = Y || []).push(m),
								(m = ""),
								!1 !== A.createErrors
									? ((m +=
											" { keyword: 'type' , dataPath: (dataPath || '') + " +
											A.errorPath +
											" , schemaPath: " +
											A.util.toQuotedString(G) +
											" , params: { type: '"),
									  (m += st ? "" + Ue.join(",") : "" + Ue),
									  (m += "' } "),
									  !1 !== A.opts.messages &&
											((m += " , message: 'should be "), (m += st ? "" + Ue.join(",") : "" + Ue), (m += "' ")),
									  A.opts.verbose &&
											(m +=
												" , schema: validate.schema" +
												I +
												" , parentSchema: validate.schema" +
												A.schemaPath +
												" , data: " +
												J +
												" "),
									  (m += " } "))
									: (m += " {} "),
								(pe = m),
								(m = Y.pop()),
								(m +=
									!A.compositeRule && Je
										? A.async
											? " throw new ValidationError([" + pe + "]); "
											: " validate.errors = [" + pe + "]; return false; "
										: " var err = " +
										  pe +
										  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ")
						m += " } "
					}
				}
				if (A.schema.$ref && !Q)
					(m += " " + A.RULES.all.$ref.code(A, "$ref") + " "),
						Je && ((m += " } if (errors === "), (m += Ne ? "0" : "errs_" + V), (m += ") { "), (We += "}"))
				else {
					var yn = A.RULES
					if (yn)
						for (var ai = -1, vt = yn.length - 1; ai < vt; )
							if (Qn((ke = yn[(ai += 1)]))) {
								if (
									(ke.type && (m += " if (" + A.util.checkDataType(ke.type, J, A.opts.strictNumbers) + ") { "),
									A.opts.useDefaults)
								)
									if ("object" == ke.type && A.schema.properties) {
										H = A.schema.properties
										var yi = Object.keys(H)
										if (yi)
											for (var Wt, we = -1, gt = yi.length - 1; we < gt; )
												if (void 0 !== (Ke = H[(Wt = yi[(we += 1)])]).default) {
													var fn = J + A.util.getProperty(Wt)
													if (A.compositeRule) {
														if (A.opts.strictDefaults) {
															if (((ye = "default is ignored for: " + fn), "log" !== A.opts.strictDefaults))
																throw new Error(ye)
															A.logger.warn(ye)
														}
													} else
														(m += " if (" + fn + " === undefined "),
															"empty" == A.opts.useDefaults &&
																(m += " || " + fn + " === null || " + fn + " === '' "),
															(m += " ) " + fn + " = "),
															(m +=
																"shared" == A.opts.useDefaults
																	? " " + A.useDefault(Ke.default) + " "
																	: " " + JSON.stringify(Ke.default) + " "),
															(m += "; ")
												}
									} else if ("array" == ke.type && Array.isArray(A.schema.items)) {
										var St = A.schema.items
										if (St) {
											qe = -1
											for (var Ke, Dt = St.length - 1; qe < Dt; )
												if (void 0 !== (Ke = St[(qe += 1)]).default)
													if (((fn = J + "[" + qe + "]"), A.compositeRule)) {
														if (A.opts.strictDefaults) {
															if (((ye = "default is ignored for: " + fn), "log" !== A.opts.strictDefaults))
																throw new Error(ye)
															A.logger.warn(ye)
														}
													} else
														(m += " if (" + fn + " === undefined "),
															"empty" == A.opts.useDefaults &&
																(m += " || " + fn + " === null || " + fn + " === '' "),
															(m += " ) " + fn + " = "),
															(m +=
																"shared" == A.opts.useDefaults
																	? " " + A.useDefault(Ke.default) + " "
																	: " " + JSON.stringify(Ke.default) + " "),
															(m += "; ")
										}
									}
								var Y,
									gn = ke.rules
								if (gn)
									for (var ci, Ci = -1, nr = gn.length - 1; Ci < nr; )
										if (io((ci = gn[(Ci += 1)]))) {
											var hr = ci.code(A, ci.keyword, ke.type)
											hr && ((m += " " + hr + " "), Je && (Ce += "}"))
										}
								if ((Je && ((m += " " + Ce + " "), (Ce = "")), ke.type && ((m += " } "), Ue && Ue === ke.type && !et)))
									(I = A.schemaPath + ".type"),
										(G = A.errSchemaPath + "/type"),
										(Y = Y || []).push((m += " else { ")),
										(m = ""),
										!1 !== A.createErrors
											? ((m +=
													" { keyword: 'type' , dataPath: (dataPath || '') + " +
													A.errorPath +
													" , schemaPath: " +
													A.util.toQuotedString(G) +
													" , params: { type: '"),
											  (m += st ? "" + Ue.join(",") : "" + Ue),
											  (m += "' } "),
											  !1 !== A.opts.messages &&
													((m += " , message: 'should be "),
													(m += st ? "" + Ue.join(",") : "" + Ue),
													(m += "' ")),
											  A.opts.verbose &&
													(m +=
														" , schema: validate.schema" +
														I +
														" , parentSchema: validate.schema" +
														A.schemaPath +
														" , data: " +
														J +
														" "),
											  (m += " } "))
											: (m += " {} "),
										(pe = m),
										(m = Y.pop()),
										(m +=
											!A.compositeRule && Je
												? A.async
													? " throw new ValidationError([" + pe + "]); "
													: " validate.errors = [" + pe + "]; return false; "
												: " var err = " +
												  pe +
												  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
										(m += " } ")
								Je && ((m += " if (errors === "), (m += Ne ? "0" : "errs_" + V), (m += ") { "), (We += "}"))
							}
				}
				function Qn(Pi) {
					for (var Ze = Pi.rules, li = 0; li < Ze.length; li++) if (io(Ze[li])) return !0
				}
				function io(Pi) {
					return (
						void 0 !== A.schema[Pi.keyword] ||
						(Pi.implements &&
							(function Br(Pi) {
								for (var Ze = Pi.implements, li = 0; li < Ze.length; li++) if (void 0 !== A.schema[Ze[li]]) return !0
							})(Pi))
					)
				}
				return (
					Je && (m += " " + We + " "),
					Ne
						? (de
								? ((m += " if (errors === 0) return data;           "), (m += " else throw new ValidationError(vErrors); "))
								: ((m += " validate.errors = vErrors; "), (m += " return errors === 0;       ")),
						  (m += " }; return validate;"))
						: (m += " var " + Qe + " = errors === errs_" + V + ";"),
					m
				)
			}
		},
		246: (ct, ft, A) => {
			"use strict"
			var X = /^[a-z_$][a-z0-9_$-]*$/i,
				q = A(6791),
				m = A(4686)
			ct.exports = {
				add: function de(R, V) {
					var B = this.RULES
					if (B.keywords[R]) throw new Error("Keyword " + R + " is already defined")
					if (!X.test(R)) throw new Error("Keyword " + R + " is not a valid identifier")
					if (V) {
						this.validateKeyword(V, !0)
						var H = V.type
						if (Array.isArray(H)) for (var I = 0; I < H.length; I++) J(R, H[I], V)
						else J(R, H, V)
						var G = V.metaSchema
						G &&
							(V.$data &&
								this._opts.$data &&
								(G = {
									anyOf: [G, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }]
								}),
							(V.validateSchema = this.compile(G, !0)))
					}
					function J(Y, pe, Ne) {
						for (var ye, Qe = 0; Qe < B.length; Qe++) {
							var Je = B[Qe]
							if (Je.type == pe) {
								ye = Je
								break
							}
						}
						ye || B.push((ye = { type: pe, rules: [] }))
						var Ce = { keyword: Y, definition: Ne, custom: !0, code: q, implements: Ne.implements }
						ye.rules.push(Ce), (B.custom[Y] = Ce)
					}
					return (B.keywords[R] = B.all[R] = !0), this
				},
				get: function Q(R) {
					var V = this.RULES.custom[R]
					return V ? V.definition : this.RULES.keywords[R] || !1
				},
				remove: function D(R) {
					var V = this.RULES
					delete V.keywords[R], delete V.all[R], delete V.custom[R]
					for (var B = 0; B < V.length; B++)
						for (var H = V[B].rules, I = 0; I < H.length; I++)
							if (H[I].keyword == R) {
								H.splice(I, 1)
								break
							}
					return this
				},
				validate: function $(R, V) {
					$.errors = null
					var B = (this._validateKeyword = this._validateKeyword || this.compile(m, !0))
					if (B(R)) return !0
					if ((($.errors = B.errors), V)) throw new Error("custom keyword definition is invalid: " + this.errorsText(B.errors))
					return !1
				}
			}
		},
		8870: ct => {
			var ft = {
				utf8: {
					stringToBytes: function (A) {
						return ft.bin.stringToBytes(unescape(encodeURIComponent(A)))
					},
					bytesToString: function (A) {
						return decodeURIComponent(escape(ft.bin.bytesToString(A)))
					}
				},
				bin: {
					stringToBytes: function (A) {
						for (var X = [], q = 0; q < A.length; q++) X.push(255 & A.charCodeAt(q))
						return X
					},
					bytesToString: function (A) {
						for (var X = [], q = 0; q < A.length; q++) X.push(String.fromCharCode(A[q]))
						return X.join("")
					}
				}
			}
			ct.exports = ft
		},
		3521: (ct, ft, A) => {
			const X = A(929),
				q = {}
			for (const Q of Object.keys(X)) q[X[Q]] = Q
			const m = {
				rgb: { channels: 3, labels: "rgb" },
				hsl: { channels: 3, labels: "hsl" },
				hsv: { channels: 3, labels: "hsv" },
				hwb: { channels: 3, labels: "hwb" },
				cmyk: { channels: 4, labels: "cmyk" },
				xyz: { channels: 3, labels: "xyz" },
				lab: { channels: 3, labels: "lab" },
				lch: { channels: 3, labels: "lch" },
				hex: { channels: 1, labels: ["hex"] },
				keyword: { channels: 1, labels: ["keyword"] },
				ansi16: { channels: 1, labels: ["ansi16"] },
				ansi256: { channels: 1, labels: ["ansi256"] },
				hcg: { channels: 3, labels: ["h", "c", "g"] },
				apple: { channels: 3, labels: ["r16", "g16", "b16"] },
				gray: { channels: 1, labels: ["gray"] }
			}
			ct.exports = m
			for (const Q of Object.keys(m)) {
				if (!("channels" in m[Q])) throw new Error("missing channels property: " + Q)
				if (!("labels" in m[Q])) throw new Error("missing channel labels property: " + Q)
				if (m[Q].labels.length !== m[Q].channels) throw new Error("channel and label counts mismatch: " + Q)
				const { channels: D, labels: $ } = m[Q]
				delete m[Q].channels,
					delete m[Q].labels,
					Object.defineProperty(m[Q], "channels", { value: D }),
					Object.defineProperty(m[Q], "labels", { value: $ })
			}
			function de(Q, D) {
				return (Q[0] - D[0]) ** 2 + (Q[1] - D[1]) ** 2 + (Q[2] - D[2]) ** 2
			}
			;(m.rgb.hsl = function (Q) {
				const D = Q[0] / 255,
					$ = Q[1] / 255,
					R = Q[2] / 255,
					V = Math.min(D, $, R),
					B = Math.max(D, $, R),
					H = B - V
				let I, G
				B === V ? (I = 0) : D === B ? (I = ($ - R) / H) : $ === B ? (I = 2 + (R - D) / H) : R === B && (I = 4 + (D - $) / H),
					(I = Math.min(60 * I, 360)),
					I < 0 && (I += 360)
				const J = (V + B) / 2
				return (G = B === V ? 0 : J <= 0.5 ? H / (B + V) : H / (2 - B - V)), [I, 100 * G, 100 * J]
			}),
				(m.rgb.hsv = function (Q) {
					let D, $, R, V, B
					const H = Q[0] / 255,
						I = Q[1] / 255,
						G = Q[2] / 255,
						J = Math.max(H, I, G),
						Y = J - Math.min(H, I, G),
						pe = function (Ne) {
							return (J - Ne) / 6 / Y + 0.5
						}
					return (
						0 === Y
							? ((V = 0), (B = 0))
							: ((B = Y / J),
							  (D = pe(H)),
							  ($ = pe(I)),
							  (R = pe(G)),
							  H === J ? (V = R - $) : I === J ? (V = 1 / 3 + D - R) : G === J && (V = 2 / 3 + $ - D),
							  V < 0 ? (V += 1) : V > 1 && (V -= 1)),
						[360 * V, 100 * B, 100 * J]
					)
				}),
				(m.rgb.hwb = function (Q) {
					const D = Q[0],
						$ = Q[1]
					let R = Q[2]
					const V = m.rgb.hsl(Q)[0],
						B = (1 / 255) * Math.min(D, Math.min($, R))
					return (R = 1 - (1 / 255) * Math.max(D, Math.max($, R))), [V, 100 * B, 100 * R]
				}),
				(m.rgb.cmyk = function (Q) {
					const D = Q[0] / 255,
						$ = Q[1] / 255,
						R = Q[2] / 255,
						V = Math.min(1 - D, 1 - $, 1 - R)
					return [
						100 * ((1 - D - V) / (1 - V) || 0),
						100 * ((1 - $ - V) / (1 - V) || 0),
						100 * ((1 - R - V) / (1 - V) || 0),
						100 * V
					]
				}),
				(m.rgb.keyword = function (Q) {
					const D = q[Q]
					if (D) return D
					let R,
						$ = 1 / 0
					for (const V of Object.keys(X)) {
						const H = de(Q, X[V])
						H < $ && (($ = H), (R = V))
					}
					return R
				}),
				(m.keyword.rgb = function (Q) {
					return X[Q]
				}),
				(m.rgb.xyz = function (Q) {
					let D = Q[0] / 255,
						$ = Q[1] / 255,
						R = Q[2] / 255
					return (
						(D = D > 0.04045 ? ((D + 0.055) / 1.055) ** 2.4 : D / 12.92),
						($ = $ > 0.04045 ? (($ + 0.055) / 1.055) ** 2.4 : $ / 12.92),
						(R = R > 0.04045 ? ((R + 0.055) / 1.055) ** 2.4 : R / 12.92),
						[
							100 * (0.4124 * D + 0.3576 * $ + 0.1805 * R),
							100 * (0.2126 * D + 0.7152 * $ + 0.0722 * R),
							100 * (0.0193 * D + 0.1192 * $ + 0.9505 * R)
						]
					)
				}),
				(m.rgb.lab = function (Q) {
					const D = m.rgb.xyz(Q)
					let $ = D[0],
						R = D[1],
						V = D[2]
					return (
						($ /= 95.047),
						(R /= 100),
						(V /= 108.883),
						($ = $ > 0.008856 ? $ ** (1 / 3) : 7.787 * $ + 16 / 116),
						(R = R > 0.008856 ? R ** (1 / 3) : 7.787 * R + 16 / 116),
						(V = V > 0.008856 ? V ** (1 / 3) : 7.787 * V + 16 / 116),
						[116 * R - 16, 500 * ($ - R), 200 * (R - V)]
					)
				}),
				(m.hsl.rgb = function (Q) {
					const D = Q[0] / 360,
						$ = Q[1] / 100,
						R = Q[2] / 100
					let V, B, H
					if (0 === $) return (H = 255 * R), [H, H, H]
					V = R < 0.5 ? R * (1 + $) : R + $ - R * $
					const I = 2 * R - V,
						G = [0, 0, 0]
					for (let J = 0; J < 3; J++)
						(B = D + (1 / 3) * -(J - 1)),
							B < 0 && B++,
							B > 1 && B--,
							(H = 6 * B < 1 ? I + 6 * (V - I) * B : 2 * B < 1 ? V : 3 * B < 2 ? I + (V - I) * (2 / 3 - B) * 6 : I),
							(G[J] = 255 * H)
					return G
				}),
				(m.hsl.hsv = function (Q) {
					const D = Q[0]
					let $ = Q[1] / 100,
						R = Q[2] / 100,
						V = $
					const B = Math.max(R, 0.01)
					return (
						(R *= 2),
						($ *= R <= 1 ? R : 2 - R),
						(V *= B <= 1 ? B : 2 - B),
						[D, 100 * (0 === R ? (2 * V) / (B + V) : (2 * $) / (R + $)), ((R + $) / 2) * 100]
					)
				}),
				(m.hsv.rgb = function (Q) {
					const D = Q[0] / 60,
						$ = Q[1] / 100
					let R = Q[2] / 100
					const V = Math.floor(D) % 6,
						B = D - Math.floor(D),
						H = 255 * R * (1 - $),
						I = 255 * R * (1 - $ * B),
						G = 255 * R * (1 - $ * (1 - B))
					switch (((R *= 255), V)) {
						case 0:
							return [R, G, H]
						case 1:
							return [I, R, H]
						case 2:
							return [H, R, G]
						case 3:
							return [H, I, R]
						case 4:
							return [G, H, R]
						case 5:
							return [R, H, I]
					}
				}),
				(m.hsv.hsl = function (Q) {
					const D = Q[0],
						$ = Q[1] / 100,
						R = Q[2] / 100,
						V = Math.max(R, 0.01)
					let B, H
					H = (2 - $) * R
					const I = (2 - $) * V
					return (B = $ * V), (B /= I <= 1 ? I : 2 - I), (B = B || 0), (H /= 2), [D, 100 * B, 100 * H]
				}),
				(m.hwb.rgb = function (Q) {
					const D = Q[0] / 360
					let $ = Q[1] / 100,
						R = Q[2] / 100
					const V = $ + R
					let B
					V > 1 && (($ /= V), (R /= V))
					const H = Math.floor(6 * D),
						I = 1 - R
					;(B = 6 * D - H), 1 & H && (B = 1 - B)
					const G = $ + B * (I - $)
					let J, Y, pe
					switch (H) {
						default:
						case 6:
						case 0:
							;(J = I), (Y = G), (pe = $)
							break
						case 1:
							;(J = G), (Y = I), (pe = $)
							break
						case 2:
							;(J = $), (Y = I), (pe = G)
							break
						case 3:
							;(J = $), (Y = G), (pe = I)
							break
						case 4:
							;(J = G), (Y = $), (pe = I)
							break
						case 5:
							;(J = I), (Y = $), (pe = G)
					}
					return [255 * J, 255 * Y, 255 * pe]
				}),
				(m.cmyk.rgb = function (Q) {
					const $ = Q[1] / 100,
						R = Q[2] / 100,
						V = Q[3] / 100
					return [
						255 * (1 - Math.min(1, (Q[0] / 100) * (1 - V) + V)),
						255 * (1 - Math.min(1, $ * (1 - V) + V)),
						255 * (1 - Math.min(1, R * (1 - V) + V))
					]
				}),
				(m.xyz.rgb = function (Q) {
					const D = Q[0] / 100,
						$ = Q[1] / 100,
						R = Q[2] / 100
					let V, B, H
					return (
						(V = 3.2406 * D + -1.5372 * $ + -0.4986 * R),
						(B = -0.9689 * D + 1.8758 * $ + 0.0415 * R),
						(H = 0.0557 * D + -0.204 * $ + 1.057 * R),
						(V = V > 0.0031308 ? 1.055 * V ** (1 / 2.4) - 0.055 : 12.92 * V),
						(B = B > 0.0031308 ? 1.055 * B ** (1 / 2.4) - 0.055 : 12.92 * B),
						(H = H > 0.0031308 ? 1.055 * H ** (1 / 2.4) - 0.055 : 12.92 * H),
						(V = Math.min(Math.max(0, V), 1)),
						(B = Math.min(Math.max(0, B), 1)),
						(H = Math.min(Math.max(0, H), 1)),
						[255 * V, 255 * B, 255 * H]
					)
				}),
				(m.xyz.lab = function (Q) {
					let D = Q[0],
						$ = Q[1],
						R = Q[2]
					return (
						(D /= 95.047),
						($ /= 100),
						(R /= 108.883),
						(D = D > 0.008856 ? D ** (1 / 3) : 7.787 * D + 16 / 116),
						($ = $ > 0.008856 ? $ ** (1 / 3) : 7.787 * $ + 16 / 116),
						(R = R > 0.008856 ? R ** (1 / 3) : 7.787 * R + 16 / 116),
						[116 * $ - 16, 500 * (D - $), 200 * ($ - R)]
					)
				}),
				(m.lab.xyz = function (Q) {
					let V, B, H
					;(B = (Q[0] + 16) / 116), (V = Q[1] / 500 + B), (H = B - Q[2] / 200)
					const I = B ** 3,
						G = V ** 3,
						J = H ** 3
					return (
						(B = I > 0.008856 ? I : (B - 16 / 116) / 7.787),
						(V = G > 0.008856 ? G : (V - 16 / 116) / 7.787),
						(H = J > 0.008856 ? J : (H - 16 / 116) / 7.787),
						(V *= 95.047),
						(B *= 100),
						(H *= 108.883),
						[V, B, H]
					)
				}),
				(m.lab.lch = function (Q) {
					const D = Q[0],
						$ = Q[1],
						R = Q[2]
					let V
					return (V = (360 * Math.atan2(R, $)) / 2 / Math.PI), V < 0 && (V += 360), [D, Math.sqrt($ * $ + R * R), V]
				}),
				(m.lch.lab = function (Q) {
					const $ = Q[1],
						V = (Q[2] / 360) * 2 * Math.PI
					return [Q[0], $ * Math.cos(V), $ * Math.sin(V)]
				}),
				(m.rgb.ansi16 = function (Q, D = null) {
					const [$, R, V] = Q
					let B = null === D ? m.rgb.hsv(Q)[2] : D
					if (((B = Math.round(B / 50)), 0 === B)) return 30
					let H = 30 + ((Math.round(V / 255) << 2) | (Math.round(R / 255) << 1) | Math.round($ / 255))
					return 2 === B && (H += 60), H
				}),
				(m.hsv.ansi16 = function (Q) {
					return m.rgb.ansi16(m.hsv.rgb(Q), Q[2])
				}),
				(m.rgb.ansi256 = function (Q) {
					const D = Q[0],
						$ = Q[1],
						R = Q[2]
					return D === $ && $ === R
						? D < 8
							? 16
							: D > 248
							? 231
							: Math.round(((D - 8) / 247) * 24) + 232
						: 16 + 36 * Math.round((D / 255) * 5) + 6 * Math.round(($ / 255) * 5) + Math.round((R / 255) * 5)
				}),
				(m.ansi16.rgb = function (Q) {
					let D = Q % 10
					if (0 === D || 7 === D) return Q > 50 && (D += 3.5), (D = (D / 10.5) * 255), [D, D, D]
					const $ = 0.5 * (1 + ~~(Q > 50))
					return [(1 & D) * $ * 255, ((D >> 1) & 1) * $ * 255, ((D >> 2) & 1) * $ * 255]
				}),
				(m.ansi256.rgb = function (Q) {
					if (Q >= 232) {
						const B = 10 * (Q - 232) + 8
						return [B, B, B]
					}
					let D
					return (Q -= 16), [(Math.floor(Q / 36) / 5) * 255, (Math.floor((D = Q % 36) / 6) / 5) * 255, ((D % 6) / 5) * 255]
				}),
				(m.rgb.hex = function (Q) {
					const $ = (((255 & Math.round(Q[0])) << 16) + ((255 & Math.round(Q[1])) << 8) + (255 & Math.round(Q[2])))
						.toString(16)
						.toUpperCase()
					return "000000".substring($.length) + $
				}),
				(m.hex.rgb = function (Q) {
					const D = Q.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
					if (!D) return [0, 0, 0]
					let $ = D[0]
					3 === D[0].length &&
						($ = $.split("")
							.map(I => I + I)
							.join(""))
					const R = parseInt($, 16)
					return [(R >> 16) & 255, (R >> 8) & 255, 255 & R]
				}),
				(m.rgb.hcg = function (Q) {
					const D = Q[0] / 255,
						$ = Q[1] / 255,
						R = Q[2] / 255,
						V = Math.max(Math.max(D, $), R),
						B = Math.min(Math.min(D, $), R),
						H = V - B
					let I, G
					return (
						(I = H < 1 ? B / (1 - H) : 0),
						(G = H <= 0 ? 0 : V === D ? (($ - R) / H) % 6 : V === $ ? 2 + (R - D) / H : 4 + (D - $) / H),
						(G /= 6),
						(G %= 1),
						[360 * G, 100 * H, 100 * I]
					)
				}),
				(m.hsl.hcg = function (Q) {
					const D = Q[1] / 100,
						$ = Q[2] / 100,
						R = $ < 0.5 ? 2 * D * $ : 2 * D * (1 - $)
					let V = 0
					return R < 1 && (V = ($ - 0.5 * R) / (1 - R)), [Q[0], 100 * R, 100 * V]
				}),
				(m.hsv.hcg = function (Q) {
					const $ = Q[2] / 100,
						R = (Q[1] / 100) * $
					let V = 0
					return R < 1 && (V = ($ - R) / (1 - R)), [Q[0], 100 * R, 100 * V]
				}),
				(m.hcg.rgb = function (Q) {
					const $ = Q[1] / 100,
						R = Q[2] / 100
					if (0 === $) return [255 * R, 255 * R, 255 * R]
					const V = [0, 0, 0],
						B = ((Q[0] / 360) % 1) * 6,
						H = B % 1,
						I = 1 - H
					let G = 0
					switch (Math.floor(B)) {
						case 0:
							;(V[0] = 1), (V[1] = H), (V[2] = 0)
							break
						case 1:
							;(V[0] = I), (V[1] = 1), (V[2] = 0)
							break
						case 2:
							;(V[0] = 0), (V[1] = 1), (V[2] = H)
							break
						case 3:
							;(V[0] = 0), (V[1] = I), (V[2] = 1)
							break
						case 4:
							;(V[0] = H), (V[1] = 0), (V[2] = 1)
							break
						default:
							;(V[0] = 1), (V[1] = 0), (V[2] = I)
					}
					return (G = (1 - $) * R), [255 * ($ * V[0] + G), 255 * ($ * V[1] + G), 255 * ($ * V[2] + G)]
				}),
				(m.hcg.hsv = function (Q) {
					const D = Q[1] / 100,
						R = D + (Q[2] / 100) * (1 - D)
					let V = 0
					return R > 0 && (V = D / R), [Q[0], 100 * V, 100 * R]
				}),
				(m.hcg.hsl = function (Q) {
					const D = Q[1] / 100,
						R = (Q[2] / 100) * (1 - D) + 0.5 * D
					let V = 0
					return R > 0 && R < 0.5 ? (V = D / (2 * R)) : R >= 0.5 && R < 1 && (V = D / (2 * (1 - R))), [Q[0], 100 * V, 100 * R]
				}),
				(m.hcg.hwb = function (Q) {
					const D = Q[1] / 100,
						R = D + (Q[2] / 100) * (1 - D)
					return [Q[0], 100 * (R - D), 100 * (1 - R)]
				}),
				(m.hwb.hcg = function (Q) {
					const R = 1 - Q[2] / 100,
						V = R - Q[1] / 100
					let B = 0
					return V < 1 && (B = (R - V) / (1 - V)), [Q[0], 100 * V, 100 * B]
				}),
				(m.apple.rgb = function (Q) {
					return [(Q[0] / 65535) * 255, (Q[1] / 65535) * 255, (Q[2] / 65535) * 255]
				}),
				(m.rgb.apple = function (Q) {
					return [(Q[0] / 255) * 65535, (Q[1] / 255) * 65535, (Q[2] / 255) * 65535]
				}),
				(m.gray.rgb = function (Q) {
					return [(Q[0] / 100) * 255, (Q[0] / 100) * 255, (Q[0] / 100) * 255]
				}),
				(m.gray.hsl = function (Q) {
					return [0, 0, Q[0]]
				}),
				(m.gray.hsv = m.gray.hsl),
				(m.gray.hwb = function (Q) {
					return [0, 100, Q[0]]
				}),
				(m.gray.cmyk = function (Q) {
					return [0, 0, 0, Q[0]]
				}),
				(m.gray.lab = function (Q) {
					return [Q[0], 0, 0]
				}),
				(m.gray.hex = function (Q) {
					const D = 255 & Math.round((Q[0] / 100) * 255),
						R = ((D << 16) + (D << 8) + D).toString(16).toUpperCase()
					return "000000".substring(R.length) + R
				}),
				(m.rgb.gray = function (Q) {
					return [((Q[0] + Q[1] + Q[2]) / 3 / 255) * 100]
				})
		},
		6137: (ct, ft, A) => {
			const X = A(3521),
				q = A(9346),
				m = {}
			Object.keys(X).forEach($ => {
				;(m[$] = {}),
					Object.defineProperty(m[$], "channels", { value: X[$].channels }),
					Object.defineProperty(m[$], "labels", { value: X[$].labels })
				const R = q($)
				Object.keys(R).forEach(B => {
					const H = R[B]
					;(m[$][B] = (function D($) {
						const R = function (...V) {
							const B = V[0]
							if (null == B) return B
							B.length > 1 && (V = B)
							const H = $(V)
							if ("object" == typeof H) for (let I = H.length, G = 0; G < I; G++) H[G] = Math.round(H[G])
							return H
						}
						return "conversion" in $ && (R.conversion = $.conversion), R
					})(H)),
						(m[$][B].raw = (function Q($) {
							const R = function (...V) {
								const B = V[0]
								return null == B ? B : (B.length > 1 && (V = B), $(V))
							}
							return "conversion" in $ && (R.conversion = $.conversion), R
						})(H))
				})
			}),
				(ct.exports = m)
		},
		9346: (ct, ft, A) => {
			const X = A(3521)
			function de(D, $) {
				return function (R) {
					return $(D(R))
				}
			}
			function Q(D, $) {
				const R = [$[D].parent, D]
				let V = X[$[D].parent][D],
					B = $[D].parent
				for (; $[B].parent; ) R.unshift($[B].parent), (V = de(X[$[B].parent][B], V)), (B = $[B].parent)
				return (V.conversion = R), V
			}
			ct.exports = function (D) {
				const $ = (function m(D) {
						const $ = (function q() {
								const D = {},
									$ = Object.keys(X)
								for (let R = $.length, V = 0; V < R; V++) D[$[V]] = { distance: -1, parent: null }
								return D
							})(),
							R = [D]
						for ($[D].distance = 0; R.length; ) {
							const V = R.pop(),
								B = Object.keys(X[V])
							for (let H = B.length, I = 0; I < H; I++) {
								const G = B[I],
									J = $[G]
								;-1 === J.distance && ((J.distance = $[V].distance + 1), (J.parent = V), R.unshift(G))
							}
						}
						return $
					})(D),
					R = {},
					V = Object.keys($)
				for (let B = V.length, H = 0; H < B; H++) {
					const I = V[H]
					null !== $[I].parent && (R[I] = Q(I, $))
				}
				return R
			}
		},
		929: ct => {
			"use strict"
			ct.exports = {
				aliceblue: [240, 248, 255],
				antiquewhite: [250, 235, 215],
				aqua: [0, 255, 255],
				aquamarine: [127, 255, 212],
				azure: [240, 255, 255],
				beige: [245, 245, 220],
				bisque: [255, 228, 196],
				black: [0, 0, 0],
				blanchedalmond: [255, 235, 205],
				blue: [0, 0, 255],
				blueviolet: [138, 43, 226],
				brown: [165, 42, 42],
				burlywood: [222, 184, 135],
				cadetblue: [95, 158, 160],
				chartreuse: [127, 255, 0],
				chocolate: [210, 105, 30],
				coral: [255, 127, 80],
				cornflowerblue: [100, 149, 237],
				cornsilk: [255, 248, 220],
				crimson: [220, 20, 60],
				cyan: [0, 255, 255],
				darkblue: [0, 0, 139],
				darkcyan: [0, 139, 139],
				darkgoldenrod: [184, 134, 11],
				darkgray: [169, 169, 169],
				darkgreen: [0, 100, 0],
				darkgrey: [169, 169, 169],
				darkkhaki: [189, 183, 107],
				darkmagenta: [139, 0, 139],
				darkolivegreen: [85, 107, 47],
				darkorange: [255, 140, 0],
				darkorchid: [153, 50, 204],
				darkred: [139, 0, 0],
				darksalmon: [233, 150, 122],
				darkseagreen: [143, 188, 143],
				darkslateblue: [72, 61, 139],
				darkslategray: [47, 79, 79],
				darkslategrey: [47, 79, 79],
				darkturquoise: [0, 206, 209],
				darkviolet: [148, 0, 211],
				deeppink: [255, 20, 147],
				deepskyblue: [0, 191, 255],
				dimgray: [105, 105, 105],
				dimgrey: [105, 105, 105],
				dodgerblue: [30, 144, 255],
				firebrick: [178, 34, 34],
				floralwhite: [255, 250, 240],
				forestgreen: [34, 139, 34],
				fuchsia: [255, 0, 255],
				gainsboro: [220, 220, 220],
				ghostwhite: [248, 248, 255],
				gold: [255, 215, 0],
				goldenrod: [218, 165, 32],
				gray: [128, 128, 128],
				green: [0, 128, 0],
				greenyellow: [173, 255, 47],
				grey: [128, 128, 128],
				honeydew: [240, 255, 240],
				hotpink: [255, 105, 180],
				indianred: [205, 92, 92],
				indigo: [75, 0, 130],
				ivory: [255, 255, 240],
				khaki: [240, 230, 140],
				lavender: [230, 230, 250],
				lavenderblush: [255, 240, 245],
				lawngreen: [124, 252, 0],
				lemonchiffon: [255, 250, 205],
				lightblue: [173, 216, 230],
				lightcoral: [240, 128, 128],
				lightcyan: [224, 255, 255],
				lightgoldenrodyellow: [250, 250, 210],
				lightgray: [211, 211, 211],
				lightgreen: [144, 238, 144],
				lightgrey: [211, 211, 211],
				lightpink: [255, 182, 193],
				lightsalmon: [255, 160, 122],
				lightseagreen: [32, 178, 170],
				lightskyblue: [135, 206, 250],
				lightslategray: [119, 136, 153],
				lightslategrey: [119, 136, 153],
				lightsteelblue: [176, 196, 222],
				lightyellow: [255, 255, 224],
				lime: [0, 255, 0],
				limegreen: [50, 205, 50],
				linen: [250, 240, 230],
				magenta: [255, 0, 255],
				maroon: [128, 0, 0],
				mediumaquamarine: [102, 205, 170],
				mediumblue: [0, 0, 205],
				mediumorchid: [186, 85, 211],
				mediumpurple: [147, 112, 219],
				mediumseagreen: [60, 179, 113],
				mediumslateblue: [123, 104, 238],
				mediumspringgreen: [0, 250, 154],
				mediumturquoise: [72, 209, 204],
				mediumvioletred: [199, 21, 133],
				midnightblue: [25, 25, 112],
				mintcream: [245, 255, 250],
				mistyrose: [255, 228, 225],
				moccasin: [255, 228, 181],
				navajowhite: [255, 222, 173],
				navy: [0, 0, 128],
				oldlace: [253, 245, 230],
				olive: [128, 128, 0],
				olivedrab: [107, 142, 35],
				orange: [255, 165, 0],
				orangered: [255, 69, 0],
				orchid: [218, 112, 214],
				palegoldenrod: [238, 232, 170],
				palegreen: [152, 251, 152],
				paleturquoise: [175, 238, 238],
				palevioletred: [219, 112, 147],
				papayawhip: [255, 239, 213],
				peachpuff: [255, 218, 185],
				peru: [205, 133, 63],
				pink: [255, 192, 203],
				plum: [221, 160, 221],
				powderblue: [176, 224, 230],
				purple: [128, 0, 128],
				rebeccapurple: [102, 51, 153],
				red: [255, 0, 0],
				rosybrown: [188, 143, 143],
				royalblue: [65, 105, 225],
				saddlebrown: [139, 69, 19],
				salmon: [250, 128, 114],
				sandybrown: [244, 164, 96],
				seagreen: [46, 139, 87],
				seashell: [255, 245, 238],
				sienna: [160, 82, 45],
				silver: [192, 192, 192],
				skyblue: [135, 206, 235],
				slateblue: [106, 90, 205],
				slategray: [112, 128, 144],
				slategrey: [112, 128, 144],
				snow: [255, 250, 250],
				springgreen: [0, 255, 127],
				steelblue: [70, 130, 180],
				tan: [210, 180, 140],
				teal: [0, 128, 128],
				thistle: [216, 191, 216],
				tomato: [255, 99, 71],
				turquoise: [64, 224, 208],
				violet: [238, 130, 238],
				wheat: [245, 222, 179],
				white: [255, 255, 255],
				whitesmoke: [245, 245, 245],
				yellow: [255, 255, 0],
				yellowgreen: [154, 205, 50]
			}
		},
		6962: ct => {
			var ft, A
			;(ft = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
				(ct.exports = A =
					{
						rotl: function (X, q) {
							return (X << q) | (X >>> (32 - q))
						},
						rotr: function (X, q) {
							return (X << (32 - q)) | (X >>> q)
						},
						endian: function (X) {
							if (X.constructor == Number) return (16711935 & A.rotl(X, 8)) | (4278255360 & A.rotl(X, 24))
							for (var q = 0; q < X.length; q++) X[q] = A.endian(X[q])
							return X
						},
						randomBytes: function (X) {
							for (var q = []; X > 0; X--) q.push(Math.floor(256 * Math.random()))
							return q
						},
						bytesToWords: function (X) {
							for (var q = [], m = 0, de = 0; m < X.length; m++, de += 8) q[de >>> 5] |= X[m] << (24 - (de % 32))
							return q
						},
						wordsToBytes: function (X) {
							for (var q = [], m = 0; m < 32 * X.length; m += 8) q.push((X[m >>> 5] >>> (24 - (m % 32))) & 255)
							return q
						},
						bytesToHex: function (X) {
							for (var q = [], m = 0; m < X.length; m++) q.push((X[m] >>> 4).toString(16)), q.push((15 & X[m]).toString(16))
							return q.join("")
						},
						hexToBytes: function (X) {
							for (var q = [], m = 0; m < X.length; m += 2) q.push(parseInt(X.substr(m, 2), 16))
							return q
						},
						bytesToBase64: function (X) {
							for (var q = [], m = 0; m < X.length; m += 3)
								for (var de = (X[m] << 16) | (X[m + 1] << 8) | X[m + 2], Q = 0; Q < 4; Q++)
									q.push(8 * m + 6 * Q <= 8 * X.length ? ft.charAt((de >>> (6 * (3 - Q))) & 63) : "=")
							return q.join("")
						},
						base64ToBytes: function (X) {
							X = X.replace(/[^A-Z0-9+\/]/gi, "")
							for (var q = [], m = 0, de = 0; m < X.length; de = ++m % 4)
								0 != de &&
									q.push(
										((ft.indexOf(X.charAt(m - 1)) & (Math.pow(2, -2 * de + 8) - 1)) << (2 * de)) |
											(ft.indexOf(X.charAt(m)) >>> (6 - 2 * de))
									)
							return q
						}
					})
		},
		9818: ct => {
			"use strict"
			ct.exports = function ft(A, X) {
				if (A === X) return !0
				if (A && X && "object" == typeof A && "object" == typeof X) {
					if (A.constructor !== X.constructor) return !1
					var q, m, de
					if (Array.isArray(A)) {
						if ((q = A.length) != X.length) return !1
						for (m = q; 0 != m--; ) if (!ft(A[m], X[m])) return !1
						return !0
					}
					if (A.constructor === RegExp) return A.source === X.source && A.flags === X.flags
					if (A.valueOf !== Object.prototype.valueOf) return A.valueOf() === X.valueOf()
					if (A.toString !== Object.prototype.toString) return A.toString() === X.toString()
					if ((q = (de = Object.keys(A)).length) !== Object.keys(X).length) return !1
					for (m = q; 0 != m--; ) if (!Object.prototype.hasOwnProperty.call(X, de[m])) return !1
					for (m = q; 0 != m--; ) {
						var Q = de[m]
						if (!ft(A[Q], X[Q])) return !1
					}
					return !0
				}
				return A != A && X != X
			}
		},
		4236: ct => {
			"use strict"
			ct.exports = function (ft, A) {
				A || (A = {}), "function" == typeof A && (A = { cmp: A })
				var de,
					X = "boolean" == typeof A.cycles && A.cycles,
					q =
						A.cmp &&
						((de = A.cmp),
						function (Q) {
							return function (D, $) {
								return de({ key: D, value: Q[D] }, { key: $, value: Q[$] })
							}
						}),
					m = []
				return (function de(Q) {
					if ((Q && Q.toJSON && "function" == typeof Q.toJSON && (Q = Q.toJSON()), void 0 !== Q)) {
						if ("number" == typeof Q) return isFinite(Q) ? "" + Q : "null"
						if ("object" != typeof Q) return JSON.stringify(Q)
						var D, $
						if (Array.isArray(Q)) {
							for ($ = "[", D = 0; D < Q.length; D++) D && ($ += ","), ($ += de(Q[D]) || "null")
							return $ + "]"
						}
						if (null === Q) return "null"
						if (-1 !== m.indexOf(Q)) {
							if (X) return JSON.stringify("__cycle__")
							throw new TypeError("Converting circular structure to JSON")
						}
						var R = m.push(Q) - 1,
							V = Object.keys(Q).sort(q && q(Q))
						for ($ = "", D = 0; D < V.length; D++) {
							var B = V[D],
								H = de(Q[B])
							H && ($ && ($ += ","), ($ += JSON.stringify(B) + ":" + H))
						}
						return m.splice(R, 1), "{" + $ + "}"
					}
				})(ft)
			}
		},
		4456: function (ct) {
			ct.exports = (function () {
				"use strict"
				var ft = function (g, p) {
					return (ft =
						Object.setPrototypeOf ||
						({ __proto__: [] } instanceof Array &&
							function (v, b) {
								v.__proto__ = b
							}) ||
						function (v, b) {
							for (var E in b) Object.prototype.hasOwnProperty.call(b, E) && (v[E] = b[E])
						})(g, p)
				}
				function A(g, p) {
					if ("function" != typeof p && null !== p)
						throw new TypeError("Class extends value " + String(p) + " is not a constructor or null")
					function v() {
						this.constructor = g
					}
					ft(g, p), (g.prototype = null === p ? Object.create(p) : ((v.prototype = p.prototype), new v()))
				}
				var X = function () {
					return (
						(X =
							Object.assign ||
							function (p) {
								for (var v, b = 1, E = arguments.length; b < E; b++)
									for (var k in (v = arguments[b])) Object.prototype.hasOwnProperty.call(v, k) && (p[k] = v[k])
								return p
							}),
						X.apply(this, arguments)
					)
				}
				function q(g, p, v, b) {
					return new (v || (v = Promise))(function (k, z) {
						function te(Fe) {
							try {
								xe(b.next(Fe))
							} catch (Oe) {
								z(Oe)
							}
						}
						function ee(Fe) {
							try {
								xe(b.throw(Fe))
							} catch (Oe) {
								z(Oe)
							}
						}
						function xe(Fe) {
							Fe.done
								? k(Fe.value)
								: (function E(k) {
										return k instanceof v
											? k
											: new v(function (z) {
													z(k)
											  })
								  })(Fe.value).then(te, ee)
						}
						xe((b = b.apply(g, p || [])).next())
					})
				}
				function m(g, p) {
					var b,
						E,
						k,
						z,
						v = {
							label: 0,
							sent: function () {
								if (1 & k[0]) throw k[1]
								return k[1]
							},
							trys: [],
							ops: []
						}
					return (
						(z = { next: te(0), throw: te(1), return: te(2) }),
						"function" == typeof Symbol &&
							(z[Symbol.iterator] = function () {
								return this
							}),
						z
					)
					function te(xe) {
						return function (Fe) {
							return (function ee(xe) {
								if (b) throw new TypeError("Generator is already executing.")
								for (; v; )
									try {
										if (
											((b = 1),
											E &&
												(k = 2 & xe[0] ? E.return : xe[0] ? E.throw || ((k = E.return) && k.call(E), 0) : E.next) &&
												!(k = k.call(E, xe[1])).done)
										)
											return k
										switch (((E = 0), k && (xe = [2 & xe[0], k.value]), xe[0])) {
											case 0:
											case 1:
												k = xe
												break
											case 4:
												return v.label++, { value: xe[1], done: !1 }
											case 5:
												v.label++, (E = xe[1]), (xe = [0])
												continue
											case 7:
												;(xe = v.ops.pop()), v.trys.pop()
												continue
											default:
												if (!(k = (k = v.trys).length > 0 && k[k.length - 1]) && (6 === xe[0] || 2 === xe[0])) {
													v = 0
													continue
												}
												if (3 === xe[0] && (!k || (xe[1] > k[0] && xe[1] < k[3]))) {
													v.label = xe[1]
													break
												}
												if (6 === xe[0] && v.label < k[1]) {
													;(v.label = k[1]), (k = xe)
													break
												}
												if (k && v.label < k[2]) {
													;(v.label = k[2]), v.ops.push(xe)
													break
												}
												k[2] && v.ops.pop(), v.trys.pop()
												continue
										}
										xe = p.call(g, v)
									} catch (Fe) {
										;(xe = [6, Fe]), (E = 0)
									} finally {
										b = k = 0
									}
								if (5 & xe[0]) throw xe[1]
								return { value: xe[0] ? xe[1] : void 0, done: !0 }
							})([xe, Fe])
						}
					}
				}
				function de(g, p, v) {
					if (v || 2 === arguments.length)
						for (var k, b = 0, E = p.length; b < E; b++)
							(k || !(b in p)) && (k || (k = Array.prototype.slice.call(p, 0, b)), (k[b] = p[b]))
					return g.concat(k || p)
				}
				for (
					var Q = (function () {
							function g(p, v, b, E) {
								;(this.left = p), (this.top = v), (this.width = b), (this.height = E)
							}
							return (
								(g.prototype.add = function (p, v, b, E) {
									return new g(this.left + p, this.top + v, this.width + b, this.height + E)
								}),
								(g.fromClientRect = function (p, v) {
									return new g(v.left + p.windowBounds.left, v.top + p.windowBounds.top, v.width, v.height)
								}),
								(g.fromDOMRectList = function (p, v) {
									var b = Array.from(v).find(function (E) {
										return 0 !== E.width
									})
									return b ? new g(b.left + p.windowBounds.left, b.top + p.windowBounds.top, b.width, b.height) : g.EMPTY
								}),
								(g.EMPTY = new g(0, 0, 0, 0)),
								g
							)
						})(),
						D = function (g, p) {
							return Q.fromClientRect(g, p.getBoundingClientRect())
						},
						R = function (g) {
							for (var p = [], v = 0, b = g.length; v < b; ) {
								var E = g.charCodeAt(v++)
								if (E >= 55296 && E <= 56319 && v < b) {
									var k = g.charCodeAt(v++)
									56320 == (64512 & k) ? p.push(((1023 & E) << 10) + (1023 & k) + 65536) : (p.push(E), v--)
								} else p.push(E)
							}
							return p
						},
						V = function () {
							for (var g = [], p = 0; p < arguments.length; p++) g[p] = arguments[p]
							if (String.fromCodePoint) return String.fromCodePoint.apply(String, g)
							var v = g.length
							if (!v) return ""
							for (var b = [], E = -1, k = ""; ++E < v; ) {
								var z = g[E]
								z <= 65535 ? b.push(z) : b.push(55296 + ((z -= 65536) >> 10), (z % 1024) + 56320),
									(E + 1 === v || b.length > 16384) && ((k += String.fromCharCode.apply(String, b)), (b.length = 0))
							}
							return k
						},
						B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
						H = typeof Uint8Array > "u" ? [] : new Uint8Array(256),
						I = 0;
					I < 64;
					I++
				)
					H[B.charCodeAt(I)] = I
				for (
					var G = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
						J = typeof Uint8Array > "u" ? [] : new Uint8Array(256),
						Y = 0;
					Y < 64;
					Y++
				)
					J[G.charCodeAt(Y)] = Y
				for (
					var Ge = function (g, p, v) {
							return g.slice ? g.slice(p, v) : new Uint16Array(Array.prototype.slice.call(g, p, v))
						},
						yn = (function () {
							function g(p, v, b, E, k, z) {
								;(this.initialValue = p),
									(this.errorValue = v),
									(this.highStart = b),
									(this.highValueIndex = E),
									(this.index = k),
									(this.data = z)
							}
							return (
								(g.prototype.get = function (p) {
									var v
									if (p >= 0) {
										if (p < 55296 || (p > 56319 && p <= 65535))
											return this.data[(v = ((v = this.index[p >> 5]) << 2) + (31 & p))]
										if (p <= 65535)
											return this.data[(v = ((v = this.index[2048 + ((p - 55296) >> 5)]) << 2) + (31 & p))]
										if (p < this.highStart)
											return (
												(v = this.index[(v = 2080 + (p >> 11))]),
												this.data[(v = ((v = this.index[(v += (p >> 5) & 63)]) << 2) + (31 & p))]
											)
										if (p <= 1114111) return this.data[this.highValueIndex]
									}
									return this.errorValue
								}),
								g
							)
						})(),
						ai = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
						vt = typeof Uint8Array > "u" ? [] : new Uint8Array(256),
						hi = 0;
					hi < 64;
					hi++
				)
					vt[ai.charCodeAt(hi)] = hi
				var v,
					b,
					E,
					z,
					te,
					Ci = 10,
					Qn = 13,
					Br = 15,
					Ze = 17,
					li = 18,
					Vr = 19,
					Yr = 20,
					rs = 21,
					No = 22,
					Gc = 24,
					Qr = 25,
					ba = 26,
					Dl = 27,
					$c = 28,
					fc = 30,
					eh = 32,
					th = 33,
					Tf = 34,
					Ff = 35,
					Od = 37,
					mc = 38,
					If = 39,
					Wc = 40,
					Nd = 42,
					Qp = [9001, 65288],
					pi = "\xd7",
					be =
						((v = (function (g) {
							var b,
								k,
								z,
								te,
								ee,
								p = 0.75 * g.length,
								v = g.length,
								E = 0
							"=" === g[g.length - 1] && (p--, "=" === g[g.length - 2] && p--)
							var xe =
									typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u"
										? new ArrayBuffer(p)
										: new Array(p),
								Fe = Array.isArray(xe) ? xe : new Uint8Array(xe)
							for (b = 0; b < v; b += 4)
								(k = J[g.charCodeAt(b)]),
									(z = J[g.charCodeAt(b + 1)]),
									(te = J[g.charCodeAt(b + 2)]),
									(ee = J[g.charCodeAt(b + 3)]),
									(Fe[E++] = (k << 2) | (z >> 4)),
									(Fe[E++] = ((15 & z) << 4) | (te >> 2)),
									(Fe[E++] = ((3 & te) << 6) | (63 & ee))
							return xe
						})(
							"KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA=="
						)),
						(b = Array.isArray(v)
							? (function (g) {
									for (var p = g.length, v = [], b = 0; b < p; b += 4)
										v.push((g[b + 3] << 24) | (g[b + 2] << 16) | (g[b + 1] << 8) | g[b])
									return v
							  })(v)
							: new Uint32Array(v)),
						(E = Array.isArray(v)
							? (function (g) {
									for (var p = g.length, v = [], b = 0; b < p; b += 2) v.push((g[b + 1] << 8) | g[b])
									return v
							  })(v)
							: new Uint16Array(v)),
						(z = Ge(E, 12, b[4] / 2)),
						(te =
							2 === b[5]
								? Ge(E, (24 + b[4]) / 2)
								: (function (g, p, v) {
										return g.slice ? g.slice(p, v) : new Uint32Array(Array.prototype.slice.call(g, p, v))
								  })(b, Math.ceil((24 + b[4]) / 4))),
						new yn(b[0], b[1], b[2], b[3], z, te)),
					ie = [fc, 36],
					_e = [1, 2, 3, 5],
					$e = [Ci, 8],
					Xe = [Dl, ba],
					Xt = _e.concat($e),
					ii = [mc, If, Wc, Tf, Ff],
					Ti = [Br, Qn],
					Ir = function (g, p, v, b) {
						var E = b[v]
						if (Array.isArray(g) ? -1 !== g.indexOf(E) : g === E)
							for (var k = v; k <= b.length; ) {
								if ((z = b[++k]) === p) return !0
								if (z !== Ci) break
							}
						if (E === Ci)
							for (k = v; k > 0; ) {
								var te = b[--k]
								if (Array.isArray(g) ? -1 !== g.indexOf(te) : g === te)
									for (var ee = v; ee <= b.length; ) {
										var z
										if ((z = b[++ee]) === p) return !0
										if (z !== Ci) break
									}
								if (te !== Ci) break
							}
						return !1
					},
					Jn = function (g, p) {
						for (var v = g; v >= 0; ) {
							var b = p[v]
							if (b !== Ci) return b
							v--
						}
						return 0
					},
					wr = function (g, p, v, b, E) {
						if (0 === v[b]) return pi
						var k = b - 1
						if (Array.isArray(E) && !0 === E[k]) return pi
						var z = k - 1,
							te = k + 1,
							ee = p[k],
							xe = z >= 0 ? p[z] : 0,
							Fe = p[te]
						if (2 === ee && 3 === Fe) return pi
						if (-1 !== _e.indexOf(ee)) return "!"
						if (-1 !== _e.indexOf(Fe) || -1 !== $e.indexOf(Fe)) return pi
						if (8 === Jn(k, p)) return "\xf7"
						if (
							11 === be.get(g[k]) ||
							((ee === eh || ee === th) && 11 === be.get(g[te])) ||
							7 === ee ||
							7 === Fe ||
							9 === ee ||
							(-1 === [Ci, Qn, Br].indexOf(ee) && 9 === Fe) ||
							-1 !== [Ze, li, Vr, Gc, $c].indexOf(Fe) ||
							Jn(k, p) === No ||
							Ir(23, No, k, p) ||
							Ir([Ze, li], rs, k, p) ||
							Ir(12, 12, k, p)
						)
							return pi
						if (ee === Ci) return "\xf7"
						if (23 === ee || 23 === Fe) return pi
						if (16 === Fe || 16 === ee) return "\xf7"
						if (
							-1 !== [Qn, Br, rs].indexOf(Fe) ||
							14 === ee ||
							(36 === xe && -1 !== Ti.indexOf(ee)) ||
							(ee === $c && 36 === Fe) ||
							Fe === Yr ||
							(-1 !== ie.indexOf(Fe) && ee === Qr) ||
							(-1 !== ie.indexOf(ee) && Fe === Qr) ||
							(ee === Dl && -1 !== [Od, eh, th].indexOf(Fe)) ||
							(-1 !== [Od, eh, th].indexOf(ee) && Fe === ba) ||
							(-1 !== ie.indexOf(ee) && -1 !== Xe.indexOf(Fe)) ||
							(-1 !== Xe.indexOf(ee) && -1 !== ie.indexOf(Fe)) ||
							(-1 !== [Dl, ba].indexOf(ee) && (Fe === Qr || (-1 !== [No, Br].indexOf(Fe) && p[te + 1] === Qr))) ||
							(-1 !== [No, Br].indexOf(ee) && Fe === Qr) ||
							(ee === Qr && -1 !== [Qr, $c, Gc].indexOf(Fe))
						)
							return pi
						if (-1 !== [Qr, $c, Gc, Ze, li].indexOf(Fe))
							for (var Oe = k; Oe >= 0; ) {
								if ((ot = p[Oe]) === Qr) return pi
								if (-1 === [$c, Gc].indexOf(ot)) break
								Oe--
							}
						if (-1 !== [Dl, ba].indexOf(Fe))
							for (Oe = -1 !== [Ze, li].indexOf(ee) ? z : k; Oe >= 0; ) {
								var ot
								if ((ot = p[Oe]) === Qr) return pi
								if (-1 === [$c, Gc].indexOf(ot)) break
								Oe--
							}
						if (
							(mc === ee && -1 !== [mc, If, Tf, Ff].indexOf(Fe)) ||
							(-1 !== [If, Tf].indexOf(ee) && -1 !== [If, Wc].indexOf(Fe)) ||
							(-1 !== [Wc, Ff].indexOf(ee) && Fe === Wc) ||
							(-1 !== ii.indexOf(ee) && -1 !== [Yr, ba].indexOf(Fe)) ||
							(-1 !== ii.indexOf(Fe) && ee === Dl) ||
							(-1 !== ie.indexOf(ee) && -1 !== ie.indexOf(Fe)) ||
							(ee === Gc && -1 !== ie.indexOf(Fe)) ||
							(-1 !== ie.concat(Qr).indexOf(ee) && Fe === No && -1 === Qp.indexOf(g[te])) ||
							(-1 !== ie.concat(Qr).indexOf(Fe) && ee === li)
						)
							return pi
						if (41 === ee && 41 === Fe) {
							for (var Yt = v[k], Ft = 1; Yt > 0 && 41 === p[--Yt]; ) Ft++
							if (Ft % 2 != 0) return pi
						}
						return ee === eh && Fe === th ? pi : "\xf7"
					},
					ir = function (g, p) {
						p || (p = { lineBreak: "normal", wordBreak: "normal" })
						var v = (function (g, p) {
								void 0 === p && (p = "strict")
								var v = [],
									b = [],
									E = []
								return (
									g.forEach(function (k, z) {
										var te = be.get(k)
										if (
											(te > 50 ? (E.push(!0), (te -= 50)) : E.push(!1),
											-1 !== ["normal", "auto", "loose"].indexOf(p) && -1 !== [8208, 8211, 12316, 12448].indexOf(k))
										)
											return b.push(z), v.push(16)
										if (4 === te || 11 === te) {
											if (0 === z) return b.push(z), v.push(fc)
											var ee = v[z - 1]
											return -1 === Xt.indexOf(ee) ? (b.push(b[z - 1]), v.push(ee)) : (b.push(z), v.push(fc))
										}
										return (
											b.push(z),
											31 === te
												? v.push("strict" === p ? rs : Od)
												: te === Nd || 29 === te
												? v.push(fc)
												: 43 === te
												? v.push((k >= 131072 && k <= 196605) || (k >= 196608 && k <= 262141) ? Od : fc)
												: void v.push(te)
										)
									}),
									[b, v, E]
								)
							})(g, p.lineBreak),
							b = v[0],
							E = v[1],
							k = v[2]
						return (
							("break-all" === p.wordBreak || "break-word" === p.wordBreak) &&
								(E = E.map(function (te) {
									return -1 !== [Qr, fc, Nd].indexOf(te) ? Od : te
								})),
							[
								b,
								E,
								"keep-all" === p.wordBreak
									? k.map(function (te, ee) {
											return te && g[ee] >= 19968 && g[ee] <= 40959
									  })
									: void 0
							]
						)
					},
					fr = (function () {
						function g(p, v, b, E) {
							;(this.codePoints = p), (this.required = "!" === v), (this.start = b), (this.end = E)
						}
						return (
							(g.prototype.slice = function () {
								return V.apply(void 0, this.codePoints.slice(this.start, this.end))
							}),
							g
						)
					})(),
					mr = function (g) {
						return g >= 48 && g <= 57
					},
					Pf = function (g) {
						return mr(g) || (g >= 65 && g <= 70) || (g >= 97 && g <= 102)
					},
					rt = function (g) {
						return 10 === g || 9 === g || 32 === g
					},
					Qd = function (g) {
						return (
							(function (g) {
								return (
									(function (g) {
										return g >= 97 && g <= 122
									})(g) ||
									(function (g) {
										return g >= 65 && g <= 90
									})(g)
								)
							})(g) ||
							(function (g) {
								return g >= 128
							})(g) ||
							95 === g
						)
					},
					_T = function (g) {
						return Qd(g) || mr(g) || 45 === g
					},
					ex = function (g) {
						return (g >= 0 && g <= 8) || 11 === g || (g >= 14 && g <= 31) || 127 === g
					},
					Ol = function (g, p) {
						return 92 === g && 10 !== p
					},
					zd = function (g, p, v) {
						return 45 === g ? Qd(p) || Ol(p, v) : !!Qd(g) || !(92 !== g || !Ol(g, p))
					},
					oh = function (g, p, v) {
						return 43 === g || 45 === g ? !!mr(p) || (46 === p && mr(v)) : mr(46 === g ? p : g)
					},
					Yb = function (g) {
						var p = 0,
							v = 1
						;(43 === g[p] || 45 === g[p]) && (45 === g[p] && (v = -1), p++)
						for (var b = []; mr(g[p]); ) b.push(g[p++])
						var E = b.length ? parseInt(V.apply(void 0, b), 10) : 0
						46 === g[p] && p++
						for (var k = []; mr(g[p]); ) k.push(g[p++])
						var z = k.length,
							te = z ? parseInt(V.apply(void 0, k), 10) : 0
						;(69 === g[p] || 101 === g[p]) && p++
						var ee = 1
						;(43 === g[p] || 45 === g[p]) && (45 === g[p] && (ee = -1), p++)
						for (var xe = []; mr(g[p]); ) xe.push(g[p++])
						var Fe = xe.length ? parseInt(V.apply(void 0, xe), 10) : 0
						return v * (E + te * Math.pow(10, -z)) * Math.pow(10, ee * Fe)
					},
					tx = { type: 2 },
					vT = { type: 3 },
					Di = { type: 4 },
					qb = { type: 13 },
					nx = { type: 8 },
					Ns = { type: 21 },
					ix = { type: 9 },
					sU = { type: 10 },
					vr = { type: 11 },
					aU = { type: 12 },
					cU = { type: 14 },
					He = { type: 23 },
					Zb = { type: 1 },
					Jb = { type: 25 },
					rx = { type: 24 },
					e_ = { type: 26 },
					yT = { type: 27 },
					t_ = { type: 28 },
					lU = { type: 29 },
					dU = { type: 31 },
					ox = { type: 32 },
					wT = (function () {
						function g() {
							this._value = []
						}
						return (
							(g.prototype.write = function (p) {
								this._value = this._value.concat(R(p))
							}),
							(g.prototype.read = function () {
								for (var p = [], v = this.consumeToken(); v !== ox; ) p.push(v), (v = this.consumeToken())
								return p
							}),
							(g.prototype.consumeToken = function () {
								var p = this.consumeCodePoint()
								switch (p) {
									case 34:
										return this.consumeStringToken(34)
									case 35:
										var v = this.peekCodePoint(0),
											b = this.peekCodePoint(1),
											E = this.peekCodePoint(2)
										if (_T(v) || Ol(b, E)) {
											var k = zd(v, b, E) ? 2 : 1
											return { type: 5, value: this.consumeName(), flags: k }
										}
										break
									case 36:
										if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), qb
										break
									case 39:
										return this.consumeStringToken(39)
									case 40:
										return tx
									case 41:
										return vT
									case 42:
										if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), cU
										break
									case 43:
										if (oh(p, this.peekCodePoint(0), this.peekCodePoint(1)))
											return this.reconsumeCodePoint(p), this.consumeNumericToken()
										break
									case 44:
										return Di
									case 45:
										var te = p,
											ee = this.peekCodePoint(0),
											xe = this.peekCodePoint(1)
										if (oh(te, ee, xe)) return this.reconsumeCodePoint(p), this.consumeNumericToken()
										if (zd(te, ee, xe)) return this.reconsumeCodePoint(p), this.consumeIdentLikeToken()
										if (45 === ee && 62 === xe) return this.consumeCodePoint(), this.consumeCodePoint(), rx
										break
									case 46:
										if (oh(p, this.peekCodePoint(0), this.peekCodePoint(1)))
											return this.reconsumeCodePoint(p), this.consumeNumericToken()
										break
									case 47:
										if (42 === this.peekCodePoint(0))
											for (this.consumeCodePoint(); ; ) {
												var Fe = this.consumeCodePoint()
												if (42 === Fe && 47 === (Fe = this.consumeCodePoint())) return this.consumeToken()
												if (-1 === Fe) return this.consumeToken()
											}
										break
									case 58:
										return e_
									case 59:
										return yT
									case 60:
										if (33 === this.peekCodePoint(0) && 45 === this.peekCodePoint(1) && 45 === this.peekCodePoint(2))
											return this.consumeCodePoint(), this.consumeCodePoint(), Jb
										break
									case 64:
										var Oe = this.peekCodePoint(0),
											ot = this.peekCodePoint(1),
											Yt = this.peekCodePoint(2)
										if (zd(Oe, ot, Yt)) return { type: 7, value: this.consumeName() }
										break
									case 91:
										return t_
									case 92:
										if (Ol(p, this.peekCodePoint(0))) return this.reconsumeCodePoint(p), this.consumeIdentLikeToken()
										break
									case 93:
										return lU
									case 61:
										if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), nx
										break
									case 123:
										return vr
									case 125:
										return aU
									case 117:
									case 85:
										var Ft = this.peekCodePoint(0),
											Pt = this.peekCodePoint(1)
										return (
											43 === Ft &&
												(Pf(Pt) || 63 === Pt) &&
												(this.consumeCodePoint(), this.consumeUnicodeRangeToken()),
											this.reconsumeCodePoint(p),
											this.consumeIdentLikeToken()
										)
									case 124:
										if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), ix
										if (124 === this.peekCodePoint(0)) return this.consumeCodePoint(), Ns
										break
									case 126:
										if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), sU
										break
									case -1:
										return ox
								}
								return rt(p)
									? (this.consumeWhiteSpace(), dU)
									: mr(p)
									? (this.reconsumeCodePoint(p), this.consumeNumericToken())
									: Qd(p)
									? (this.reconsumeCodePoint(p), this.consumeIdentLikeToken())
									: { type: 6, value: V(p) }
							}),
							(g.prototype.consumeCodePoint = function () {
								var p = this._value.shift()
								return typeof p > "u" ? -1 : p
							}),
							(g.prototype.reconsumeCodePoint = function (p) {
								this._value.unshift(p)
							}),
							(g.prototype.peekCodePoint = function (p) {
								return p >= this._value.length ? -1 : this._value[p]
							}),
							(g.prototype.consumeUnicodeRangeToken = function () {
								for (var p = [], v = this.consumeCodePoint(); Pf(v) && p.length < 6; )
									p.push(v), (v = this.consumeCodePoint())
								for (var b = !1; 63 === v && p.length < 6; ) p.push(v), (v = this.consumeCodePoint()), (b = !0)
								if (b)
									return {
										type: 30,
										start: parseInt(
											V.apply(
												void 0,
												p.map(function (ee) {
													return 63 === ee ? 48 : ee
												})
											),
											16
										),
										end: parseInt(
											V.apply(
												void 0,
												p.map(function (ee) {
													return 63 === ee ? 70 : ee
												})
											),
											16
										)
									}
								var z = parseInt(V.apply(void 0, p), 16)
								if (45 === this.peekCodePoint(0) && Pf(this.peekCodePoint(1))) {
									this.consumeCodePoint(), (v = this.consumeCodePoint())
									for (var te = []; Pf(v) && te.length < 6; ) te.push(v), (v = this.consumeCodePoint())
									return { type: 30, start: z, end: parseInt(V.apply(void 0, te), 16) }
								}
								return { type: 30, start: z, end: z }
							}),
							(g.prototype.consumeIdentLikeToken = function () {
								var p = this.consumeName()
								return "url" === p.toLowerCase() && 40 === this.peekCodePoint(0)
									? (this.consumeCodePoint(), this.consumeUrlToken())
									: 40 === this.peekCodePoint(0)
									? (this.consumeCodePoint(), { type: 19, value: p })
									: { type: 20, value: p }
							}),
							(g.prototype.consumeUrlToken = function () {
								var p = []
								if ((this.consumeWhiteSpace(), -1 === this.peekCodePoint(0))) return { type: 22, value: "" }
								var v = this.peekCodePoint(0)
								if (39 === v || 34 === v) {
									var b = this.consumeStringToken(this.consumeCodePoint())
									return 0 === b.type &&
										(this.consumeWhiteSpace(), -1 === this.peekCodePoint(0) || 41 === this.peekCodePoint(0))
										? (this.consumeCodePoint(), { type: 22, value: b.value })
										: (this.consumeBadUrlRemnants(), He)
								}
								for (;;) {
									var E = this.consumeCodePoint()
									if (-1 === E || 41 === E) return { type: 22, value: V.apply(void 0, p) }
									if (rt(E))
										return (
											this.consumeWhiteSpace(),
											-1 === this.peekCodePoint(0) || 41 === this.peekCodePoint(0)
												? (this.consumeCodePoint(), { type: 22, value: V.apply(void 0, p) })
												: (this.consumeBadUrlRemnants(), He)
										)
									if (34 === E || 39 === E || 40 === E || ex(E)) return this.consumeBadUrlRemnants(), He
									if (92 === E) {
										if (!Ol(E, this.peekCodePoint(0))) return this.consumeBadUrlRemnants(), He
										p.push(this.consumeEscapedCodePoint())
									} else p.push(E)
								}
							}),
							(g.prototype.consumeWhiteSpace = function () {
								for (; rt(this.peekCodePoint(0)); ) this.consumeCodePoint()
							}),
							(g.prototype.consumeBadUrlRemnants = function () {
								for (;;) {
									var p = this.consumeCodePoint()
									if (41 === p || -1 === p) return
									Ol(p, this.peekCodePoint(0)) && this.consumeEscapedCodePoint()
								}
							}),
							(g.prototype.consumeStringSlice = function (p) {
								for (var b = ""; p > 0; ) {
									var E = Math.min(5e4, p)
									;(b += V.apply(void 0, this._value.splice(0, E))), (p -= E)
								}
								return this._value.shift(), b
							}),
							(g.prototype.consumeStringToken = function (p) {
								for (var v = "", b = 0; ; ) {
									var E = this._value[b]
									if (-1 === E || void 0 === E || E === p) return { type: 0, value: (v += this.consumeStringSlice(b)) }
									if (10 === E) return this._value.splice(0, b), Zb
									if (92 === E) {
										var k = this._value[b + 1]
										;-1 !== k &&
											void 0 !== k &&
											(10 === k
												? ((v += this.consumeStringSlice(b)), (b = -1), this._value.shift())
												: Ol(E, k) &&
												  ((v += this.consumeStringSlice(b)), (v += V(this.consumeEscapedCodePoint())), (b = -1)))
									}
									b++
								}
							}),
							(g.prototype.consumeNumber = function () {
								var p = [],
									v = 4,
									b = this.peekCodePoint(0)
								for ((43 === b || 45 === b) && p.push(this.consumeCodePoint()); mr(this.peekCodePoint(0)); )
									p.push(this.consumeCodePoint())
								b = this.peekCodePoint(0)
								var E = this.peekCodePoint(1)
								if (46 === b && mr(E))
									for (p.push(this.consumeCodePoint(), this.consumeCodePoint()), v = 8; mr(this.peekCodePoint(0)); )
										p.push(this.consumeCodePoint())
								;(b = this.peekCodePoint(0)), (E = this.peekCodePoint(1))
								var k = this.peekCodePoint(2)
								if ((69 === b || 101 === b) && (((43 === E || 45 === E) && mr(k)) || mr(E)))
									for (p.push(this.consumeCodePoint(), this.consumeCodePoint()), v = 8; mr(this.peekCodePoint(0)); )
										p.push(this.consumeCodePoint())
								return [Yb(p), v]
							}),
							(g.prototype.consumeNumericToken = function () {
								var p = this.consumeNumber(),
									v = p[0],
									b = p[1],
									E = this.peekCodePoint(0),
									k = this.peekCodePoint(1),
									z = this.peekCodePoint(2)
								return zd(E, k, z)
									? { type: 15, number: v, flags: b, unit: this.consumeName() }
									: 37 === E
									? (this.consumeCodePoint(), { type: 16, number: v, flags: b })
									: { type: 17, number: v, flags: b }
							}),
							(g.prototype.consumeEscapedCodePoint = function () {
								var p = this.consumeCodePoint()
								if (Pf(p)) {
									for (var v = V(p); Pf(this.peekCodePoint(0)) && v.length < 6; ) v += V(this.consumeCodePoint())
									rt(this.peekCodePoint(0)) && this.consumeCodePoint()
									var b = parseInt(v, 16)
									return 0 === b ||
										(function (g) {
											return g >= 55296 && g <= 57343
										})(b) ||
										b > 1114111
										? 65533
										: b
								}
								return -1 === p ? 65533 : p
							}),
							(g.prototype.consumeName = function () {
								for (var p = ""; ; ) {
									var v = this.consumeCodePoint()
									if (_T(v)) p += V(v)
									else {
										if (!Ol(v, this.peekCodePoint(0))) return this.reconsumeCodePoint(v), p
										p += V(this.consumeEscapedCodePoint())
									}
								}
							}),
							g
						)
					})(),
					xT = (function () {
						function g(p) {
							this._tokens = p
						}
						return (
							(g.create = function (p) {
								var v = new wT()
								return v.write(p), new g(v.read())
							}),
							(g.parseValue = function (p) {
								return g.create(p).parseComponentValue()
							}),
							(g.parseValues = function (p) {
								return g.create(p).parseComponentValues()
							}),
							(g.prototype.parseComponentValue = function () {
								for (var p = this.consumeToken(); 31 === p.type; ) p = this.consumeToken()
								if (32 === p.type) throw new SyntaxError("Error parsing CSS component value, unexpected EOF")
								this.reconsumeToken(p)
								var v = this.consumeComponentValue()
								do {
									p = this.consumeToken()
								} while (31 === p.type)
								if (32 === p.type) return v
								throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one")
							}),
							(g.prototype.parseComponentValues = function () {
								for (var p = []; ; ) {
									var v = this.consumeComponentValue()
									if (32 === v.type) return p
									p.push(v), p.push()
								}
							}),
							(g.prototype.consumeComponentValue = function () {
								var p = this.consumeToken()
								switch (p.type) {
									case 11:
									case 28:
									case 2:
										return this.consumeSimpleBlock(p.type)
									case 19:
										return this.consumeFunction(p)
								}
								return p
							}),
							(g.prototype.consumeSimpleBlock = function (p) {
								for (var v = { type: p, values: [] }, b = this.consumeToken(); ; ) {
									if (32 === b.type || ET(b, p)) return v
									this.reconsumeToken(b), v.values.push(this.consumeComponentValue()), (b = this.consumeToken())
								}
							}),
							(g.prototype.consumeFunction = function (p) {
								for (var v = { name: p.value, values: [], type: 18 }; ; ) {
									var b = this.consumeToken()
									if (32 === b.type || 3 === b.type) return v
									this.reconsumeToken(b), v.values.push(this.consumeComponentValue())
								}
							}),
							(g.prototype.consumeToken = function () {
								var p = this._tokens.shift()
								return typeof p > "u" ? ox : p
							}),
							(g.prototype.reconsumeToken = function (p) {
								this._tokens.unshift(p)
							}),
							g
						)
					})(),
					Kc = function (g) {
						return 15 === g.type
					},
					Nl = function (g) {
						return 17 === g.type
					},
					qi = function (g) {
						return 20 === g.type
					},
					CT = function (g) {
						return 0 === g.type
					},
					n_ = function (g, p) {
						return qi(g) && g.value === p
					},
					sx = function (g) {
						return 31 !== g.type
					},
					Gd = function (g) {
						return 31 !== g.type && 4 !== g.type
					},
					bs = function (g) {
						var p = [],
							v = []
						return (
							g.forEach(function (b) {
								if (4 === b.type) {
									if (0 === v.length) throw new Error("Error parsing function args, zero tokens for arg")
									return p.push(v), void (v = [])
								}
								31 !== b.type && v.push(b)
							}),
							v.length && p.push(v),
							p
						)
					},
					ET = function (g, p) {
						return (11 === p && 12 === g.type) || (28 === p && 29 === g.type) || (2 === p && 3 === g.type)
					},
					_s = function (g) {
						return 17 === g.type || 15 === g.type
					},
					mo = function (g) {
						return 16 === g.type || _s(g)
					},
					re = function (g) {
						return g.length > 1 ? [g[0], g[1]] : [g[0]]
					},
					Ho = { type: 17, number: 0, flags: 4 },
					Rt = { type: 16, number: 50, flags: 4 },
					Va = { type: 16, number: 100, flags: 4 },
					$d = function (g, p, v) {
						var b = g[0],
							E = g[1]
						return [tr(b, p), tr(typeof E < "u" ? E : b, v)]
					},
					tr = function (g, p) {
						if (16 === g.type) return (g.number / 100) * p
						if (Kc(g))
							switch (g.unit) {
								case "rem":
								case "em":
									return 16 * g.number
								default:
									return g.number
							}
						return g.number
					},
					Wd_parse = function (g, p) {
						if (15 === p.type)
							switch (p.unit) {
								case "deg":
									return (Math.PI * p.number) / 180
								case "grad":
									return (Math.PI / 200) * p.number
								case "rad":
									return p.number
								case "turn":
									return 2 * Math.PI * p.number
							}
						throw new Error("Unsupported angle type")
					},
					Zs = function (g) {
						return 15 === g.type && ("deg" === g.unit || "grad" === g.unit || "rad" === g.unit || "turn" === g.unit)
					},
					Qa = function (g) {
						switch (
							g
								.filter(qi)
								.map(function (v) {
									return v.value
								})
								.join(" ")
						) {
							case "to bottom right":
							case "to right bottom":
							case "left top":
							case "top left":
								return [Ho, Ho]
							case "to top":
							case "bottom":
								return oi(0)
							case "to bottom left":
							case "to left bottom":
							case "right top":
							case "top right":
								return [Ho, Va]
							case "to right":
							case "left":
								return oi(90)
							case "to top left":
							case "to left top":
							case "right bottom":
							case "bottom right":
								return [Va, Va]
							case "to bottom":
							case "top":
								return oi(180)
							case "to top right":
							case "to right top":
							case "left bottom":
							case "bottom left":
								return [Va, Ho]
							case "to left":
							case "right":
								return oi(270)
						}
						return 0
					},
					oi = function (g) {
						return (Math.PI * g) / 180
					},
					za_parse = function (g, p) {
						if (18 === p.type) {
							var v = r_[p.name]
							if (typeof v > "u") throw new Error('Attempting to parse an unsupported color function "' + p.name + '"')
							return v(g, p.values)
						}
						if (5 === p.type) {
							if (3 === p.value.length) {
								var b = p.value.substring(0, 1),
									E = p.value.substring(1, 2),
									k = p.value.substring(2, 3)
								return Xc(parseInt(b + b, 16), parseInt(E + E, 16), parseInt(k + k, 16), 1)
							}
							if (4 === p.value.length) {
								;(b = p.value.substring(0, 1)), (E = p.value.substring(1, 2)), (k = p.value.substring(2, 3))
								var z = p.value.substring(3, 4)
								return Xc(parseInt(b + b, 16), parseInt(E + E, 16), parseInt(k + k, 16), parseInt(z + z, 16) / 255)
							}
							if (6 === p.value.length)
								return (
									(b = p.value.substring(0, 2)),
									(E = p.value.substring(2, 4)),
									(k = p.value.substring(4, 6)),
									Xc(parseInt(b, 16), parseInt(E, 16), parseInt(k, 16), 1)
								)
							if (8 === p.value.length)
								return (
									(b = p.value.substring(0, 2)),
									(E = p.value.substring(2, 4)),
									(k = p.value.substring(4, 6)),
									(z = p.value.substring(6, 8)),
									Xc(parseInt(b, 16), parseInt(E, 16), parseInt(k, 16), parseInt(z, 16) / 255)
								)
						}
						if (20 === p.type) {
							var te = wc[p.value.toUpperCase()]
							if (typeof te < "u") return te
						}
						return wc.TRANSPARENT
					},
					vc = function (g) {
						return 0 == (255 & g)
					},
					po = function (g) {
						var p = 255 & g,
							v = 255 & (g >> 8),
							b = 255 & (g >> 16),
							E = 255 & (g >> 24)
						return p < 255 ? "rgba(" + E + "," + b + "," + v + "," + p / 255 + ")" : "rgb(" + E + "," + b + "," + v + ")"
					},
					Xc = function (g, p, v, b) {
						return ((g << 24) | (p << 16) | (v << 8) | (Math.round(255 * b) << 0)) >>> 0
					},
					yc = function (g, p) {
						if (17 === g.type) return g.number
						if (16 === g.type) {
							var v = 3 === p ? 1 : 255
							return 3 === p ? (g.number / 100) * v : Math.round((g.number / 100) * v)
						}
						return 0
					},
					sh = function (g, p) {
						var v = p.filter(Gd)
						if (3 === v.length) {
							var b = v.map(yc)
							return Xc(b[0], b[1], b[2], 1)
						}
						if (4 === v.length) {
							var te = v.map(yc)
							return Xc(te[0], te[1], te[2], te[3])
						}
						return 0
					}
				function $p(g, p, v) {
					return (
						v < 0 && (v += 1),
						v >= 1 && (v -= 1),
						v < 1 / 6 ? (p - g) * v * 6 + g : v < 0.5 ? p : v < 2 / 3 ? 6 * (p - g) * (2 / 3 - v) + g : g
					)
				}
				var i_ = function (g, p) {
						var v = p.filter(Gd),
							b = v[0],
							E = v[1],
							k = v[2],
							z = v[3],
							te = (17 === b.type ? oi(b.number) : Wd_parse(g, b)) / (2 * Math.PI),
							ee = mo(E) ? E.number / 100 : 0,
							xe = mo(k) ? k.number / 100 : 0,
							Fe = typeof z < "u" && mo(z) ? tr(z, 1) : 1
						if (0 === ee) return Xc(255 * xe, 255 * xe, 255 * xe, 1)
						var Oe = xe <= 0.5 ? xe * (ee + 1) : xe + ee - xe * ee,
							ot = 2 * xe - Oe,
							Yt = $p(ot, Oe, te + 1 / 3),
							Ft = $p(ot, Oe, te),
							Pt = $p(ot, Oe, te - 1 / 3)
						return Xc(255 * Yt, 255 * Ft, 255 * Pt, Fe)
					},
					r_ = { hsl: i_, hsla: i_, rgb: sh, rgba: sh },
					ah = function (g, p) {
						return za_parse(g, xT.create(p).parseComponentValue())
					},
					wc = {
						ALICEBLUE: 4042850303,
						ANTIQUEWHITE: 4209760255,
						AQUA: 16777215,
						AQUAMARINE: 2147472639,
						AZURE: 4043309055,
						BEIGE: 4126530815,
						BISQUE: 4293182719,
						BLACK: 255,
						BLANCHEDALMOND: 4293643775,
						BLUE: 65535,
						BLUEVIOLET: 2318131967,
						BROWN: 2771004159,
						BURLYWOOD: 3736635391,
						CADETBLUE: 1604231423,
						CHARTREUSE: 2147418367,
						CHOCOLATE: 3530104575,
						CORAL: 4286533887,
						CORNFLOWERBLUE: 1687547391,
						CORNSILK: 4294499583,
						CRIMSON: 3692313855,
						CYAN: 16777215,
						DARKBLUE: 35839,
						DARKCYAN: 9145343,
						DARKGOLDENROD: 3095837695,
						DARKGRAY: 2846468607,
						DARKGREEN: 6553855,
						DARKGREY: 2846468607,
						DARKKHAKI: 3182914559,
						DARKMAGENTA: 2332068863,
						DARKOLIVEGREEN: 1433087999,
						DARKORANGE: 4287365375,
						DARKORCHID: 2570243327,
						DARKRED: 2332033279,
						DARKSALMON: 3918953215,
						DARKSEAGREEN: 2411499519,
						DARKSLATEBLUE: 1211993087,
						DARKSLATEGRAY: 793726975,
						DARKSLATEGREY: 793726975,
						DARKTURQUOISE: 13554175,
						DARKVIOLET: 2483082239,
						DEEPPINK: 4279538687,
						DEEPSKYBLUE: 12582911,
						DIMGRAY: 1768516095,
						DIMGREY: 1768516095,
						DODGERBLUE: 512819199,
						FIREBRICK: 2988581631,
						FLORALWHITE: 4294635775,
						FORESTGREEN: 579543807,
						FUCHSIA: 4278255615,
						GAINSBORO: 3705462015,
						GHOSTWHITE: 4177068031,
						GOLD: 4292280575,
						GOLDENROD: 3668254975,
						GRAY: 2155905279,
						GREEN: 8388863,
						GREENYELLOW: 2919182335,
						GREY: 2155905279,
						HONEYDEW: 4043305215,
						HOTPINK: 4285117695,
						INDIANRED: 3445382399,
						INDIGO: 1258324735,
						IVORY: 4294963455,
						KHAKI: 4041641215,
						LAVENDER: 3873897215,
						LAVENDERBLUSH: 4293981695,
						LAWNGREEN: 2096890111,
						LEMONCHIFFON: 4294626815,
						LIGHTBLUE: 2916673279,
						LIGHTCORAL: 4034953471,
						LIGHTCYAN: 3774873599,
						LIGHTGOLDENRODYELLOW: 4210742015,
						LIGHTGRAY: 3553874943,
						LIGHTGREEN: 2431553791,
						LIGHTGREY: 3553874943,
						LIGHTPINK: 4290167295,
						LIGHTSALMON: 4288707327,
						LIGHTSEAGREEN: 548580095,
						LIGHTSKYBLUE: 2278488831,
						LIGHTSLATEGRAY: 2005441023,
						LIGHTSLATEGREY: 2005441023,
						LIGHTSTEELBLUE: 2965692159,
						LIGHTYELLOW: 4294959359,
						LIME: 16711935,
						LIMEGREEN: 852308735,
						LINEN: 4210091775,
						MAGENTA: 4278255615,
						MAROON: 2147483903,
						MEDIUMAQUAMARINE: 1724754687,
						MEDIUMBLUE: 52735,
						MEDIUMORCHID: 3126187007,
						MEDIUMPURPLE: 2473647103,
						MEDIUMSEAGREEN: 1018393087,
						MEDIUMSLATEBLUE: 2070474495,
						MEDIUMSPRINGGREEN: 16423679,
						MEDIUMTURQUOISE: 1221709055,
						MEDIUMVIOLETRED: 3340076543,
						MIDNIGHTBLUE: 421097727,
						MINTCREAM: 4127193855,
						MISTYROSE: 4293190143,
						MOCCASIN: 4293178879,
						NAVAJOWHITE: 4292783615,
						NAVY: 33023,
						OLDLACE: 4260751103,
						OLIVE: 2155872511,
						OLIVEDRAB: 1804477439,
						ORANGE: 4289003775,
						ORANGERED: 4282712319,
						ORCHID: 3664828159,
						PALEGOLDENROD: 4008225535,
						PALEGREEN: 2566625535,
						PALETURQUOISE: 2951671551,
						PALEVIOLETRED: 3681588223,
						PAPAYAWHIP: 4293907967,
						PEACHPUFF: 4292524543,
						PERU: 3448061951,
						PINK: 4290825215,
						PLUM: 3718307327,
						POWDERBLUE: 2967529215,
						PURPLE: 2147516671,
						REBECCAPURPLE: 1714657791,
						RED: 4278190335,
						ROSYBROWN: 3163525119,
						ROYALBLUE: 1097458175,
						SADDLEBROWN: 2336560127,
						SALMON: 4202722047,
						SANDYBROWN: 4104413439,
						SEAGREEN: 780883967,
						SEASHELL: 4294307583,
						SIENNA: 2689740287,
						SILVER: 3233857791,
						SKYBLUE: 2278484991,
						SLATEBLUE: 1784335871,
						SLATEGRAY: 1887473919,
						SLATEGREY: 1887473919,
						SNOW: 4294638335,
						SPRINGGREEN: 16744447,
						STEELBLUE: 1182971135,
						TAN: 3535047935,
						TEAL: 8421631,
						THISTLE: 3636451583,
						TOMATO: 4284696575,
						TRANSPARENT: 0,
						TURQUOISE: 1088475391,
						VIOLET: 4001558271,
						WHEAT: 4125012991,
						WHITE: 4294967295,
						WHITESMOKE: 4126537215,
						YELLOW: 4294902015,
						YELLOWGREEN: 2597139199
					},
					Of = {
						name: "background-clip",
						initialValue: "border-box",
						prefix: !1,
						type: 1,
						parse: function (g, p) {
							return p.map(function (v) {
								if (qi(v))
									switch (v.value) {
										case "padding-box":
											return 1
										case "content-box":
											return 2
									}
								return 0
							})
						}
					},
					dx = { name: "background-color", initialValue: "transparent", prefix: !1, type: 3, format: "color" },
					Nf = function (g, p) {
						var v = za_parse(g, p[0]),
							b = p[1]
						return b && mo(b) ? { color: v, stop: b } : { color: v, stop: null }
					},
					ux = function (g, p) {
						var v = g[0],
							b = g[g.length - 1]
						null === v.stop && (v.stop = Ho), null === b.stop && (b.stop = Va)
						for (var E = [], k = 0, z = 0; z < g.length; z++) {
							var te = g[z].stop
							if (null !== te) {
								var ee = tr(te, p)
								E.push(ee > k ? ee : k), (k = ee)
							} else E.push(null)
						}
						var xe = null
						for (z = 0; z < E.length; z++) {
							var Fe = E[z]
							if (null === Fe) null === xe && (xe = z)
							else if (null !== xe) {
								for (var Oe = z - xe, Yt = (Fe - E[xe - 1]) / (Oe + 1), Ft = 1; Ft <= Oe; Ft++) E[xe + Ft - 1] = Yt * Ft
								xe = null
							}
						}
						return g.map(function (Pt, fi) {
							return { color: Pt.color, stop: Math.max(Math.min(1, E[fi] / p), 0) }
						})
					},
					MT = function (g, p, v) {
						var b =
								"number" == typeof g
									? g
									: (function (g, p, v) {
											var b = p / 2,
												E = v / 2,
												k = tr(g[0], p) - b,
												z = E - tr(g[1], v)
											return (Math.atan2(z, k) + 2 * Math.PI) % (2 * Math.PI)
									  })(g, p, v),
							E = Math.abs(p * Math.sin(b)) + Math.abs(v * Math.cos(b)),
							k = p / 2,
							z = v / 2,
							te = E / 2,
							ee = Math.sin(b - Math.PI / 2) * te,
							xe = Math.cos(b - Math.PI / 2) * te
						return [E, k - xe, k + xe, z - ee, z + ee]
					},
					Ga = function (g, p) {
						return Math.sqrt(g * g + p * p)
					},
					wa = function (g, p, v, b, E) {
						return [
							[0, 0],
							[0, p],
							[g, 0],
							[g, p]
						].reduce(
							function (z, te) {
								var Fe = Ga(v - te[0], b - te[1])
								return (E ? Fe < z.optimumDistance : Fe > z.optimumDistance)
									? { optimumCorner: te, optimumDistance: Fe }
									: z
							},
							{ optimumDistance: E ? 1 / 0 : -1 / 0, optimumCorner: null }
						).optimumCorner
					},
					Wp = function (g, p) {
						var v = oi(180),
							b = []
						return (
							bs(p).forEach(function (E, k) {
								if (0 === k) {
									var z = E[0]
									if (20 === z.type && -1 !== ["top", "left", "right", "bottom"].indexOf(z.value)) return void (v = Qa(E))
									if (Zs(z)) return void (v = (Wd_parse(g, z) + oi(270)) % oi(360))
								}
								var te = Nf(g, E)
								b.push(te)
							}),
							{ angle: v, stops: b, type: 1 }
						)
					},
					mx = "closest-side",
					px = "farthest-side",
					o_ = "closest-corner",
					Ax = "farthest-corner",
					bx = "ellipse",
					Uf = "contain",
					jp = function (g, p) {
						var v = 0,
							b = 3,
							E = [],
							k = []
						return (
							bs(p).forEach(function (z, te) {
								var ee = !0
								if (
									(0 === te
										? (ee = z.reduce(function (Fe, Oe) {
												if (qi(Oe))
													switch (Oe.value) {
														case "center":
															return k.push(Rt), !1
														case "top":
														case "left":
															return k.push(Ho), !1
														case "right":
														case "bottom":
															return k.push(Va), !1
													}
												else if (mo(Oe) || _s(Oe)) return k.push(Oe), !1
												return Fe
										  }, ee))
										: 1 === te &&
										  (ee = z.reduce(function (Fe, Oe) {
												if (qi(Oe))
													switch (Oe.value) {
														case "circle":
															return (v = 0), !1
														case bx:
															return (v = 1), !1
														case Uf:
														case mx:
															return (b = 0), !1
														case px:
															return (b = 1), !1
														case o_:
															return (b = 2), !1
														case "cover":
														case Ax:
															return (b = 3), !1
													}
												else if (_s(Oe) || mo(Oe)) return Array.isArray(b) || (b = []), b.push(Oe), !1
												return Fe
										  }, ee)),
									ee)
								) {
									var xe = Nf(g, z)
									E.push(xe)
								}
							}),
							{ size: b, shape: v, stops: E, position: k, type: 2 }
						)
					},
					Kp_parse = function (g, p) {
						if (22 === p.type) {
							var v = { url: p.value, type: 0 }
							return g.cache.addImage(p.value), v
						}
						if (18 === p.type) {
							var b = Zi[p.name]
							if (typeof b > "u") throw new Error('Attempting to parse an unsupported image function "' + p.name + '"')
							return b(g, p.values)
						}
						throw new Error("Unsupported image type " + p.type)
					}
				for (
					var Zi = {
							"linear-gradient": function (g, p) {
								var v = oi(180),
									b = []
								return (
									bs(p).forEach(function (E, k) {
										if (0 === k) {
											var z = E[0]
											if (20 === z.type && "to" === z.value) return void (v = Qa(E))
											if (Zs(z)) return void (v = Wd_parse(g, z))
										}
										var te = Nf(g, E)
										b.push(te)
									}),
									{ angle: v, stops: b, type: 1 }
								)
							},
							"-moz-linear-gradient": Wp,
							"-ms-linear-gradient": Wp,
							"-o-linear-gradient": Wp,
							"-webkit-linear-gradient": Wp,
							"radial-gradient": function (g, p) {
								var v = 0,
									b = 3,
									E = [],
									k = []
								return (
									bs(p).forEach(function (z, te) {
										var ee = !0
										if (0 === te) {
											var xe = !1
											ee = z.reduce(function (Oe, ot) {
												if (xe)
													if (qi(ot))
														switch (ot.value) {
															case "center":
																return k.push(Rt), Oe
															case "top":
															case "left":
																return k.push(Ho), Oe
															case "right":
															case "bottom":
																return k.push(Va), Oe
														}
													else (mo(ot) || _s(ot)) && k.push(ot)
												else if (qi(ot))
													switch (ot.value) {
														case "circle":
															return (v = 0), !1
														case bx:
															return (v = 1), !1
														case "at":
															return (xe = !0), !1
														case mx:
															return (b = 0), !1
														case "cover":
														case px:
															return (b = 1), !1
														case Uf:
														case o_:
															return (b = 2), !1
														case Ax:
															return (b = 3), !1
													}
												else if (_s(ot) || mo(ot)) return Array.isArray(b) || (b = []), b.push(ot), !1
												return Oe
											}, ee)
										}
										if (ee) {
											var Fe = Nf(g, z)
											E.push(Fe)
										}
									}),
									{ size: b, shape: v, stops: E, position: k, type: 2 }
								)
							},
							"-moz-radial-gradient": jp,
							"-ms-radial-gradient": jp,
							"-o-radial-gradient": jp,
							"-webkit-radial-gradient": jp,
							"-webkit-gradient": function (g, p) {
								var v = oi(180),
									b = [],
									E = 1
								return (
									bs(p).forEach(function (ee, xe) {
										var Fe = ee[0]
										if (0 === xe) {
											if (qi(Fe) && "linear" === Fe.value) return void (E = 1)
											if (qi(Fe) && "radial" === Fe.value) return void (E = 2)
										}
										if (18 === Fe.type)
											if ("from" === Fe.name) {
												var Oe = za_parse(g, Fe.values[0])
												b.push({ stop: Ho, color: Oe })
											} else if ("to" === Fe.name) (Oe = za_parse(g, Fe.values[0])), b.push({ stop: Va, color: Oe })
											else if ("color-stop" === Fe.name) {
												var ot = Fe.values.filter(Gd)
												if (2 === ot.length) {
													Oe = za_parse(g, ot[1])
													var Yt = ot[0]
													Nl(Yt) &&
														b.push({ stop: { type: 16, number: 100 * Yt.number, flags: Yt.flags }, color: Oe })
												}
											}
									}),
									1 === E
										? { angle: (v + oi(180)) % oi(360), stops: b, type: E }
										: { size: 3, shape: 0, stops: b, position: [], type: E }
								)
							}
						},
						Ni = {
							name: "background-image",
							initialValue: "none",
							type: 1,
							prefix: !1,
							parse: function (g, p) {
								if (0 === p.length) return []
								var v = p[0]
								return 20 === v.type && "none" === v.value
									? []
									: p
											.filter(function (b) {
												return (
													Gd(b) &&
													(function yt(g) {
														return !((20 === g.type && "none" === g.value) || (18 === g.type && !Zi[g.name]))
													})(b)
												)
											})
											.map(function (b) {
												return Kp_parse(g, b)
											})
							}
						},
						jo = {
							name: "background-origin",
							initialValue: "border-box",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								return p.map(function (v) {
									if (qi(v))
										switch (v.value) {
											case "padding-box":
												return 1
											case "content-box":
												return 2
										}
									return 0
								})
							}
						},
						vs = {
							name: "background-position",
							initialValue: "0% 0%",
							type: 1,
							prefix: !1,
							parse: function (g, p) {
								return bs(p)
									.map(function (v) {
										return v.filter(mo)
									})
									.map(re)
							}
						},
						Hf = {
							name: "background-repeat",
							initialValue: "repeat",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								return bs(p)
									.map(function (v) {
										return v
											.filter(qi)
											.map(function (b) {
												return b.value
											})
											.join(" ")
									})
									.map(Js)
							}
						},
						Js = function (g) {
							switch (g) {
								case "no-repeat":
									return 1
								case "repeat-x":
								case "repeat no-repeat":
									return 2
								case "repeat-y":
								case "no-repeat repeat":
									return 3
								default:
									return 0
							}
						},
						ch = (function (g) {
							return (g.AUTO = "auto"), (g.CONTAIN = "contain"), (g.COVER = "cover"), g
						})(ch || {}),
						_x = {
							name: "background-size",
							initialValue: "0",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								return bs(p).map(function (v) {
									return v.filter(Xp)
								})
							}
						},
						Xp = function (g) {
							return qi(g) || mo(g)
						},
						Yp = function (g) {
							return { name: "border-" + g + "-color", initialValue: "transparent", prefix: !1, type: 3, format: "color" }
						},
						BT = Yp("top"),
						qr = Yp("right"),
						Qt = Yp("bottom"),
						si = Yp("left"),
						pr = function (g) {
							return {
								name: "border-radius-" + g,
								initialValue: "0 0",
								prefix: !1,
								type: 1,
								parse: function (p, v) {
									return re(v.filter(mo))
								}
							}
						},
						$a = pr("top-left"),
						Vf = pr("top-right"),
						as = pr("bottom-right"),
						lh = pr("bottom-left"),
						Rr = function (g) {
							return {
								name: "border-" + g + "-style",
								initialValue: "solid",
								prefix: !1,
								type: 2,
								parse: function (p, v) {
									switch (v) {
										case "none":
											return 0
										case "dashed":
											return 2
										case "dotted":
											return 3
										case "double":
											return 4
									}
									return 1
								}
							}
						},
						Ul = Rr("top"),
						dh = Rr("right"),
						ei = Rr("bottom"),
						Qf = Rr("left"),
						zf = function (g) {
							return {
								name: "border-" + g + "-width",
								initialValue: "0",
								type: 0,
								prefix: !1,
								parse: function (p, v) {
									return Kc(v) ? v.number : 0
								}
							}
						},
						uh = zf("top"),
						so = zf("right"),
						Gf = zf("bottom"),
						hh = zf("left"),
						xc = { name: "color", initialValue: "transparent", prefix: !1, type: 3, format: "color" },
						$f = {
							name: "direction",
							initialValue: "ltr",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								return "rtl" === p ? 1 : 0
							}
						},
						vx = {
							name: "display",
							initialValue: "inline-block",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								return p.filter(qi).reduce(function (v, b) {
									return v | Hl(b.value)
								}, 0)
							}
						},
						Hl = function (g) {
							switch (g) {
								case "block":
								case "-webkit-box":
									return 2
								case "inline":
									return 4
								case "run-in":
									return 8
								case "flow":
									return 16
								case "flow-root":
									return 32
								case "table":
									return 64
								case "flex":
								case "-webkit-flex":
									return 128
								case "grid":
								case "-ms-grid":
									return 256
								case "ruby":
									return 512
								case "subgrid":
									return 1024
								case "list-item":
									return 2048
								case "table-row-group":
									return 4096
								case "table-header-group":
									return 8192
								case "table-footer-group":
									return 16384
								case "table-row":
									return 32768
								case "table-cell":
									return 65536
								case "table-column-group":
									return 131072
								case "table-column":
									return 262144
								case "table-caption":
									return 524288
								case "ruby-base":
									return 1048576
								case "ruby-text":
									return 2097152
								case "ruby-base-container":
									return 4194304
								case "ruby-text-container":
									return 8388608
								case "contents":
									return 16777216
								case "inline-block":
									return 33554432
								case "inline-list-item":
									return 67108864
								case "inline-table":
									return 134217728
								case "inline-flex":
									return 268435456
								case "inline-grid":
									return 536870912
							}
							return 0
						},
						Yc = {
							name: "float",
							initialValue: "none",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								switch (p) {
									case "left":
										return 1
									case "right":
										return 2
									case "inline-start":
										return 3
									case "inline-end":
										return 4
								}
								return 0
							}
						},
						Wf = {
							name: "letter-spacing",
							initialValue: "0",
							prefix: !1,
							type: 0,
							parse: function (g, p) {
								return 20 === p.type && "normal" === p.value ? 0 : 17 === p.type || 15 === p.type ? p.number : 0
							}
						},
						jd = (function (g) {
							return (g.NORMAL = "normal"), (g.STRICT = "strict"), g
						})(jd || {}),
						Ei = {
							name: "line-break",
							initialValue: "normal",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								return "strict" === p ? jd.STRICT : jd.NORMAL
							}
						},
						uU = { name: "line-height", initialValue: "normal", prefix: !1, type: 4 },
						qp = function (g, p) {
							return qi(g) && "normal" === g.value ? 1.2 * p : 17 === g.type ? p * g.number : mo(g) ? tr(g, p) : p
						},
						yx = {
							name: "list-style-image",
							initialValue: "none",
							type: 0,
							prefix: !1,
							parse: function (g, p) {
								return 20 === p.type && "none" === p.value ? null : Kp_parse(g, p)
							}
						},
						Cc = {
							name: "list-style-position",
							initialValue: "outside",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								return "inside" === p ? 0 : 1
							}
						},
						fh = {
							name: "list-style-type",
							initialValue: "none",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								switch (p) {
									case "disc":
										return 0
									case "circle":
										return 1
									case "square":
										return 2
									case "decimal":
										return 3
									case "cjk-decimal":
										return 4
									case "decimal-leading-zero":
										return 5
									case "lower-roman":
										return 6
									case "upper-roman":
										return 7
									case "lower-greek":
										return 8
									case "lower-alpha":
										return 9
									case "upper-alpha":
										return 10
									case "arabic-indic":
										return 11
									case "armenian":
										return 12
									case "bengali":
										return 13
									case "cambodian":
										return 14
									case "cjk-earthly-branch":
										return 15
									case "cjk-heavenly-stem":
										return 16
									case "cjk-ideographic":
										return 17
									case "devanagari":
										return 18
									case "ethiopic-numeric":
										return 19
									case "georgian":
										return 20
									case "gujarati":
										return 21
									case "gurmukhi":
									case "hebrew":
										return 22
									case "hiragana":
										return 23
									case "hiragana-iroha":
										return 24
									case "japanese-formal":
										return 25
									case "japanese-informal":
										return 26
									case "kannada":
										return 27
									case "katakana":
										return 28
									case "katakana-iroha":
										return 29
									case "khmer":
										return 30
									case "korean-hangul-formal":
										return 31
									case "korean-hanja-formal":
										return 32
									case "korean-hanja-informal":
										return 33
									case "lao":
										return 34
									case "lower-armenian":
										return 35
									case "malayalam":
										return 36
									case "mongolian":
										return 37
									case "myanmar":
										return 38
									case "oriya":
										return 39
									case "persian":
										return 40
									case "simp-chinese-formal":
										return 41
									case "simp-chinese-informal":
										return 42
									case "tamil":
										return 43
									case "telugu":
										return 44
									case "thai":
										return 45
									case "tibetan":
										return 46
									case "trad-chinese-formal":
										return 47
									case "trad-chinese-informal":
										return 48
									case "upper-armenian":
										return 49
									case "disclosure-open":
										return 50
									case "disclosure-closed":
										return 51
									default:
										return -1
								}
							}
						},
						qc = function (g) {
							return { name: "margin-" + g, initialValue: "0", prefix: !1, type: 4 }
						},
						jf = qc("top"),
						Ko = qc("right"),
						hU = qc("bottom"),
						Us = qc("left"),
						ys = {
							name: "overflow",
							initialValue: "visible",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								return p.filter(qi).map(function (v) {
									switch (v.value) {
										case "hidden":
											return 1
										case "scroll":
											return 2
										case "clip":
											return 3
										case "auto":
											return 4
										default:
											return 0
									}
								})
							}
						},
						s_ = {
							name: "overflow-wrap",
							initialValue: "normal",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								return "break-word" === p ? "break-word" : "normal"
							}
						},
						Ec = function (g) {
							return { name: "padding-" + g, initialValue: "0", prefix: !1, type: 3, format: "length-percentage" }
						},
						Zp = Ec("top"),
						Wa = Ec("right"),
						a_ = Ec("bottom"),
						IT = Ec("left"),
						DT = {
							name: "text-align",
							initialValue: "left",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								switch (p) {
									case "right":
										return 2
									case "center":
									case "justify":
										return 1
									default:
										return 0
								}
							}
						},
						fU = {
							name: "position",
							initialValue: "static",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								switch (p) {
									case "relative":
										return 1
									case "absolute":
										return 2
									case "fixed":
										return 3
									case "sticky":
										return 4
								}
								return 0
							}
						},
						LT = {
							name: "text-shadow",
							initialValue: "none",
							type: 1,
							prefix: !1,
							parse: function (g, p) {
								return 1 === p.length && n_(p[0], "none")
									? []
									: bs(p).map(function (v) {
											for (
												var b = { color: wc.TRANSPARENT, offsetX: Ho, offsetY: Ho, blur: Ho }, E = 0, k = 0;
												k < v.length;
												k++
											) {
												var z = v[k]
												_s(z)
													? (0 === E ? (b.offsetX = z) : 1 === E ? (b.offsetY = z) : (b.blur = z), E++)
													: (b.color = za_parse(g, z))
											}
											return b
									  })
							}
						},
						RT = {
							name: "text-transform",
							initialValue: "none",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								switch (p) {
									case "uppercase":
										return 2
									case "lowercase":
										return 1
									case "capitalize":
										return 3
								}
								return 0
							}
						},
						mU = {
							name: "transform",
							initialValue: "none",
							prefix: !0,
							type: 0,
							parse: function (g, p) {
								if (20 === p.type && "none" === p.value) return null
								if (18 === p.type) {
									var v = gU[p.name]
									if (typeof v > "u")
										throw new Error('Attempting to parse an unsupported transform function "' + p.name + '"')
									return v(p.values)
								}
								return null
							}
						},
						gU = {
							matrix: function (g) {
								var p = g
									.filter(function (v) {
										return 17 === v.type
									})
									.map(function (v) {
										return v.number
									})
								return 6 === p.length ? p : null
							},
							matrix3d: function (g) {
								var p = g
									.filter(function (ee) {
										return 17 === ee.type
									})
									.map(function (ee) {
										return ee.number
									})
								return 16 === p.length ? [p[0], p[1], p[4], p[5], p[12], p[13]] : null
							}
						},
						PT = { type: 16, number: 50, flags: 4 },
						bU = [PT, PT],
						_U = {
							name: "transform-origin",
							initialValue: "50% 50%",
							prefix: !0,
							type: 1,
							parse: function (g, p) {
								var v = p.filter(mo)
								return 2 !== v.length ? bU : [v[0], v[1]]
							}
						},
						vU = {
							name: "visible",
							initialValue: "none",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								switch (p) {
									case "hidden":
										return 1
									case "collapse":
										return 2
									default:
										return 0
								}
							}
						},
						c_ = (function (g) {
							return (g.NORMAL = "normal"), (g.BREAK_ALL = "break-all"), (g.KEEP_ALL = "keep-all"), g
						})(c_ || {}),
						yU = {
							name: "word-break",
							initialValue: "normal",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								switch (p) {
									case "break-all":
										return c_.BREAK_ALL
									case "keep-all":
										return c_.KEEP_ALL
									default:
										return c_.NORMAL
								}
							}
						},
						wU = {
							name: "z-index",
							initialValue: "auto",
							prefix: !1,
							type: 0,
							parse: function (g, p) {
								if (20 === p.type) return { auto: !0, order: 0 }
								if (Nl(p)) return { auto: !1, order: p.number }
								throw new Error("Invalid z-index number parsed")
							}
						},
						OT = {
							name: "time",
							parse: function (g, p) {
								if (15 === p.type)
									switch (p.unit.toLowerCase()) {
										case "s":
											return 1e3 * p.number
										case "ms":
											return p.number
									}
								throw new Error("Unsupported time type")
							}
						},
						wx = {
							name: "opacity",
							initialValue: "1",
							type: 0,
							prefix: !1,
							parse: function (g, p) {
								return Nl(p) ? p.number : 1
							}
						},
						xx = { name: "text-decoration-color", initialValue: "transparent", prefix: !1, type: 3, format: "color" },
						xU = {
							name: "text-decoration-line",
							initialValue: "none",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								return p
									.filter(qi)
									.map(function (v) {
										switch (v.value) {
											case "underline":
												return 1
											case "overline":
												return 2
											case "line-through":
												return 3
											case "none":
												return 4
										}
										return 0
									})
									.filter(function (v) {
										return 0 !== v
									})
							}
						},
						CU = {
							name: "font-family",
							initialValue: "",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								var v = [],
									b = []
								return (
									p.forEach(function (E) {
										switch (E.type) {
											case 20:
											case 0:
												v.push(E.value)
												break
											case 17:
												v.push(E.number.toString())
												break
											case 4:
												b.push(v.join(" ")), (v.length = 0)
										}
									}),
									v.length && b.push(v.join(" ")),
									b.map(function (E) {
										return -1 === E.indexOf(" ") ? E : "'" + E + "'"
									})
								)
							}
						},
						EU = { name: "font-size", initialValue: "0", prefix: !1, type: 3, format: "length" },
						Kd = {
							name: "font-weight",
							initialValue: "normal",
							type: 0,
							prefix: !1,
							parse: function (g, p) {
								return Nl(p) ? p.number : qi(p) && "bold" === p.value ? 700 : 400
							}
						},
						Vl = {
							name: "font-variant",
							initialValue: "none",
							type: 1,
							prefix: !1,
							parse: function (g, p) {
								return p.filter(qi).map(function (v) {
									return v.value
								})
							}
						},
						MU = {
							name: "font-style",
							initialValue: "normal",
							prefix: !1,
							type: 2,
							parse: function (g, p) {
								switch (p) {
									case "oblique":
										return "oblique"
									case "italic":
										return "italic"
									default:
										return "normal"
								}
							}
						},
						Ao = function (g, p) {
							return 0 != (g & p)
						},
						Xo = {
							name: "content",
							initialValue: "none",
							type: 1,
							prefix: !1,
							parse: function (g, p) {
								if (0 === p.length) return []
								var v = p[0]
								return 20 === v.type && "none" === v.value ? [] : p
							}
						},
						Jp = {
							name: "counter-increment",
							initialValue: "none",
							prefix: !0,
							type: 1,
							parse: function (g, p) {
								if (0 === p.length) return null
								var v = p[0]
								if (20 === v.type && "none" === v.value) return null
								for (var b = [], E = p.filter(sx), k = 0; k < E.length; k++) {
									var z = E[k],
										te = E[k + 1]
									if (20 === z.type) {
										var ee = te && Nl(te) ? te.number : 1
										b.push({ counter: z.value, increment: ee })
									}
								}
								return b
							}
						},
						xa = {
							name: "counter-reset",
							initialValue: "none",
							prefix: !0,
							type: 1,
							parse: function (g, p) {
								if (0 === p.length) return []
								for (var v = [], b = p.filter(sx), E = 0; E < b.length; E++) {
									var k = b[E],
										z = b[E + 1]
									if (qi(k) && "none" !== k.value) {
										var te = z && Nl(z) ? z.number : 0
										v.push({ counter: k.value, reset: te })
									}
								}
								return v
							}
						},
						eA = {
							name: "duration",
							initialValue: "0s",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								return p.filter(Kc).map(function (v) {
									return OT.parse(g, v)
								})
							}
						},
						Cx = {
							name: "quotes",
							initialValue: "none",
							prefix: !0,
							type: 1,
							parse: function (g, p) {
								if (0 === p.length) return null
								var v = p[0]
								if (20 === v.type && "none" === v.value) return null
								var b = [],
									E = p.filter(CT)
								if (E.length % 2 != 0) return null
								for (var k = 0; k < E.length; k += 2) b.push({ open: E[k].value, close: E[k + 1].value })
								return b
							}
						},
						l_ = function (g, p, v) {
							if (!g) return ""
							var b = g[Math.min(p, g.length - 1)]
							return b ? (v ? b.open : b.close) : ""
						},
						Ex = {
							name: "box-shadow",
							initialValue: "none",
							type: 1,
							prefix: !1,
							parse: function (g, p) {
								return 1 === p.length && n_(p[0], "none")
									? []
									: bs(p).map(function (v) {
											for (
												var b = { color: 255, offsetX: Ho, offsetY: Ho, blur: Ho, spread: Ho, inset: !1 },
													E = 0,
													k = 0;
												k < v.length;
												k++
											) {
												var z = v[k]
												n_(z, "inset")
													? (b.inset = !0)
													: _s(z)
													? (0 === E
															? (b.offsetX = z)
															: 1 === E
															? (b.offsetY = z)
															: 2 === E
															? (b.blur = z)
															: (b.spread = z),
													  E++)
													: (b.color = za_parse(g, z))
											}
											return b
									  })
							}
						},
						d_ = {
							name: "paint-order",
							initialValue: "normal",
							prefix: !1,
							type: 1,
							parse: function (g, p) {
								var b = []
								return (
									p.filter(qi).forEach(function (E) {
										switch (E.value) {
											case "stroke":
												b.push(1)
												break
											case "fill":
												b.push(0)
												break
											case "markers":
												b.push(2)
										}
									}),
									[0, 1, 2].forEach(function (E) {
										;-1 === b.indexOf(E) && b.push(E)
									}),
									b
								)
							}
						},
						Mx = { name: "-webkit-text-stroke-color", initialValue: "currentcolor", prefix: !1, type: 3, format: "color" },
						tA = {
							name: "-webkit-text-stroke-width",
							initialValue: "0",
							type: 0,
							prefix: !1,
							parse: function (g, p) {
								return Kc(p) ? p.number : 0
							}
						},
						nA = (function () {
							function g(p, v) {
								var b, E
								;(this.animationDuration = qt(p, eA, v.animationDuration)),
									(this.backgroundClip = qt(p, Of, v.backgroundClip)),
									(this.backgroundColor = qt(p, dx, v.backgroundColor)),
									(this.backgroundImage = qt(p, Ni, v.backgroundImage)),
									(this.backgroundOrigin = qt(p, jo, v.backgroundOrigin)),
									(this.backgroundPosition = qt(p, vs, v.backgroundPosition)),
									(this.backgroundRepeat = qt(p, Hf, v.backgroundRepeat)),
									(this.backgroundSize = qt(p, _x, v.backgroundSize)),
									(this.borderTopColor = qt(p, BT, v.borderTopColor)),
									(this.borderRightColor = qt(p, qr, v.borderRightColor)),
									(this.borderBottomColor = qt(p, Qt, v.borderBottomColor)),
									(this.borderLeftColor = qt(p, si, v.borderLeftColor)),
									(this.borderTopLeftRadius = qt(p, $a, v.borderTopLeftRadius)),
									(this.borderTopRightRadius = qt(p, Vf, v.borderTopRightRadius)),
									(this.borderBottomRightRadius = qt(p, as, v.borderBottomRightRadius)),
									(this.borderBottomLeftRadius = qt(p, lh, v.borderBottomLeftRadius)),
									(this.borderTopStyle = qt(p, Ul, v.borderTopStyle)),
									(this.borderRightStyle = qt(p, dh, v.borderRightStyle)),
									(this.borderBottomStyle = qt(p, ei, v.borderBottomStyle)),
									(this.borderLeftStyle = qt(p, Qf, v.borderLeftStyle)),
									(this.borderTopWidth = qt(p, uh, v.borderTopWidth)),
									(this.borderRightWidth = qt(p, so, v.borderRightWidth)),
									(this.borderBottomWidth = qt(p, Gf, v.borderBottomWidth)),
									(this.borderLeftWidth = qt(p, hh, v.borderLeftWidth)),
									(this.boxShadow = qt(p, Ex, v.boxShadow)),
									(this.color = qt(p, xc, v.color)),
									(this.direction = qt(p, $f, v.direction)),
									(this.display = qt(p, vx, v.display)),
									(this.float = qt(p, Yc, v.cssFloat)),
									(this.fontFamily = qt(p, CU, v.fontFamily)),
									(this.fontSize = qt(p, EU, v.fontSize)),
									(this.fontStyle = qt(p, MU, v.fontStyle)),
									(this.fontVariant = qt(p, Vl, v.fontVariant)),
									(this.fontWeight = qt(p, Kd, v.fontWeight)),
									(this.letterSpacing = qt(p, Wf, v.letterSpacing)),
									(this.lineBreak = qt(p, Ei, v.lineBreak)),
									(this.lineHeight = qt(p, uU, v.lineHeight)),
									(this.listStyleImage = qt(p, yx, v.listStyleImage)),
									(this.listStylePosition = qt(p, Cc, v.listStylePosition)),
									(this.listStyleType = qt(p, fh, v.listStyleType)),
									(this.marginTop = qt(p, jf, v.marginTop)),
									(this.marginRight = qt(p, Ko, v.marginRight)),
									(this.marginBottom = qt(p, hU, v.marginBottom)),
									(this.marginLeft = qt(p, Us, v.marginLeft)),
									(this.opacity = qt(p, wx, v.opacity))
								var k = qt(p, ys, v.overflow)
								;(this.overflowX = k[0]),
									(this.overflowY = k[k.length > 1 ? 1 : 0]),
									(this.overflowWrap = qt(p, s_, v.overflowWrap)),
									(this.paddingTop = qt(p, Zp, v.paddingTop)),
									(this.paddingRight = qt(p, Wa, v.paddingRight)),
									(this.paddingBottom = qt(p, a_, v.paddingBottom)),
									(this.paddingLeft = qt(p, IT, v.paddingLeft)),
									(this.paintOrder = qt(p, d_, v.paintOrder)),
									(this.position = qt(p, fU, v.position)),
									(this.textAlign = qt(p, DT, v.textAlign)),
									(this.textDecorationColor = qt(
										p,
										xx,
										null !== (b = v.textDecorationColor) && void 0 !== b ? b : v.color
									)),
									(this.textDecorationLine = qt(
										p,
										xU,
										null !== (E = v.textDecorationLine) && void 0 !== E ? E : v.textDecoration
									)),
									(this.textShadow = qt(p, LT, v.textShadow)),
									(this.textTransform = qt(p, RT, v.textTransform)),
									(this.transform = qt(p, mU, v.transform)),
									(this.transformOrigin = qt(p, _U, v.transformOrigin)),
									(this.visibility = qt(p, vU, v.visibility)),
									(this.webkitTextStrokeColor = qt(p, Mx, v.webkitTextStrokeColor)),
									(this.webkitTextStrokeWidth = qt(p, tA, v.webkitTextStrokeWidth)),
									(this.wordBreak = qt(p, yU, v.wordBreak)),
									(this.zIndex = qt(p, wU, v.zIndex))
							}
							return (
								(g.prototype.isVisible = function () {
									return this.display > 0 && this.opacity > 0 && 0 === this.visibility
								}),
								(g.prototype.isTransparent = function () {
									return vc(this.backgroundColor)
								}),
								(g.prototype.isTransformed = function () {
									return null !== this.transform
								}),
								(g.prototype.isPositioned = function () {
									return 0 !== this.position
								}),
								(g.prototype.isPositionedWithZIndex = function () {
									return this.isPositioned() && !this.zIndex.auto
								}),
								(g.prototype.isFloating = function () {
									return 0 !== this.float
								}),
								(g.prototype.isInlineLevel = function () {
									return (
										Ao(this.display, 4) ||
										Ao(this.display, 33554432) ||
										Ao(this.display, 268435456) ||
										Ao(this.display, 536870912) ||
										Ao(this.display, 67108864) ||
										Ao(this.display, 134217728)
									)
								}),
								g
							)
						})(),
						Sx = function g(p, v) {
							;(this.content = qt(p, Xo, v.content)), (this.quotes = qt(p, Cx, v.quotes))
						},
						u_ = function g(p, v) {
							;(this.counterIncrement = qt(p, Jp, v.counterIncrement)), (this.counterReset = qt(p, xa, v.counterReset))
						},
						qt = function (g, p, v) {
							var b = new wT(),
								E = null !== v && typeof v < "u" ? v.toString() : p.initialValue
							b.write(E)
							var k = new xT(b.read())
							switch (p.type) {
								case 2:
									var z = k.parseComponentValue()
									return p.parse(g, qi(z) ? z.value : p.initialValue)
								case 0:
									return p.parse(g, k.parseComponentValue())
								case 1:
									return p.parse(g, k.parseComponentValues())
								case 4:
									return k.parseComponentValue()
								case 3:
									switch (p.format) {
										case "angle":
											return Wd_parse(g, k.parseComponentValue())
										case "color":
											return za_parse(g, k.parseComponentValue())
										case "image":
											return Kp_parse(g, k.parseComponentValue())
										case "length":
											var te = k.parseComponentValue()
											return _s(te) ? te : Ho
										case "length-percentage":
											var ee = k.parseComponentValue()
											return mo(ee) ? ee : Ho
										case "time":
											return OT.parse(g, k.parseComponentValue())
									}
							}
						},
						Ql = function (g, p) {
							var v = (function (g) {
								switch (g.getAttribute("data-html2canvas-debug")) {
									case "all":
										return 1
									case "clone":
										return 2
									case "parse":
										return 3
									case "render":
										return 4
									default:
										return 0
								}
							})(g)
							return 1 === v || p === v
						},
						ja = function g(p, v) {
							;(this.context = p),
								(this.textNodes = []),
								(this.elements = []),
								(this.flags = 0),
								Ql(v, 3),
								(this.styles = new nA(p, window.getComputedStyle(v, null))),
								nm(v) &&
									(this.styles.animationDuration.some(function (b) {
										return b > 0
									}) && (v.style.animationDuration = "0s"),
									null !== this.styles.transform && (v.style.transform = "none")),
								(this.bounds = D(this.context, v)),
								Ql(v, 4) && (this.flags |= 16)
						},
						rA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
						Xd = typeof Uint8Array > "u" ? [] : new Uint8Array(256),
						Yd = 0;
					Yd < 64;
					Yd++
				)
					Xd[rA.charCodeAt(Yd)] = Yd
				for (
					var jT = function (g, p, v) {
							return g.slice ? g.slice(p, v) : new Uint16Array(Array.prototype.slice.call(g, p, v))
						},
						Lx = (function () {
							function g(p, v, b, E, k, z) {
								;(this.initialValue = p),
									(this.errorValue = v),
									(this.highStart = b),
									(this.highValueIndex = E),
									(this.index = k),
									(this.data = z)
							}
							return (
								(g.prototype.get = function (p) {
									var v
									if (p >= 0) {
										if (p < 55296 || (p > 56319 && p <= 65535))
											return this.data[(v = ((v = this.index[p >> 5]) << 2) + (31 & p))]
										if (p <= 65535)
											return this.data[(v = ((v = this.index[2048 + ((p - 55296) >> 5)]) << 2) + (31 & p))]
										if (p < this.highStart)
											return (
												(v = this.index[(v = 2080 + (p >> 11))]),
												this.data[(v = ((v = this.index[(v += (p >> 5) & 63)]) << 2) + (31 & p))]
											)
										if (p <= 1114111) return this.data[this.highValueIndex]
									}
									return this.errorValue
								}),
								g
							)
						})(),
						Rx = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
						XT = typeof Uint8Array > "u" ? [] : new Uint8Array(256),
						Yf = 0;
					Yf < 64;
					Yf++
				)
					XT[Rx.charCodeAt(Yf)] = Yf
				var m_ = 8,
					ar = 9,
					Jf = 11,
					ws = 12,
					YT = function () {
						for (var g = [], p = 0; p < arguments.length; p++) g[p] = arguments[p]
						if (String.fromCodePoint) return String.fromCodePoint.apply(String, g)
						var v = g.length
						if (!v) return ""
						for (var b = [], E = -1, k = ""; ++E < v; ) {
							var z = g[E]
							z <= 65535 ? b.push(z) : b.push(55296 + ((z -= 65536) >> 10), (z % 1024) + 56320),
								(E + 1 === v || b.length > 16384) && ((k += String.fromCharCode.apply(String, b)), (b.length = 0))
						}
						return k
					},
					qT = (function (g, p) {
						var v = (function (g) {
								var b,
									k,
									z,
									te,
									ee,
									p = 0.75 * g.length,
									v = g.length,
									E = 0
								"=" === g[g.length - 1] && (p--, "=" === g[g.length - 2] && p--)
								var xe =
										typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u"
											? new ArrayBuffer(p)
											: new Array(p),
									Fe = Array.isArray(xe) ? xe : new Uint8Array(xe)
								for (b = 0; b < v; b += 4)
									(k = Xd[g.charCodeAt(b)]),
										(z = Xd[g.charCodeAt(b + 1)]),
										(te = Xd[g.charCodeAt(b + 2)]),
										(ee = Xd[g.charCodeAt(b + 3)]),
										(Fe[E++] = (k << 2) | (z >> 4)),
										(Fe[E++] = ((15 & z) << 4) | (te >> 2)),
										(Fe[E++] = ((3 & te) << 6) | (63 & ee))
								return xe
							})(g),
							b = Array.isArray(v)
								? (function (g) {
										for (var p = g.length, v = [], b = 0; b < p; b += 4)
											v.push((g[b + 3] << 24) | (g[b + 2] << 16) | (g[b + 1] << 8) | g[b])
										return v
								  })(v)
								: new Uint32Array(v),
							E = Array.isArray(v)
								? (function (g) {
										for (var p = g.length, v = [], b = 0; b < p; b += 2) v.push((g[b + 1] << 8) | g[b])
										return v
								  })(v)
								: new Uint16Array(v),
							z = jT(E, 12, b[4] / 2),
							te =
								2 === b[5]
									? jT(E, (24 + b[4]) / 2)
									: (function (g, p, v) {
											return g.slice ? g.slice(p, v) : new Uint32Array(Array.prototype.slice.call(g, p, v))
									  })(b, Math.ceil((24 + b[4]) / 4))
						return new Lx(b[0], b[1], b[2], b[3], z, te)
					})(
						"AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA="
					),
					Hx = function (g) {
						return qT.get(g)
					},
					ZT = function (g, p, v) {
						var b = v - 2,
							E = p[b],
							k = p[v - 1],
							z = p[v]
						if (2 === k && 3 === z) return "\xd7"
						if (2 === k || 3 === k || 4 === k || 2 === z || 3 === z || 4 === z) return "\xf7"
						if (
							(k === m_ && -1 !== [m_, ar, Jf, ws].indexOf(z)) ||
							((k === Jf || k === ar) && (z === ar || 10 === z)) ||
							((k === ws || 10 === k) && 10 === z) ||
							13 === z ||
							5 === z ||
							7 === z ||
							1 === k
						)
							return "\xd7"
						if (13 === k && 14 === z) {
							for (; 5 === E; ) E = p[--b]
							if (14 === E) return "\xd7"
						}
						if (15 === k && 15 === z) {
							for (var te = 0; 15 === E; ) te++, (E = p[--b])
							if (te % 2 == 0) return "\xd7"
						}
						return "\xf7"
					},
					Vx = function (g) {
						var p = (function (g) {
								for (var p = [], v = 0, b = g.length; v < b; ) {
									var E = g.charCodeAt(v++)
									if (E >= 55296 && E <= 56319 && v < b) {
										var k = g.charCodeAt(v++)
										56320 == (64512 & k) ? p.push(((1023 & E) << 10) + (1023 & k) + 65536) : (p.push(E), v--)
									} else p.push(E)
								}
								return p
							})(g),
							v = p.length,
							b = 0,
							E = 0,
							k = p.map(Hx)
						return {
							next: function () {
								if (b >= v) return { done: !0, value: null }
								for (var z = "\xd7"; b < v && "\xd7" === (z = ZT(0, k, ++b)); );
								if ("\xd7" !== z || b === v) {
									var te = YT.apply(null, p.slice(E, b))
									return (E = b), { value: te, done: !1 }
								}
								return { done: !0, value: null }
							}
						}
					},
					$x = function (g) {
						return 0 === g[0] && 255 === g[1] && 0 === g[2] && 255 === g[3]
					},
					A_ = function (g, p, v, b, E) {
						var k = "http://www.w3.org/2000/svg",
							z = document.createElementNS(k, "svg"),
							te = document.createElementNS(k, "foreignObject")
						return (
							z.setAttributeNS(null, "width", g.toString()),
							z.setAttributeNS(null, "height", p.toString()),
							te.setAttributeNS(null, "width", "100%"),
							te.setAttributeNS(null, "height", "100%"),
							te.setAttributeNS(null, "x", v.toString()),
							te.setAttributeNS(null, "y", b.toString()),
							te.setAttributeNS(null, "externalResourcesRequired", "true"),
							z.appendChild(te),
							te.appendChild(E),
							z
						)
					},
					g_ = function (g) {
						return new Promise(function (p, v) {
							var b = new Image()
							;(b.onload = function () {
								return p(b)
							}),
								(b.onerror = v),
								(b.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(g)))
						})
					},
					Zr = {
						get SUPPORT_RANGE_BOUNDS() {
							var g = (function (g) {
								if (g.createRange) {
									var v = g.createRange()
									if (v.getBoundingClientRect) {
										var b = g.createElement("boundtest")
										;(b.style.height = "123px"), (b.style.display = "block"), g.body.appendChild(b), v.selectNode(b)
										var E = v.getBoundingClientRect(),
											k = Math.round(E.height)
										if ((g.body.removeChild(b), 123 === k)) return !0
									}
								}
								return !1
							})(document)
							return Object.defineProperty(Zr, "SUPPORT_RANGE_BOUNDS", { value: g }), g
						},
						get SUPPORT_WORD_BREAKING() {
							var g =
								Zr.SUPPORT_RANGE_BOUNDS &&
								(function (g) {
									var p = g.createElement("boundtest")
									;(p.style.width = "50px"),
										(p.style.display = "block"),
										(p.style.fontSize = "12px"),
										(p.style.letterSpacing = "0px"),
										(p.style.wordSpacing = "0px"),
										g.body.appendChild(p)
									var v = g.createRange()
									p.innerHTML = "function" == typeof "".repeat ? "&#128104;".repeat(10) : ""
									var b = p.firstChild,
										E = R(b.data).map(function (ee) {
											return V(ee)
										}),
										k = 0,
										z = {},
										te = E.every(function (ee, xe) {
											v.setStart(b, k), v.setEnd(b, k + ee.length)
											var Fe = v.getBoundingClientRect()
											k += ee.length
											var Oe = Fe.x > z.x || Fe.y > z.y
											return (z = Fe), 0 === xe || Oe
										})
									return g.body.removeChild(p), te
								})(document)
							return Object.defineProperty(Zr, "SUPPORT_WORD_BREAKING", { value: g }), g
						},
						get SUPPORT_SVG_DRAWING() {
							var g = (function (g) {
								var p = new Image(),
									v = g.createElement("canvas"),
									b = v.getContext("2d")
								if (!b) return !1
								p.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>"
								try {
									b.drawImage(p, 0, 0), v.toDataURL()
								} catch {
									return !1
								}
								return !0
							})(document)
							return Object.defineProperty(Zr, "SUPPORT_SVG_DRAWING", { value: g }), g
						},
						get SUPPORT_FOREIGNOBJECT_DRAWING() {
							var g =
								"function" == typeof Array.from && "function" == typeof window.fetch
									? (function (g) {
											var p = g.createElement("canvas"),
												v = 100
											;(p.width = v), (p.height = v)
											var b = p.getContext("2d")
											if (!b) return Promise.reject(!1)
											;(b.fillStyle = "rgb(0, 255, 0)"), b.fillRect(0, 0, v, v)
											var E = new Image(),
												k = p.toDataURL()
											E.src = k
											var z = A_(v, v, 0, 0, E)
											return (
												(b.fillStyle = "red"),
												b.fillRect(0, 0, v, v),
												g_(z)
													.then(function (te) {
														b.drawImage(te, 0, 0)
														var ee = b.getImageData(0, 0, v, v).data
														;(b.fillStyle = "red"), b.fillRect(0, 0, v, v)
														var xe = g.createElement("div")
														return (
															(xe.style.backgroundImage = "url(" + k + ")"),
															(xe.style.height = v + "px"),
															$x(ee) ? g_(A_(v, v, 0, 0, xe)) : Promise.reject(!1)
														)
													})
													.then(function (te) {
														return b.drawImage(te, 0, 0), $x(b.getImageData(0, 0, v, v).data)
													})
													.catch(function () {
														return !1
													})
											)
									  })(document)
									: Promise.resolve(!1)
							return Object.defineProperty(Zr, "SUPPORT_FOREIGNOBJECT_DRAWING", { value: g }), g
						},
						get SUPPORT_CORS_IMAGES() {
							var g = typeof new Image().crossOrigin < "u"
							return Object.defineProperty(Zr, "SUPPORT_CORS_IMAGES", { value: g }), g
						},
						get SUPPORT_RESPONSE_TYPE() {
							var g = "string" == typeof new XMLHttpRequest().responseType
							return Object.defineProperty(Zr, "SUPPORT_RESPONSE_TYPE", { value: g }), g
						},
						get SUPPORT_CORS_XHR() {
							var g = "withCredentials" in new XMLHttpRequest()
							return Object.defineProperty(Zr, "SUPPORT_CORS_XHR", { value: g }), g
						},
						get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
							var g = !!(typeof Intl < "u" && Intl.Segmenter)
							return Object.defineProperty(Zr, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value: g }), g
						}
					},
					em = function g(p, v) {
						;(this.text = p), (this.bounds = v)
					},
					nF = function (g, p) {
						var v = p.ownerDocument
						if (v) {
							var b = v.createElement("html2canvaswrapper")
							b.appendChild(p.cloneNode(!0))
							var E = p.parentNode
							if (E) {
								E.replaceChild(b, p)
								var k = D(g, b)
								return b.firstChild && E.replaceChild(b.firstChild, b), k
							}
						}
						return Q.EMPTY
					},
					Wx = function (g, p, v) {
						var b = g.ownerDocument
						if (!b) throw new Error("Node has no owner document")
						var E = b.createRange()
						return E.setStart(g, p), E.setEnd(g, p + v), E
					},
					b_ = function (g) {
						if (Zr.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
							var p = new Intl.Segmenter(void 0, { granularity: "grapheme" })
							return Array.from(p.segment(g)).map(function (v) {
								return v.segment
							})
						}
						return (function (g) {
							for (var b, p = Vx(g), v = []; !(b = p.next()).done; ) b.value && v.push(b.value.slice())
							return v
						})(g)
					},
					Ui = function (g, p) {
						return 0 !== p.letterSpacing
							? b_(g)
							: (function (g, p) {
									if (Zr.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
										var v = new Intl.Segmenter(void 0, { granularity: "word" })
										return Array.from(v.segment(g)).map(function (b) {
											return b.segment
										})
									}
									return on(g, p)
							  })(g, p)
					},
					rn = [32, 160, 4961, 65792, 65793, 4153, 4241],
					on = function (g, p) {
						for (
							var E,
								v = (function (g, p) {
									var v = R(g),
										b = ir(v, p),
										E = b[0],
										k = b[1],
										z = b[2],
										te = v.length,
										ee = 0,
										xe = 0
									return {
										next: function () {
											if (xe >= te) return { done: !0, value: null }
											for (var Fe = pi; xe < te && (Fe = wr(v, k, E, ++xe, z)) === pi; );
											if (Fe !== pi || xe === te) {
												var Oe = new fr(v, Fe, ee, xe)
												return (ee = xe), { value: Oe, done: !1 }
											}
											return { done: !0, value: null }
										}
									}
								})(g, { lineBreak: p.lineBreak, wordBreak: "break-word" === p.overflowWrap ? "break-word" : p.wordBreak }),
								b = [],
								k = function () {
									if (E.value) {
										var z = E.value.slice(),
											te = R(z),
											ee = ""
										te.forEach(function (xe) {
											;-1 === rn.indexOf(xe) ? (ee += V(xe)) : (ee.length && b.push(ee), b.push(V(xe)), (ee = ""))
										}),
											ee.length && b.push(ee)
									}
								};
							!(E = v.next()).done;

						)
							k()
						return b
					},
					Yo = function g(p, v, b) {
						;(this.text = jx(v.data, b.textTransform)),
							(this.textBounds = (function (g, p, v, b) {
								var E = Ui(p, v),
									k = [],
									z = 0
								return (
									E.forEach(function (te) {
										if (v.textDecorationLine.length || te.trim().length > 0)
											if (Zr.SUPPORT_RANGE_BOUNDS) {
												var ee = Wx(b, z, te.length).getClientRects()
												if (ee.length > 1) {
													var xe = b_(te),
														Fe = 0
													xe.forEach(function (ot) {
														k.push(new em(ot, Q.fromDOMRectList(g, Wx(b, Fe + z, ot.length).getClientRects()))),
															(Fe += ot.length)
													})
												} else k.push(new em(te, Q.fromDOMRectList(g, ee)))
											} else {
												var Oe = b.splitText(te.length)
												k.push(new em(te, nF(g, b))), (b = Oe)
											}
										else Zr.SUPPORT_RANGE_BOUNDS || (b = b.splitText(te.length))
										z += te.length
									}),
									k
								)
							})(p, this.text, b, v))
					},
					jx = function (g, p) {
						switch (p) {
							case 1:
								return g.toLowerCase()
							case 3:
								return g.replace(tm, Sc)
							case 2:
								return g.toUpperCase()
							default:
								return g
						}
					},
					tm = /(^|\s|:|-|\(|\))([a-z])/g,
					Sc = function (g, p, v) {
						return g.length > 0 ? p + v.toUpperCase() : g
					},
					sA = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							return (
								(E.src = b.currentSrc || b.src),
								(E.intrinsicWidth = b.naturalWidth),
								(E.intrinsicHeight = b.naturalHeight),
								E.context.cache.addImage(E.src),
								E
							)
						}
						return A(p, g), p
					})(ja),
					aA = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							return (E.canvas = b), (E.intrinsicWidth = b.width), (E.intrinsicHeight = b.height), E
						}
						return A(p, g), p
					})(ja),
					Kx = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this,
								k = new XMLSerializer(),
								z = D(v, b)
							return (
								b.setAttribute("width", z.width + "px"),
								b.setAttribute("height", z.height + "px"),
								(E.svg = "data:image/svg+xml," + encodeURIComponent(k.serializeToString(b))),
								(E.intrinsicWidth = b.width.baseVal.value),
								(E.intrinsicHeight = b.height.baseVal.value),
								E.context.cache.addImage(E.svg),
								E
							)
						}
						return A(p, g), p
					})(ja),
					iF = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							return (E.value = b.value), E
						}
						return A(p, g), p
					})(ja),
					cA = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							return (E.start = b.start), (E.reversed = "boolean" == typeof b.reversed && !0 === b.reversed), E
						}
						return A(p, g), p
					})(ja),
					xs = [{ type: 15, flags: 0, unit: "px", number: 3 }],
					Jc = [{ type: 16, flags: 0, number: 50 }],
					Ea = "checkbox",
					lA = "radio",
					Yx = "password",
					qx = 707406591,
					__ = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							switch (
								((E.type = b.type.toLowerCase()),
								(E.checked = b.checked),
								(E.value = (function (g) {
									var p = g.type === Yx ? new Array(g.value.length + 1).join("\u2022") : g.value
									return 0 === p.length ? g.placeholder || "" : p
								})(b)),
								(E.type === Ea || E.type === lA) &&
									((E.styles.backgroundColor = 3739148031),
									(E.styles.borderTopColor =
										E.styles.borderRightColor =
										E.styles.borderBottomColor =
										E.styles.borderLeftColor =
											2779096575),
									(E.styles.borderTopWidth =
										E.styles.borderRightWidth =
										E.styles.borderBottomWidth =
										E.styles.borderLeftWidth =
											1),
									(E.styles.borderTopStyle =
										E.styles.borderRightStyle =
										E.styles.borderBottomStyle =
										E.styles.borderLeftStyle =
											1),
									(E.styles.backgroundClip = [0]),
									(E.styles.backgroundOrigin = [0]),
									(E.bounds = (function (g) {
										return g.width > g.height
											? new Q(g.left + (g.width - g.height) / 2, g.top, g.height, g.height)
											: g.width < g.height
											? new Q(g.left, g.top + (g.height - g.width) / 2, g.width, g.width)
											: g
									})(E.bounds))),
								E.type)
							) {
								case Ea:
									E.styles.borderTopRightRadius =
										E.styles.borderTopLeftRadius =
										E.styles.borderBottomRightRadius =
										E.styles.borderBottomLeftRadius =
											xs
									break
								case lA:
									E.styles.borderTopRightRadius =
										E.styles.borderTopLeftRadius =
										E.styles.borderBottomRightRadius =
										E.styles.borderBottomLeftRadius =
											Jc
							}
							return E
						}
						return A(p, g), p
					})(ja),
					dA = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this,
								k = b.options[b.selectedIndex || 0]
							return (E.value = (k && k.text) || ""), E
						}
						return A(p, g), p
					})(ja),
					uA = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							return (E.value = b.value), E
						}
						return A(p, g), p
					})(ja),
					v_ = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							;(E.src = b.src),
								(E.width = parseInt(b.width, 10) || 0),
								(E.height = parseInt(b.height, 10) || 0),
								(E.backgroundColor = E.styles.backgroundColor)
							try {
								if (b.contentWindow && b.contentWindow.document && b.contentWindow.document.documentElement) {
									E.tree = fA(v, b.contentWindow.document.documentElement)
									var k = b.contentWindow.document.documentElement
											? ah(v, getComputedStyle(b.contentWindow.document.documentElement).backgroundColor)
											: wc.TRANSPARENT,
										z = b.contentWindow.document.body
											? ah(v, getComputedStyle(b.contentWindow.document.body).backgroundColor)
											: wc.TRANSPARENT
									E.backgroundColor = vc(k) ? (vc(z) ? E.styles.backgroundColor : z) : k
								}
							} catch {}
							return E
						}
						return A(p, g), p
					})(ja),
					y_ = ["OL", "UL", "MENU"],
					hA = function (g, p, v, b) {
						for (var E = p.firstChild, k = void 0; E; E = k)
							if (((k = E.nextSibling), x_(E) && E.data.trim().length > 0)) v.textNodes.push(new Yo(g, E, v.styles))
							else if (qd(E))
								if (rm(E) && E.assignedNodes)
									E.assignedNodes().forEach(function (te) {
										return hA(g, te, v, b)
									})
								else {
									var z = w_(g, E)
									z.styles.isVisible() &&
										(Zx(E, z, b) ? (z.flags |= 4) : Jx(z.styles) && (z.flags |= 2),
										-1 !== y_.indexOf(E.tagName) && (z.flags |= 8),
										v.elements.push(z),
										E.shadowRoot ? hA(g, E.shadowRoot, z, b) : !AA(E) && !Xa(E) && !Jd(E) && hA(g, E, z, b))
								}
					},
					w_ = function (g, p) {
						return pA(p)
							? new sA(g, p)
							: ph(p)
							? new aA(g, p)
							: Xa(p)
							? new Kx(g, p)
							: rF(p)
							? new iF(g, p)
							: Cs(p)
							? new cA(g, p)
							: Zd(p)
							? new __(g, p)
							: Jd(p)
							? new dA(g, p)
							: AA(p)
							? new uA(g, p)
							: E_(p)
							? new v_(g, p)
							: new ja(g, p)
					},
					fA = function (g, p) {
						var v = w_(g, p)
						return (v.flags |= 4), hA(g, p, v, v), v
					},
					Zx = function (g, p, v) {
						return (
							p.styles.isPositionedWithZIndex() ||
							p.styles.opacity < 1 ||
							p.styles.isTransformed() ||
							(C_(g) && v.styles.isTransparent())
						)
					},
					Jx = function (g) {
						return g.isPositioned() || g.isFloating()
					},
					x_ = function (g) {
						return g.nodeType === Node.TEXT_NODE
					},
					qd = function (g) {
						return g.nodeType === Node.ELEMENT_NODE
					},
					nm = function (g) {
						return qd(g) && typeof g.style < "u" && !mA(g)
					},
					mA = function (g) {
						return "object" == typeof g.className
					},
					rF = function (g) {
						return "LI" === g.tagName
					},
					Cs = function (g) {
						return "OL" === g.tagName
					},
					Zd = function (g) {
						return "INPUT" === g.tagName
					},
					Xa = function (g) {
						return "svg" === g.tagName
					},
					C_ = function (g) {
						return "BODY" === g.tagName
					},
					ph = function (g) {
						return "CANVAS" === g.tagName
					},
					e1 = function (g) {
						return "VIDEO" === g.tagName
					},
					pA = function (g) {
						return "IMG" === g.tagName
					},
					E_ = function (g) {
						return "IFRAME" === g.tagName
					},
					im = function (g) {
						return "STYLE" === g.tagName
					},
					AA = function (g) {
						return "TEXTAREA" === g.tagName
					},
					Jd = function (g) {
						return "SELECT" === g.tagName
					},
					rm = function (g) {
						return "SLOT" === g.tagName
					},
					om = function (g) {
						return g.tagName.indexOf("-") > 0
					},
					M_ = (function () {
						function g() {
							this.counters = {}
						}
						return (
							(g.prototype.getCounterValue = function (p) {
								var v = this.counters[p]
								return v && v.length ? v[v.length - 1] : 1
							}),
							(g.prototype.getCounterValues = function (p) {
								return this.counters[p] || []
							}),
							(g.prototype.pop = function (p) {
								var v = this
								p.forEach(function (b) {
									return v.counters[b].pop()
								})
							}),
							(g.prototype.parse = function (p) {
								var v = this,
									b = p.counterIncrement,
									E = p.counterReset,
									k = !0
								null !== b &&
									b.forEach(function (te) {
										var ee = v.counters[te.counter]
										ee &&
											0 !== te.increment &&
											((k = !1), ee.length || ee.push(1), (ee[Math.max(0, ee.length - 1)] += te.increment))
									})
								var z = []
								return (
									k &&
										E.forEach(function (te) {
											var ee = v.counters[te.counter]
											z.push(te.counter), ee || (ee = v.counters[te.counter] = []), ee.push(te.reset)
										}),
									z
								)
							}),
							g
						)
					})(),
					S_ = {
						integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
						values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
					},
					k_ = {
						integers: [
							9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50,
							40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
						],
						values: [
							"\u0554",
							"\u0553",
							"\u0552",
							"\u0551",
							"\u0550",
							"\u054f",
							"\u054e",
							"\u054d",
							"\u054c",
							"\u054b",
							"\u054a",
							"\u0549",
							"\u0548",
							"\u0547",
							"\u0546",
							"\u0545",
							"\u0544",
							"\u0543",
							"\u0542",
							"\u0541",
							"\u0540",
							"\u053f",
							"\u053e",
							"\u053d",
							"\u053c",
							"\u053b",
							"\u053a",
							"\u0539",
							"\u0538",
							"\u0537",
							"\u0536",
							"\u0535",
							"\u0534",
							"\u0533",
							"\u0532",
							"\u0531"
						]
					},
					oF = {
						integers: [
							1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18,
							17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
						],
						values: [
							"\u05d9\u05f3",
							"\u05d8\u05f3",
							"\u05d7\u05f3",
							"\u05d6\u05f3",
							"\u05d5\u05f3",
							"\u05d4\u05f3",
							"\u05d3\u05f3",
							"\u05d2\u05f3",
							"\u05d1\u05f3",
							"\u05d0\u05f3",
							"\u05ea",
							"\u05e9",
							"\u05e8",
							"\u05e7",
							"\u05e6",
							"\u05e4",
							"\u05e2",
							"\u05e1",
							"\u05e0",
							"\u05de",
							"\u05dc",
							"\u05db",
							"\u05d9\u05d8",
							"\u05d9\u05d7",
							"\u05d9\u05d6",
							"\u05d8\u05d6",
							"\u05d8\u05d5",
							"\u05d9",
							"\u05d8",
							"\u05d7",
							"\u05d6",
							"\u05d5",
							"\u05d4",
							"\u05d3",
							"\u05d2",
							"\u05d1",
							"\u05d0"
						]
					},
					Ah = {
						integers: [
							1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60,
							50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
						],
						values: [
							"\u10f5",
							"\u10f0",
							"\u10ef",
							"\u10f4",
							"\u10ee",
							"\u10ed",
							"\u10ec",
							"\u10eb",
							"\u10ea",
							"\u10e9",
							"\u10e8",
							"\u10e7",
							"\u10e6",
							"\u10e5",
							"\u10e4",
							"\u10f3",
							"\u10e2",
							"\u10e1",
							"\u10e0",
							"\u10df",
							"\u10de",
							"\u10dd",
							"\u10f2",
							"\u10dc",
							"\u10db",
							"\u10da",
							"\u10d9",
							"\u10d8",
							"\u10d7",
							"\u10f1",
							"\u10d6",
							"\u10d5",
							"\u10d4",
							"\u10d3",
							"\u10d2",
							"\u10d1",
							"\u10d0"
						]
					},
					kc = function (g, p, v, b, E, k) {
						return g < p || g > v
							? tu(g, E, k.length > 0)
							: b.integers.reduce(function (z, te, ee) {
									for (; g >= te; ) (g -= te), (z += b.values[ee])
									return z
							  }, "") + k
					},
					t1 = function (g, p, v, b) {
						var E = ""
						do {
							v || g--, (E = b(g) + E), (g /= p)
						} while (g * p >= p)
						return E
					},
					go = function (g, p, v, b, E) {
						var k = v - p + 1
						return (
							(g < 0 ? "-" : "") +
							(t1(Math.abs(g), k, b, function (z) {
								return V(Math.floor(z % k) + p)
							}) +
								E)
						)
					},
					el = function (g, p, v) {
						void 0 === v && (v = ". ")
						var b = p.length
						return (
							t1(Math.abs(g), b, !1, function (E) {
								return p[Math.floor(E % b)]
							}) + v
						)
					},
					jl = function (g, p, v, b, E, k) {
						if (g < -9999 || g > 9999) return tu(g, 4, E.length > 0)
						var z = Math.abs(g),
							te = E
						if (0 === z) return p[0] + te
						for (var ee = 0; z > 0 && ee <= 4; ee++) {
							var xe = z % 10
							0 === xe && Ao(k, 1) && "" !== te
								? (te = p[xe] + te)
								: xe > 1 ||
								  (1 === xe && 0 === ee) ||
								  (1 === xe && 1 === ee && Ao(k, 2)) ||
								  (1 === xe && 1 === ee && Ao(k, 4) && g > 100) ||
								  (1 === xe && ee > 1 && Ao(k, 8))
								? (te = p[xe] + (ee > 0 ? v[ee - 1] : "") + te)
								: 1 === xe && ee > 0 && (te = v[ee - 1] + te),
								(z = Math.floor(z / 10))
						}
						return (g < 0 ? b : "") + te
					},
					eu = "\ub9c8\uc774\ub108\uc2a4",
					tu = function (g, p, v) {
						var b = v ? ". " : "",
							E = v ? "\u3001" : "",
							k = v ? ", " : "",
							z = v ? " " : ""
						switch (p) {
							case 0:
								return "\u2022" + z
							case 1:
								return "\u25e6" + z
							case 2:
								return "\u25fe" + z
							case 5:
								var te = go(g, 48, 57, !0, b)
								return te.length < 4 ? "0" + te : te
							case 4:
								return el(g, "\u3007\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d", E)
							case 6:
								return kc(g, 1, 3999, S_, 3, b).toLowerCase()
							case 7:
								return kc(g, 1, 3999, S_, 3, b)
							case 8:
								return go(g, 945, 969, !1, b)
							case 9:
								return go(g, 97, 122, !1, b)
							case 10:
								return go(g, 65, 90, !1, b)
							case 11:
								return go(g, 1632, 1641, !0, b)
							case 12:
							case 49:
								return kc(g, 1, 9999, k_, 3, b)
							case 35:
								return kc(g, 1, 9999, k_, 3, b).toLowerCase()
							case 13:
								return go(g, 2534, 2543, !0, b)
							case 14:
							case 30:
								return go(g, 6112, 6121, !0, b)
							case 15:
								return el(g, "\u5b50\u4e11\u5bc5\u536f\u8fb0\u5df3\u5348\u672a\u7533\u9149\u620c\u4ea5", E)
							case 16:
								return el(g, "\u7532\u4e59\u4e19\u4e01\u620a\u5df1\u5e9a\u8f9b\u58ec\u7678", E)
							case 17:
							case 48:
								return jl(
									g,
									"\u96f6\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d",
									"\u5341\u767e\u5343\u842c",
									"\u8ca0",
									E,
									14
								)
							case 47:
								return jl(
									g,
									"\u96f6\u58f9\u8cb3\u53c3\u8086\u4f0d\u9678\u67d2\u634c\u7396",
									"\u62fe\u4f70\u4edf\u842c",
									"\u8ca0",
									E,
									15
								)
							case 42:
								return jl(
									g,
									"\u96f6\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d",
									"\u5341\u767e\u5343\u842c",
									"\u8d1f",
									E,
									14
								)
							case 41:
								return jl(
									g,
									"\u96f6\u58f9\u8d30\u53c1\u8086\u4f0d\u9646\u67d2\u634c\u7396",
									"\u62fe\u4f70\u4edf\u842c",
									"\u8d1f",
									E,
									15
								)
							case 26:
								return jl(
									g,
									"\u3007\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d",
									"\u5341\u767e\u5343\u4e07",
									"\u30de\u30a4\u30ca\u30b9",
									E,
									0
								)
							case 25:
								return jl(
									g,
									"\u96f6\u58f1\u5f10\u53c2\u56db\u4f0d\u516d\u4e03\u516b\u4e5d",
									"\u62fe\u767e\u5343\u4e07",
									"\u30de\u30a4\u30ca\u30b9",
									E,
									7
								)
							case 31:
								return jl(
									g,
									"\uc601\uc77c\uc774\uc0bc\uc0ac\uc624\uc721\uce60\ud314\uad6c",
									"\uc2ed\ubc31\ucc9c\ub9cc",
									eu,
									k,
									7
								)
							case 33:
								return jl(
									g,
									"\u96f6\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d",
									"\u5341\u767e\u5343\u842c",
									eu,
									k,
									0
								)
							case 32:
								return jl(g, "\u96f6\u58f9\u8cb3\u53c3\u56db\u4e94\u516d\u4e03\u516b\u4e5d", "\u62fe\u767e\u5343", eu, k, 7)
							case 18:
								return go(g, 2406, 2415, !0, b)
							case 20:
								return kc(g, 1, 19999, Ah, 3, b)
							case 21:
								return go(g, 2790, 2799, !0, b)
							case 22:
								return go(g, 2662, 2671, !0, b)
							case 22:
								return kc(g, 1, 10999, oF, 3, b)
							case 23:
								return el(
									g,
									"\u3042\u3044\u3046\u3048\u304a\u304b\u304d\u304f\u3051\u3053\u3055\u3057\u3059\u305b\u305d\u305f\u3061\u3064\u3066\u3068\u306a\u306b\u306c\u306d\u306e\u306f\u3072\u3075\u3078\u307b\u307e\u307f\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308a\u308b\u308c\u308d\u308f\u3090\u3091\u3092\u3093"
								)
							case 24:
								return el(
									g,
									"\u3044\u308d\u306f\u306b\u307b\u3078\u3068\u3061\u308a\u306c\u308b\u3092\u308f\u304b\u3088\u305f\u308c\u305d\u3064\u306d\u306a\u3089\u3080\u3046\u3090\u306e\u304a\u304f\u3084\u307e\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304d\u3086\u3081\u307f\u3057\u3091\u3072\u3082\u305b\u3059"
								)
							case 27:
								return go(g, 3302, 3311, !0, b)
							case 28:
								return el(
									g,
									"\u30a2\u30a4\u30a6\u30a8\u30aa\u30ab\u30ad\u30af\u30b1\u30b3\u30b5\u30b7\u30b9\u30bb\u30bd\u30bf\u30c1\u30c4\u30c6\u30c8\u30ca\u30cb\u30cc\u30cd\u30ce\u30cf\u30d2\u30d5\u30d8\u30db\u30de\u30df\u30e0\u30e1\u30e2\u30e4\u30e6\u30e8\u30e9\u30ea\u30eb\u30ec\u30ed\u30ef\u30f0\u30f1\u30f2\u30f3",
									E
								)
							case 29:
								return el(
									g,
									"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8\u30c1\u30ea\u30cc\u30eb\u30f2\u30ef\u30ab\u30e8\u30bf\u30ec\u30bd\u30c4\u30cd\u30ca\u30e9\u30e0\u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de\u30b1\u30d5\u30b3\u30a8\u30c6\u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7\u30f1\u30d2\u30e2\u30bb\u30b9",
									E
								)
							case 34:
								return go(g, 3792, 3801, !0, b)
							case 37:
								return go(g, 6160, 6169, !0, b)
							case 38:
								return go(g, 4160, 4169, !0, b)
							case 39:
								return go(g, 2918, 2927, !0, b)
							case 40:
								return go(g, 1776, 1785, !0, b)
							case 43:
								return go(g, 3046, 3055, !0, b)
							case 44:
								return go(g, 3174, 3183, !0, b)
							case 45:
								return go(g, 3664, 3673, !0, b)
							case 46:
								return go(g, 3872, 3881, !0, b)
							default:
								return go(g, 48, 57, !0, b)
						}
					},
					am = "data-html2canvas-ignore",
					sF = (function () {
						function g(p, v, b) {
							if (
								((this.context = p),
								(this.options = b),
								(this.scrolledElements = []),
								(this.referenceElement = v),
								(this.counters = new M_()),
								(this.quoteDepth = 0),
								!v.ownerDocument)
							)
								throw new Error("Cloned element does not have an owner document")
							this.documentElement = this.cloneNode(v.ownerDocument.documentElement, !1)
						}
						return (
							(g.prototype.toIFrame = function (p, v) {
								var b = this,
									E = r1(p, v)
								if (!E.contentWindow) return Promise.reject("Unable to find iframe window")
								var k = p.defaultView.pageXOffset,
									z = p.defaultView.pageYOffset,
									te = E.contentWindow,
									ee = te.document,
									xe = cF(E).then(function () {
										return q(b, void 0, void 0, function () {
											var Fe, Oe
											return m(this, function (ot) {
												switch (ot.label) {
													case 0:
														return (
															this.scrolledElements.forEach(T_),
															te &&
																(te.scrollTo(v.left, v.top),
																/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
																	(te.scrollY !== v.top || te.scrollX !== v.left) &&
																	(this.context.logger.warn(
																		"Unable to restore scroll position for cloned document"
																	),
																	(this.context.windowBounds = this.context.windowBounds.add(
																		te.scrollX - v.left,
																		te.scrollY - v.top,
																		0,
																		0
																	)))),
															(Fe = this.options.onclone),
															typeof (Oe = this.clonedReferenceElement) > "u"
																? [
																		2,
																		Promise.reject(
																			"Error finding the " +
																				this.referenceElement.nodeName +
																				" in the cloned document"
																		)
																  ]
																: ee.fonts && ee.fonts.ready
																? [4, ee.fonts.ready]
																: [3, 2]
														)
													case 1:
														ot.sent(), (ot.label = 2)
													case 2:
														return /(AppleWebKit)/g.test(navigator.userAgent) ? [4, Tc(ee)] : [3, 4]
													case 3:
														ot.sent(), (ot.label = 4)
													case 4:
														return "function" == typeof Fe
															? [
																	2,
																	Promise.resolve()
																		.then(function () {
																			return Fe(ee, Oe)
																		})
																		.then(function () {
																			return E
																		})
															  ]
															: [2, E]
												}
											})
										})
									})
								return (
									ee.open(),
									ee.write(o1(document.doctype) + "<html></html>"),
									vA(this.referenceElement.ownerDocument, k, z),
									ee.replaceChild(ee.adoptNode(this.documentElement), ee.documentElement),
									ee.close(),
									xe
								)
							}),
							(g.prototype.createElementClone = function (p) {
								if ((Ql(p, 2), ph(p))) return this.createCanvasClone(p)
								if (e1(p)) return this.createVideoClone(p)
								if (im(p)) return this.createStyleClone(p)
								var v = p.cloneNode(!1)
								return (
									pA(v) &&
										(pA(p) && p.currentSrc && p.currentSrc !== p.src && ((v.src = p.currentSrc), (v.srcset = "")),
										"lazy" === v.loading && (v.loading = "eager")),
									om(v) ? this.createCustomElementClone(v) : v
								)
							}),
							(g.prototype.createCustomElementClone = function (p) {
								var v = document.createElement("html2canvascustomelement")
								return lm(p.style, v), v
							}),
							(g.prototype.createStyleClone = function (p) {
								try {
									var v = p.sheet
									if (v && v.cssRules) {
										var b = [].slice.call(v.cssRules, 0).reduce(function (k, z) {
												return z && "string" == typeof z.cssText ? k + z.cssText : k
											}, ""),
											E = p.cloneNode(!1)
										return (E.textContent = b), E
									}
								} catch (k) {
									if ((this.context.logger.error("Unable to access cssRules property", k), "SecurityError" !== k.name))
										throw k
								}
								return p.cloneNode(!1)
							}),
							(g.prototype.createCanvasClone = function (p) {
								var v
								if (this.options.inlineImages && p.ownerDocument) {
									var b = p.ownerDocument.createElement("img")
									try {
										return (b.src = p.toDataURL()), b
									} catch {
										this.context.logger.info("Unable to inline canvas contents, canvas is tainted", p)
									}
								}
								var E = p.cloneNode(!1)
								try {
									;(E.width = p.width), (E.height = p.height)
									var k = p.getContext("2d"),
										z = E.getContext("2d")
									if (z)
										if (!this.options.allowTaint && k) z.putImageData(k.getImageData(0, 0, p.width, p.height), 0, 0)
										else {
											var te = null !== (v = p.getContext("webgl2")) && void 0 !== v ? v : p.getContext("webgl")
											if (te) {
												var ee = te.getContextAttributes()
												!1 === ee?.preserveDrawingBuffer &&
													this.context.logger.warn(
														"Unable to clone WebGL context as it has preserveDrawingBuffer=false",
														p
													)
											}
											z.drawImage(p, 0, 0)
										}
									return E
								} catch {
									this.context.logger.info("Unable to clone canvas as it is tainted", p)
								}
								return E
							}),
							(g.prototype.createVideoClone = function (p) {
								var v = p.ownerDocument.createElement("canvas")
								;(v.width = p.offsetWidth), (v.height = p.offsetHeight)
								var b = v.getContext("2d")
								try {
									return (
										b &&
											(b.drawImage(p, 0, 0, v.width, v.height),
											this.options.allowTaint || b.getImageData(0, 0, v.width, v.height)),
										v
									)
								} catch {
									this.context.logger.info("Unable to clone video as it is tainted", p)
								}
								var E = p.ownerDocument.createElement("canvas")
								return (E.width = p.offsetWidth), (E.height = p.offsetHeight), E
							}),
							(g.prototype.appendChildNode = function (p, v, b) {
								;(!qd(v) ||
									(!(function (g) {
										return "SCRIPT" === g.tagName
									})(v) &&
										!v.hasAttribute(am) &&
										("function" != typeof this.options.ignoreElements || !this.options.ignoreElements(v)))) &&
									(!this.options.copyStyles || !qd(v) || !im(v)) &&
									p.appendChild(this.cloneNode(v, b))
							}),
							(g.prototype.cloneChildNodes = function (p, v, b) {
								for (var E = this, k = p.shadowRoot ? p.shadowRoot.firstChild : p.firstChild; k; k = k.nextSibling)
									if (qd(k) && rm(k) && "function" == typeof k.assignedNodes) {
										var z = k.assignedNodes()
										z.length &&
											z.forEach(function (te) {
												return E.appendChildNode(v, te, b)
											})
									} else this.appendChildNode(v, k, b)
							}),
							(g.prototype.cloneNode = function (p, v) {
								if (x_(p)) return document.createTextNode(p.data)
								if (!p.ownerDocument) return p.cloneNode(!1)
								var b = p.ownerDocument.defaultView
								if (b && qd(p) && (nm(p) || mA(p))) {
									var E = this.createElementClone(p)
									E.style.transitionProperty = "none"
									var k = b.getComputedStyle(p),
										z = b.getComputedStyle(p, ":before"),
										te = b.getComputedStyle(p, ":after")
									this.referenceElement === p && nm(E) && (this.clonedReferenceElement = E), C_(E) && dF(E)
									var ee = this.counters.parse(new u_(this.context, k)),
										xe = this.resolvePseudoContent(p, E, z, cm.BEFORE)
									om(p) && (v = !0), e1(p) || this.cloneChildNodes(p, E, v), xe && E.insertBefore(xe, E.firstChild)
									var Fe = this.resolvePseudoContent(p, E, te, cm.AFTER)
									return (
										Fe && E.appendChild(Fe),
										this.counters.pop(ee),
										((k && (this.options.copyStyles || mA(p)) && !E_(p)) || v) && lm(k, E),
										(0 !== p.scrollTop || 0 !== p.scrollLeft) &&
											this.scrolledElements.push([E, p.scrollLeft, p.scrollTop]),
										(AA(p) || Jd(p)) && (AA(E) || Jd(E)) && (E.value = p.value),
										E
									)
								}
								return p.cloneNode(!1)
							}),
							(g.prototype.resolvePseudoContent = function (p, v, b, E) {
								var k = this
								if (b) {
									var z = b.content,
										te = v.ownerDocument
									if (te && z && "none" !== z && "-moz-alt-content" !== z && "none" !== b.display) {
										this.counters.parse(new u_(this.context, b))
										var ee = new Sx(this.context, b),
											xe = te.createElement("html2canvaspseudoelement")
										lm(b, xe),
											ee.content.forEach(function (Oe) {
												if (0 === Oe.type) xe.appendChild(te.createTextNode(Oe.value))
												else if (22 === Oe.type) {
													var ot = te.createElement("img")
													;(ot.src = Oe.value), (ot.style.opacity = "1"), xe.appendChild(ot)
												} else if (18 === Oe.type) {
													if ("attr" === Oe.name) {
														var Yt = Oe.values.filter(qi)
														Yt.length && xe.appendChild(te.createTextNode(p.getAttribute(Yt[0].value) || ""))
													} else if ("counter" === Oe.name) {
														var Ft = Oe.values.filter(Gd),
															fi = Ft[1]
														if ((Pt = Ft[0]) && qi(Pt)) {
															var bn = k.counters.getCounterValue(Pt.value),
																dn = fi && qi(fi) ? fh.parse(k.context, fi.value) : 3
															xe.appendChild(te.createTextNode(tu(bn, dn, !1)))
														}
													} else if ("counters" === Oe.name) {
														var Pt,
															Vi = Oe.values.filter(Gd),
															gi = Vi[1]
														if (((fi = Vi[2]), (Pt = Vi[0]) && qi(Pt))) {
															var Yn = k.counters.getCounterValues(Pt.value),
																zt = fi && qi(fi) ? fh.parse(k.context, fi.value) : 3,
																Gi = gi && 0 === gi.type ? gi.value : "",
																$i = Yn.map(function (ta) {
																	return tu(ta, zt, !1)
																}).join(Gi)
															xe.appendChild(te.createTextNode($i))
														}
													}
												} else if (20 === Oe.type)
													switch (Oe.value) {
														case "open-quote":
															xe.appendChild(te.createTextNode(l_(ee.quotes, k.quoteDepth++, !0)))
															break
														case "close-quote":
															xe.appendChild(te.createTextNode(l_(ee.quotes, --k.quoteDepth, !1)))
															break
														default:
															xe.appendChild(te.createTextNode(Oe.value))
													}
											}),
											(xe.className = yA + " " + wA)
										var Fe = E === cm.BEFORE ? " " + yA : " " + wA
										return mA(v) ? (v.className.baseValue += Fe) : (v.className += Fe), xe
									}
								}
							}),
							(g.destroy = function (p) {
								return !!p.parentNode && (p.parentNode.removeChild(p), !0)
							}),
							g
						)
					})(),
					cm = (function (g) {
						return (g[(g.BEFORE = 0)] = "BEFORE"), (g[(g.AFTER = 1)] = "AFTER"), g
					})(cm || {}),
					r1 = function (g, p) {
						var v = g.createElement("iframe")
						return (
							(v.className = "html2canvas-container"),
							(v.style.visibility = "hidden"),
							(v.style.position = "fixed"),
							(v.style.left = "-10000px"),
							(v.style.top = "0px"),
							(v.style.border = "0"),
							(v.width = p.width.toString()),
							(v.height = p.height.toString()),
							(v.scrolling = "no"),
							v.setAttribute(am, "true"),
							g.body.appendChild(v),
							v
						)
					},
					aF = function (g) {
						return new Promise(function (p) {
							g.complete ? p() : g.src ? ((g.onload = p), (g.onerror = p)) : p()
						})
					},
					Tc = function (g) {
						return Promise.all([].slice.call(g.images, 0).map(aF))
					},
					cF = function (g) {
						return new Promise(function (p, v) {
							var b = g.contentWindow
							if (!b) return v("No window assigned for iframe")
							var E = b.document
							b.onload = g.onload = function () {
								b.onload = g.onload = null
								var k = setInterval(function () {
									E.body.childNodes.length > 0 && "complete" === E.readyState && (clearInterval(k), p(g))
								}, 50)
							}
						})
					},
					_A = ["all", "d", "content"],
					lm = function (g, p) {
						for (var v = g.length - 1; v >= 0; v--) {
							var b = g.item(v)
							;-1 === _A.indexOf(b) && p.style.setProperty(b, g.getPropertyValue(b))
						}
						return p
					},
					o1 = function (g) {
						var p = ""
						return (
							g &&
								((p += "<!DOCTYPE "),
								g.name && (p += g.name),
								g.internalSubset && (p += g.internalSubset),
								g.publicId && (p += '"' + g.publicId + '"'),
								g.systemId && (p += '"' + g.systemId + '"'),
								(p += ">")),
							p
						)
					},
					vA = function (g, p, v) {
						g &&
							g.defaultView &&
							(p !== g.defaultView.pageXOffset || v !== g.defaultView.pageYOffset) &&
							g.defaultView.scrollTo(p, v)
					},
					T_ = function (g) {
						var p = g[0],
							b = g[2]
						;(p.scrollLeft = g[1]), (p.scrollTop = b)
					},
					yA = "___html2canvas___pseudoelement_before",
					wA = "___html2canvas___pseudoelement_after",
					F_ = '{\n    content: "" !important;\n    display: none !important;\n}',
					dF = function (g) {
						xA(g, "." + yA + ":before" + F_ + "\n         ." + wA + ":after" + F_)
					},
					xA = function (g, p) {
						var v = g.ownerDocument
						if (v) {
							var b = v.createElement("style")
							;(b.textContent = p), g.appendChild(b)
						}
					},
					Kl = (function () {
						function g() {}
						return (
							(g.getOrigin = function (p) {
								var v = g._link
								return v ? ((v.href = p), (v.href = v.href), v.protocol + v.hostname + v.port) : "about:blank"
							}),
							(g.isSameOrigin = function (p) {
								return g.getOrigin(p) === g._origin
							}),
							(g.setContext = function (p) {
								;(g._link = p.document.createElement("a")), (g._origin = g.getOrigin(p.location.href))
							}),
							(g._origin = "about:blank"),
							g
						)
					})(),
					uF = (function () {
						function g(p, v) {
							;(this.context = p), (this._options = v), (this._cache = {})
						}
						return (
							(g.prototype.addImage = function (p) {
								var v = Promise.resolve()
								return this.has(p) || ((gr(p) || hF(p)) && (this._cache[p] = this.loadImage(p)).catch(function () {})), v
							}),
							(g.prototype.match = function (p) {
								return this._cache[p]
							}),
							(g.prototype.loadImage = function (p) {
								return q(this, void 0, void 0, function () {
									var v,
										b,
										E,
										k,
										z = this
									return m(this, function (te) {
										switch (te.label) {
											case 0:
												return (
													(v = Kl.isSameOrigin(p)),
													(b = !qo(p) && !0 === this._options.useCORS && Zr.SUPPORT_CORS_IMAGES && !v),
													(E =
														!qo(p) &&
														!v &&
														!gr(p) &&
														"string" == typeof this._options.proxy &&
														Zr.SUPPORT_CORS_XHR &&
														!b),
													v || !1 !== this._options.allowTaint || qo(p) || gr(p) || E || b
														? ((k = p), E ? [4, this.proxy(k)] : [3, 2])
														: [2]
												)
											case 1:
												;(k = te.sent()), (te.label = 2)
											case 2:
												return (
													this.context.logger.debug("Added image " + p.substring(0, 256)),
													[
														4,
														new Promise(function (ee, xe) {
															var Fe = new Image()
															;(Fe.onload = function () {
																return ee(Fe)
															}),
																(Fe.onerror = xe),
																(fF(k) || b) && (Fe.crossOrigin = "anonymous"),
																(Fe.src = k),
																!0 === Fe.complete &&
																	setTimeout(function () {
																		return ee(Fe)
																	}, 500),
																z._options.imageTimeout > 0 &&
																	setTimeout(function () {
																		return xe(
																			"Timed out (" + z._options.imageTimeout + "ms) loading image"
																		)
																	}, z._options.imageTimeout)
														})
													]
												)
											case 3:
												return [2, te.sent()]
										}
									})
								})
							}),
							(g.prototype.has = function (p) {
								return typeof this._cache[p] < "u"
							}),
							(g.prototype.keys = function () {
								return Promise.resolve(Object.keys(this._cache))
							}),
							(g.prototype.proxy = function (p) {
								var v = this,
									b = this._options.proxy
								if (!b) throw new Error("No proxy defined")
								var E = p.substring(0, 256)
								return new Promise(function (k, z) {
									var te = Zr.SUPPORT_RESPONSE_TYPE ? "blob" : "text",
										ee = new XMLHttpRequest()
									;(ee.onload = function () {
										if (200 === ee.status)
											if ("text" === te) k(ee.response)
											else {
												var Oe = new FileReader()
												Oe.addEventListener(
													"load",
													function () {
														return k(Oe.result)
													},
													!1
												),
													Oe.addEventListener(
														"error",
														function (ot) {
															return z(ot)
														},
														!1
													),
													Oe.readAsDataURL(ee.response)
											}
										else z("Failed to proxy resource " + E + " with status code " + ee.status)
									}),
										(ee.onerror = z)
									var xe = b.indexOf("?") > -1 ? "&" : "?"
									if (
										(ee.open("GET", "" + b + xe + "url=" + encodeURIComponent(p) + "&responseType=" + te),
										"text" !== te && ee instanceof XMLHttpRequest && (ee.responseType = te),
										v._options.imageTimeout)
									) {
										var Fe = v._options.imageTimeout
										;(ee.timeout = Fe),
											(ee.ontimeout = function () {
												return z("Timed out (" + Fe + "ms) proxying " + E)
											})
									}
									ee.send()
								})
							}),
							g
						)
					})(),
					a1 = /^data:image\/svg\+xml/i,
					c1 = /^data:image\/.*;base64,/i,
					dm = /^data:image\/.*/i,
					hF = function (g) {
						return Zr.SUPPORT_SVG_DRAWING || !B_(g)
					},
					qo = function (g) {
						return dm.test(g)
					},
					fF = function (g) {
						return c1.test(g)
					},
					gr = function (g) {
						return "blob" === g.substr(0, 4)
					},
					B_ = function (g) {
						return "svg" === g.substr(-3).toLowerCase() || a1.test(g)
					},
					jt = (function () {
						function g(p, v) {
							;(this.type = 0), (this.x = p), (this.y = v)
						}
						return (
							(g.prototype.add = function (p, v) {
								return new g(this.x + p, this.y + v)
							}),
							g
						)
					})(),
					nu = function (g, p, v) {
						return new jt(g.x + (p.x - g.x) * v, g.y + (p.y - g.y) * v)
					},
					Ma = (function () {
						function g(p, v, b, E) {
							;(this.type = 1), (this.start = p), (this.startControl = v), (this.endControl = b), (this.end = E)
						}
						return (
							(g.prototype.subdivide = function (p, v) {
								var b = nu(this.start, this.startControl, p),
									E = nu(this.startControl, this.endControl, p),
									k = nu(this.endControl, this.end, p),
									z = nu(b, E, p),
									te = nu(E, k, p),
									ee = nu(z, te, p)
								return v ? new g(this.start, b, z, ee) : new g(ee, te, k, this.end)
							}),
							(g.prototype.add = function (p, v) {
								return new g(
									this.start.add(p, v),
									this.startControl.add(p, v),
									this.endControl.add(p, v),
									this.end.add(p, v)
								)
							}),
							(g.prototype.reverse = function () {
								return new g(this.end, this.endControl, this.startControl, this.start)
							}),
							g
						)
					})(),
					Zo = function (g) {
						return 1 === g.type
					},
					bh = function g(p) {
						var v = p.styles,
							b = p.bounds,
							E = $d(v.borderTopLeftRadius, b.width, b.height),
							k = E[0],
							z = E[1],
							te = $d(v.borderTopRightRadius, b.width, b.height),
							ee = te[0],
							xe = te[1],
							Fe = $d(v.borderBottomRightRadius, b.width, b.height),
							Oe = Fe[0],
							ot = Fe[1],
							Yt = $d(v.borderBottomLeftRadius, b.width, b.height),
							Ft = Yt[0],
							Pt = Yt[1],
							fi = []
						fi.push((k + ee) / b.width),
							fi.push((Ft + Oe) / b.width),
							fi.push((z + Pt) / b.height),
							fi.push((xe + ot) / b.height)
						var bn = Math.max.apply(Math, fi)
						bn > 1 && ((k /= bn), (z /= bn), (ee /= bn), (xe /= bn), (Oe /= bn), (ot /= bn), (Ft /= bn), (Pt /= bn))
						var dn = b.width - ee,
							Vi = b.height - ot,
							gi = b.width - Oe,
							Yn = b.height - Pt,
							zt = v.borderTopWidth,
							Gi = v.borderRightWidth,
							$i = v.borderBottomWidth,
							ti = v.borderLeftWidth,
							Fo = tr(v.paddingTop, p.bounds.width),
							ta = tr(v.paddingRight, p.bounds.width),
							na = tr(v.paddingBottom, p.bounds.width),
							Ji = tr(v.paddingLeft, p.bounds.width)
						;(this.topLeftBorderDoubleOuterBox =
							k > 0 || z > 0
								? xr(b.left + ti / 3, b.top + zt / 3, k - ti / 3, z - zt / 3, Hi.TOP_LEFT)
								: new jt(b.left + ti / 3, b.top + zt / 3)),
							(this.topRightBorderDoubleOuterBox =
								k > 0 || z > 0
									? xr(b.left + dn, b.top + zt / 3, ee - Gi / 3, xe - zt / 3, Hi.TOP_RIGHT)
									: new jt(b.left + b.width - Gi / 3, b.top + zt / 3)),
							(this.bottomRightBorderDoubleOuterBox =
								Oe > 0 || ot > 0
									? xr(b.left + gi, b.top + Vi, Oe - Gi / 3, ot - $i / 3, Hi.BOTTOM_RIGHT)
									: new jt(b.left + b.width - Gi / 3, b.top + b.height - $i / 3)),
							(this.bottomLeftBorderDoubleOuterBox =
								Ft > 0 || Pt > 0
									? xr(b.left + ti / 3, b.top + Yn, Ft - ti / 3, Pt - $i / 3, Hi.BOTTOM_LEFT)
									: new jt(b.left + ti / 3, b.top + b.height - $i / 3)),
							(this.topLeftBorderDoubleInnerBox =
								k > 0 || z > 0
									? xr(b.left + (2 * ti) / 3, b.top + (2 * zt) / 3, k - (2 * ti) / 3, z - (2 * zt) / 3, Hi.TOP_LEFT)
									: new jt(b.left + (2 * ti) / 3, b.top + (2 * zt) / 3)),
							(this.topRightBorderDoubleInnerBox =
								k > 0 || z > 0
									? xr(b.left + dn, b.top + (2 * zt) / 3, ee - (2 * Gi) / 3, xe - (2 * zt) / 3, Hi.TOP_RIGHT)
									: new jt(b.left + b.width - (2 * Gi) / 3, b.top + (2 * zt) / 3)),
							(this.bottomRightBorderDoubleInnerBox =
								Oe > 0 || ot > 0
									? xr(b.left + gi, b.top + Vi, Oe - (2 * Gi) / 3, ot - (2 * $i) / 3, Hi.BOTTOM_RIGHT)
									: new jt(b.left + b.width - (2 * Gi) / 3, b.top + b.height - (2 * $i) / 3)),
							(this.bottomLeftBorderDoubleInnerBox =
								Ft > 0 || Pt > 0
									? xr(b.left + (2 * ti) / 3, b.top + Yn, Ft - (2 * ti) / 3, Pt - (2 * $i) / 3, Hi.BOTTOM_LEFT)
									: new jt(b.left + (2 * ti) / 3, b.top + b.height - (2 * $i) / 3)),
							(this.topLeftBorderStroke =
								k > 0 || z > 0
									? xr(b.left + ti / 2, b.top + zt / 2, k - ti / 2, z - zt / 2, Hi.TOP_LEFT)
									: new jt(b.left + ti / 2, b.top + zt / 2)),
							(this.topRightBorderStroke =
								k > 0 || z > 0
									? xr(b.left + dn, b.top + zt / 2, ee - Gi / 2, xe - zt / 2, Hi.TOP_RIGHT)
									: new jt(b.left + b.width - Gi / 2, b.top + zt / 2)),
							(this.bottomRightBorderStroke =
								Oe > 0 || ot > 0
									? xr(b.left + gi, b.top + Vi, Oe - Gi / 2, ot - $i / 2, Hi.BOTTOM_RIGHT)
									: new jt(b.left + b.width - Gi / 2, b.top + b.height - $i / 2)),
							(this.bottomLeftBorderStroke =
								Ft > 0 || Pt > 0
									? xr(b.left + ti / 2, b.top + Yn, Ft - ti / 2, Pt - $i / 2, Hi.BOTTOM_LEFT)
									: new jt(b.left + ti / 2, b.top + b.height - $i / 2)),
							(this.topLeftBorderBox = k > 0 || z > 0 ? xr(b.left, b.top, k, z, Hi.TOP_LEFT) : new jt(b.left, b.top)),
							(this.topRightBorderBox =
								ee > 0 || xe > 0 ? xr(b.left + dn, b.top, ee, xe, Hi.TOP_RIGHT) : new jt(b.left + b.width, b.top)),
							(this.bottomRightBorderBox =
								Oe > 0 || ot > 0
									? xr(b.left + gi, b.top + Vi, Oe, ot, Hi.BOTTOM_RIGHT)
									: new jt(b.left + b.width, b.top + b.height)),
							(this.bottomLeftBorderBox =
								Ft > 0 || Pt > 0 ? xr(b.left, b.top + Yn, Ft, Pt, Hi.BOTTOM_LEFT) : new jt(b.left, b.top + b.height)),
							(this.topLeftPaddingBox =
								k > 0 || z > 0
									? xr(b.left + ti, b.top + zt, Math.max(0, k - ti), Math.max(0, z - zt), Hi.TOP_LEFT)
									: new jt(b.left + ti, b.top + zt)),
							(this.topRightPaddingBox =
								ee > 0 || xe > 0
									? xr(
											b.left + Math.min(dn, b.width - Gi),
											b.top + zt,
											dn > b.width + Gi ? 0 : Math.max(0, ee - Gi),
											Math.max(0, xe - zt),
											Hi.TOP_RIGHT
									  )
									: new jt(b.left + b.width - Gi, b.top + zt)),
							(this.bottomRightPaddingBox =
								Oe > 0 || ot > 0
									? xr(
											b.left + Math.min(gi, b.width - ti),
											b.top + Math.min(Vi, b.height - $i),
											Math.max(0, Oe - Gi),
											Math.max(0, ot - $i),
											Hi.BOTTOM_RIGHT
									  )
									: new jt(b.left + b.width - Gi, b.top + b.height - $i)),
							(this.bottomLeftPaddingBox =
								Ft > 0 || Pt > 0
									? xr(
											b.left + ti,
											b.top + Math.min(Yn, b.height - $i),
											Math.max(0, Ft - ti),
											Math.max(0, Pt - $i),
											Hi.BOTTOM_LEFT
									  )
									: new jt(b.left + ti, b.top + b.height - $i)),
							(this.topLeftContentBox =
								k > 0 || z > 0
									? xr(
											b.left + ti + Ji,
											b.top + zt + Fo,
											Math.max(0, k - (ti + Ji)),
											Math.max(0, z - (zt + Fo)),
											Hi.TOP_LEFT
									  )
									: new jt(b.left + ti + Ji, b.top + zt + Fo)),
							(this.topRightContentBox =
								ee > 0 || xe > 0
									? xr(
											b.left + Math.min(dn, b.width + ti + Ji),
											b.top + zt + Fo,
											dn > b.width + ti + Ji ? 0 : ee - ti + Ji,
											xe - (zt + Fo),
											Hi.TOP_RIGHT
									  )
									: new jt(b.left + b.width - (Gi + ta), b.top + zt + Fo)),
							(this.bottomRightContentBox =
								Oe > 0 || ot > 0
									? xr(
											b.left + Math.min(gi, b.width - (ti + Ji)),
											b.top + Math.min(Vi, b.height + zt + Fo),
											Math.max(0, Oe - (Gi + ta)),
											ot - ($i + na),
											Hi.BOTTOM_RIGHT
									  )
									: new jt(b.left + b.width - (Gi + ta), b.top + b.height - ($i + na))),
							(this.bottomLeftContentBox =
								Ft > 0 || Pt > 0
									? xr(b.left + ti + Ji, b.top + Yn, Math.max(0, Ft - (ti + Ji)), Pt - ($i + na), Hi.BOTTOM_LEFT)
									: new jt(b.left + ti + Ji, b.top + b.height - ($i + na)))
					},
					Hi = (function (g) {
						return (
							(g[(g.TOP_LEFT = 0)] = "TOP_LEFT"),
							(g[(g.TOP_RIGHT = 1)] = "TOP_RIGHT"),
							(g[(g.BOTTOM_RIGHT = 2)] = "BOTTOM_RIGHT"),
							(g[(g.BOTTOM_LEFT = 3)] = "BOTTOM_LEFT"),
							g
						)
					})(Hi || {}),
					xr = function (g, p, v, b, E) {
						var k = ((Math.sqrt(2) - 1) / 3) * 4,
							z = v * k,
							te = b * k,
							ee = g + v,
							xe = p + b
						switch (E) {
							case Hi.TOP_LEFT:
								return new Ma(new jt(g, xe), new jt(g, xe - te), new jt(ee - z, p), new jt(ee, p))
							case Hi.TOP_RIGHT:
								return new Ma(new jt(g, p), new jt(g + z, p), new jt(ee, xe - te), new jt(ee, xe))
							case Hi.BOTTOM_RIGHT:
								return new Ma(new jt(ee, p), new jt(ee, p + te), new jt(g + z, xe), new jt(g, xe))
							default:
								return new Ma(new jt(ee, xe), new jt(ee - z, xe), new jt(g, p + te), new jt(g, p))
						}
					},
					_h = function (g) {
						return [g.topLeftBorderBox, g.topRightBorderBox, g.bottomRightBorderBox, g.bottomLeftBorderBox]
					},
					I_ = function (g) {
						return [g.topLeftPaddingBox, g.topRightPaddingBox, g.bottomRightPaddingBox, g.bottomLeftPaddingBox]
					},
					mF = function g(p, v, b) {
						;(this.offsetX = p), (this.offsetY = v), (this.matrix = b), (this.type = 0), (this.target = 6)
					},
					D_ = function g(p, v) {
						;(this.path = p), (this.target = v), (this.type = 1)
					},
					kU = function g(p) {
						;(this.opacity = p), (this.type = 2), (this.target = 6)
					},
					pF = function (g) {
						return 1 === g.type
					},
					AF = function (g, p) {
						return (
							g.length === p.length &&
							g.some(function (v, b) {
								return v === p[b]
							})
						)
					},
					l1 = function g(p) {
						;(this.element = p),
							(this.inlineLevel = []),
							(this.nonInlineLevel = []),
							(this.negativeZIndex = []),
							(this.zeroOrAutoZIndexOrTransformedOrOpacity = []),
							(this.positiveZIndex = []),
							(this.nonPositionedFloats = []),
							(this.nonPositionedInlineLevel = [])
					},
					d1 = (function () {
						function g(p, v) {
							if (
								((this.container = p),
								(this.parent = v),
								(this.effects = []),
								(this.curves = new bh(this.container)),
								this.container.styles.opacity < 1 && this.effects.push(new kU(this.container.styles.opacity)),
								null !== this.container.styles.transform &&
									this.effects.push(
										new mF(
											this.container.bounds.left + this.container.styles.transformOrigin[0].number,
											this.container.bounds.top + this.container.styles.transformOrigin[1].number,
											this.container.styles.transform
										)
									),
								0 !== this.container.styles.overflowX)
							) {
								var z = _h(this.curves),
									te = I_(this.curves)
								AF(z, te)
									? this.effects.push(new D_(z, 6))
									: (this.effects.push(new D_(z, 2)), this.effects.push(new D_(te, 4)))
							}
						}
						return (
							(g.prototype.getEffects = function (p) {
								for (
									var v = -1 === [2, 3].indexOf(this.container.styles.position),
										b = this.parent,
										E = this.effects.slice(0);
									b;

								) {
									var k = b.effects.filter(function (ee) {
										return !pF(ee)
									})
									if (v || 0 !== b.container.styles.position || !b.parent) {
										if (
											(E.unshift.apply(E, k),
											(v = -1 === [2, 3].indexOf(b.container.styles.position)),
											0 !== b.container.styles.overflowX)
										) {
											var z = _h(b.curves),
												te = I_(b.curves)
											AF(z, te) || E.unshift(new D_(te, 6))
										}
									} else E.unshift.apply(E, k)
									b = b.parent
								}
								return E.filter(function (ee) {
									return Ao(ee.target, p)
								})
							}),
							g
						)
					})(),
					ao = function (g, p, v, b) {
						g.container.elements.forEach(function (E) {
							var k = Ao(E.flags, 4),
								z = Ao(E.flags, 2),
								te = new d1(E, g)
							Ao(E.styles.display, 2048) && b.push(te)
							var ee = Ao(E.flags, 8) ? [] : b
							if (k || z) {
								var xe = k || E.styles.isPositioned() ? v : p,
									Fe = new l1(te)
								if (E.styles.isPositioned() || E.styles.opacity < 1 || E.styles.isTransformed()) {
									var Oe = E.styles.zIndex.order
									if (Oe < 0) {
										var ot = 0
										xe.negativeZIndex.some(function (Ft, Pt) {
											return Oe > Ft.element.container.styles.zIndex.order ? ((ot = Pt), !1) : ot > 0
										}),
											xe.negativeZIndex.splice(ot, 0, Fe)
									} else if (Oe > 0) {
										var Yt = 0
										xe.positiveZIndex.some(function (Ft, Pt) {
											return Oe >= Ft.element.container.styles.zIndex.order ? ((Yt = Pt + 1), !1) : Yt > 0
										}),
											xe.positiveZIndex.splice(Yt, 0, Fe)
									} else xe.zeroOrAutoZIndexOrTransformedOrOpacity.push(Fe)
								} else E.styles.isFloating() ? xe.nonPositionedFloats.push(Fe) : xe.nonPositionedInlineLevel.push(Fe)
								ao(te, Fe, k ? Fe : v, ee)
							} else E.styles.isInlineLevel() ? p.inlineLevel.push(te) : p.nonInlineLevel.push(te), ao(te, p, v, ee)
							Ao(E.flags, 8) && u1(E, ee)
						})
					},
					u1 = function (g, p) {
						for (var v = g instanceof cA ? g.start : 1, b = g instanceof cA && g.reversed, E = 0; E < p.length; E++) {
							var k = p[E]
							k.container instanceof iF &&
								"number" == typeof k.container.value &&
								0 !== k.container.value &&
								(v = k.container.value),
								(k.listValue = tu(v, k.container.styles.listStyleType, !0)),
								(v += b ? -1 : 1)
						}
					},
					h1 = function (g, p) {
						switch (p) {
							case 0:
								return cs(g.topLeftBorderBox, g.topLeftPaddingBox, g.topRightBorderBox, g.topRightPaddingBox)
							case 1:
								return cs(g.topRightBorderBox, g.topRightPaddingBox, g.bottomRightBorderBox, g.bottomRightPaddingBox)
							case 2:
								return cs(g.bottomRightBorderBox, g.bottomRightPaddingBox, g.bottomLeftBorderBox, g.bottomLeftPaddingBox)
							default:
								return cs(g.bottomLeftBorderBox, g.bottomLeftPaddingBox, g.topLeftBorderBox, g.topLeftPaddingBox)
						}
					},
					iu = function (g, p) {
						var v = []
						return Zo(g) ? v.push(g.subdivide(0.5, !1)) : v.push(g), Zo(p) ? v.push(p.subdivide(0.5, !0)) : v.push(p), v
					},
					cs = function (g, p, v, b) {
						var E = []
						return (
							Zo(g) ? E.push(g.subdivide(0.5, !1)) : E.push(g),
							Zo(v) ? E.push(v.subdivide(0.5, !0)) : E.push(v),
							Zo(b) ? E.push(b.subdivide(0.5, !0).reverse()) : E.push(b),
							Zo(p) ? E.push(p.subdivide(0.5, !1).reverse()) : E.push(p),
							E
						)
					},
					m1 = function (g) {
						var v = g.styles
						return g.bounds.add(
							v.borderLeftWidth,
							v.borderTopWidth,
							-(v.borderRightWidth + v.borderLeftWidth),
							-(v.borderTopWidth + v.borderBottomWidth)
						)
					},
					L_ = function (g) {
						var p = g.styles,
							v = g.bounds,
							b = tr(p.paddingLeft, v.width),
							E = tr(p.paddingRight, v.width),
							k = tr(p.paddingTop, v.width),
							z = tr(p.paddingBottom, v.width)
						return v.add(
							b + p.borderLeftWidth,
							k + p.borderTopWidth,
							-(p.borderRightWidth + p.borderLeftWidth + b + E),
							-(p.borderTopWidth + p.borderBottomWidth + k + z)
						)
					},
					Es = function (g, p, v) {
						var b = (function (g, p) {
								return 0 === g ? p.bounds : 2 === g ? L_(p) : m1(p)
							})(ru(g.styles.backgroundOrigin, p), g),
							E = (function (g, p) {
								return 0 === g ? p.bounds : 2 === g ? L_(p) : m1(p)
							})(ru(g.styles.backgroundClip, p), g),
							k = IU(ru(g.styles.backgroundSize, p), v, b),
							z = k[0],
							te = k[1],
							ee = $d(ru(g.styles.backgroundPosition, p), b.width - z, b.height - te)
						return [
							bF(ru(g.styles.backgroundRepeat, p), ee, k, b, E),
							Math.round(b.left + ee[0]),
							Math.round(b.top + ee[1]),
							z,
							te
						]
					},
					Xl = function (g) {
						return qi(g) && g.value === ch.AUTO
					},
					tl = function (g) {
						return "number" == typeof g
					},
					IU = function (g, p, v) {
						var b = p[0],
							E = p[1],
							k = p[2],
							z = g[0],
							te = g[1]
						if (!z) return [0, 0]
						if (mo(z) && te && mo(te)) return [tr(z, v.width), tr(te, v.height)]
						var ee = tl(k)
						if (qi(z) && (z.value === ch.CONTAIN || z.value === ch.COVER))
							return tl(k)
								? v.width / v.height < k != (z.value === ch.COVER)
									? [v.width, v.width / k]
									: [v.height * k, v.height]
								: [v.width, v.height]
						var Fe = tl(b),
							Oe = tl(E),
							ot = Fe || Oe
						if (Xl(z) && (!te || Xl(te)))
							return Fe && Oe
								? [b, E]
								: ee || ot
								? ot && ee
									? [Fe ? b : E * k, Oe ? E : b / k]
									: [Fe ? b : v.width, Oe ? E : v.height]
								: [v.width, v.height]
						if (ee) {
							var bn = 0,
								dn = 0
							return (
								mo(z) ? (bn = tr(z, v.width)) : mo(te) && (dn = tr(te, v.height)),
								Xl(z) ? (bn = dn * k) : (!te || Xl(te)) && (dn = bn / k),
								[bn, dn]
							)
						}
						var Vi = null,
							gi = null
						if (
							(mo(z) ? (Vi = tr(z, v.width)) : te && mo(te) && (gi = tr(te, v.height)),
							null !== Vi && (!te || Xl(te)) && (gi = Fe && Oe ? (Vi / b) * E : v.height),
							null !== gi && Xl(z) && (Vi = Fe && Oe ? (gi / E) * b : v.width),
							null !== Vi && null !== gi)
						)
							return [Vi, gi]
						throw new Error("Unable to calculate background-size for element")
					},
					ru = function (g, p) {
						var v = g[p]
						return typeof v > "u" ? g[0] : v
					},
					bF = function (g, p, v, b, E) {
						var k = p[0],
							z = p[1],
							te = v[0],
							ee = v[1]
						switch (g) {
							case 2:
								return [
									new jt(Math.round(b.left), Math.round(b.top + z)),
									new jt(Math.round(b.left + b.width), Math.round(b.top + z)),
									new jt(Math.round(b.left + b.width), Math.round(ee + b.top + z)),
									new jt(Math.round(b.left), Math.round(ee + b.top + z))
								]
							case 3:
								return [
									new jt(Math.round(b.left + k), Math.round(b.top)),
									new jt(Math.round(b.left + k + te), Math.round(b.top)),
									new jt(Math.round(b.left + k + te), Math.round(b.height + b.top)),
									new jt(Math.round(b.left + k), Math.round(b.height + b.top))
								]
							case 1:
								return [
									new jt(Math.round(b.left + k), Math.round(b.top + z)),
									new jt(Math.round(b.left + k + te), Math.round(b.top + z)),
									new jt(Math.round(b.left + k + te), Math.round(b.top + z + ee)),
									new jt(Math.round(b.left + k), Math.round(b.top + z + ee))
								]
							default:
								return [
									new jt(Math.round(E.left), Math.round(E.top)),
									new jt(Math.round(E.left + E.width), Math.round(E.top)),
									new jt(Math.round(E.left + E.width), Math.round(E.height + E.top)),
									new jt(Math.round(E.left), Math.round(E.height + E.top))
								]
						}
					},
					p1 = "Hidden Text",
					vF = (function () {
						function g(p) {
							;(this._data = {}), (this._document = p)
						}
						return (
							(g.prototype.parseMetrics = function (p, v) {
								var b = this._document.createElement("div"),
									E = this._document.createElement("img"),
									k = this._document.createElement("span"),
									z = this._document.body
								;(b.style.visibility = "hidden"),
									(b.style.fontFamily = p),
									(b.style.fontSize = v),
									(b.style.margin = "0"),
									(b.style.padding = "0"),
									(b.style.whiteSpace = "nowrap"),
									z.appendChild(b),
									(E.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"),
									(E.width = 1),
									(E.height = 1),
									(E.style.margin = "0"),
									(E.style.padding = "0"),
									(E.style.verticalAlign = "baseline"),
									(k.style.fontFamily = p),
									(k.style.fontSize = v),
									(k.style.margin = "0"),
									(k.style.padding = "0"),
									k.appendChild(this._document.createTextNode(p1)),
									b.appendChild(k),
									b.appendChild(E)
								var te = E.offsetTop - k.offsetTop + 2
								b.removeChild(k),
									b.appendChild(this._document.createTextNode(p1)),
									(b.style.lineHeight = "normal"),
									(E.style.verticalAlign = "super")
								var ee = E.offsetTop - b.offsetTop + 2
								return z.removeChild(b), { baseline: te, middle: ee }
							}),
							(g.prototype.getMetrics = function (p, v) {
								var b = p + " " + v
								return typeof this._data[b] > "u" && (this._data[b] = this.parseMetrics(p, v)), this._data[b]
							}),
							g
						)
					})(),
					A1 = function g(p, v) {
						;(this.context = p), (this.options = v)
					},
					R_ = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							return (
								(E._activeEffects = []),
								(E.canvas = b.canvas ? b.canvas : document.createElement("canvas")),
								(E.ctx = E.canvas.getContext("2d")),
								b.canvas ||
									((E.canvas.width = Math.floor(b.width * b.scale)),
									(E.canvas.height = Math.floor(b.height * b.scale)),
									(E.canvas.style.width = b.width + "px"),
									(E.canvas.style.height = b.height + "px")),
								(E.fontMetrics = new vF(document)),
								E.ctx.scale(E.options.scale, E.options.scale),
								E.ctx.translate(-b.x, -b.y),
								(E.ctx.textBaseline = "bottom"),
								(E._activeEffects = []),
								E.context.logger.debug(
									"Canvas renderer initialized (" + b.width + "x" + b.height + ") with scale " + b.scale
								),
								E
							)
						}
						return (
							A(p, g),
							(p.prototype.applyEffects = function (v) {
								for (var b = this; this._activeEffects.length; ) this.popEffect()
								v.forEach(function (E) {
									return b.applyEffect(E)
								})
							}),
							(p.prototype.applyEffect = function (v) {
								this.ctx.save(),
									(function (g) {
										return 2 === g.type
									})(v) && (this.ctx.globalAlpha = v.opacity),
									(function (g) {
										return 0 === g.type
									})(v) &&
										(this.ctx.translate(v.offsetX, v.offsetY),
										this.ctx.transform(v.matrix[0], v.matrix[1], v.matrix[2], v.matrix[3], v.matrix[4], v.matrix[5]),
										this.ctx.translate(-v.offsetX, -v.offsetY)),
									pF(v) && (this.path(v.path), this.ctx.clip()),
									this._activeEffects.push(v)
							}),
							(p.prototype.popEffect = function () {
								this._activeEffects.pop(), this.ctx.restore()
							}),
							(p.prototype.renderStack = function (v) {
								return q(this, void 0, void 0, function () {
									return m(this, function (E) {
										switch (E.label) {
											case 0:
												return v.element.container.styles.isVisible() ? [4, this.renderStackContent(v)] : [3, 2]
											case 1:
												E.sent(), (E.label = 2)
											case 2:
												return [2]
										}
									})
								})
							}),
							(p.prototype.renderNode = function (v) {
								return q(this, void 0, void 0, function () {
									return m(this, function (b) {
										switch (b.label) {
											case 0:
												return (
													Ao(v.container.flags, 16),
													v.container.styles.isVisible() ? [4, this.renderNodeBackgroundAndBorders(v)] : [3, 3]
												)
											case 1:
												return b.sent(), [4, this.renderNodeContent(v)]
											case 2:
												b.sent(), (b.label = 3)
											case 3:
												return [2]
										}
									})
								})
							}),
							(p.prototype.renderTextWithLetterSpacing = function (v, b, E) {
								var k = this
								0 === b
									? this.ctx.fillText(v.text, v.bounds.left, v.bounds.top + E)
									: b_(v.text).reduce(function (te, ee) {
											return k.ctx.fillText(ee, te, v.bounds.top + E), te + k.ctx.measureText(ee).width
									  }, v.bounds.left)
							}),
							(p.prototype.createFontStyle = function (v) {
								var b = v.fontVariant
										.filter(function (z) {
											return "normal" === z || "small-caps" === z
										})
										.join(""),
									E = N_(v.fontFamily).join(", "),
									k = Kc(v.fontSize) ? "" + v.fontSize.number + v.fontSize.unit : v.fontSize.number + "px"
								return [[v.fontStyle, b, v.fontWeight, k, E].join(" "), E, k]
							}),
							(p.prototype.renderTextNode = function (v, b) {
								return q(this, void 0, void 0, function () {
									var E,
										z,
										te,
										ee,
										xe,
										Fe,
										Oe,
										ot = this
									return m(this, function (Yt) {
										return (
											(E = this.createFontStyle(b)),
											(z = E[1]),
											(te = E[2]),
											(this.ctx.font = E[0]),
											(this.ctx.direction = 1 === b.direction ? "rtl" : "ltr"),
											(this.ctx.textAlign = "left"),
											(this.ctx.textBaseline = "alphabetic"),
											(ee = this.fontMetrics.getMetrics(z, te)),
											(xe = ee.baseline),
											(Fe = ee.middle),
											(Oe = b.paintOrder),
											v.textBounds.forEach(function (Ft) {
												Oe.forEach(function (Pt) {
													switch (Pt) {
														case 0:
															;(ot.ctx.fillStyle = po(b.color)),
																ot.renderTextWithLetterSpacing(Ft, b.letterSpacing, xe)
															var fi = b.textShadow
															fi.length &&
																Ft.text.trim().length &&
																(fi
																	.slice(0)
																	.reverse()
																	.forEach(function (bn) {
																		;(ot.ctx.shadowColor = po(bn.color)),
																			(ot.ctx.shadowOffsetX = bn.offsetX.number * ot.options.scale),
																			(ot.ctx.shadowOffsetY = bn.offsetY.number * ot.options.scale),
																			(ot.ctx.shadowBlur = bn.blur.number),
																			ot.renderTextWithLetterSpacing(Ft, b.letterSpacing, xe)
																	}),
																(ot.ctx.shadowColor = ""),
																(ot.ctx.shadowOffsetX = 0),
																(ot.ctx.shadowOffsetY = 0),
																(ot.ctx.shadowBlur = 0)),
																b.textDecorationLine.length &&
																	((ot.ctx.fillStyle = po(b.textDecorationColor || b.color)),
																	b.textDecorationLine.forEach(function (bn) {
																		switch (bn) {
																			case 1:
																				ot.ctx.fillRect(
																					Ft.bounds.left,
																					Math.round(Ft.bounds.top + xe),
																					Ft.bounds.width,
																					1
																				)
																				break
																			case 2:
																				ot.ctx.fillRect(
																					Ft.bounds.left,
																					Math.round(Ft.bounds.top),
																					Ft.bounds.width,
																					1
																				)
																				break
																			case 3:
																				ot.ctx.fillRect(
																					Ft.bounds.left,
																					Math.ceil(Ft.bounds.top + Fe),
																					Ft.bounds.width,
																					1
																				)
																		}
																	}))
															break
														case 1:
															b.webkitTextStrokeWidth &&
																Ft.text.trim().length &&
																((ot.ctx.strokeStyle = po(b.webkitTextStrokeColor)),
																(ot.ctx.lineWidth = b.webkitTextStrokeWidth),
																(ot.ctx.lineJoin = window.chrome ? "miter" : "round"),
																ot.ctx.strokeText(Ft.text, Ft.bounds.left, Ft.bounds.top + xe)),
																(ot.ctx.strokeStyle = ""),
																(ot.ctx.lineWidth = 0),
																(ot.ctx.lineJoin = "miter")
													}
												})
											}),
											[2]
										)
									})
								})
							}),
							(p.prototype.renderReplacedElement = function (v, b, E) {
								if (E && v.intrinsicWidth > 0 && v.intrinsicHeight > 0) {
									var k = L_(v),
										z = I_(b)
									this.path(z),
										this.ctx.save(),
										this.ctx.clip(),
										this.ctx.drawImage(E, 0, 0, v.intrinsicWidth, v.intrinsicHeight, k.left, k.top, k.width, k.height),
										this.ctx.restore()
								}
							}),
							(p.prototype.renderNodeContent = function (v) {
								return q(this, void 0, void 0, function () {
									var b, E, k, z, te, Fe, Oe, ot, Ft, Pt, fi, bn, dn, Vi, gi, Yn
									return m(this, function (zt) {
										switch (zt.label) {
											case 0:
												this.applyEffects(v.getEffects(4)),
													(E = v.curves),
													(k = (b = v.container).styles),
													(z = 0),
													(te = b.textNodes),
													(zt.label = 1)
											case 1:
												return z < te.length ? [4, this.renderTextNode(te[z], k)] : [3, 4]
											case 2:
												zt.sent(), (zt.label = 3)
											case 3:
												return z++, [3, 1]
											case 4:
												if (!(b instanceof sA)) return [3, 8]
												zt.label = 5
											case 5:
												return zt.trys.push([5, 7, , 8]), [4, this.context.cache.match(b.src)]
											case 6:
												return (dn = zt.sent()), this.renderReplacedElement(b, E, dn), [3, 8]
											case 7:
												return zt.sent(), this.context.logger.error("Error loading image " + b.src), [3, 8]
											case 8:
												if ((b instanceof aA && this.renderReplacedElement(b, E, b.canvas), !(b instanceof Kx)))
													return [3, 12]
												zt.label = 9
											case 9:
												return zt.trys.push([9, 11, , 12]), [4, this.context.cache.match(b.svg)]
											case 10:
												return (dn = zt.sent()), this.renderReplacedElement(b, E, dn), [3, 12]
											case 11:
												return (
													zt.sent(),
													this.context.logger.error("Error loading svg " + b.svg.substring(0, 255)),
													[3, 12]
												)
											case 12:
												return b instanceof v_ && b.tree
													? [
															4,
															new p(this.context, {
																scale: this.options.scale,
																backgroundColor: b.backgroundColor,
																x: 0,
																y: 0,
																width: b.width,
																height: b.height
															}).render(b.tree)
													  ]
													: [3, 14]
											case 13:
												;(Fe = zt.sent()),
													b.width &&
														b.height &&
														this.ctx.drawImage(
															Fe,
															0,
															0,
															b.width,
															b.height,
															b.bounds.left,
															b.bounds.top,
															b.bounds.width,
															b.bounds.height
														),
													(zt.label = 14)
											case 14:
												if (
													(b instanceof __ &&
														((Oe = Math.min(b.bounds.width, b.bounds.height)),
														b.type === Ea
															? b.checked &&
															  (this.ctx.save(),
															  this.path([
																	new jt(b.bounds.left + 0.39363 * Oe, b.bounds.top + 0.79 * Oe),
																	new jt(b.bounds.left + 0.16 * Oe, b.bounds.top + 0.5549 * Oe),
																	new jt(b.bounds.left + 0.27347 * Oe, b.bounds.top + 0.44071 * Oe),
																	new jt(b.bounds.left + 0.39694 * Oe, b.bounds.top + 0.5649 * Oe),
																	new jt(b.bounds.left + 0.72983 * Oe, b.bounds.top + 0.23 * Oe),
																	new jt(b.bounds.left + 0.84 * Oe, b.bounds.top + 0.34085 * Oe),
																	new jt(b.bounds.left + 0.39363 * Oe, b.bounds.top + 0.79 * Oe)
															  ]),
															  (this.ctx.fillStyle = po(qx)),
															  this.ctx.fill(),
															  this.ctx.restore())
															: b.type === lA &&
															  b.checked &&
															  (this.ctx.save(),
															  this.ctx.beginPath(),
															  this.ctx.arc(
																	b.bounds.left + Oe / 2,
																	b.bounds.top + Oe / 2,
																	Oe / 4,
																	0,
																	2 * Math.PI,
																	!0
															  ),
															  (this.ctx.fillStyle = po(qx)),
															  this.ctx.fill(),
															  this.ctx.restore())),
													CA(b) && b.value.length)
												) {
													switch (
														((ot = this.createFontStyle(k)),
														(Ft = this.fontMetrics.getMetrics((gi = ot[0]), ot[1]).baseline),
														(this.ctx.font = gi),
														(this.ctx.fillStyle = po(k.color)),
														(this.ctx.textBaseline = "alphabetic"),
														(this.ctx.textAlign = O_(b.styles.textAlign)),
														(Yn = L_(b)),
														(Pt = 0),
														b.styles.textAlign)
													) {
														case 1:
															Pt += Yn.width / 2
															break
														case 2:
															Pt += Yn.width
													}
													;(fi = Yn.add(Pt, 0, 0, -Yn.height / 2 + 1)),
														this.ctx.save(),
														this.path([
															new jt(Yn.left, Yn.top),
															new jt(Yn.left + Yn.width, Yn.top),
															new jt(Yn.left + Yn.width, Yn.top + Yn.height),
															new jt(Yn.left, Yn.top + Yn.height)
														]),
														this.ctx.clip(),
														this.renderTextWithLetterSpacing(new em(b.value, fi), k.letterSpacing, Ft),
														this.ctx.restore(),
														(this.ctx.textBaseline = "alphabetic"),
														(this.ctx.textAlign = "left")
												}
												if (!Ao(b.styles.display, 2048)) return [3, 20]
												if (null === b.styles.listStyleImage) return [3, 19]
												if (0 !== (bn = b.styles.listStyleImage).type) return [3, 18]
												;(dn = void 0), (Vi = bn.url), (zt.label = 15)
											case 15:
												return zt.trys.push([15, 17, , 18]), [4, this.context.cache.match(Vi)]
											case 16:
												return (
													(dn = zt.sent()),
													this.ctx.drawImage(dn, b.bounds.left - (dn.width + 10), b.bounds.top),
													[3, 18]
												)
											case 17:
												return zt.sent(), this.context.logger.error("Error loading list-style-image " + Vi), [3, 18]
											case 18:
												return [3, 20]
											case 19:
												v.listValue &&
													-1 !== b.styles.listStyleType &&
													((gi = this.createFontStyle(k)[0]),
													(this.ctx.font = gi),
													(this.ctx.fillStyle = po(k.color)),
													(this.ctx.textBaseline = "middle"),
													(this.ctx.textAlign = "right"),
													(Yn = new Q(
														b.bounds.left,
														b.bounds.top + tr(b.styles.paddingTop, b.bounds.width),
														b.bounds.width,
														qp(k.lineHeight, k.fontSize.number) / 2 + 1
													)),
													this.renderTextWithLetterSpacing(
														new em(v.listValue, Yn),
														k.letterSpacing,
														qp(k.lineHeight, k.fontSize.number) / 2 + 2
													),
													(this.ctx.textBaseline = "bottom"),
													(this.ctx.textAlign = "left")),
													(zt.label = 20)
											case 20:
												return [2]
										}
									})
								})
							}),
							(p.prototype.renderStackContent = function (v) {
								return q(this, void 0, void 0, function () {
									var b, E, k, z, te, ee, xe, Fe, Oe, ot, Yt, Ft, Pt, fi
									return m(this, function (dn) {
										switch (dn.label) {
											case 0:
												return (
													Ao(v.element.container.flags, 16), [4, this.renderNodeBackgroundAndBorders(v.element)]
												)
											case 1:
												dn.sent(), (b = 0), (E = v.negativeZIndex), (dn.label = 2)
											case 2:
												return b < E.length ? [4, this.renderStack(E[b])] : [3, 5]
											case 3:
												dn.sent(), (dn.label = 4)
											case 4:
												return b++, [3, 2]
											case 5:
												return [4, this.renderNodeContent(v.element)]
											case 6:
												dn.sent(), (k = 0), (z = v.nonInlineLevel), (dn.label = 7)
											case 7:
												return k < z.length ? [4, this.renderNode(z[k])] : [3, 10]
											case 8:
												dn.sent(), (dn.label = 9)
											case 9:
												return k++, [3, 7]
											case 10:
												;(te = 0), (ee = v.nonPositionedFloats), (dn.label = 11)
											case 11:
												return te < ee.length ? [4, this.renderStack(ee[te])] : [3, 14]
											case 12:
												dn.sent(), (dn.label = 13)
											case 13:
												return te++, [3, 11]
											case 14:
												;(xe = 0), (Fe = v.nonPositionedInlineLevel), (dn.label = 15)
											case 15:
												return xe < Fe.length ? [4, this.renderStack(Fe[xe])] : [3, 18]
											case 16:
												dn.sent(), (dn.label = 17)
											case 17:
												return xe++, [3, 15]
											case 18:
												;(Oe = 0), (ot = v.inlineLevel), (dn.label = 19)
											case 19:
												return Oe < ot.length ? [4, this.renderNode(ot[Oe])] : [3, 22]
											case 20:
												dn.sent(), (dn.label = 21)
											case 21:
												return Oe++, [3, 19]
											case 22:
												;(Yt = 0), (Ft = v.zeroOrAutoZIndexOrTransformedOrOpacity), (dn.label = 23)
											case 23:
												return Yt < Ft.length ? [4, this.renderStack(Ft[Yt])] : [3, 26]
											case 24:
												dn.sent(), (dn.label = 25)
											case 25:
												return Yt++, [3, 23]
											case 26:
												;(Pt = 0), (fi = v.positiveZIndex), (dn.label = 27)
											case 27:
												return Pt < fi.length ? [4, this.renderStack(fi[Pt])] : [3, 30]
											case 28:
												dn.sent(), (dn.label = 29)
											case 29:
												return Pt++, [3, 27]
											case 30:
												return [2]
										}
									})
								})
							}),
							(p.prototype.mask = function (v) {
								this.ctx.beginPath(),
									this.ctx.moveTo(0, 0),
									this.ctx.lineTo(this.canvas.width, 0),
									this.ctx.lineTo(this.canvas.width, this.canvas.height),
									this.ctx.lineTo(0, this.canvas.height),
									this.ctx.lineTo(0, 0),
									this.formatPath(v.slice(0).reverse()),
									this.ctx.closePath()
							}),
							(p.prototype.path = function (v) {
								this.ctx.beginPath(), this.formatPath(v), this.ctx.closePath()
							}),
							(p.prototype.formatPath = function (v) {
								var b = this
								v.forEach(function (E, k) {
									var z = Zo(E) ? E.start : E
									0 === k ? b.ctx.moveTo(z.x, z.y) : b.ctx.lineTo(z.x, z.y),
										Zo(E) &&
											b.ctx.bezierCurveTo(
												E.startControl.x,
												E.startControl.y,
												E.endControl.x,
												E.endControl.y,
												E.end.x,
												E.end.y
											)
								})
							}),
							(p.prototype.renderRepeat = function (v, b, E, k) {
								this.path(v),
									(this.ctx.fillStyle = b),
									this.ctx.translate(E, k),
									this.ctx.fill(),
									this.ctx.translate(-E, -k)
							}),
							(p.prototype.resizeImage = function (v, b, E) {
								var k
								if (v.width === b && v.height === E) return v
								var te = (null !== (k = this.canvas.ownerDocument) && void 0 !== k ? k : document).createElement("canvas")
								return (
									(te.width = Math.max(1, b)),
									(te.height = Math.max(1, E)),
									te.getContext("2d").drawImage(v, 0, 0, v.width, v.height, 0, 0, b, E),
									te
								)
							}),
							(p.prototype.renderBackgroundImage = function (v) {
								return q(this, void 0, void 0, function () {
									var b, E, k, z, te
									return m(this, function (xe) {
										switch (xe.label) {
											case 0:
												;(b = v.styles.backgroundImage.length - 1),
													(E = function (Fe) {
														var Oe,
															ot,
															Yt,
															Ft,
															Pt,
															fi,
															bn,
															dn,
															Vi,
															gi,
															Yn,
															zt,
															Gi,
															$i,
															ti,
															Fo,
															ta,
															na,
															Ji,
															bo,
															nl,
															Ms,
															Ss,
															ka,
															Ya,
															il,
															Fc,
															Bc,
															ls,
															ou,
															rl
														return m(this, function (xh) {
															switch (xh.label) {
																case 0:
																	if (0 !== Fe.type) return [3, 5]
																	;(Oe = void 0), (ot = Fe.url), (xh.label = 1)
																case 1:
																	return xh.trys.push([1, 3, , 4]), [4, k.context.cache.match(ot)]
																case 2:
																	return (Oe = xh.sent()), [3, 4]
																case 3:
																	return (
																		xh.sent(),
																		k.context.logger.error("Error loading background-image " + ot),
																		[3, 4]
																	)
																case 4:
																	return (
																		Oe &&
																			((Yt = Es(v, b, [Oe.width, Oe.height, Oe.width / Oe.height])),
																			(Fo = Yt[0]),
																			(Ms = Yt[1]),
																			(Ss = Yt[2]),
																			($i = k.ctx.createPattern(
																				k.resizeImage(Oe, (Ji = Yt[3]), (bo = Yt[4])),
																				"repeat"
																			)),
																			k.renderRepeat(Fo, $i, Ms, Ss)),
																		[3, 6]
																	)
																case 5:
																	!(function (g) {
																		return 1 === g.type
																	})(Fe)
																		? (function (g) {
																				return 2 === g.type
																		  })(Fe) &&
																		  ((ti = Es(v, b, [null, null, null])),
																		  (Fo = ti[0]),
																		  (ta = ti[1]),
																		  (na = ti[2]),
																		  (bo = ti[4]),
																		  (Ms = tr(
																				(nl = 0 === Fe.position.length ? [Rt] : Fe.position)[0],
																				(Ji = ti[3])
																		  )),
																		  (Ss = tr(nl[nl.length - 1], bo)),
																		  (ka = (function (g, p, v, b, E) {
																				var k = 0,
																					z = 0
																				switch (g.size) {
																					case 0:
																						0 === g.shape
																							? (k = z =
																									Math.min(
																										Math.abs(p),
																										Math.abs(p - b),
																										Math.abs(v),
																										Math.abs(v - E)
																									))
																							: 1 === g.shape &&
																							  ((k = Math.min(Math.abs(p), Math.abs(p - b))),
																							  (z = Math.min(Math.abs(v), Math.abs(v - E))))
																						break
																					case 2:
																						if (0 === g.shape)
																							k = z = Math.min(
																								Ga(p, v),
																								Ga(p, v - E),
																								Ga(p - b, v),
																								Ga(p - b, v - E)
																							)
																						else if (1 === g.shape) {
																							var te =
																									Math.min(Math.abs(v), Math.abs(v - E)) /
																									Math.min(Math.abs(p), Math.abs(p - b)),
																								ee = wa(b, E, p, v, !0)
																							z = te * (k = Ga(ee[0] - p, (ee[1] - v) / te))
																						}
																						break
																					case 1:
																						0 === g.shape
																							? (k = z =
																									Math.max(
																										Math.abs(p),
																										Math.abs(p - b),
																										Math.abs(v),
																										Math.abs(v - E)
																									))
																							: 1 === g.shape &&
																							  ((k = Math.max(Math.abs(p), Math.abs(p - b))),
																							  (z = Math.max(Math.abs(v), Math.abs(v - E))))
																						break
																					case 3:
																						if (0 === g.shape)
																							k = z = Math.max(
																								Ga(p, v),
																								Ga(p, v - E),
																								Ga(p - b, v),
																								Ga(p - b, v - E)
																							)
																						else if (1 === g.shape) {
																							te =
																								Math.max(Math.abs(v), Math.abs(v - E)) /
																								Math.max(Math.abs(p), Math.abs(p - b))
																							var Oe = wa(b, E, p, v, !1)
																							z = te * (k = Ga(Oe[0] - p, (Oe[1] - v) / te))
																						}
																				}
																				return (
																					Array.isArray(g.size) &&
																						((k = tr(g.size[0], b)),
																						(z = 2 === g.size.length ? tr(g.size[1], E) : k)),
																					[k, z]
																				)
																		  })(Fe, Ms, Ss, Ji, bo)),
																		  (il = ka[1]),
																		  (Ya = ka[0]) > 0 &&
																				il > 0 &&
																				((Fc = k.ctx.createRadialGradient(
																					ta + Ms,
																					na + Ss,
																					0,
																					ta + Ms,
																					na + Ss,
																					Ya
																				)),
																				ux(Fe.stops, 2 * Ya).forEach(function (Ch) {
																					return Fc.addColorStop(Ch.stop, po(Ch.color))
																				}),
																				k.path(Fo),
																				(k.ctx.fillStyle = Fc),
																				Ya !== il
																					? ((Bc = v.bounds.left + 0.5 * v.bounds.width),
																					  (ls = v.bounds.top + 0.5 * v.bounds.height),
																					  (rl = 1 / (ou = il / Ya)),
																					  k.ctx.save(),
																					  k.ctx.translate(Bc, ls),
																					  k.ctx.transform(1, 0, 0, ou, 0, 0),
																					  k.ctx.translate(-Bc, -ls),
																					  k.ctx.fillRect(ta, rl * (na - ls) + ls, Ji, bo * rl),
																					  k.ctx.restore())
																					: k.ctx.fill()))
																		: ((Ft = Es(v, b, [null, null, null])),
																		  (Fo = Ft[0]),
																		  (Ms = Ft[1]),
																		  (Ss = Ft[2]),
																		  (Pt = MT(Fe.angle, (Ji = Ft[3]), (bo = Ft[4]))),
																		  (fi = Pt[0]),
																		  (bn = Pt[1]),
																		  (dn = Pt[2]),
																		  (Vi = Pt[3]),
																		  (gi = Pt[4]),
																		  ((Yn = document.createElement("canvas")).width = Ji),
																		  (Yn.height = bo),
																		  (zt = Yn.getContext("2d")),
																		  (Gi = zt.createLinearGradient(bn, Vi, dn, gi)),
																		  ux(Fe.stops, fi).forEach(function (Ch) {
																				return Gi.addColorStop(Ch.stop, po(Ch.color))
																		  }),
																		  (zt.fillStyle = Gi),
																		  zt.fillRect(0, 0, Ji, bo),
																		  Ji > 0 &&
																				bo > 0 &&
																				(($i = k.ctx.createPattern(Yn, "repeat")),
																				k.renderRepeat(Fo, $i, Ms, Ss))),
																		(xh.label = 6)
																case 6:
																	return b--, [2]
															}
														})
													}),
													(k = this),
													(z = 0),
													(te = v.styles.backgroundImage.slice(0).reverse()),
													(xe.label = 1)
											case 1:
												return z < te.length ? [5, E(te[z])] : [3, 4]
											case 2:
												xe.sent(), (xe.label = 3)
											case 3:
												return z++, [3, 1]
											case 4:
												return [2]
										}
									})
								})
							}),
							(p.prototype.renderSolidBorder = function (v, b, E) {
								return q(this, void 0, void 0, function () {
									return m(this, function (k) {
										return this.path(h1(E, b)), (this.ctx.fillStyle = po(v)), this.ctx.fill(), [2]
									})
								})
							}),
							(p.prototype.renderDoubleBorder = function (v, b, E, k) {
								return q(this, void 0, void 0, function () {
									var z, te
									return m(this, function (ee) {
										switch (ee.label) {
											case 0:
												return b < 3 ? [4, this.renderSolidBorder(v, E, k)] : [3, 2]
											case 1:
												return ee.sent(), [2]
											case 2:
												return (
													(z = (function (g, p) {
														switch (p) {
															case 0:
																return cs(
																	g.topLeftBorderBox,
																	g.topLeftBorderDoubleOuterBox,
																	g.topRightBorderBox,
																	g.topRightBorderDoubleOuterBox
																)
															case 1:
																return cs(
																	g.topRightBorderBox,
																	g.topRightBorderDoubleOuterBox,
																	g.bottomRightBorderBox,
																	g.bottomRightBorderDoubleOuterBox
																)
															case 2:
																return cs(
																	g.bottomRightBorderBox,
																	g.bottomRightBorderDoubleOuterBox,
																	g.bottomLeftBorderBox,
																	g.bottomLeftBorderDoubleOuterBox
																)
															default:
																return cs(
																	g.bottomLeftBorderBox,
																	g.bottomLeftBorderDoubleOuterBox,
																	g.topLeftBorderBox,
																	g.topLeftBorderDoubleOuterBox
																)
														}
													})(k, E)),
													this.path(z),
													(this.ctx.fillStyle = po(v)),
													this.ctx.fill(),
													(te = (function (g, p) {
														switch (p) {
															case 0:
																return cs(
																	g.topLeftBorderDoubleInnerBox,
																	g.topLeftPaddingBox,
																	g.topRightBorderDoubleInnerBox,
																	g.topRightPaddingBox
																)
															case 1:
																return cs(
																	g.topRightBorderDoubleInnerBox,
																	g.topRightPaddingBox,
																	g.bottomRightBorderDoubleInnerBox,
																	g.bottomRightPaddingBox
																)
															case 2:
																return cs(
																	g.bottomRightBorderDoubleInnerBox,
																	g.bottomRightPaddingBox,
																	g.bottomLeftBorderDoubleInnerBox,
																	g.bottomLeftPaddingBox
																)
															default:
																return cs(
																	g.bottomLeftBorderDoubleInnerBox,
																	g.bottomLeftPaddingBox,
																	g.topLeftBorderDoubleInnerBox,
																	g.topLeftPaddingBox
																)
														}
													})(k, E)),
													this.path(te),
													this.ctx.fill(),
													[2]
												)
										}
									})
								})
							}),
							(p.prototype.renderNodeBackgroundAndBorders = function (v) {
								return q(this, void 0, void 0, function () {
									var b,
										E,
										k,
										z,
										te,
										ee,
										xe,
										Fe,
										Oe = this
									return m(this, function (ot) {
										switch (ot.label) {
											case 0:
												return (
													this.applyEffects(v.getEffects(2)),
													(E = !vc((b = v.container.styles).backgroundColor) || b.backgroundImage.length),
													(k = [
														{ style: b.borderTopStyle, color: b.borderTopColor, width: b.borderTopWidth },
														{ style: b.borderRightStyle, color: b.borderRightColor, width: b.borderRightWidth },
														{
															style: b.borderBottomStyle,
															color: b.borderBottomColor,
															width: b.borderBottomWidth
														},
														{ style: b.borderLeftStyle, color: b.borderLeftColor, width: b.borderLeftWidth }
													]),
													(z = P_(ru(b.backgroundClip, 0), v.curves)),
													E || b.boxShadow.length
														? (this.ctx.save(),
														  this.path(z),
														  this.ctx.clip(),
														  vc(b.backgroundColor) ||
																((this.ctx.fillStyle = po(b.backgroundColor)), this.ctx.fill()),
														  [4, this.renderBackgroundImage(v.container)])
														: [3, 2]
												)
											case 1:
												ot.sent(),
													this.ctx.restore(),
													b.boxShadow
														.slice(0)
														.reverse()
														.forEach(function (Yt) {
															Oe.ctx.save()
															var Ft = _h(v.curves),
																Pt = Yt.inset ? 0 : 1e4,
																fi = (function (g, p, v, b, E) {
																	return g.map(function (k, z) {
																		switch (z) {
																			case 0:
																				return k.add(p, v)
																			case 1:
																				return k.add(p + b, v)
																			case 2:
																				return k.add(p + b, v + E)
																			case 3:
																				return k.add(p, v + E)
																		}
																		return k
																	})
																})(
																	Ft,
																	(Yt.inset ? 1 : -1) * Yt.spread.number - Pt,
																	(Yt.inset ? 1 : -1) * Yt.spread.number,
																	Yt.spread.number * (Yt.inset ? -2 : 2),
																	Yt.spread.number * (Yt.inset ? -2 : 2)
																)
															Yt.inset
																? (Oe.path(Ft), Oe.ctx.clip(), Oe.mask(fi))
																: (Oe.mask(Ft), Oe.ctx.clip(), Oe.path(fi)),
																(Oe.ctx.shadowOffsetX = Yt.offsetX.number + Pt),
																(Oe.ctx.shadowOffsetY = Yt.offsetY.number),
																(Oe.ctx.shadowColor = po(Yt.color)),
																(Oe.ctx.shadowBlur = Yt.blur.number),
																(Oe.ctx.fillStyle = Yt.inset ? po(Yt.color) : "rgba(0,0,0,1)"),
																Oe.ctx.fill(),
																Oe.ctx.restore()
														}),
													(ot.label = 2)
											case 2:
												;(te = 0), (ee = 0), (xe = k), (ot.label = 3)
											case 3:
												return ee < xe.length
													? 0 !== (Fe = xe[ee]).style && !vc(Fe.color) && Fe.width > 0
														? 2 !== Fe.style
															? [3, 5]
															: [4, this.renderDashedDottedBorder(Fe.color, Fe.width, te, v.curves, 2)]
														: [3, 11]
													: [3, 13]
											case 4:
												return ot.sent(), [3, 11]
											case 5:
												return 3 !== Fe.style
													? [3, 7]
													: [4, this.renderDashedDottedBorder(Fe.color, Fe.width, te, v.curves, 3)]
											case 6:
												return ot.sent(), [3, 11]
											case 7:
												return 4 !== Fe.style
													? [3, 9]
													: [4, this.renderDoubleBorder(Fe.color, Fe.width, te, v.curves)]
											case 8:
												return ot.sent(), [3, 11]
											case 9:
												return [4, this.renderSolidBorder(Fe.color, te, v.curves)]
											case 10:
												ot.sent(), (ot.label = 11)
											case 11:
												te++, (ot.label = 12)
											case 12:
												return ee++, [3, 3]
											case 13:
												return [2]
										}
									})
								})
							}),
							(p.prototype.renderDashedDottedBorder = function (v, b, E, k, z) {
								return q(this, void 0, void 0, function () {
									var te, ee, xe, Fe, Oe, ot, Yt, Ft, Pt, fi, bn, dn, Vi, gi, Yn, zt
									return m(this, function (Gi) {
										return (
											this.ctx.save(),
											(te = (function (g, p) {
												switch (p) {
													case 0:
														return iu(g.topLeftBorderStroke, g.topRightBorderStroke)
													case 1:
														return iu(g.topRightBorderStroke, g.bottomRightBorderStroke)
													case 2:
														return iu(g.bottomRightBorderStroke, g.bottomLeftBorderStroke)
													default:
														return iu(g.bottomLeftBorderStroke, g.topLeftBorderStroke)
												}
											})(k, E)),
											(ee = h1(k, E)),
											2 === z && (this.path(ee), this.ctx.clip()),
											Zo(ee[0]) ? ((xe = ee[0].start.x), (Fe = ee[0].start.y)) : ((xe = ee[0].x), (Fe = ee[0].y)),
											Zo(ee[1]) ? ((Oe = ee[1].end.x), (ot = ee[1].end.y)) : ((Oe = ee[1].x), (ot = ee[1].y)),
											(Yt = 0 === E || 2 === E ? Math.abs(xe - Oe) : Math.abs(Fe - ot)),
											this.ctx.beginPath(),
											this.formatPath(3 === z ? te : ee.slice(0, 2)),
											(Ft = b < 3 ? 3 * b : 2 * b),
											(Pt = b < 3 ? 2 * b : b),
											3 === z && ((Ft = b), (Pt = b)),
											(fi = !0),
											Yt <= 2 * Ft
												? (fi = !1)
												: Yt <= 2 * Ft + Pt
												? ((Ft *= bn = Yt / (2 * Ft + Pt)), (Pt *= bn))
												: ((dn = Math.floor((Yt + Pt) / (Ft + Pt))),
												  (Vi = (Yt - dn * Ft) / (dn - 1)),
												  (Pt =
														(gi = (Yt - (dn + 1) * Ft) / dn) <= 0 || Math.abs(Pt - Vi) < Math.abs(Pt - gi)
															? Vi
															: gi)),
											fi && this.ctx.setLineDash(3 === z ? [0, Ft + Pt] : [Ft, Pt]),
											3 === z
												? ((this.ctx.lineCap = "round"), (this.ctx.lineWidth = b))
												: (this.ctx.lineWidth = 2 * b + 1.1),
											(this.ctx.strokeStyle = po(v)),
											this.ctx.stroke(),
											this.ctx.setLineDash([]),
											2 === z &&
												(Zo(ee[0]) &&
													((Yn = ee[3]),
													(zt = ee[0]),
													this.ctx.beginPath(),
													this.formatPath([new jt(Yn.end.x, Yn.end.y), new jt(zt.start.x, zt.start.y)]),
													this.ctx.stroke()),
												Zo(ee[1]) &&
													((Yn = ee[1]),
													(zt = ee[2]),
													this.ctx.beginPath(),
													this.formatPath([new jt(Yn.end.x, Yn.end.y), new jt(zt.start.x, zt.start.y)]),
													this.ctx.stroke())),
											this.ctx.restore(),
											[2]
										)
									})
								})
							}),
							(p.prototype.render = function (v) {
								return q(this, void 0, void 0, function () {
									var b
									return m(this, function (E) {
										switch (E.label) {
											case 0:
												return (
													this.options.backgroundColor &&
														((this.ctx.fillStyle = po(this.options.backgroundColor)),
														this.ctx.fillRect(
															this.options.x,
															this.options.y,
															this.options.width,
															this.options.height
														)),
													(b = (function (g) {
														var p = new d1(g, null),
															v = new l1(p),
															b = []
														return ao(p, v, v, b), u1(p.container, b), v
													})(v)),
													[4, this.renderStack(b)]
												)
											case 1:
												return E.sent(), this.applyEffects([]), [2, this.canvas]
										}
									})
								})
							}),
							p
						)
					})(A1),
					CA = function (g) {
						return g instanceof uA || g instanceof dA || (g instanceof __ && g.type !== lA && g.type !== Ea)
					},
					P_ = function (g, p) {
						switch (g) {
							case 0:
								return _h(p)
							case 2:
								return (function (g) {
									return [g.topLeftContentBox, g.topRightContentBox, g.bottomRightContentBox, g.bottomLeftContentBox]
								})(p)
							default:
								return I_(p)
						}
					},
					O_ = function (g) {
						switch (g) {
							case 1:
								return "center"
							case 2:
								return "right"
							default:
								return "left"
						}
					},
					wF = ["-apple-system", "system-ui"],
					N_ = function (g) {
						return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)
							? g.filter(function (p) {
									return -1 === wF.indexOf(p)
							  })
							: g
					},
					xF = (function (g) {
						function p(v, b) {
							var E = g.call(this, v, b) || this
							return (
								(E.canvas = b.canvas ? b.canvas : document.createElement("canvas")),
								(E.ctx = E.canvas.getContext("2d")),
								(E.options = b),
								(E.canvas.width = Math.floor(b.width * b.scale)),
								(E.canvas.height = Math.floor(b.height * b.scale)),
								(E.canvas.style.width = b.width + "px"),
								(E.canvas.style.height = b.height + "px"),
								E.ctx.scale(E.options.scale, E.options.scale),
								E.ctx.translate(-b.x, -b.y),
								E.context.logger.debug(
									"EXPERIMENTAL ForeignObject renderer initialized (" +
										b.width +
										"x" +
										b.height +
										" at " +
										b.x +
										"," +
										b.y +
										") with scale " +
										b.scale
								),
								E
							)
						}
						return (
							A(p, g),
							(p.prototype.render = function (v) {
								return q(this, void 0, void 0, function () {
									var b, E
									return m(this, function (k) {
										switch (k.label) {
											case 0:
												return (
													(b = A_(
														this.options.width * this.options.scale,
														this.options.height * this.options.scale,
														this.options.scale,
														this.options.scale,
														v
													)),
													[4, g1(b)]
												)
											case 1:
												return (
													(E = k.sent()),
													this.options.backgroundColor &&
														((this.ctx.fillStyle = po(this.options.backgroundColor)),
														this.ctx.fillRect(
															0,
															0,
															this.options.width * this.options.scale,
															this.options.height * this.options.scale
														)),
													this.ctx.drawImage(
														E,
														-this.options.x * this.options.scale,
														-this.options.y * this.options.scale
													),
													[2, this.canvas]
												)
										}
									})
								})
							}),
							p
						)
					})(A1),
					g1 = function (g) {
						return new Promise(function (p, v) {
							var b = new Image()
							;(b.onload = function () {
								p(b)
							}),
								(b.onerror = v),
								(b.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(g)))
						})
					},
					U_ = (function () {
						function g(p) {
							var b = p.enabled
							;(this.id = p.id), (this.enabled = b), (this.start = Date.now())
						}
						return (
							(g.prototype.debug = function () {
								for (var p = [], v = 0; v < arguments.length; v++) p[v] = arguments[v]
								this.enabled &&
									(typeof window < "u" && window.console && "function" == typeof console.debug
										? console.debug.apply(console, de([this.id, this.getTime() + "ms"], p))
										: this.info.apply(this, p))
							}),
							(g.prototype.getTime = function () {
								return Date.now() - this.start
							}),
							(g.prototype.info = function () {
								for (var p = [], v = 0; v < arguments.length; v++) p[v] = arguments[v]
								this.enabled &&
									typeof window < "u" &&
									window.console &&
									"function" == typeof console.info &&
									console.info.apply(console, de([this.id, this.getTime() + "ms"], p))
							}),
							(g.prototype.warn = function () {
								for (var p = [], v = 0; v < arguments.length; v++) p[v] = arguments[v]
								this.enabled &&
									(typeof window < "u" && window.console && "function" == typeof console.warn
										? console.warn.apply(console, de([this.id, this.getTime() + "ms"], p))
										: this.info.apply(this, p))
							}),
							(g.prototype.error = function () {
								for (var p = [], v = 0; v < arguments.length; v++) p[v] = arguments[v]
								this.enabled &&
									(typeof window < "u" && window.console && "function" == typeof console.error
										? console.error.apply(console, de([this.id, this.getTime() + "ms"], p))
										: this.info.apply(this, p))
							}),
							(g.instances = {}),
							g
						)
					})(),
					EA = (function () {
						function g(p, v) {
							var b
							;(this.windowBounds = v),
								(this.instanceName = "#" + g.instanceCount++),
								(this.logger = new U_({ id: this.instanceName, enabled: p.logging })),
								(this.cache = null !== (b = p.cache) && void 0 !== b ? b : new uF(this, p))
						}
						return (g.instanceCount = 1), g
					})()
				typeof window < "u" && Kl.setContext(window)
				var CF = function (g, p) {
						return q(void 0, void 0, void 0, function () {
							var v,
								b,
								E,
								k,
								z,
								te,
								ee,
								xe,
								Fe,
								Oe,
								ot,
								Yt,
								Ft,
								Pt,
								fi,
								bn,
								dn,
								Vi,
								gi,
								Yn,
								zt,
								$i,
								ti,
								Fo,
								ta,
								na,
								Ji,
								bo,
								nl,
								Ms,
								Ss,
								ka,
								Ya,
								il,
								Fc,
								Bc,
								ls,
								ou
							return m(this, function (rl) {
								switch (rl.label) {
									case 0:
										if (!g || "object" != typeof g)
											return [2, Promise.reject("Invalid element provided as first argument")]
										if (!(v = g.ownerDocument)) throw new Error("Element is not attached to a Document")
										if (!(b = v.defaultView)) throw new Error("Document is not attached to a Window")
										return (
											(E = {
												allowTaint: null !== ($i = p.allowTaint) && void 0 !== $i && $i,
												imageTimeout: null !== (ti = p.imageTimeout) && void 0 !== ti ? ti : 15e3,
												proxy: p.proxy,
												useCORS: null !== (Fo = p.useCORS) && void 0 !== Fo && Fo
											}),
											(k = X({ logging: null === (ta = p.logging) || void 0 === ta || ta, cache: p.cache }, E)),
											(z = {
												windowWidth: null !== (na = p.windowWidth) && void 0 !== na ? na : b.innerWidth,
												windowHeight: null !== (Ji = p.windowHeight) && void 0 !== Ji ? Ji : b.innerHeight,
												scrollX: null !== (bo = p.scrollX) && void 0 !== bo ? bo : b.pageXOffset,
												scrollY: null !== (nl = p.scrollY) && void 0 !== nl ? nl : b.pageYOffset
											}),
											(te = new Q(z.scrollX, z.scrollY, z.windowWidth, z.windowHeight)),
											(ee = new EA(k, te)),
											(xe = null !== (Ms = p.foreignObjectRendering) && void 0 !== Ms && Ms),
											(Fe = {
												allowTaint: null !== (Ss = p.allowTaint) && void 0 !== Ss && Ss,
												onclone: p.onclone,
												ignoreElements: p.ignoreElements,
												inlineImages: xe,
												copyStyles: xe
											}),
											ee.logger.debug(
												"Starting document clone with size " +
													te.width +
													"x" +
													te.height +
													" scrolled to " +
													-te.left +
													"," +
													-te.top
											),
											(Oe = new sF(ee, g, Fe)),
											(ot = Oe.clonedReferenceElement)
												? [4, Oe.toIFrame(v, te)]
												: [2, Promise.reject("Unable to find element in cloned iframe")]
										)
									case 1:
										return (
											(Yt = rl.sent()),
											(Ft =
												C_(ot) ||
												(function (g) {
													return "HTML" === g.tagName
												})(ot)
													? (function (g) {
															var p = g.body,
																v = g.documentElement
															if (!p || !v) throw new Error("Unable to get document size")
															var b = Math.max(
																	Math.max(p.scrollWidth, v.scrollWidth),
																	Math.max(p.offsetWidth, v.offsetWidth),
																	Math.max(p.clientWidth, v.clientWidth)
																),
																E = Math.max(
																	Math.max(p.scrollHeight, v.scrollHeight),
																	Math.max(p.offsetHeight, v.offsetHeight),
																	Math.max(p.clientHeight, v.clientHeight)
																)
															return new Q(0, 0, b, E)
													  })(ot.ownerDocument)
													: D(ee, ot)),
											(Pt = Ft.width),
											(fi = Ft.height),
											(bn = Ft.left),
											(dn = Ft.top),
											(Vi = EF(ee, ot, p.backgroundColor)),
											(gi = {
												canvas: p.canvas,
												backgroundColor: Vi,
												scale:
													null !== (Ya = null !== (ka = p.scale) && void 0 !== ka ? ka : b.devicePixelRatio) &&
													void 0 !== Ya
														? Ya
														: 1,
												x: (null !== (il = p.x) && void 0 !== il ? il : 0) + bn,
												y: (null !== (Fc = p.y) && void 0 !== Fc ? Fc : 0) + dn,
												width: null !== (Bc = p.width) && void 0 !== Bc ? Bc : Math.ceil(Pt),
												height: null !== (ls = p.height) && void 0 !== ls ? ls : Math.ceil(fi)
											}),
											xe
												? (ee.logger.debug("Document cloned, using foreign object rendering"),
												  [4, new xF(ee, gi).render(ot)])
												: [3, 3]
										)
									case 2:
										return (Yn = rl.sent()), [3, 5]
									case 3:
										return (
											ee.logger.debug(
												"Document cloned, element located at " +
													bn +
													"," +
													dn +
													" with size " +
													Pt +
													"x" +
													fi +
													" using computed rendering"
											),
											ee.logger.debug("Starting DOM parsing"),
											(zt = fA(ee, ot)),
											Vi === zt.styles.backgroundColor && (zt.styles.backgroundColor = wc.TRANSPARENT),
											ee.logger.debug(
												"Starting renderer for element at " +
													gi.x +
													"," +
													gi.y +
													" with size " +
													gi.width +
													"x" +
													gi.height
											),
											[4, new R_(ee, gi).render(zt)]
										)
									case 4:
										;(Yn = rl.sent()), (rl.label = 5)
									case 5:
										return (
											(!(null !== (ou = p.removeContainer) && void 0 !== ou) || ou) &&
												(sF.destroy(Yt) ||
													ee.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore")),
											ee.logger.debug("Finished rendering"),
											[2, Yn]
										)
								}
							})
						})
					},
					EF = function (g, p, v) {
						var b = p.ownerDocument,
							E = b.documentElement ? ah(g, getComputedStyle(b.documentElement).backgroundColor) : wc.TRANSPARENT,
							k = b.body ? ah(g, getComputedStyle(b.body).backgroundColor) : wc.TRANSPARENT,
							z = "string" == typeof v ? ah(g, v) : null === v ? wc.TRANSPARENT : 4294967295
						return p === b.documentElement ? (vc(E) ? (vc(k) ? z : k) : E) : z
					}
				return function (g, p) {
					return void 0 === p && (p = {}), CF(g, p)
				}
			})()
		},
		4244: ct => {
			function ft(Re) {
				return Array.isArray(Re) ? Re : [Re]
			}
			const m = /^\s+$/,
				de = /(?:[^\\]|^)\\$/,
				Q = /^\\!/,
				D = /^\\#/,
				$ = /\r?\n/g,
				R = /^\.*\/|^\.+$/
			let B = "node-ignore"
			typeof Symbol < "u" && (B = Symbol.for("node-ignore"))
			const H = B,
				G = /([0-z])-([0-z])/g,
				J = () => !1,
				Ne = [
					[/\\?\s+$/, Re => (0 === Re.indexOf("\\") ? " " : "")],
					[/\\\s/g, () => " "],
					[/[\\$.|*+(){^]/g, Re => `\\${Re}`],
					[/(?!\\)\?/g, () => "[^/]"],
					[/^\//, () => "^"],
					[/\//g, () => "\\/"],
					[/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"],
					[
						/^(?=[^^])/,
						function () {
							return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)"
						}
					],
					[/\\\/\\\*\\\*(?=\\\/|$)/g, (Re, ze, qe) => (ze + 6 < qe.length ? "(?:\\/[^\\/]+)*" : "\\/.+")],
					[/(^|[^\\]+)(\\\*)+(?=.+)/g, (Re, ze, qe) => ze + qe.replace(/\\\*/g, "[^\\/]*")],
					[/\\\\\\(?=[$.|*+(){^])/g, () => "\\"],
					[/\\\\/g, () => "\\"],
					[
						/(\\)?\[([^\]/]*?)(\\*)($|\])/g,
						(Re, ze, qe, Ge, wt) =>
							"\\" === ze
								? `\\[${qe}${(Re => {
										const { length: ze } = Re
										return Re.slice(0, ze - (ze % 2))
								  })(Ge)}${wt}`
								: "]" === wt && Ge.length % 2 == 0
								? `[${(Re => Re.replace(G, (ze, qe, Ge) => (qe.charCodeAt(0) <= Ge.charCodeAt(0) ? ze : "")))(qe)}${Ge}]`
								: "[]"
					],
					[/(?:[^*])$/, Re => (/\/$/.test(Re) ? `${Re}$` : `${Re}(?=$|\\/$)`)],
					[/(\^|\\\/)?\\\*$/, (Re, ze) => (ze ? `${ze}[^/]+` : "[^/]*") + "(?=$|\\/$)"]
				],
				ye = Object.create(null),
				Je = Re => "string" == typeof Re
			class it {
				constructor(ze, qe, Ge, wt) {
					;(this.origin = ze), (this.pattern = qe), (this.negative = Ge), (this.regex = wt)
				}
			}
			const st = (Re, ze) => {
					throw new ze(Re)
				},
				et = (Re, ze, qe) =>
					Je(Re)
						? Re
							? !et.isNotRelative(Re) || qe(`path should be a \`path.relative()\`d string, but got "${ze}"`, RangeError)
							: qe("path must not be empty", TypeError)
						: qe(`path must be a string, but got \`${ze}\``, TypeError),
				ke = Re => R.test(Re)
			;(et.isNotRelative = ke), (et.convert = Re => Re)
			class he {
				constructor({ ignorecase: ze = !0, ignoreCase: qe = ze, allowRelativePaths: Ge = !1 } = {}) {
					;((Re, ze, qe) => {
						Object.defineProperty(this, ze, { value: !0 })
					})(0, H),
						(this._rules = []),
						(this._ignoreCase = qe),
						(this._allowRelativePaths = Ge),
						this._initCache()
				}
				_initCache() {
					;(this._ignoreCache = Object.create(null)), (this._testCache = Object.create(null))
				}
				_addPattern(ze) {
					if (ze && ze[H]) return (this._rules = this._rules.concat(ze._rules)), void (this._added = !0)
					if ((Re = ze) && Je(Re) && !m.test(Re) && !de.test(Re) && 0 !== Re.indexOf("#")) {
						const qe = ((Re, ze) => {
							const qe = Re
							let Ge = !1
							0 === Re.indexOf("!") && ((Ge = !0), (Re = Re.substr(1)))
							const wt = ((Re, ze) => {
								let qe = ye[Re]
								return (
									qe || ((qe = Ne.reduce((Ge, wt) => Ge.replace(wt[0], wt[1].bind(Re)), Re)), (ye[Re] = qe)),
									ze ? new RegExp(qe, "i") : new RegExp(qe)
								)
							})((Re = Re.replace(Q, "!").replace(D, "#")), ze)
							return new it(qe, Re, Ge, wt)
						})(ze, this._ignoreCase)
						;(this._added = !0), this._rules.push(qe)
					}
					var Re
				}
				add(ze) {
					return (
						(this._added = !1),
						ft(Je(ze) ? ((Re = ze), Re.split($)) : ze).forEach(this._addPattern, this),
						this._added && this._initCache(),
						this
					)
					var Re
				}
				addPattern(ze) {
					return this.add(ze)
				}
				_testOne(ze, qe) {
					let Ge = !1,
						wt = !1
					return (
						this._rules.forEach(Jt => {
							const { negative: yn } = Jt
							;(wt === yn && Ge !== wt) || (yn && !Ge && !wt && !qe) || (Jt.regex.test(ze) && ((Ge = !yn), (wt = yn)))
						}),
						{ ignored: Ge, unignored: wt }
					)
				}
				_test(ze, qe, Ge, wt) {
					const Jt = ze && et.convert(ze)
					return et(Jt, ze, this._allowRelativePaths ? J : st), this._t(Jt, qe, Ge, wt)
				}
				_t(ze, qe, Ge, wt) {
					if (ze in qe) return qe[ze]
					if ((wt || (wt = ze.split("/")), wt.pop(), !wt.length)) return (qe[ze] = this._testOne(ze, Ge))
					const Jt = this._t(wt.join("/") + "/", qe, Ge, wt)
					return (qe[ze] = Jt.ignored ? Jt : this._testOne(ze, Ge))
				}
				ignores(ze) {
					return this._test(ze, this._ignoreCache, !1).ignored
				}
				createFilter() {
					return ze => !this.ignores(ze)
				}
				filter(ze) {
					return ft(ze).filter(this.createFilter())
				}
				test(ze) {
					return this._test(ze, this._testCache, !0)
				}
			}
			const Ve = Re => new he(Re)
			if (
				((Ve.isPathValid = Re => et(Re && et.convert(Re), Re, J)),
				(Ve.default = Ve),
				(ct.exports = Ve),
				typeof process < "u" && ((process.env && process.env.IGNORE_TEST_WIN32) || "win32" === process.platform))
			) {
				et.convert = qe => (/^\\\\\?\\/.test(qe) || /["<>|\u0000-\u001F]+/u.test(qe) ? qe : qe.replace(/\\/g, "/"))
				const ze = /^[a-z]:\//i
				et.isNotRelative = qe => ze.test(qe) || ke(qe)
			}
		},
		3678: ct => {
			function ft(X) {
				return !!X.constructor && "function" == typeof X.constructor.isBuffer && X.constructor.isBuffer(X)
			}
			ct.exports = function (X) {
				return (
					null != X &&
					(ft(X) ||
						(function A(X) {
							return "function" == typeof X.readFloatLE && "function" == typeof X.slice && ft(X.slice(0, 0))
						})(X) ||
						!!X._isBuffer)
				)
			}
		},
		7037: ct => {
			"use strict"
			var ft = (ct.exports = function (q, m, de) {
				"function" == typeof m && ((de = m), (m = {})),
					A(m, "function" == typeof (de = m.cb || de) ? de : de.pre || function () {}, de.post || function () {}, q, "", q)
			})
			function A(q, m, de, Q, D, $, R, V, B, H) {
				if (Q && "object" == typeof Q && !Array.isArray(Q)) {
					for (var I in (m(Q, D, $, R, V, B, H), Q)) {
						var G = Q[I]
						if (Array.isArray(G)) {
							if (I in ft.arrayKeywords)
								for (var J = 0; J < G.length; J++) A(q, m, de, G[J], D + "/" + I + "/" + J, $, D, I, Q, J)
						} else if (I in ft.propsKeywords) {
							if (G && "object" == typeof G) for (var Y in G) A(q, m, de, G[Y], D + "/" + I + "/" + X(Y), $, D, I, Q, Y)
						} else (I in ft.keywords || (q.allKeys && !(I in ft.skipKeywords))) && A(q, m, de, G, D + "/" + I, $, D, I, Q)
					}
					de(Q, D, $, R, V, B, H)
				}
			}
			function X(q) {
				return q.replace(/~/g, "~0").replace(/\//g, "~1")
			}
			;(ft.keywords = { additionalItems: !0, items: !0, contains: !0, additionalProperties: !0, propertyNames: !0, not: !0 }),
				(ft.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 }),
				(ft.propsKeywords = { definitions: !0, properties: !0, patternProperties: !0, dependencies: !0 }),
				(ft.skipKeywords = {
					default: !0,
					enum: !0,
					const: !0,
					required: !0,
					maximum: !0,
					minimum: !0,
					exclusiveMaximum: !0,
					exclusiveMinimum: !0,
					multipleOf: !0,
					maxLength: !0,
					minLength: !0,
					pattern: !0,
					format: !0,
					maxItems: !0,
					minItems: !0,
					uniqueItems: !0,
					maxProperties: !0,
					minProperties: !0
				})
		},
		9095: (ct, ft, A) => {
			var X, q, m, de, Q
			;(X = A(6962)),
				(q = A(8870).utf8),
				(m = A(3678)),
				(de = A(8870).bin),
				((Q = function (D, $) {
					D.constructor == String
						? (D = $ && "binary" === $.encoding ? de.stringToBytes(D) : q.stringToBytes(D))
						: m(D)
						? (D = Array.prototype.slice.call(D, 0))
						: !Array.isArray(D) && D.constructor !== Uint8Array && (D = D.toString())
					for (
						var R = X.bytesToWords(D), V = 8 * D.length, B = 1732584193, H = -271733879, I = -1732584194, G = 271733878, J = 0;
						J < R.length;
						J++
					)
						R[J] = (16711935 & ((R[J] << 8) | (R[J] >>> 24))) | (4278255360 & ((R[J] << 24) | (R[J] >>> 8)))
					;(R[V >>> 5] |= 128 << V % 32), (R[14 + (((V + 64) >>> 9) << 4)] = V)
					var Y = Q._ff,
						pe = Q._gg,
						Ne = Q._hh,
						ye = Q._ii
					for (J = 0; J < R.length; J += 16) {
						var Qe = B,
							Je = H,
							Ce = I,
							We = G
						;(B = Y(B, H, I, G, R[J + 0], 7, -680876936)),
							(G = Y(G, B, H, I, R[J + 1], 12, -389564586)),
							(I = Y(I, G, B, H, R[J + 2], 17, 606105819)),
							(H = Y(H, I, G, B, R[J + 3], 22, -1044525330)),
							(B = Y(B, H, I, G, R[J + 4], 7, -176418897)),
							(G = Y(G, B, H, I, R[J + 5], 12, 1200080426)),
							(I = Y(I, G, B, H, R[J + 6], 17, -1473231341)),
							(H = Y(H, I, G, B, R[J + 7], 22, -45705983)),
							(B = Y(B, H, I, G, R[J + 8], 7, 1770035416)),
							(G = Y(G, B, H, I, R[J + 9], 12, -1958414417)),
							(I = Y(I, G, B, H, R[J + 10], 17, -42063)),
							(H = Y(H, I, G, B, R[J + 11], 22, -1990404162)),
							(B = Y(B, H, I, G, R[J + 12], 7, 1804603682)),
							(G = Y(G, B, H, I, R[J + 13], 12, -40341101)),
							(I = Y(I, G, B, H, R[J + 14], 17, -1502002290)),
							(B = pe(B, (H = Y(H, I, G, B, R[J + 15], 22, 1236535329)), I, G, R[J + 1], 5, -165796510)),
							(G = pe(G, B, H, I, R[J + 6], 9, -1069501632)),
							(I = pe(I, G, B, H, R[J + 11], 14, 643717713)),
							(H = pe(H, I, G, B, R[J + 0], 20, -373897302)),
							(B = pe(B, H, I, G, R[J + 5], 5, -701558691)),
							(G = pe(G, B, H, I, R[J + 10], 9, 38016083)),
							(I = pe(I, G, B, H, R[J + 15], 14, -660478335)),
							(H = pe(H, I, G, B, R[J + 4], 20, -405537848)),
							(B = pe(B, H, I, G, R[J + 9], 5, 568446438)),
							(G = pe(G, B, H, I, R[J + 14], 9, -1019803690)),
							(I = pe(I, G, B, H, R[J + 3], 14, -187363961)),
							(H = pe(H, I, G, B, R[J + 8], 20, 1163531501)),
							(B = pe(B, H, I, G, R[J + 13], 5, -1444681467)),
							(G = pe(G, B, H, I, R[J + 2], 9, -51403784)),
							(I = pe(I, G, B, H, R[J + 7], 14, 1735328473)),
							(B = Ne(B, (H = pe(H, I, G, B, R[J + 12], 20, -1926607734)), I, G, R[J + 5], 4, -378558)),
							(G = Ne(G, B, H, I, R[J + 8], 11, -2022574463)),
							(I = Ne(I, G, B, H, R[J + 11], 16, 1839030562)),
							(H = Ne(H, I, G, B, R[J + 14], 23, -35309556)),
							(B = Ne(B, H, I, G, R[J + 1], 4, -1530992060)),
							(G = Ne(G, B, H, I, R[J + 4], 11, 1272893353)),
							(I = Ne(I, G, B, H, R[J + 7], 16, -155497632)),
							(H = Ne(H, I, G, B, R[J + 10], 23, -1094730640)),
							(B = Ne(B, H, I, G, R[J + 13], 4, 681279174)),
							(G = Ne(G, B, H, I, R[J + 0], 11, -358537222)),
							(I = Ne(I, G, B, H, R[J + 3], 16, -722521979)),
							(H = Ne(H, I, G, B, R[J + 6], 23, 76029189)),
							(B = Ne(B, H, I, G, R[J + 9], 4, -640364487)),
							(G = Ne(G, B, H, I, R[J + 12], 11, -421815835)),
							(I = Ne(I, G, B, H, R[J + 15], 16, 530742520)),
							(B = ye(B, (H = Ne(H, I, G, B, R[J + 2], 23, -995338651)), I, G, R[J + 0], 6, -198630844)),
							(G = ye(G, B, H, I, R[J + 7], 10, 1126891415)),
							(I = ye(I, G, B, H, R[J + 14], 15, -1416354905)),
							(H = ye(H, I, G, B, R[J + 5], 21, -57434055)),
							(B = ye(B, H, I, G, R[J + 12], 6, 1700485571)),
							(G = ye(G, B, H, I, R[J + 3], 10, -1894986606)),
							(I = ye(I, G, B, H, R[J + 10], 15, -1051523)),
							(H = ye(H, I, G, B, R[J + 1], 21, -2054922799)),
							(B = ye(B, H, I, G, R[J + 8], 6, 1873313359)),
							(G = ye(G, B, H, I, R[J + 15], 10, -30611744)),
							(I = ye(I, G, B, H, R[J + 6], 15, -1560198380)),
							(H = ye(H, I, G, B, R[J + 13], 21, 1309151649)),
							(B = ye(B, H, I, G, R[J + 4], 6, -145523070)),
							(G = ye(G, B, H, I, R[J + 11], 10, -1120210379)),
							(I = ye(I, G, B, H, R[J + 2], 15, 718787259)),
							(H = ye(H, I, G, B, R[J + 9], 21, -343485551)),
							(B = (B + Qe) >>> 0),
							(H = (H + Je) >>> 0),
							(I = (I + Ce) >>> 0),
							(G = (G + We) >>> 0)
					}
					return X.endian([B, H, I, G])
				})._ff = function (D, $, R, V, B, H, I) {
					var G = D + (($ & R) | (~$ & V)) + (B >>> 0) + I
					return ((G << H) | (G >>> (32 - H))) + $
				}),
				(Q._gg = function (D, $, R, V, B, H, I) {
					var G = D + (($ & V) | (R & ~V)) + (B >>> 0) + I
					return ((G << H) | (G >>> (32 - H))) + $
				}),
				(Q._hh = function (D, $, R, V, B, H, I) {
					var G = D + ($ ^ R ^ V) + (B >>> 0) + I
					return ((G << H) | (G >>> (32 - H))) + $
				}),
				(Q._ii = function (D, $, R, V, B, H, I) {
					var G = D + (R ^ ($ | ~V)) + (B >>> 0) + I
					return ((G << H) | (G >>> (32 - H))) + $
				}),
				(Q._blocksize = 16),
				(Q._digestsize = 16),
				(ct.exports = function (D, $) {
					if (null == D) throw new Error("Illegal argument " + D)
					var R = X.wordsToBytes(Q(D, $))
					return $ && $.asBytes ? R : $ && $.asString ? de.bytesToString(R) : X.bytesToHex(R)
				})
		},
		5158: (ct, ft) => {
			"use strict"
			const { hasOwnProperty: A } = Object.prototype,
				X = J()
			;(X.configure = J), (X.stringify = X), (X.default = X), (ft.stringify = X), (ft.configure = J), (ct.exports = X)
			const q = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/
			function m(Y) {
				return Y.length < 5e3 && !q.test(Y) ? `"${Y}"` : JSON.stringify(Y)
			}
			function de(Y) {
				if (Y.length > 200) return Y.sort()
				for (let pe = 1; pe < Y.length; pe++) {
					const Ne = Y[pe]
					let ye = pe
					for (; 0 !== ye && Y[ye - 1] > Ne; ) (Y[ye] = Y[ye - 1]), ye--
					Y[ye] = Ne
				}
				return Y
			}
			const Q = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get
			function D(Y) {
				return void 0 !== Q.call(Y) && 0 !== Y.length
			}
			function $(Y, pe, Ne) {
				Y.length < Ne && (Ne = Y.length)
				const ye = "," === pe ? "" : " "
				let Qe = `"0":${ye}${Y[0]}`
				for (let Je = 1; Je < Ne; Je++) Qe += `${pe}"${Je}":${ye}${Y[Je]}`
				return Qe
			}
			function V(Y, pe) {
				let Ne
				if (A.call(Y, pe) && ((Ne = Y[pe]), "boolean" != typeof Ne))
					throw new TypeError(`The "${pe}" argument must be of type boolean`)
				return void 0 === Ne || Ne
			}
			function B(Y, pe) {
				let Ne
				if (A.call(Y, pe)) {
					if (((Ne = Y[pe]), "number" != typeof Ne)) throw new TypeError(`The "${pe}" argument must be of type number`)
					if (!Number.isInteger(Ne)) throw new TypeError(`The "${pe}" argument must be an integer`)
					if (Ne < 1) throw new RangeError(`The "${pe}" argument must be >= 1`)
				}
				return void 0 === Ne ? 1 / 0 : Ne
			}
			function H(Y) {
				return 1 === Y ? "1 item" : `${Y} items`
			}
			function J(Y) {
				const pe = (function G(Y) {
					if (A.call(Y, "strict")) {
						const pe = Y.strict
						if ("boolean" != typeof pe) throw new TypeError('The "strict" argument must be of type boolean')
						if (pe)
							return Ne => {
								let ye = "Object can not safely be stringified. Received type " + typeof Ne
								throw ("function" != typeof Ne && (ye += ` (${Ne.toString()})`), new Error(ye))
							}
					}
				})((Y = { ...Y }))
				pe && (void 0 === Y.bigint && (Y.bigint = !1), "circularValue" in Y || (Y.circularValue = Error))
				const Ne = (function R(Y) {
						if (A.call(Y, "circularValue")) {
							const pe = Y.circularValue
							if ("string" == typeof pe) return `"${pe}"`
							if (null == pe) return pe
							if (pe === Error || pe === TypeError)
								return {
									toString() {
										throw new TypeError("Converting circular structure to JSON")
									}
								}
							throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined')
						}
						return '"[Circular]"'
					})(Y),
					ye = V(Y, "bigint"),
					Qe = V(Y, "deterministic"),
					Je = B(Y, "maximumDepth"),
					Ce = B(Y, "maximumBreadth")
				function We(ke, he, Ve, je, Re, ze) {
					let qe = he[ke]
					switch (
						("object" == typeof qe && null !== qe && "function" == typeof qe.toJSON && (qe = qe.toJSON(ke)),
						(qe = je.call(he, ke, qe)),
						typeof qe)
					) {
						case "string":
							return m(qe)
						case "object": {
							if (null === qe) return "null"
							if (-1 !== Ve.indexOf(qe)) return Ne
							let Ge = "",
								wt = ","
							const Jt = ze
							if (Array.isArray(qe)) {
								if (0 === qe.length) return "[]"
								if (Je < Ve.length + 1) return '"[Array]"'
								Ve.push(qe), "" !== Re && ((Ge += `\n${(ze += Re)}`), (wt = `,\n${ze}`))
								const Wt = Math.min(qe.length, Ce)
								let we = 0
								for (; we < Wt - 1; we++) {
									const Ke = We(String(we), qe, Ve, je, Re, ze)
									;(Ge += void 0 !== Ke ? Ke : "null"), (Ge += wt)
								}
								const gt = We(String(we), qe, Ve, je, Re, ze)
								return (
									(Ge += void 0 !== gt ? gt : "null"),
									qe.length - 1 > Ce && (Ge += `${wt}"... ${H(qe.length - Ce - 1)} not stringified"`),
									"" !== Re && (Ge += `\n${Jt}`),
									Ve.pop(),
									`[${Ge}]`
								)
							}
							let yn = Object.keys(qe)
							const ai = yn.length
							if (0 === ai) return "{}"
							if (Je < Ve.length + 1) return '"[Object]"'
							let vt = "",
								hi = ""
							"" !== Re && ((wt = `,\n${(ze += Re)}`), (vt = " "))
							const yi = Math.min(ai, Ce)
							Qe && !D(qe) && (yn = de(yn)), Ve.push(qe)
							for (let Wt = 0; Wt < yi; Wt++) {
								const we = yn[Wt],
									gt = We(we, qe, Ve, je, Re, ze)
								void 0 !== gt && ((Ge += `${hi}${m(we)}:${vt}${gt}`), (hi = wt))
							}
							return (
								ai > Ce && ((Ge += `${hi}"...":${vt}"${H(ai - Ce)} not stringified"`), (hi = wt)),
								"" !== Re && hi.length > 1 && (Ge = `\n${ze}${Ge}\n${Jt}`),
								Ve.pop(),
								`{${Ge}}`
							)
						}
						case "number":
							return isFinite(qe) ? String(qe) : pe ? pe(qe) : "null"
						case "boolean":
							return !0 === qe ? "true" : "false"
						case "undefined":
							return
						case "bigint":
							if (ye) return String(qe)
						default:
							return pe ? pe(qe) : void 0
					}
				}
				function it(ke, he, Ve, je, Re, ze) {
					switch (("object" == typeof he && null !== he && "function" == typeof he.toJSON && (he = he.toJSON(ke)), typeof he)) {
						case "string":
							return m(he)
						case "object": {
							if (null === he) return "null"
							if (-1 !== Ve.indexOf(he)) return Ne
							const qe = ze
							let Ge = "",
								wt = ","
							if (Array.isArray(he)) {
								if (0 === he.length) return "[]"
								if (Je < Ve.length + 1) return '"[Array]"'
								Ve.push(he), "" !== Re && ((Ge += `\n${(ze += Re)}`), (wt = `,\n${ze}`))
								const ai = Math.min(he.length, Ce)
								let vt = 0
								for (; vt < ai - 1; vt++) {
									const yi = it(String(vt), he[vt], Ve, je, Re, ze)
									;(Ge += void 0 !== yi ? yi : "null"), (Ge += wt)
								}
								const hi = it(String(vt), he[vt], Ve, je, Re, ze)
								return (
									(Ge += void 0 !== hi ? hi : "null"),
									he.length - 1 > Ce && (Ge += `${wt}"... ${H(he.length - Ce - 1)} not stringified"`),
									"" !== Re && (Ge += `\n${qe}`),
									Ve.pop(),
									`[${Ge}]`
								)
							}
							Ve.push(he)
							let Jt = ""
							"" !== Re && ((wt = `,\n${(ze += Re)}`), (Jt = " "))
							let yn = ""
							for (const ai of je) {
								const vt = it(ai, he[ai], Ve, je, Re, ze)
								void 0 !== vt && ((Ge += `${yn}${m(ai)}:${Jt}${vt}`), (yn = wt))
							}
							return "" !== Re && yn.length > 1 && (Ge = `\n${ze}${Ge}\n${qe}`), Ve.pop(), `{${Ge}}`
						}
						case "number":
							return isFinite(he) ? String(he) : pe ? pe(he) : "null"
						case "boolean":
							return !0 === he ? "true" : "false"
						case "undefined":
							return
						case "bigint":
							if (ye) return String(he)
						default:
							return pe ? pe(he) : void 0
					}
				}
				function Ue(ke, he, Ve, je, Re) {
					switch (typeof he) {
						case "string":
							return m(he)
						case "object": {
							if (null === he) return "null"
							if ("function" == typeof he.toJSON) {
								if ("object" != typeof (he = he.toJSON(ke))) return Ue(ke, he, Ve, je, Re)
								if (null === he) return "null"
							}
							if (-1 !== Ve.indexOf(he)) return Ne
							const ze = Re
							if (Array.isArray(he)) {
								if (0 === he.length) return "[]"
								if (Je < Ve.length + 1) return '"[Array]"'
								Ve.push(he)
								let vt = `\n${(Re += je)}`
								const hi = `,\n${Re}`,
									yi = Math.min(he.length, Ce)
								let Wt = 0
								for (; Wt < yi - 1; Wt++) {
									const gt = Ue(String(Wt), he[Wt], Ve, je, Re)
									;(vt += void 0 !== gt ? gt : "null"), (vt += hi)
								}
								const we = Ue(String(Wt), he[Wt], Ve, je, Re)
								return (
									(vt += void 0 !== we ? we : "null"),
									he.length - 1 > Ce && (vt += `${hi}"... ${H(he.length - Ce - 1)} not stringified"`),
									(vt += `\n${ze}`),
									Ve.pop(),
									`[${vt}]`
								)
							}
							let qe = Object.keys(he)
							const Ge = qe.length
							if (0 === Ge) return "{}"
							if (Je < Ve.length + 1) return '"[Object]"'
							const wt = `,\n${(Re += je)}`
							let Jt = "",
								yn = "",
								ai = Math.min(Ge, Ce)
							D(he) && ((Jt += $(he, wt, Ce)), (qe = qe.slice(he.length)), (ai -= he.length), (yn = wt)),
								Qe && (qe = de(qe)),
								Ve.push(he)
							for (let vt = 0; vt < ai; vt++) {
								const hi = qe[vt],
									yi = Ue(hi, he[hi], Ve, je, Re)
								void 0 !== yi && ((Jt += `${yn}${m(hi)}: ${yi}`), (yn = wt))
							}
							return (
								Ge > Ce && ((Jt += `${yn}"...": "${H(Ge - Ce)} not stringified"`), (yn = wt)),
								"" !== yn && (Jt = `\n${Re}${Jt}\n${ze}`),
								Ve.pop(),
								`{${Jt}}`
							)
						}
						case "number":
							return isFinite(he) ? String(he) : pe ? pe(he) : "null"
						case "boolean":
							return !0 === he ? "true" : "false"
						case "undefined":
							return
						case "bigint":
							if (ye) return String(he)
						default:
							return pe ? pe(he) : void 0
					}
				}
				function st(ke, he, Ve) {
					switch (typeof he) {
						case "string":
							return m(he)
						case "object": {
							if (null === he) return "null"
							if ("function" == typeof he.toJSON) {
								if ("object" != typeof (he = he.toJSON(ke))) return st(ke, he, Ve)
								if (null === he) return "null"
							}
							if (-1 !== Ve.indexOf(he)) return Ne
							let je = ""
							if (Array.isArray(he)) {
								if (0 === he.length) return "[]"
								if (Je < Ve.length + 1) return '"[Array]"'
								Ve.push(he)
								const wt = Math.min(he.length, Ce)
								let Jt = 0
								for (; Jt < wt - 1; Jt++) {
									const ai = st(String(Jt), he[Jt], Ve)
									;(je += void 0 !== ai ? ai : "null"), (je += ",")
								}
								const yn = st(String(Jt), he[Jt], Ve)
								return (
									(je += void 0 !== yn ? yn : "null"),
									he.length - 1 > Ce && (je += `,"... ${H(he.length - Ce - 1)} not stringified"`),
									Ve.pop(),
									`[${je}]`
								)
							}
							let Re = Object.keys(he)
							const ze = Re.length
							if (0 === ze) return "{}"
							if (Je < Ve.length + 1) return '"[Object]"'
							let qe = "",
								Ge = Math.min(ze, Ce)
							D(he) && ((je += $(he, ",", Ce)), (Re = Re.slice(he.length)), (Ge -= he.length), (qe = ",")),
								Qe && (Re = de(Re)),
								Ve.push(he)
							for (let wt = 0; wt < Ge; wt++) {
								const Jt = Re[wt],
									yn = st(Jt, he[Jt], Ve)
								void 0 !== yn && ((je += `${qe}${m(Jt)}:${yn}`), (qe = ","))
							}
							return ze > Ce && (je += `${qe}"...":"${H(ze - Ce)} not stringified"`), Ve.pop(), `{${je}}`
						}
						case "number":
							return isFinite(he) ? String(he) : pe ? pe(he) : "null"
						case "boolean":
							return !0 === he ? "true" : "false"
						case "undefined":
							return
						case "bigint":
							if (ye) return String(he)
						default:
							return pe ? pe(he) : void 0
					}
				}
				return function et(ke, he, Ve) {
					if (arguments.length > 1) {
						let je = ""
						if (
							("number" == typeof Ve ? (je = " ".repeat(Math.min(Ve, 10))) : "string" == typeof Ve && (je = Ve.slice(0, 10)),
							null != he)
						) {
							if ("function" == typeof he) return We("", { "": ke }, [], he, je, "")
							if (Array.isArray(he))
								return it(
									"",
									ke,
									[],
									(function I(Y) {
										const pe = new Set()
										for (const Ne of Y) ("string" == typeof Ne || "number" == typeof Ne) && pe.add(String(Ne))
										return pe
									})(he),
									je,
									""
								)
						}
						if (0 !== je.length) return Ue("", ke, [], je, "")
					}
					return st("", ke, [])
				}
			}
		},
		8336: ct => {
			ct.exports = function (ft) {
				function A(X, q) {
					var Ze, li, Vr, Yr, rs
					;(this.object = X),
						(this.domElement = void 0 !== q ? q : document),
						(this.enabled = !0),
						(this.target = new ft.Vector3()),
						(this.minDistance = 0),
						(this.maxDistance = 1 / 0),
						(this.minZoom = 0),
						(this.maxZoom = 1 / 0),
						(this.minPolarAngle = 0),
						(this.maxPolarAngle = Math.PI),
						(this.minAzimuthAngle = -1 / 0),
						(this.maxAzimuthAngle = 1 / 0),
						(this.enableDamping = !1),
						(this.dampingFactor = 0.25),
						(this.enableZoom = !0),
						(this.zoomSpeed = 1),
						(this.enableRotate = !0),
						(this.rotateSpeed = 1),
						(this.enablePan = !0),
						(this.keyPanSpeed = 7),
						(this.autoRotate = !1),
						(this.autoRotateSpeed = 2),
						(this.enableKeys = !0),
						(this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }),
						(this.mouseButtons = { ORBIT: ft.MOUSE.LEFT, ZOOM: ft.MOUSE.MIDDLE, PAN: ft.MOUSE.RIGHT }),
						(this.target0 = this.target.clone()),
						(this.position0 = this.object.position.clone()),
						(this.zoom0 = this.object.zoom),
						(this.getPolarAngle = function () {
							return B.phi
						}),
						(this.getAzimuthalAngle = function () {
							return B.theta
						}),
						(this.reset = function () {
							m.target.copy(m.target0),
								m.object.position.copy(m.position0),
								(m.object.zoom = m.zoom0),
								m.object.updateProjectionMatrix(),
								m.dispatchEvent(de),
								m.update(),
								(R = $.NONE)
						}),
						(this.update =
							((Ze = new ft.Vector3()),
							(li = new ft.Quaternion().setFromUnitVectors(X.up, new ft.Vector3(0, 1, 0))),
							(Vr = li.clone().inverse()),
							(Yr = new ft.Vector3()),
							(rs = new ft.Quaternion()),
							function () {
								var os = m.object.position
								return (
									Ze.copy(os).sub(m.target),
									Ze.applyQuaternion(li),
									B.setFromVector3(Ze),
									m.autoRotate &&
										R === $.NONE &&
										et(
											(function Ue() {
												return ((2 * Math.PI) / 60 / 60) * m.autoRotateSpeed
											})()
										),
									(B.theta += H.theta),
									(B.phi += H.phi),
									(B.theta = Math.max(m.minAzimuthAngle, Math.min(m.maxAzimuthAngle, B.theta))),
									(B.phi = Math.max(m.minPolarAngle, Math.min(m.maxPolarAngle, B.phi))),
									B.makeSafe(),
									(B.radius *= I),
									(B.radius = Math.max(m.minDistance, Math.min(m.maxDistance, B.radius))),
									m.target.add(G),
									Ze.setFromSpherical(B),
									Ze.applyQuaternion(Vr),
									os.copy(m.target).add(Ze),
									m.object.lookAt(m.target),
									!0 === m.enableDamping
										? ((H.theta *= 1 - m.dampingFactor), (H.phi *= 1 - m.dampingFactor))
										: H.set(0, 0, 0),
									(I = 1),
									G.set(0, 0, 0),
									!!(J || Yr.distanceToSquared(m.object.position) > V || 8 * (1 - rs.dot(m.object.quaternion)) > V) &&
										(m.dispatchEvent(de), Yr.copy(m.object.position), rs.copy(m.object.quaternion), (J = !1), !0)
								)
							})),
						(this.dispose = function () {
							m.domElement.removeEventListener("contextmenu", Pi, !1),
								m.domElement.removeEventListener("mousedown", gn, !1),
								m.domElement.removeEventListener("wheel", nr, !1),
								m.domElement.removeEventListener("touchstart", Qn, !1),
								m.domElement.removeEventListener("touchend", Br, !1),
								m.domElement.removeEventListener("touchmove", io, !1),
								document.removeEventListener("mousemove", ci, !1),
								document.removeEventListener("mouseup", Ci, !1),
								window.removeEventListener("keydown", hr, !1)
						})
					var m = this,
						de = { type: "change" },
						Q = { type: "start" },
						D = { type: "end" },
						$ = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 },
						R = $.NONE,
						V = 1e-6,
						B = new ft.Spherical(),
						H = new ft.Spherical(),
						I = 1,
						G = new ft.Vector3(),
						J = !1,
						Y = new ft.Vector2(),
						pe = new ft.Vector2(),
						Ne = new ft.Vector2(),
						ye = new ft.Vector2(),
						Qe = new ft.Vector2(),
						Je = new ft.Vector2(),
						Ce = new ft.Vector2(),
						We = new ft.Vector2(),
						it = new ft.Vector2()
					function st() {
						return Math.pow(0.95, m.zoomSpeed)
					}
					function et(Ze) {
						H.theta -= Ze
					}
					function ke(Ze) {
						H.phi -= Ze
					}
					var he = (function () {
							var Ze = new ft.Vector3()
							return function (Vr, Yr) {
								Ze.setFromMatrixColumn(Yr, 0), Ze.multiplyScalar(-Vr), G.add(Ze)
							}
						})(),
						Ve = (function () {
							var Ze = new ft.Vector3()
							return function (Vr, Yr) {
								Ze.setFromMatrixColumn(Yr, 1), Ze.multiplyScalar(Vr), G.add(Ze)
							}
						})(),
						je = (function () {
							var Ze = new ft.Vector3()
							return function (Vr, Yr) {
								var rs = m.domElement === document ? m.domElement.body : m.domElement
								if (m.object instanceof ft.PerspectiveCamera) {
									Ze.copy(m.object.position).sub(m.target)
									var os = Ze.length()
									;(os *= Math.tan(((m.object.fov / 2) * Math.PI) / 180)),
										he((2 * Vr * os) / rs.clientHeight, m.object.matrix),
										Ve((2 * Yr * os) / rs.clientHeight, m.object.matrix)
								} else
									m.object instanceof ft.OrthographicCamera
										? (he((Vr * (m.object.right - m.object.left)) / m.object.zoom / rs.clientWidth, m.object.matrix),
										  Ve((Yr * (m.object.top - m.object.bottom)) / m.object.zoom / rs.clientHeight, m.object.matrix))
										: (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
										  (m.enablePan = !1))
							}
						})()
					function Re(Ze) {
						m.object instanceof ft.PerspectiveCamera
							? (I /= Ze)
							: m.object instanceof ft.OrthographicCamera
							? ((m.object.zoom = Math.max(m.minZoom, Math.min(m.maxZoom, m.object.zoom * Ze))),
							  m.object.updateProjectionMatrix(),
							  (J = !0))
							: (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
							  (m.enableZoom = !1))
					}
					function ze(Ze) {
						m.object instanceof ft.PerspectiveCamera
							? (I *= Ze)
							: m.object instanceof ft.OrthographicCamera
							? ((m.object.zoom = Math.max(m.minZoom, Math.min(m.maxZoom, m.object.zoom / Ze))),
							  m.object.updateProjectionMatrix(),
							  (J = !0))
							: (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
							  (m.enableZoom = !1))
					}
					function gn(Ze) {
						if (!1 !== m.enabled) {
							if ((Ze.preventDefault(), Ze.button === m.mouseButtons.ORBIT)) {
								if (!1 === m.enableRotate) return
								;(function qe(Ze) {
									Y.set(Ze.clientX, Ze.clientY)
								})(Ze),
									(R = $.ROTATE)
							} else if (Ze.button === m.mouseButtons.ZOOM) {
								if (!1 === m.enableZoom) return
								;(function Ge(Ze) {
									Ce.set(Ze.clientX, Ze.clientY)
								})(Ze),
									(R = $.DOLLY)
							} else if (Ze.button === m.mouseButtons.PAN) {
								if (!1 === m.enablePan) return
								;(function wt(Ze) {
									ye.set(Ze.clientX, Ze.clientY)
								})(Ze),
									(R = $.PAN)
							}
							R !== $.NONE &&
								(document.addEventListener("mousemove", ci, !1),
								document.addEventListener("mouseup", Ci, !1),
								m.dispatchEvent(Q))
						}
					}
					function ci(Ze) {
						if (!1 !== m.enabled)
							if ((Ze.preventDefault(), R === $.ROTATE)) {
								if (!1 === m.enableRotate) return
								!(function Jt(Ze) {
									pe.set(Ze.clientX, Ze.clientY), Ne.subVectors(pe, Y)
									var li = m.domElement === document ? m.domElement.body : m.domElement
									et(((2 * Math.PI * Ne.x) / li.clientWidth) * m.rotateSpeed),
										ke(((2 * Math.PI * Ne.y) / li.clientHeight) * m.rotateSpeed),
										Y.copy(pe),
										m.update()
								})(Ze)
							} else if (R === $.DOLLY) {
								if (!1 === m.enableZoom) return
								!(function yn(Ze) {
									We.set(Ze.clientX, Ze.clientY),
										it.subVectors(We, Ce),
										it.y > 0 ? Re(st()) : it.y < 0 && ze(st()),
										Ce.copy(We),
										m.update()
								})(Ze)
							} else if (R === $.PAN) {
								if (!1 === m.enablePan) return
								!(function ai(Ze) {
									Qe.set(Ze.clientX, Ze.clientY), Je.subVectors(Qe, ye), je(Je.x, Je.y), ye.copy(Qe), m.update()
								})(Ze)
							}
					}
					function Ci(Ze) {
						!1 !== m.enabled &&
							(document.removeEventListener("mousemove", ci, !1),
							document.removeEventListener("mouseup", Ci, !1),
							m.dispatchEvent(D),
							(R = $.NONE))
					}
					function nr(Ze) {
						!1 === m.enabled ||
							!1 === m.enableZoom ||
							(R !== $.NONE && R !== $.ROTATE) ||
							(Ze.preventDefault(),
							Ze.stopPropagation(),
							(function hi(Ze) {
								Ze.deltaY < 0 ? ze(st()) : Ze.deltaY > 0 && Re(st()), m.update()
							})(Ze),
							m.dispatchEvent(Q),
							m.dispatchEvent(D))
					}
					function hr(Ze) {
						!1 === m.enabled ||
							!1 === m.enableKeys ||
							!1 === m.enablePan ||
							(function yi(Ze) {
								switch (Ze.keyCode) {
									case m.keys.UP:
										je(0, m.keyPanSpeed), m.update()
										break
									case m.keys.BOTTOM:
										je(0, -m.keyPanSpeed), m.update()
										break
									case m.keys.LEFT:
										je(m.keyPanSpeed, 0), m.update()
										break
									case m.keys.RIGHT:
										je(-m.keyPanSpeed, 0), m.update()
								}
							})(Ze)
					}
					function Qn(Ze) {
						if (!1 !== m.enabled) {
							switch (Ze.touches.length) {
								case 1:
									if (!1 === m.enableRotate) return
									;(function Wt(Ze) {
										Y.set(Ze.touches[0].pageX, Ze.touches[0].pageY)
									})(Ze),
										(R = $.TOUCH_ROTATE)
									break
								case 2:
									if (!1 === m.enableZoom) return
									;(function we(Ze) {
										var li = Ze.touches[0].pageX - Ze.touches[1].pageX,
											Vr = Ze.touches[0].pageY - Ze.touches[1].pageY,
											Yr = Math.sqrt(li * li + Vr * Vr)
										Ce.set(0, Yr)
									})(Ze),
										(R = $.TOUCH_DOLLY)
									break
								case 3:
									if (!1 === m.enablePan) return
									;(function gt(Ze) {
										ye.set(Ze.touches[0].pageX, Ze.touches[0].pageY)
									})(Ze),
										(R = $.TOUCH_PAN)
									break
								default:
									R = $.NONE
							}
							R !== $.NONE && m.dispatchEvent(Q)
						}
					}
					function io(Ze) {
						if (!1 !== m.enabled)
							switch ((Ze.preventDefault(), Ze.stopPropagation(), Ze.touches.length)) {
								case 1:
									if (!1 === m.enableRotate || R !== $.TOUCH_ROTATE) return
									!(function Ke(Ze) {
										pe.set(Ze.touches[0].pageX, Ze.touches[0].pageY), Ne.subVectors(pe, Y)
										var li = m.domElement === document ? m.domElement.body : m.domElement
										et(((2 * Math.PI * Ne.x) / li.clientWidth) * m.rotateSpeed),
											ke(((2 * Math.PI * Ne.y) / li.clientHeight) * m.rotateSpeed),
											Y.copy(pe),
											m.update()
									})(Ze)
									break
								case 2:
									if (!1 === m.enableZoom || R !== $.TOUCH_DOLLY) return
									!(function fn(Ze) {
										var li = Ze.touches[0].pageX - Ze.touches[1].pageX,
											Vr = Ze.touches[0].pageY - Ze.touches[1].pageY,
											Yr = Math.sqrt(li * li + Vr * Vr)
										We.set(0, Yr),
											it.subVectors(We, Ce),
											it.y > 0 ? ze(st()) : it.y < 0 && Re(st()),
											Ce.copy(We),
											m.update()
									})(Ze)
									break
								case 3:
									if (!1 === m.enablePan || R !== $.TOUCH_PAN) return
									!(function St(Ze) {
										Qe.set(Ze.touches[0].pageX, Ze.touches[0].pageY),
											Je.subVectors(Qe, ye),
											je(Je.x, Je.y),
											ye.copy(Qe),
											m.update()
									})(Ze)
									break
								default:
									R = $.NONE
							}
					}
					function Br(Ze) {
						!1 !== m.enabled && (m.dispatchEvent(D), (R = $.NONE))
					}
					function Pi(Ze) {
						Ze.preventDefault()
					}
					m.domElement.addEventListener("contextmenu", Pi, !1),
						m.domElement.addEventListener("mousedown", gn, !1),
						m.domElement.addEventListener("wheel", nr, !1),
						m.domElement.addEventListener("touchstart", Qn, !1),
						m.domElement.addEventListener("touchend", Br, !1),
						m.domElement.addEventListener("touchmove", io, !1),
						window.addEventListener("keydown", hr, !1),
						this.update()
				}
				return (
					((A.prototype = Object.create(ft.EventDispatcher.prototype)).constructor = A),
					Object.defineProperties(A.prototype, {
						center: {
							get: function () {
								return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target
							}
						},
						noZoom: {
							get: function () {
								return (
									console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
									!this.enableZoom
								)
							},
							set: function (X) {
								console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
									(this.enableZoom = !X)
							}
						},
						noRotate: {
							get: function () {
								return (
									console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
									!this.enableRotate
								)
							},
							set: function (X) {
								console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
									(this.enableRotate = !X)
							}
						},
						noPan: {
							get: function () {
								return (
									console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
									!this.enablePan
								)
							},
							set: function (X) {
								console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
									(this.enablePan = !X)
							}
						},
						noKeys: {
							get: function () {
								return (
									console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
									!this.enableKeys
								)
							},
							set: function (X) {
								console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
									(this.enableKeys = !X)
							}
						},
						staticMoving: {
							get: function () {
								return (
									console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
									!this.enableDamping
								)
							},
							set: function (X) {
								console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
									(this.enableDamping = !X)
							}
						},
						dynamicDampingFactor: {
							get: function () {
								return (
									console.warn(
										"THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."
									),
									this.dampingFactor
								)
							},
							set: function (X) {
								console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
									(this.dampingFactor = X)
							}
						}
					}),
					A
				)
			}
		},
		6064: function (ct, ft) {
			!(function (A) {
				"use strict"
				function X() {
					for (var be = arguments.length, ie = Array(be), _e = 0; _e < be; _e++) ie[_e] = arguments[_e]
					if (ie.length > 1) {
						ie[0] = ie[0].slice(0, -1)
						for (var $e = ie.length - 1, Xe = 1; Xe < $e; ++Xe) ie[Xe] = ie[Xe].slice(1, -1)
						return (ie[$e] = ie[$e].slice(1)), ie.join("")
					}
					return ie[0]
				}
				function q(be) {
					return "(?:" + be + ")"
				}
				function m(be) {
					return void 0 === be
						? "undefined"
						: null === be
						? "null"
						: Object.prototype.toString.call(be).split(" ").pop().split("]").shift().toLowerCase()
				}
				function de(be) {
					return be.toUpperCase()
				}
				function $(be) {
					var ie = "[A-Za-z]",
						$e = "[0-9]",
						Xt = X($e, "[A-Fa-f]"),
						ji = q(
							q("%[EFef]" + Xt + "%" + Xt + Xt + "%" + Xt + Xt) +
								"|" +
								q("%[89A-Fa-f]" + Xt + "%" + Xt + Xt) +
								"|" +
								q("%" + Xt + Xt)
						),
						Jn = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
						wr = X("[\\:\\/\\?\\#\\[\\]\\@]", Jn),
						fr = be ? "[\\uE000-\\uF8FF]" : "[]",
						Ai = X(
							ie,
							$e,
							"[\\-\\.\\_\\~]",
							be ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"
						),
						Dr = q(ie + X(ie, $e, "[\\+\\-\\.]") + "*"),
						er = q(q(ji + "|" + X(Ai, Jn, "[\\:]")) + "*"),
						Uo =
							(q(q("25[0-5]") + "|" + q("2[0-4]" + $e) + "|" + q("1" + $e + $e) + "|" + q("[1-9]" + $e) + "|" + $e),
							q(q("25[0-5]") + "|" + q("2[0-4]" + $e) + "|" + q("1" + $e + $e) + "|" + q("0?[1-9]" + $e) + "|0?0?" + $e)),
						ko = q(Uo + "\\." + Uo + "\\." + Uo + "\\." + Uo),
						Oi = q(Xt + "{1,4}"),
						To = q(q(Oi + "\\:" + Oi) + "|" + ko),
						ss = q(q(Oi + "\\:") + "{6}" + To),
						Xs = q("\\:\\:" + q(Oi + "\\:") + "{5}" + To),
						va = q(q(Oi) + "?\\:\\:" + q(Oi + "\\:") + "{4}" + To),
						gs = q(q(q(Oi + "\\:") + "{0,1}" + Oi) + "?\\:\\:" + q(Oi + "\\:") + "{3}" + To),
						Ud = q(q(q(Oi + "\\:") + "{0,2}" + Oi) + "?\\:\\:" + q(Oi + "\\:") + "{2}" + To),
						ih = q(q(q(Oi + "\\:") + "{0,3}" + Oi) + "?\\:\\:" + Oi + "\\:" + To),
						Hd = q(q(q(Oi + "\\:") + "{0,4}" + Oi) + "?\\:\\:" + To),
						Ua = q(q(q(Oi + "\\:") + "{0,5}" + Oi) + "?\\:\\:" + Oi),
						Ha = q(q(q(Oi + "\\:") + "{0,6}" + Oi) + "?\\:\\:"),
						ro = q([ss, Xs, va, gs, Ud, ih, Hd, Ua, Ha].join("|")),
						oo = q(q(Ai + "|" + ji) + "+"),
						Wo = (q(ro + "\\%25" + oo), q(ro + q("\\%25|\\%(?!" + Xt + "{2})") + oo)),
						Rl = q("[vV]" + Xt + "+\\." + X(Ai, Jn, "[\\:]") + "+"),
						Rf = q("\\[" + q(Wo + "|" + ro + "|" + Rl) + "\\]"),
						ya = q(q(ji + "|" + X(Ai, Jn)) + "*"),
						Ys = q(Rf + "|" + ko + "(?!" + ya + ")|" + ya),
						Vd = q($e + "*"),
						Ki = q(q(er + "@") + "?" + Ys + q("\\:" + Vd) + "?"),
						pc = q(ji + "|" + X(Ai, Jn, "[\\:\\@]")),
						Lr = q(pc + "*"),
						rh = q(pc + "+"),
						zp = q(q(ji + "|" + X(Ai, Jn, "[\\@]")) + "+"),
						Kn = q(q("\\/" + Lr) + "*"),
						Tn = q("\\/" + q(rh + Kn) + "?"),
						Pl = q(zp + Kn),
						Ac = q(rh + Kn),
						qs = "(?!" + pc + ")",
						ht = (q(Kn + "|" + Tn + "|" + Pl + "|" + Ac + "|" + qs), q(q(pc + "|" + X("[\\/\\?]", fr)) + "*")),
						gc = q(q(pc + "|[\\/\\?]") + "*"),
						Dn = q(q("\\/\\/" + Ki + Kn) + "|" + Tn + "|" + Ac + "|" + qs),
						Xi = q(Dr + "\\:" + Dn + q("\\?" + ht) + "?" + q("\\#" + gc) + "?"),
						Kb = q(q("\\/\\/" + Ki + Kn) + "|" + Tn + "|" + Pl + "|" + qs),
						Yw = q(Kb + q("\\?" + ht) + "?" + q("\\#" + gc) + "?")
					return (
						q(Xi + "|" + Yw),
						q(Dr + "\\:" + Dn + q("\\?" + ht) + "?"),
						q(
							q("\\/\\/(" + q("(" + er + ")@") + "?(" + Ys + ")" + q("\\:(" + Vd + ")") + "?)") +
								"?(" +
								Kn +
								"|" +
								Tn +
								"|" +
								Ac +
								"|" +
								qs +
								")"
						),
						q("\\?(" + ht + ")"),
						q("\\#(" + gc + ")"),
						q(
							q("\\/\\/(" + q("(" + er + ")@") + "?(" + Ys + ")" + q("\\:(" + Vd + ")") + "?)") +
								"?(" +
								Kn +
								"|" +
								Tn +
								"|" +
								Pl +
								"|" +
								qs +
								")"
						),
						q("\\?(" + ht + ")"),
						q("\\#(" + gc + ")"),
						q(
							q("\\/\\/(" + q("(" + er + ")@") + "?(" + Ys + ")" + q("\\:(" + Vd + ")") + "?)") +
								"?(" +
								Kn +
								"|" +
								Tn +
								"|" +
								Ac +
								"|" +
								qs +
								")"
						),
						q("\\?(" + ht + ")"),
						q("\\#(" + gc + ")"),
						q("(" + er + ")@"),
						q("\\:(" + Vd + ")"),
						{
							NOT_SCHEME: new RegExp(X("[^]", ie, $e, "[\\+\\-\\.]"), "g"),
							NOT_USERINFO: new RegExp(X("[^\\%\\:]", Ai, Jn), "g"),
							NOT_HOST: new RegExp(X("[^\\%\\[\\]\\:]", Ai, Jn), "g"),
							NOT_PATH: new RegExp(X("[^\\%\\/\\:\\@]", Ai, Jn), "g"),
							NOT_PATH_NOSCHEME: new RegExp(X("[^\\%\\/\\@]", Ai, Jn), "g"),
							NOT_QUERY: new RegExp(X("[^\\%]", Ai, Jn, "[\\:\\@\\/\\?]", fr), "g"),
							NOT_FRAGMENT: new RegExp(X("[^\\%]", Ai, Jn, "[\\:\\@\\/\\?]"), "g"),
							ESCAPE: new RegExp(X("[^]", Ai, Jn), "g"),
							UNRESERVED: new RegExp(Ai, "g"),
							OTHER_CHARS: new RegExp(X("[^\\%]", Ai, wr), "g"),
							PCT_ENCODED: new RegExp(ji, "g"),
							IPV4ADDRESS: new RegExp("^(" + ko + ")$"),
							IPV6ADDRESS: new RegExp("^\\[?(" + ro + ")" + q(q("\\%25|\\%(?!" + Xt + "{2})") + "(" + oo + ")") + "?\\]?$")
						}
					)
				}
				var R = $(!1),
					V = $(!0),
					B = function (ie, _e) {
						if (Array.isArray(ie)) return ie
						if (Symbol.iterator in Object(ie))
							return (function be(ie, _e) {
								var $e = [],
									Xe = !0,
									Xt = !1,
									ii = void 0
								try {
									for (
										var ji, Ti = ie[Symbol.iterator]();
										!(Xe = (ji = Ti.next()).done) && ($e.push(ji.value), !_e || $e.length !== _e);
										Xe = !0
									);
								} catch (Ir) {
									;(Xt = !0), (ii = Ir)
								} finally {
									try {
										!Xe && Ti.return && Ti.return()
									} finally {
										if (Xt) throw ii
									}
								}
								return $e
							})(ie, _e)
						throw new TypeError("Invalid attempt to destructure non-iterable instance")
					},
					I = 2147483647,
					G = 36,
					Ce = /^xn--/,
					We = /[^\0-\x7E]/,
					it = /[\x2E\u3002\uFF0E\uFF61]/g,
					Ue = {
						overflow: "Overflow: input needs wider integers to process",
						"not-basic": "Illegal input >= 0x80 (not a basic code point)",
						"invalid-input": "Invalid input"
					},
					et = Math.floor,
					ke = String.fromCharCode
				function he(be) {
					throw new RangeError(Ue[be])
				}
				function je(be, ie) {
					var _e = be.split("@"),
						$e = ""
					return (
						_e.length > 1 && (($e = _e[0] + "@"), (be = _e[1])),
						$e +
							(function Ve(be, ie) {
								for (var _e = [], $e = be.length; $e--; ) _e[$e] = ie(be[$e])
								return _e
							})((be = be.replace(it, ".")).split("."), ie).join(".")
					)
				}
				function Re(be) {
					for (var ie = [], _e = 0, $e = be.length; _e < $e; ) {
						var Xe = be.charCodeAt(_e++)
						if (Xe >= 55296 && Xe <= 56319 && _e < $e) {
							var Xt = be.charCodeAt(_e++)
							56320 == (64512 & Xt) ? ie.push(((1023 & Xe) << 10) + (1023 & Xt) + 65536) : (ie.push(Xe), _e--)
						} else ie.push(Xe)
					}
					return ie
				}
				var qe = function (ie) {
						return ie - 48 < 10 ? ie - 22 : ie - 65 < 26 ? ie - 65 : ie - 97 < 26 ? ie - 97 : G
					},
					Ge = function (ie, _e) {
						return ie + 22 + 75 * (ie < 26) - ((0 != _e) << 5)
					},
					wt = function (ie, _e, $e) {
						var Xe = 0
						for (ie = $e ? et(ie / 700) : ie >> 1, ie += et(ie / _e); ie > 455; Xe += G) ie = et(ie / 35)
						return et(Xe + (36 * ie) / (ie + 38))
					},
					Jt = function (ie) {
						var _e = [],
							$e = ie.length,
							Xe = 0,
							Xt = 128,
							ii = 72,
							Ti = ie.lastIndexOf("-")
						Ti < 0 && (Ti = 0)
						for (var ji = 0; ji < Ti; ++ji) ie.charCodeAt(ji) >= 128 && he("not-basic"), _e.push(ie.charCodeAt(ji))
						for (var Ir = Ti > 0 ? Ti + 1 : 0; Ir < $e; ) {
							for (var Jn = Xe, wr = 1, ir = G; ; ir += G) {
								Ir >= $e && he("invalid-input")
								var fr = qe(ie.charCodeAt(Ir++))
								;(fr >= G || fr > et((I - Xe) / wr)) && he("overflow"), (Xe += fr * wr)
								var Ai = ir <= ii ? 1 : ir >= ii + 26 ? 26 : ir - ii
								if (fr < Ai) break
								var Dr = G - Ai
								wr > et(I / Dr) && he("overflow"), (wr *= Dr)
							}
							var er = _e.length + 1
							;(ii = wt(Xe - Jn, er, 0 == Jn)),
								et(Xe / er) > I - Xt && he("overflow"),
								(Xt += et(Xe / er)),
								(Xe %= er),
								_e.splice(Xe++, 0, Xt)
						}
						return String.fromCodePoint.apply(String, _e)
					},
					yn = function (ie) {
						var _e = [],
							$e = (ie = Re(ie)).length,
							Xe = 128,
							Xt = 0,
							ii = 72,
							Ti = !0,
							ji = !1,
							Ir = void 0
						try {
							for (var wr, Jn = ie[Symbol.iterator](); !(Ti = (wr = Jn.next()).done); Ti = !0) {
								var ir = wr.value
								ir < 128 && _e.push(ke(ir))
							}
						} catch (Wo) {
							;(ji = !0), (Ir = Wo)
						} finally {
							try {
								!Ti && Jn.return && Jn.return()
							} finally {
								if (ji) throw Ir
							}
						}
						var fr = _e.length,
							Ai = fr
						for (fr && _e.push("-"); Ai < $e; ) {
							var Dr = I,
								er = !0,
								Ps = !1,
								Uo = void 0
							try {
								for (var Oi, ko = ie[Symbol.iterator](); !(er = (Oi = ko.next()).done); er = !0) {
									var To = Oi.value
									To >= Xe && To < Dr && (Dr = To)
								}
							} catch (Wo) {
								;(Ps = !0), (Uo = Wo)
							} finally {
								try {
									!er && ko.return && ko.return()
								} finally {
									if (Ps) throw Uo
								}
							}
							var ss = Ai + 1
							Dr - Xe > et((I - Xt) / ss) && he("overflow"), (Xt += (Dr - Xe) * ss), (Xe = Dr)
							var Xs = !0,
								va = !1,
								gs = void 0
							try {
								for (var ih, Ud = ie[Symbol.iterator](); !(Xs = (ih = Ud.next()).done); Xs = !0) {
									var Hd = ih.value
									if ((Hd < Xe && ++Xt > I && he("overflow"), Hd == Xe)) {
										for (var Ua = Xt, Ha = G; ; Ha += G) {
											var ro = Ha <= ii ? 1 : Ha >= ii + 26 ? 26 : Ha - ii
											if (Ua < ro) break
											var oo = Ua - ro,
												zr = G - ro
											_e.push(ke(Ge(ro + (oo % zr), 0))), (Ua = et(oo / zr))
										}
										_e.push(ke(Ge(Ua, 0))), (ii = wt(Xt, ss, Ai == fr)), (Xt = 0), ++Ai
									}
								}
							} catch (Wo) {
								;(va = !0), (gs = Wo)
							} finally {
								try {
									!Xs && Ud.return && Ud.return()
								} finally {
									if (va) throw gs
								}
							}
							++Xt, ++Xe
						}
						return _e.join("")
					},
					hi = {
						version: "2.1.0",
						ucs2: {
							decode: Re,
							encode: function (ie) {
								return String.fromCodePoint.apply(
									String,
									(function (be) {
										if (Array.isArray(be)) {
											for (var ie = 0, _e = Array(be.length); ie < be.length; ie++) _e[ie] = be[ie]
											return _e
										}
										return Array.from(be)
									})(ie)
								)
							}
						},
						decode: Jt,
						encode: yn,
						toASCII: function (ie) {
							return je(ie, function (_e) {
								return We.test(_e) ? "xn--" + yn(_e) : _e
							})
						},
						toUnicode: function (ie) {
							return je(ie, function (_e) {
								return Ce.test(_e) ? Jt(_e.slice(4).toLowerCase()) : _e
							})
						}
					},
					yi = {}
				function Wt(be) {
					var ie = be.charCodeAt(0)
					return ie < 16
						? "%0" + ie.toString(16).toUpperCase()
						: ie < 128
						? "%" + ie.toString(16).toUpperCase()
						: ie < 2048
						? "%" + ((ie >> 6) | 192).toString(16).toUpperCase() + "%" + ((63 & ie) | 128).toString(16).toUpperCase()
						: "%" +
						  ((ie >> 12) | 224).toString(16).toUpperCase() +
						  "%" +
						  (((ie >> 6) & 63) | 128).toString(16).toUpperCase() +
						  "%" +
						  ((63 & ie) | 128).toString(16).toUpperCase()
				}
				function we(be) {
					for (var ie = "", _e = 0, $e = be.length; _e < $e; ) {
						var Xe = parseInt(be.substr(_e + 1, 2), 16)
						if (Xe < 128) (ie += String.fromCharCode(Xe)), (_e += 3)
						else if (Xe >= 194 && Xe < 224) {
							if ($e - _e >= 6) {
								var Xt = parseInt(be.substr(_e + 4, 2), 16)
								ie += String.fromCharCode(((31 & Xe) << 6) | (63 & Xt))
							} else ie += be.substr(_e, 6)
							_e += 6
						} else if (Xe >= 224) {
							if ($e - _e >= 9) {
								var ii = parseInt(be.substr(_e + 4, 2), 16),
									Ti = parseInt(be.substr(_e + 7, 2), 16)
								ie += String.fromCharCode(((15 & Xe) << 12) | ((63 & ii) << 6) | (63 & Ti))
							} else ie += be.substr(_e, 9)
							_e += 9
						} else (ie += be.substr(_e, 3)), (_e += 3)
					}
					return ie
				}
				function gt(be, ie) {
					function _e($e) {
						var Xe = we($e)
						return Xe.match(ie.UNRESERVED) ? Xe : $e
					}
					return (
						be.scheme && (be.scheme = String(be.scheme).replace(ie.PCT_ENCODED, _e).toLowerCase().replace(ie.NOT_SCHEME, "")),
						void 0 !== be.userinfo &&
							(be.userinfo = String(be.userinfo)
								.replace(ie.PCT_ENCODED, _e)
								.replace(ie.NOT_USERINFO, Wt)
								.replace(ie.PCT_ENCODED, de)),
						void 0 !== be.host &&
							(be.host = String(be.host)
								.replace(ie.PCT_ENCODED, _e)
								.toLowerCase()
								.replace(ie.NOT_HOST, Wt)
								.replace(ie.PCT_ENCODED, de)),
						void 0 !== be.path &&
							(be.path = String(be.path)
								.replace(ie.PCT_ENCODED, _e)
								.replace(be.scheme ? ie.NOT_PATH : ie.NOT_PATH_NOSCHEME, Wt)
								.replace(ie.PCT_ENCODED, de)),
						void 0 !== be.query &&
							(be.query = String(be.query).replace(ie.PCT_ENCODED, _e).replace(ie.NOT_QUERY, Wt).replace(ie.PCT_ENCODED, de)),
						void 0 !== be.fragment &&
							(be.fragment = String(be.fragment)
								.replace(ie.PCT_ENCODED, _e)
								.replace(ie.NOT_FRAGMENT, Wt)
								.replace(ie.PCT_ENCODED, de)),
						be
					)
				}
				function Ke(be) {
					return be.replace(/^0*(.*)/, "$1") || "0"
				}
				function fn(be, ie) {
					var _e = be.match(ie.IPV4ADDRESS) || [],
						Xe = B(_e, 2)[1]
					return Xe ? Xe.split(".").map(Ke).join(".") : be
				}
				function St(be, ie) {
					var _e = be.match(ie.IPV6ADDRESS) || [],
						$e = B(_e, 3),
						Xe = $e[1],
						Xt = $e[2]
					if (Xe) {
						for (
							var ii = Xe.toLowerCase().split("::").reverse(),
								Ti = B(ii, 2),
								ji = Ti[0],
								Ir = Ti[1],
								Jn = Ir ? Ir.split(":").map(Ke) : [],
								wr = ji.split(":").map(Ke),
								ir = ie.IPV4ADDRESS.test(wr[wr.length - 1]),
								fr = ir ? 7 : 8,
								Ai = wr.length - fr,
								Dr = Array(fr),
								er = 0;
							er < fr;
							++er
						)
							Dr[er] = Jn[er] || wr[Ai + er] || ""
						ir && (Dr[fr - 1] = fn(Dr[fr - 1], ie))
						var Uo = Dr.reduce(function (ss, Xs, va) {
								if (!Xs || "0" === Xs) {
									var gs = ss[ss.length - 1]
									gs && gs.index + gs.length === va ? gs.length++ : ss.push({ index: va, length: 1 })
								}
								return ss
							}, []).sort(function (ss, Xs) {
								return Xs.length - ss.length
							})[0],
							ko = void 0
						if (Uo && Uo.length > 1) {
							var Oi = Dr.slice(0, Uo.index),
								To = Dr.slice(Uo.index + Uo.length)
							ko = Oi.join(":") + "::" + To.join(":")
						} else ko = Dr.join(":")
						return Xt && (ko += "%" + Xt), ko
					}
					return be
				}
				var Dt =
						/^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
					gn = void 0 === "".match(/(){0}/)[1]
				function ci(be) {
					var ie = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
						_e = {},
						$e = !1 !== ie.iri ? V : R
					"suffix" === ie.reference && (be = (ie.scheme ? ie.scheme + ":" : "") + "//" + be)
					var Xe = be.match(Dt)
					if (Xe) {
						gn
							? ((_e.scheme = Xe[1]),
							  (_e.userinfo = Xe[3]),
							  (_e.host = Xe[4]),
							  (_e.port = parseInt(Xe[5], 10)),
							  (_e.path = Xe[6] || ""),
							  (_e.query = Xe[7]),
							  (_e.fragment = Xe[8]),
							  isNaN(_e.port) && (_e.port = Xe[5]))
							: ((_e.scheme = Xe[1] || void 0),
							  (_e.userinfo = -1 !== be.indexOf("@") ? Xe[3] : void 0),
							  (_e.host = -1 !== be.indexOf("//") ? Xe[4] : void 0),
							  (_e.port = parseInt(Xe[5], 10)),
							  (_e.path = Xe[6] || ""),
							  (_e.query = -1 !== be.indexOf("?") ? Xe[7] : void 0),
							  (_e.fragment = -1 !== be.indexOf("#") ? Xe[8] : void 0),
							  isNaN(_e.port) && (_e.port = be.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? Xe[4] : void 0)),
							_e.host && (_e.host = St(fn(_e.host, $e), $e)),
							(_e.reference =
								void 0 !== _e.scheme ||
								void 0 !== _e.userinfo ||
								void 0 !== _e.host ||
								void 0 !== _e.port ||
								_e.path ||
								void 0 !== _e.query
									? void 0 === _e.scheme
										? "relative"
										: void 0 === _e.fragment
										? "absolute"
										: "uri"
									: "same-document"),
							ie.reference &&
								"suffix" !== ie.reference &&
								ie.reference !== _e.reference &&
								(_e.error = _e.error || "URI is not a " + ie.reference + " reference.")
						var Xt = yi[(ie.scheme || _e.scheme || "").toLowerCase()]
						if (ie.unicodeSupport || (Xt && Xt.unicodeSupport)) gt(_e, $e)
						else {
							if (_e.host && (ie.domainHost || (Xt && Xt.domainHost)))
								try {
									_e.host = hi.toASCII(_e.host.replace($e.PCT_ENCODED, we).toLowerCase())
								} catch (ii) {
									_e.error = _e.error || "Host's domain name can not be converted to ASCII via punycode: " + ii
								}
							gt(_e, R)
						}
						Xt && Xt.parse && Xt.parse(_e, ie)
					} else _e.error = _e.error || "URI can not be parsed."
					return _e
				}
				var nr = /^\.\.?\//,
					hr = /^\/\.(\/|$)/,
					Qn = /^\/\.\.(\/|$)/,
					io = /^\/?(?:.|\n)*?(?=\/|$)/
				function Br(be) {
					for (var ie = []; be.length; )
						if (be.match(nr)) be = be.replace(nr, "")
						else if (be.match(hr)) be = be.replace(hr, "/")
						else if (be.match(Qn)) (be = be.replace(Qn, "/")), ie.pop()
						else if ("." === be || ".." === be) be = ""
						else {
							var _e = be.match(io)
							if (!_e) throw new Error("Unexpected dot segment condition")
							var $e = _e[0]
							;(be = be.slice($e.length)), ie.push($e)
						}
					return ie.join("")
				}
				function Pi(be) {
					var ie = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
						_e = ie.iri ? V : R,
						$e = [],
						Xe = yi[(ie.scheme || be.scheme || "").toLowerCase()]
					if (
						(Xe && Xe.serialize && Xe.serialize(be, ie),
						be.host && !_e.IPV6ADDRESS.test(be.host) && (ie.domainHost || (Xe && Xe.domainHost)))
					)
						try {
							be.host = ie.iri ? hi.toUnicode(be.host) : hi.toASCII(be.host.replace(_e.PCT_ENCODED, we).toLowerCase())
						} catch (Ti) {
							be.error =
								be.error ||
								"Host's domain name can not be converted to " + (ie.iri ? "Unicode" : "ASCII") + " via punycode: " + Ti
						}
					gt(be, _e), "suffix" !== ie.reference && be.scheme && ($e.push(be.scheme), $e.push(":"))
					var Xt = (function Ci(be, ie) {
						var _e = !1 !== ie.iri ? V : R,
							$e = []
						return (
							void 0 !== be.userinfo && ($e.push(be.userinfo), $e.push("@")),
							void 0 !== be.host &&
								$e.push(
									St(fn(String(be.host), _e), _e).replace(_e.IPV6ADDRESS, function (Xe, Xt, ii) {
										return "[" + Xt + (ii ? "%25" + ii : "") + "]"
									})
								),
							("number" == typeof be.port || "string" == typeof be.port) && ($e.push(":"), $e.push(String(be.port))),
							$e.length ? $e.join("") : void 0
						)
					})(be, ie)
					if (
						(void 0 !== Xt &&
							("suffix" !== ie.reference && $e.push("//"), $e.push(Xt), be.path && "/" !== be.path.charAt(0) && $e.push("/")),
						void 0 !== be.path)
					) {
						var ii = be.path
						!ie.absolutePath && (!Xe || !Xe.absolutePath) && (ii = Br(ii)),
							void 0 === Xt && (ii = ii.replace(/^\/\//, "/%2F")),
							$e.push(ii)
					}
					return (
						void 0 !== be.query && ($e.push("?"), $e.push(be.query)),
						void 0 !== be.fragment && ($e.push("#"), $e.push(be.fragment)),
						$e.join("")
					)
				}
				function Ze(be, ie) {
					var _e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
						Xe = {}
					return (
						arguments[3] || ((be = ci(Pi(be, _e), _e)), (ie = ci(Pi(ie, _e), _e))),
						!(_e = _e || {}).tolerant && ie.scheme
							? ((Xe.scheme = ie.scheme),
							  (Xe.userinfo = ie.userinfo),
							  (Xe.host = ie.host),
							  (Xe.port = ie.port),
							  (Xe.path = Br(ie.path || "")),
							  (Xe.query = ie.query))
							: (void 0 !== ie.userinfo || void 0 !== ie.host || void 0 !== ie.port
									? ((Xe.userinfo = ie.userinfo),
									  (Xe.host = ie.host),
									  (Xe.port = ie.port),
									  (Xe.path = Br(ie.path || "")),
									  (Xe.query = ie.query))
									: (ie.path
											? ("/" === ie.path.charAt(0)
													? (Xe.path = Br(ie.path))
													: ((Xe.path =
															(void 0 === be.userinfo && void 0 === be.host && void 0 === be.port) || be.path
																? be.path
																	? be.path.slice(0, be.path.lastIndexOf("/") + 1) + ie.path
																	: ie.path
																: "/" + ie.path),
													  (Xe.path = Br(Xe.path))),
											  (Xe.query = ie.query))
											: ((Xe.path = be.path), (Xe.query = void 0 !== ie.query ? ie.query : be.query)),
									  (Xe.userinfo = be.userinfo),
									  (Xe.host = be.host),
									  (Xe.port = be.port)),
							  (Xe.scheme = be.scheme)),
						(Xe.fragment = ie.fragment),
						Xe
					)
				}
				function No(be, ie) {
					return be && be.toString().replace(ie && ie.iri ? V.PCT_ENCODED : R.PCT_ENCODED, we)
				}
				var os = {
						scheme: "http",
						domainHost: !0,
						parse: function (ie, _e) {
							return ie.host || (ie.error = ie.error || "HTTP URIs must have a host."), ie
						},
						serialize: function (ie, _e) {
							var $e = "https" === String(ie.scheme).toLowerCase()
							return (ie.port === ($e ? 443 : 80) || "" === ie.port) && (ie.port = void 0), ie.path || (ie.path = "/"), ie
						}
					},
					Gc = { scheme: "https", domainHost: os.domainHost, parse: os.parse, serialize: os.serialize }
				function Qr(be) {
					return "boolean" == typeof be.secure ? be.secure : "wss" === String(be.scheme).toLowerCase()
				}
				var ba = {
						scheme: "ws",
						domainHost: !0,
						parse: function (ie, _e) {
							var $e = ie
							return (
								($e.secure = Qr($e)),
								($e.resourceName = ($e.path || "/") + ($e.query ? "?" + $e.query : "")),
								($e.path = void 0),
								($e.query = void 0),
								$e
							)
						},
						serialize: function (ie, _e) {
							if (
								((ie.port === (Qr(ie) ? 443 : 80) || "" === ie.port) && (ie.port = void 0),
								"boolean" == typeof ie.secure && ((ie.scheme = ie.secure ? "wss" : "ws"), (ie.secure = void 0)),
								ie.resourceName)
							) {
								var $e = ie.resourceName.split("?"),
									Xe = B($e, 2),
									Xt = Xe[0],
									ii = Xe[1]
								;(ie.path = Xt && "/" !== Xt ? Xt : void 0), (ie.query = ii), (ie.resourceName = void 0)
							}
							return (ie.fragment = void 0), ie
						}
					},
					Dl = { scheme: "wss", domainHost: ba.domainHost, parse: ba.parse, serialize: ba.serialize },
					$c = {},
					fc = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",
					_a = "[0-9A-Fa-f]",
					eh = q(
						q("%[EFef]" + _a + "%" + _a + _a + "%" + _a + _a) +
							"|" +
							q("%[89A-Fa-f]" + _a + "%" + _a + _a) +
							"|" +
							q("%" + _a + _a)
					),
					Ff = X("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'),
					Od = new RegExp(fc, "g"),
					mc = new RegExp(eh, "g"),
					If = new RegExp(X("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', Ff), "g"),
					Wc = new RegExp(X("[^]", fc, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"),
					nh = Wc
				function Nd(be) {
					var ie = we(be)
					return ie.match(Od) ? ie : be
				}
				var Df = {
						scheme: "mailto",
						parse: function (ie, _e) {
							var $e = ie,
								Xe = ($e.to = $e.path ? $e.path.split(",") : [])
							if ((($e.path = void 0), $e.query)) {
								for (var Xt = !1, ii = {}, Ti = $e.query.split("&"), ji = 0, Ir = Ti.length; ji < Ir; ++ji) {
									var Jn = Ti[ji].split("=")
									switch (Jn[0]) {
										case "to":
											for (var wr = Jn[1].split(","), ir = 0, fr = wr.length; ir < fr; ++ir) Xe.push(wr[ir])
											break
										case "subject":
											$e.subject = No(Jn[1], _e)
											break
										case "body":
											$e.body = No(Jn[1], _e)
											break
										default:
											;(Xt = !0), (ii[No(Jn[0], _e)] = No(Jn[1], _e))
									}
								}
								Xt && ($e.headers = ii)
							}
							$e.query = void 0
							for (var Ai = 0, Dr = Xe.length; Ai < Dr; ++Ai) {
								var er = Xe[Ai].split("@")
								if (((er[0] = No(er[0])), _e.unicodeSupport)) er[1] = No(er[1], _e).toLowerCase()
								else
									try {
										er[1] = hi.toASCII(No(er[1], _e).toLowerCase())
									} catch (Ps) {
										$e.error =
											$e.error || "Email address's domain name can not be converted to ASCII via punycode: " + Ps
									}
								Xe[Ai] = er.join("@")
							}
							return $e
						},
						serialize: function (ie, _e) {
							var $e = ie,
								Xe = (function Q(be) {
									return null != be
										? be instanceof Array
											? be
											: "number" != typeof be.length || be.split || be.setInterval || be.call
											? [be]
											: Array.prototype.slice.call(be)
										: []
								})(ie.to)
							if (Xe) {
								for (var Xt = 0, ii = Xe.length; Xt < ii; ++Xt) {
									var Ti = String(Xe[Xt]),
										ji = Ti.lastIndexOf("@"),
										Ir = Ti.slice(0, ji).replace(mc, Nd).replace(mc, de).replace(If, Wt),
										Jn = Ti.slice(ji + 1)
									try {
										Jn = _e.iri ? hi.toUnicode(Jn) : hi.toASCII(No(Jn, _e).toLowerCase())
									} catch (Ai) {
										$e.error =
											$e.error ||
											"Email address's domain name can not be converted to " +
												(_e.iri ? "Unicode" : "ASCII") +
												" via punycode: " +
												Ai
									}
									Xe[Xt] = Ir + "@" + Jn
								}
								$e.path = Xe.join(",")
							}
							var wr = (ie.headers = ie.headers || {})
							ie.subject && (wr.subject = ie.subject), ie.body && (wr.body = ie.body)
							var ir = []
							for (var fr in wr)
								wr[fr] !== $c[fr] &&
									ir.push(
										fr.replace(mc, Nd).replace(mc, de).replace(Wc, Wt) +
											"=" +
											wr[fr].replace(mc, Nd).replace(mc, de).replace(nh, Wt)
									)
							return ir.length && ($e.query = ir.join("&")), $e
						}
					},
					Qp = /^([^\:]+)\:(.*)/,
					Lf = {
						scheme: "urn",
						parse: function (ie, _e) {
							var $e = ie.path && ie.path.match(Qp),
								Xe = ie
							if ($e) {
								var Xt = _e.scheme || Xe.scheme || "urn",
									ii = $e[1].toLowerCase(),
									Ti = $e[2],
									Ir = yi[Xt + ":" + (_e.nid || ii)]
								;(Xe.nid = ii), (Xe.nss = Ti), (Xe.path = void 0), Ir && (Xe = Ir.parse(Xe, _e))
							} else Xe.error = Xe.error || "URN can not be parsed."
							return Xe
						},
						serialize: function (ie, _e) {
							var Xe = ie.nid,
								ii = yi[(_e.scheme || ie.scheme || "urn") + ":" + (_e.nid || Xe)]
							ii && (ie = ii.serialize(ie, _e))
							var Ti = ie
							return (Ti.path = (Xe || _e.nid) + ":" + ie.nss), Ti
						}
					},
					pi = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,
					Ll = {
						scheme: "urn:uuid",
						parse: function (ie, _e) {
							var $e = ie
							return (
								($e.uuid = $e.nss),
								($e.nss = void 0),
								!_e.tolerant && (!$e.uuid || !$e.uuid.match(pi)) && ($e.error = $e.error || "UUID is not valid."),
								$e
							)
						},
						serialize: function (ie, _e) {
							var $e = ie
							return ($e.nss = (ie.uuid || "").toLowerCase()), $e
						}
					}
				;(yi[os.scheme] = os),
					(yi[Gc.scheme] = Gc),
					(yi[ba.scheme] = ba),
					(yi[Dl.scheme] = Dl),
					(yi[Df.scheme] = Df),
					(yi[Lf.scheme] = Lf),
					(yi[Ll.scheme] = Ll),
					(A.SCHEMES = yi),
					(A.pctEncChar = Wt),
					(A.pctDecChars = we),
					(A.parse = ci),
					(A.removeDotSegments = Br),
					(A.serialize = Pi),
					(A.resolveComponents = Ze),
					(A.resolve = function li(be, ie, _e) {
						var $e = (function D(be, ie) {
							var _e = be
							if (ie) for (var $e in ie) _e[$e] = ie[$e]
							return _e
						})({ scheme: "null" }, _e)
						return Pi(Ze(ci(be, $e), ci(ie, $e), $e, !0), $e)
					}),
					(A.normalize = function Vr(be, ie) {
						return "string" == typeof be ? (be = Pi(ci(be, ie), ie)) : "object" === m(be) && (be = ci(Pi(be, ie), ie)), be
					}),
					(A.equal = function Yr(be, ie, _e) {
						return (
							"string" == typeof be ? (be = Pi(ci(be, _e), _e)) : "object" === m(be) && (be = Pi(be, _e)),
							"string" == typeof ie ? (ie = Pi(ci(ie, _e), _e)) : "object" === m(ie) && (ie = Pi(ie, _e)),
							be === ie
						)
					}),
					(A.escapeComponent = function rs(be, ie) {
						return be && be.toString().replace(ie && ie.iri ? V.ESCAPE : R.ESCAPE, Wt)
					}),
					(A.unescapeComponent = No),
					Object.defineProperty(A, "__esModule", { value: !0 })
			})(ft)
		},
		1204: ct => {
			ct.exports =
				"varying highp float vDelta;\nvarying vec2 vUV;\nvarying vec4 vOutgoingDiffuseColor;\nvarying vec4 vOutgoingDiffuseDeltaColor;\nvarying vec3 vWorldNormal;\n\nbool normalPointingUp(const in vec3 normal)\n{\n    return normal.y > 0.9;\n}\n\nvoid main() {\n    const float minDelta = 0.001;\n    bool isTop = normalPointingUp(vWorldNormal);\n    \n    if (abs(vDelta) > minDelta && (vUV.y > 1.0 - abs(vDelta) || isTop))\n    {\n        gl_FragColor = vOutgoingDiffuseDeltaColor;\n    } else {\n        gl_FragColor = vOutgoingDiffuseColor;\n    }\n}\n"
		},
		4902: ct => {
			ct.exports =
				"#define saturate(a) clamp( a, 0.0, 1.0)\n#define RECIPROCAL_PI 0.31830988618\n#define PI 3.14159265359\n\nattribute vec3 color;\nattribute vec3 deltaColor;\nattribute highp float delta;\nattribute lowp float isHeight;\n\nvarying vec3 vWorldNormal;\nvarying highp float vDelta;\nvarying vec2 vUV;\nvarying vec4 vOutgoingDiffuseColor;\nvarying vec4 vOutgoingDiffuseDeltaColor;\n\nuniform vec3 ambientLightColor;\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\nuniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\n\nstruct IncidentLight {\n    vec3 color;\n    vec3 direction;\n};\n\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\n\nvoid getDirectionalDirectLightIrradiance(const in DirectionalLight directionalLight,out IncidentLight directLight) {\n    directLight.color = directionalLight.color;\n    directLight.direction = directionalLight.direction;\n}\n\nvec3 BRDF_Diffuse_Lambert (const in vec3 diffuseColor) {\n    return RECIPROCAL_PI * diffuseColor;\n}\n\nvec3 getAmbientLightIrradiance() {\n    return ambientLightColor*PI;\n}\n\nvec3 getBaseOutgoingLight(const vec3 lightFront) {\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    reflectedLight.indirectDiffuse = getAmbientLightIrradiance();\n    reflectedLight.directDiffuse = lightFront;\n    return (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);\n}\n\n// better to calc the colors in vertex as no color interpolation is used, performance improvements will be noticeable \n// once frustum or occlusion culling is properly used\n\nvoid main() \n{\n    vec3 adjustedHeightPos = position;\n    \n    // height position will be adjusted based on camera position in order to prevent \n    // z-fighting in different zoom levels when position is positive.\n    // preferred multiplication over if branching of the isHeight variable \n    // the same line could be written this way : \n    //\n    // adjustedHeightPos = position\n    // if (isHeight>0.5 && cameraPosition.y>0) {\n    //    adjustedHeightPos.y = position.y + cameraPosition.y/1000.\n    // } \n    // \n    \n    adjustedHeightPos.y = position.y + (isHeight*max(0.,cameraPosition.y/1000.));\n\n\tvec4 modelViewPosition = modelViewMatrix * vec4(adjustedHeightPos, 1.0);\n\tgl_Position = projectionMatrix * modelViewPosition;\n\n    vec3 worldNormal = vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);\n    vec3 normal= normalize(normalMatrix * normal);\n    vec3 lightFront = vec3(0.0);\n\n    vUV = uv;\n    vDelta = abs(delta);\n\n    for (int i=0; i < 2; ++i)\n    {\n        IncidentLight directLight;\n\n        getDirectionalDirectLightIrradiance(directionalLights[i],directLight);\n        float dotNL = dot(normal, directLight.direction);\n        vec3 directLightColor_Diffuse = PI * directLight.color; \n        lightFront += saturate(dotNL) * directLightColor_Diffuse;\n    }\n\n    vec3 baseOutgoingLight = getBaseOutgoingLight(lightFront);\n    \n    vOutgoingDiffuseColor = vec4(BRDF_Diffuse_Lambert(color.rgb)*baseOutgoingLight,1.0);\n    vOutgoingDiffuseDeltaColor = vec4(BRDF_Diffuse_Lambert(deltaColor)*baseOutgoingLight,1.0);\n}\n"
		},
		463: ct => {
			ct.exports =
				'precision highp float;\n\t\t\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\n\t\t\nvarying vec2 vUv;\n\t\t\n// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n//----------------------------------------------------------------------------------\n// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\\\\ AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n\t\t\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 15\n#define FXAA_GATHER4_ALPHA 0\n#define FXAA_GREEN_AS_LUMA 1\n#define FXAA_EARLY_EXIT 1\n\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_5\n    #define FXAA_HLSL_5 0\n#endif\n/*==========================================================================*/\n#ifndef FXAA_GREEN_AS_LUMA\n    //\n    // For those using non-linear color,\n    // and either not able to get luma in alpha, or not wanting to,\n    // this enables FXAA to run using green as a proxy for luma.\n    // So with this enabled, no need to pack luma in alpha.\n    //\n    // This will turn off AA on anything which lacks some amount of green.\n    // Pure red and blue or combination of only R and B, will get no AA.\n    //\n    // Might want to lower the settings for both,\n    //    fxaaConsoleEdgeThresholdMin\n    //    fxaaQualityEdgeThresholdMin\n    // In order to insure AA does not get turned off on colors\n    // which contain a minor amount of green.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n    //\n    // Controls algorithm\\s early exit path.\n    // On PS3 turning this ON adds 2 cycles to the shader.\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n    // Turning this off on console will result in a more blurry image.\n    // So this defaults to on.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n    //\n    // Only valid for PC OpenGL currently.\n    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n    //\n    // 1 = Use discard on pixels which don\\t need AA.\n    //     For APIs which enable concurrent TEX+ROP from same surface.\n    // 0 = Return unchanged color on pixels which don\\t need AA.\n    //\n    #define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    //\n    // Used for GLSL 120 only.\n    //\n    // 1 = GL API supports fast pixel offsets\n    // 0 = do not use fast pixel offsets\n    //\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n    //\n    // 1 = API supports gather4 on alpha channel.\n    // 0 = API does not support gather4 on alpha channel.\n    //\n    #if (FXAA_HLSL_5 == 1)\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n\n\n/*============================================================================\n                        FXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n============================================================================*/\n#ifndef FXAA_QUALITY_PRESET\n    //\n    // Choose the quality preset.\n    // This needs to be compiled into the shader as it effects code.\n    // Best option to include multiple presets is to\n    // in each shader define the preset, then include this file.\n    //\n    // OPTIONS\n    // -----------------------------------------------------------------------\n    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n    // 39       - no dither, very expensive\n    //\n    // NOTES\n    // -----------------------------------------------------------------------\n    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n    // 13 = about same speed as FXAA 3.9 and better than 12\n    // 23 = closest to FXAA 3.9 visually and performance wise\n    //  _ = the lowest digit is directly related to performance\n    // _  = the highest digit is directly related to style\n    //\n    #define FXAA_QUALITY_PRESET 12\n#endif\n\n\n/*============================================================================\n\n                            FXAA QUALITY - PRESETS\n\n============================================================================*/\n\n/*============================================================================\n                        FXAA QUALITY - MEDIUM DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n\n/*============================================================================\n                        FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n                        FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n\n\n/*============================================================================\n\n                                API PORTING\n\n============================================================================*/\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#else\n    #define FxaaBool bool\n    #define FxaaDiscard clip(-1)\n    #define FxaaFloat float\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaHalf half\n    #define FxaaHalf2 half2\n    #define FxaaHalf3 half3\n    #define FxaaHalf4 half4\n    #define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 == 1)\n    #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n    // Requires,\n    //  #version 120\n    // And at least,\n    //  #extension GL_EXT_gpu_shader4 : enable\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n    // Requires "#version 130" or better\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_3 == 1)\n    #define FxaaInt2 float2\n    #define FxaaTex sampler2D\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_4 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_5 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n\n\n/*============================================================================\n                    GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n/*============================================================================\n\n                                FXAA3 QUALITY - PC\n\n============================================================================*/\n#if (FXAA_PC == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy_} = upper left of pixel\n    // {_zw} = lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {__a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    // {x__} = -N/screenWidthInPixels\n    // {_y_} = -N/screenHeightInPixels\n    // {_z_} =  N/screenWidthInPixels\n    // {__w} =  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x__} = -2.0/screenWidthInPixels\n    // {_y_} = -2.0/screenHeightInPixels\n    // {_z_} =  2.0/screenWidthInPixels\n    // {__w} =  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x__} =  8.0/screenWidthInPixels\n    // {_y_} =  8.0/screenHeightInPixels\n    // {_z_} = -4.0/screenWidthInPixels\n    // {__w} = -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only three safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3,\n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //\n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immediates.\n    // Immediates will result in compiler un-optimizing.\n    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n            #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            #define lumaM rgbyM.w\n        #else\n            #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_GATHER4_ALPHA == 0)\n        #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    #else\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    #if (FXAA_DISCARD == 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n    #endif\n}\n/*==========================================================================*/\n#endif\n\nvoid main() {\n    gl_FragColor = FxaaPixelShader(\n    vUv,\n    vec4(0.0),\n    tDiffuse,\n    tDiffuse,\n    tDiffuse,\n    resolution,\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    0.75,\n    0.166,\n    0.0833,\n    0.0,\n    0.0,\n    0.0,\n    vec4(0.0)\n    );\n\n    // TODO avoid querying texture twice for same texel\n    gl_FragColor.a = texture2D(tDiffuse, vUv).a;\n}\n'
		},
		8489: ct => {
			ct.exports =
				"varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"
		},
		894: ct => {
			"use strict"
			ct.exports = JSON.parse(
				'{"$schema":"http://json-schema.org/draft-07/schema#","$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON Schema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}'
			)
		},
		6680: ct => {
			"use strict"
			ct.exports = JSON.parse(
				'{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}'
			)
		}
	},
	ct => {
		ct((ct.s = 490))
	}
])
